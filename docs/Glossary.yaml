example_function:
    desc: Pops and pushes
    source: |
        len
    pops:
        - type: list
          desc: Just a list
    pushes:
        - type: int
          desc: Just an int

native_functions:
    - category: Input / Output
      functions:
        - p:
              desc: Prints the function off the top of the stack.
              source: |
                  void PredefinedFunctions::p(Runner* r) {
                  	PredefinedFunctions::print(r->getCurrentStack()->pop());
                  }

                  void PredefinedFunctions::print(CharmFunction f1) {
                  	printf("%s", charmFunctionToString(f1).c_str());
                  }
              pops:
                  - type: any
                    desc: The function that will be printed
              pushes:
        - pstring:
              desc: Prints a string off the top of the stack.
              source: |
                addBuiltinFunction("pstring", [](Runner* r) {
                	CharmFunction f1 = r->getCurrentStack()->pop();
                	if (f1.functionType == STRING_FUNCTION) {
                		printf("%s", f1.stringValue.c_str());
                	} else {
                		runtime_die("Non string passed to `pstring`.");
                	}
                });
              pops:
                  - type: string
                    desc: The string that will be printed
              pushes:
        - newline:
              desc: Prints a newline.
              source: |
                  void PredefinedFunctions::newline(Runner* r) {
                  	printf("\n");
                  }
              pops:
              pushes:
        - getline:
              desc: Gets a line from standard input.
              source: |
                  void PredefinedFunctions::getline(Runner* r) {
                  	CharmFunction input;
                  	input.functionType = STRING_FUNCTION;
                  	std::getline(std::cin, input.stringValue);
                  	r->getCurrentStack()->push(input);
                  }
              pops:
              pushes:
                  - type: string
                    desc: The line from standard input
    - category: Debugging Functions
      functions:
        - type:
              desc: Pushes the type of the function to the stack.
              source: |
                addBuiltinFunction("type", [](Runner* r) {
                	CharmFunction f1 = r->getCurrentStack()->pop();
                	CharmFunction out;
                	out.functionType = STRING_FUNCTION;
                	switch (f1.functionType) {
                		case LIST_FUNCTION:
                		out.stringValue = "LIST_FUNCTION";
                		break;

                		case NUMBER_FUNCTION:
                		out.stringValue = "NUMBER_FUNCTION"
                		break;

                		case STRING_FUNCTION:
                		out.stringValue = "STRING_FUNCTION"
                		break;

                		case DEFINED_FUNCTION:
                		out.stringValue = "DEFINED_FUNCTION"
                		break;

                		case FUNCTION_DEFINITION:
                		out.stringValue = "FUNCTION_DEFINITION"
                		break;
                	}
                	r->getCurrentStack()->push(out);
                });
              pops:
                  - type: any
                    desc: The function to find the type of
              pushes:
                  - type: any
                    desc: The input function
                  - type: string
                    desc: The type of the input function
    - category: Function Definition
      functions:
        - def:
              desc: Define a function without any special syntax.
              source: |
                addBuiltinFunction("def", [](Runner* r, RunnerContext* context) {
                	//function body
                	CharmFunction f1 = r->getCurrentStack()->pop();
                	//function name
                	CharmFunction f2 = r->getCurrentStack()->pop();
                	if (f2.functionType != STRING_FUNCTION) {
                		runtime_die("Non string passed to `def`.");
                	}
                	if (f1.functionType != LIST_FUNCTION) {
                		runtime_die("Non list passed to `def`.");
                	}
                	//a function with type FUNCTION_DEFINITION
                	CharmFunction f;
                	f.functionType = FUNCTION_DEFINITION;
                	f.functionName = f2.stringValue;
                	f.literalFunctions = f1.literalFunctions;

                	FunctionDefinition fD;
                	fD.functionName = f.functionName;
                	fD.functionBody = f.literalFunctions;

                	CharmFunctionDefinitionInfo defInfo;
                	defInfo.inlineable = context->fA->isInlinable(f);
                	if (defInfo.inlineable) {
                		context->fA->addToInlineDefinitions(f);
                	}
                	defInfo.tailCallRecursive = context->fA->isInlinable(f);

                	fD.definitionInfo = defInfo;
                	r->addFunctionDefinition(fD);
                });
              pops:
                  - type: string
                    desc: The name of the function to define
                  - type: list
                    desc: The body of the function
              pushes:
        - ffi:
              desc: Define a function through the Foreign Function Interface.
              note:
                  - There is only one type of function accepted, and that type is defined in <span class="code">FFI.h</span> as <span class="code">typedef void (*MutateFFI)(Runner*);</span>. Since <span class="code">Runner</span> uses C++ types inside of it, any functions from other languages must be called through a C++ compatibility layer.
              source: |
                addBuiltinFunction("ffi", [](Runner* r) {
                	//library symbol
                	CharmFunction f1 = r->getCurrentStack()->pop();
                	//library path
                	CharmFunction f2 = r->getCurrentStack()->pop();
                	//charm function name
                	CharmFunction f3 = r->getCurrentStack()->pop();
                	if (f1.functionType != STRING_FUNCTION || f2.functionType != STRING_FUNCTION || f3.functionType != STRING_FUNCTION) {
                		runtime_die("Non string passed to `ffi`.");
                	}
                	r->ffi->loadMutateFFI(f3.stringValue, f2.stringValue, f1.stringValue);
                });
              pops:
                  - type: string
                    desc: The name of the charm function to define
                  - type: string
                    desc: The path to the library
                  - type: string
                    desc: The name of the function symbol from the library
              pushes:
    - category: Comparisons
      functions:
        - eq:
              desc: Compares the equality of the top two functions on the stack.
              source: |
                addBuiltinFunction("eq", [](Runner* r) {
                	CharmFunction f1 = r->getCurrentStack()->pop();
                	CharmFunction f2 = r->getCurrentStack()->pop();
                	CharmFunction out;
                	out.functionType = NUMBER_FUNCTION;
                	out.numberValue.whichType = INTEGER_VALUE;
                	out.numberValue.integerValue = f1 == f2 ? 1 : 0;
                	r->getCurrentStack()->push(out);
                });
              pops:
                  - type: any
                    desc: The first function to check equality of
                  - type: any
                    desc: The second function to check equality of
              pushes:
                  - type: int
                    desc: 1 if equal, 0 if not
    - category: Stack Manipulations
      functions:
        - dup:
              desc: Duplicates the top value on the stack.
              source: |
                  void PredefinedFunctions::dup(Runner* r) {
                  	CharmFunction f1 = r->getCurrentStack()->pop();
                  	r->getCurrentStack()->push(f1);
                  	r->getCurrentStack()->push(f1);
                  }
              pops:
                  - type: any
                    desc: The duplicand
              pushes:
                  - type: any
                    desc: The duplicand
                  - type: any
                    desc: The duplicand
        - pop:
              desc: Pops the top value off the stack.
              source: |
                  void PredefinedFunctions::pop(Runner* r) {
                  	r->getCurrentStack()->pop();
                  }
              pops:
                  - type: any
                    desc: The popped function
              pushes:
        - swap:
              desc: Swaps two values on the stack.
              source: |
                 void PredefinedFunctions::swap(Runner* r) {
                 	CharmFunction f1 = r->getCurrentStack()->pop();
                 	CharmFunction f2 = r->getCurrentStack()->pop();
                 	//check to make sure we've got ints that are positive and below MAX_STACK
                 	if (Stack::isInt(f1) && Stack::isInt(f2)) {
                 		if ((f1.numberValue.integerValue < 0) || (f2.numberValue.integerValue < 0)) {
                 			runtime_die("Negative int passed to `swap`.");
                 		}
                 		if ((f1.numberValue.integerValue >= r->MAX_STACK) || (f2.numberValue.integerValue >= r->MAX_STACK)) {
                 			runtime_die("Overflowing pointers passed to `swap`.");
                 		}
                 		r->getCurrentStack()->swap((unsigned long long)f1.numberValue.integerValue, (unsigned long long)f2.numberValue.integerValue);
                 	} else {
                 		runtime_die("Non integer passed to `swap`.");
                 	}
                 }
              pops:
                  - type: int
                    desc: The stack index of a value to swap
                  - type: int
                    desc: The stack index of the other value to swap
              pushes:
    - category: List / String Manipulations
      functions:
        - len:
              desc: Finds the length of a list or string.
              note:
                  - This can be used with any type, but will push a trivial value.
              source: |
                  void PredefinedFunctions::len(Runner* r) {
                  	//list to check length of
                  	CharmFunction f1 = r->getCurrentStack()->pop();
                  	//push list back on because we dont need to get rid of it
                  	r->getCurrentStack()->push(f1);
                  	CharmFunction out;
                  	out.functionType = NUMBER_FUNCTION;
                  	CharmNumber num;
                  	num.whichType = INTEGER_VALUE;
                  	//make sure f1 is a list or string
                  	if (f1.functionType == LIST_FUNCTION) {
                  		num.integerValue = f1.literalFunctions.size();
                  	} else if (f1.functionType == STRING_FUNCTION) {
                  		num.integerValue = f1.stringValue.size();
                  	} else {
                  		//so if it's a bad type, i was going to just report a len of 0 or 1
                  		//but i feel like that would be really misleading. eh, i'll just do 1
                  		num.integerValue = 1;
                  	}
                  	out.numberValue = num;
                  	r->getCurrentStack()->push(out);
                  }
              pops:
                  - type: any
                    desc: The function to find the length of (usually lists or strings)
              pushes:
                  - type: any
                    desc: The previously popped function
                  - type: int
                    desc: The popped function's length
        - at:
              desc: Gets the element at an index of a list or string.
              note:
                  - This function cannot "unquote" values -- for a list, it pushes a list; and for a string, it pushes a string. This is deliberate, and is in order to prevent naked functions from being pushed to the stack. To "unquote" values, use `i`.
              source: |
                  void PredefinedFunctions::at(Runner* r) {
                  	//index number
                  	CharmFunction f1 = r->getCurrentStack()->pop();
                  	//list / string
                  	CharmFunction f2 = r->getCurrentStack()->pop();
                  	r->getCurrentStack()->push(f2);
                  	if (Stack::isInt(f1)) {
                  		CharmFunction out;
                  		if (f2.functionType == LIST_FUNCTION) {
                  			out.functionType = LIST_FUNCTION;
                  			out.literalFunctions = { f2.literalFunctions.at(f1.numberValue.integerValue % f2.literalFunctions.size()) };
                  		} else if (f2.functionType == STRING_FUNCTION) {
                  			out.functionType = STRING_FUNCTION;
                  			out.stringValue = f2.stringValue[f1.numberValue.integerValue % f2.stringValue.size()];
                  		} else {
                  			runtime_die("Neither a list nor a string was passed to `at`");
                  		}
                  		r->getCurrentStack()->push(out);
                  	} else {
                  		runtime_die("Non integer index passed to `at`");
                  	}
                  }
              pops:
                  - type: list/string
                    desc: The list or string to index
                  - type: int
                    desc: The index
              pushes:
                  - type: list/string
                    desc: The list or string previously popped
                  - type: list/string
                    desc: The indexed element
        - insert:
              desc: Insert an element into a list or string.
              source: |
                 void PredefinedFunctions::insert(Runner* r) {
                 	//get index to insert in
                 	CharmFunction f1 = r->getCurrentStack()->pop();
                 	//get element to insert
                 	CharmFunction f2 = r->getCurrentStack()->pop();
                 	//get list or string
                 	CharmFunction f3 = r->getCurrentStack()->pop();
                 	//make sure f1 is an int
                 	if (!Stack::isInt(f1))
                 		runtime_die("Non integer index passed to `insert`.");
                 	if (f3.functionType == LIST_FUNCTION) {
                 		//only allow a list to be inserted into a list
                 		if (f2.functionType == LIST_FUNCTION) {
                 			f3.literalFunctions.insert(
                 				f3.literalFunctions.begin() + (f1.numberValue.integerValue % f3.literalFunctions.size()),
                 				f2.literalFunctions.begin(),
                 				f2.literalFunctions.end()
                 			);
                 		} else {
                 			runtime_die("Attempted to `insert` a non list into a list.");
                 		}
                 	} else if (f3.functionType == STRING_FUNCTION) {
                 		//only allow a string to be inserted into another string
                 		if (f2.functionType == STRING_FUNCTION) {
                 			f3.stringValue.insert(
                 				f1.numberValue.integerValue % f3.stringValue.size(),
                 				f2.stringValue
                 			);
                 		} else {
                 			runtime_die("Attempted to `insert` a non string into a string.");
                 		}
                 	}
                 	r->getCurrentStack()->push(f3);
                 }
              pops:
                  - type: list/string
                    desc: The list or string to modify
                  - type: list/string
                    desc: The element to be unboxed and inserted
                  - type: int
                    desc: The insertation index
              pushes:
                  - type: list/string
                    desc: The modified list or string
        - concat:
              desc: Concatenates two lists or strings.
              source: |
                 void PredefinedFunctions::concat(Runner* r) {
                 	//get first list
                 	CharmFunction f1 = r->getCurrentStack()->pop();
                 	//get second list (first in order of concatination)
                 	CharmFunction f2 = r->getCurrentStack()->pop();
                 	//make sure they're both lists or strings
                 	if ((f1.functionType == LIST_FUNCTION) && (f2.functionType == LIST_FUNCTION)) {
                 		f2.literalFunctions.insert(f2.literalFunctions.end(), f1.literalFunctions.begin(), f1.literalFunctions.end());
                 	} else if ((f1.functionType == STRING_FUNCTION) && (f2.functionType == STRING_FUNCTION)) {
                 		f2.stringValue = f2.stringValue + f1.stringValue;
                 	} else {
                 		runtime_die("Unmatching types passed to `concat`.");
                 	}
                 	r->getCurrentStack()->push(f2);
                 }
              pops:
                  - type: list/string
                    desc: The first list or string
                  - type: list/string
                    desc: The second list or string
              pushes:
                  - type: list/string
                    desc: The concatenated list or string
        - split:
              desc: Split a list or string after a certain amount of elements.
              note:
                  - This function is the inverse of `concat`. That is, `[ list ] n split concat` is equal to `[ list ]`.
              source: |
                 void PredefinedFunctions::concat(Runner* r) {
                 	//get first list
                 	CharmFunction f1 = r->getCurrentStack()->pop();
                 	//get second list (first in order of concatination)
                 	CharmFunction f2 = r->getCurrentStack()->pop();
                 	//make sure they're both lists or strings
                 	if ((f1.functionType == LIST_FUNCTION) && (f2.functionType == LIST_FUNCTION)) {
                 		f2.literalFunctions.insert(f2.literalFunctions.end(), f1.literalFunctions.begin(), f1.literalFunctions.end());
                 	} else if ((f1.functionType == STRING_FUNCTION) && (f2.functionType == STRING_FUNCTION)) {
                 		f2.stringValue = f2.stringValue + f1.stringValue;
                 	} else {
                 		runtime_die("Unmatching types passed to `concat`.");
                 	}
                 	r->getCurrentStack()->push(f2);
                 }
              pops:
                  - type: list/string
                    desc: The list or string to split
                  - type: int
                    desc: The amount of elements before the list or string is split
              pushes:
                  - type: list/string
                    desc: The first part of the list or string
                  - type: list/string
                    desc: The rest of the list or string
    - category: String Manipulation
      functions:
        - tostring:
              desc: Convert a function into a parseable string.
              note:
                  - This function essentially turns a function into a string that can be plopped back into the interpreter. This may cause unexpected functionality, such as <span class="code">" hello " tostring</span> shooting back <span class="code">" " hello " " </span>.
              source: |
                addBuiltinFunction("tostring", [](Runner* r) {
                	CharmFunction f1 = r->getCurrentStack()->pop();
                	CharmFunction out;
                	out.functionType = STRING_FUNCTION;
                	out.stringValue = charmFunctionToString(f1);
                	r->getCurrentStack()->push(out);
                });
              pops:
                  - type: any
                    desc: The function to convert to a string
              pushes:
                  - type: string
                    desc: The converted, parseable function
        - char:
              desc: Convert an integer to its corresponding character.
              source: |
                addBuiltinFunction("char", [](Runner* r) {
                    CharmFunction f1 = r->getCurrentStack()->pop();
                    if (f1.functionType == NUMBER_FUNCTION) {
                        if (f1.numberValue.whichType == INTEGER_VALUE) {
                            if (f1.numberValue.integerValue < 0) {
                                runtime_die("Negative integer passed to `char`.");
                            } else {
                                CharmFunction out;
                                out.functionType = STRING_FUNCTION;
                                out.stringValue = std::string(1, static_cast<char>(f1.numberValue.integerValue));
                                r->getCurrentStack()->push(out);
                            }
                        } else {
                            runtime_die("Non integer passed to `char`.");
                        }
                    } else {
                        runtime_die("Non number passed to `char`.");
                    }
                });
              pops:
                  - type: int
                    desc: The integer to convert to a character
              pushes:
                  - type: string
                    desc: A string containing the converted character
        - ord:
              desc: Convert a character to its corresponding integer.
              source: |
                addBuiltinFunction("ord", [](Runner* r) {
                    CharmFunction f1 = r->getCurrentStack()->pop();
                    if (f1.functionType == STRING_FUNCTION) {
                        if (f1.stringValue.size() > 0) {
                            CharmFunction out;
                            CharmNumber n;
                            n.whichType = INTEGER_VALUE;
                            n.integerValue = static_cast<long long>(f1.stringValue[0]);
                            out.functionType = NUMBER_FUNCTION;
                            out.numberValue = n;
                            r->getCurrentStack()->push(out);
                        } else {
                            runtime_die("Empty string passed to `ord`.");
                        }
                    } else {
                        runtime_die("Non string passed to `ord`.");
                    }
                });
              pops:
                  - type: string
                    desc: The string containing a first character to convert to an integer
              pushes:
                  - type: int
                    desc: An integer representing the first character in the input string
    - category: Control Flow
      functions:
        - i:
              desc: Similar to Lisp's `unquote`, runs the top of the stack as a program.
              source: |
                addBuiltinFunction("i", [](Runner* r, RunnerContext* context) {
                	//pop the top of the stack and run it
                	CharmFunction f1 = r->getCurrentStack()->pop();
                	if (f1.functionType == LIST_FUNCTION) {
                		//when we run with `i`, remove the context (we can't tail call from an `i`)
                		r->run(std::pair<CHARM_LIST_TYPE, FunctionAnalyzer*>(f1.literalFunctions, context->fA));
                	} else {
                		runtime_die("Non list passed to `i`.");
                	}
                });
              pops:
                  - type: list
                    desc: The list to be unquoted and run
              pushes:
        - q:
              desc: Similar to Lisp's `quote`, boxes the top of the stack.
              note:
                  - This is the inverse of i, so `<value> q i` is the same as `<value>`
              source: |
                  void PredefinedFunctions::q(Runner* r) {
                  	CharmFunction f1 = r->getCurrentStack()->pop();
                  	CharmFunction list;
                  	list.functionType = LIST_FUNCTION;
                  	list.literalFunctions.push_back(f1);
                  	r->getCurrentStack()->push(list);
                  }
              pops:
                  - type: any
                    desc: The value to be boxed
                  - type: list
                    desc: The boxed value
              pushes:
        - ifthen:
              desc: Branching operator; runs the first block then decides whether or not to run the second or third based off of whether the top of the stack is > 0 or <= 0.
              note:
                  - This is the only function which provides inherent tail call optimization. More info is written up in Documentation.md.
                  - This function does not clean up after itself more than listed -- you need to clear the stack yourself if you want it cleared in a recursive function!
              source: |
                  void PredefinedFunctions::ifthen(Runner* r, FunctionDefinition *context) {
                  	//the arguments to this function are a little different...
                  	//ifthen performs very basic tail-call optimization on its two sections (truthy/falsy)
                  	//if truthy (or falsy) end with the function itself (found through fD.functionName), then
                  	//the tail-call optimizer kicks in and the function simply loops instead of
                  	//creating a new stack frame by calling r->run()

                  	//this one is gonna take 3 arguments --
                  	//stack[2] = condition to run truthy section
                  	//stack[1] = truthy section (if...)
                  	//stack[0] = falsy section (else...)
                  	//have to reverse it because popping is weird
                  	CharmFunction falsy = r->getCurrentStack()->pop();
                  	bool falsyTailCall = false;
                  	CharmFunction truthy = r->getCurrentStack()->pop();
                  	bool truthyTailCall = false;
                  	CharmFunction condFunction = r->getCurrentStack()->pop();
                  	if ((condFunction.functionType == LIST_FUNCTION) &&
                  		(truthy.functionType == LIST_FUNCTION) &&
                  		(falsy.functionType == LIST_FUNCTION)) {
                  			//first, we run checks to set the tail call bools
                  			if (context != nullptr) {
                  				if (truthy.literalFunctions.back().functionName == context->functionName) {
                  					truthyTailCall = true;
                  				}
                  				if (falsy.literalFunctions.back().functionName == context->functionName) {
                  					falsyTailCall = true;
                  				}
                  				//now, if we _DO_ have a tail call, modify truthy/falsy and enter a loop instead
                  				//there are 3 seperate cases here -- truthy tail call, falsy tail call, or both
                  				if (truthyTailCall) {
                  					ONLYDEBUG printf("ENGAGING TRUTHY IF/THEN TAIL CALL OPTIMIZATION\n");
                  					//remove the tail call
                  					truthy.literalFunctions.pop_back();
                  					while (1) {
                  						r->run(condFunction.literalFunctions);
                  						CharmFunction cond = r->getCurrentStack()->pop();
                  						if (Stack::isInt(cond)) {
                  							if (cond.numberValue.integerValue > 0) {
                  								r->run(truthy.literalFunctions);
                  							} else {
                  								r->run(falsy.literalFunctions);
                  								//end this function immediately once the tail call loop ends
                  								ONLYDEBUG printf("DISENGAGING TRUTHY IF/THEN TAIL CALL OPTIMIZATION\n");
                  								return;
                  							}
                  						} else {
                  							runtime_die("`ifthen` condition returned non integer.");
                  						}
                  					}
                  				}
                  				if (falsyTailCall) {
                  					ONLYDEBUG printf("ENGAGING FALSY IF/THEN TAIL CALL OPTIMIZATION\n");
                  					//remove the tail call
                  					falsy.literalFunctions.pop_back();
                  					while (1) {
                  						r->run(condFunction.literalFunctions);
                  						CharmFunction cond = r->getCurrentStack()->pop();
                  						if (Stack::isInt(cond)) {
                  							if (cond.numberValue.integerValue > 0) {
                  								r->run(truthy.literalFunctions);
                  								//end this function immediately once the tail call loop ends
                  								ONLYDEBUG printf("DISENGAGING FALSY IF/THEN TAIL CALL OPTIMIZATION\n");
                  								return;
                  							} else {
                  								r->run(falsy.literalFunctions);
                  							}
                  						} else {
                  							runtime_die("`ifthen` condition returned non integer.");
                  						}
                  					}
                  				}
                  				//here's an extra special case if both truthy and falsy have a tail call
                  				//that is `f := [ <cond> ] [ <code> f ] [ <code> f ] ifthen`
                  				//this is equivalent to `f := [ <cond> ] [ <code> ] [ <code> ] ifthen f`
                  				//so we run it as an infinite loop
                  				if (truthyTailCall && falsyTailCall) {
                  					ONLYDEBUG printf("ENGAGING TRUTHY/FALSY IF/THEN TAIL CALL OPTIMIZATION\n");
                  					//remove the tail calls
                  					truthy.literalFunctions.pop_back();
                  					falsy.literalFunctions.pop_back();
                  					while (1) {
                  						CharmFunction cond = r->getCurrentStack()->pop();
                  						if (Stack::isInt(cond)) {
                  							if (cond.numberValue.integerValue > 0) {
                  								r->run(truthy.literalFunctions);
                  							} else {
                  								r->run(falsy.literalFunctions);
                  							}
                  						} else {
                  							runtime_die("`ifthen` condition returned non integer.");
                  						}
                  					}
                  				}
                  				//good joke
                  				ONLYDEBUG printf("DISENGAGING TRUTHY/FALSY IF/THEN TAIL CALL OPTIMIZATION\n");
                  			}
                  			//but if not (or context was nullptr), continue execution as normal
                  			r->run(condFunction.literalFunctions);
                  			//now we check the top of the stack to see if it's truthy or falsy
                  			CharmFunction cond = r->getCurrentStack()->pop();
                  			if (Stack::isInt(cond)) {
                  				if (cond.numberValue.integerValue > 0) {
                  					r->run(truthy.literalFunctions);
                  				} else {
                  					r->run(falsy.literalFunctions);
                  				}
                  			} else {
                  				runtime_die("`ifthen` condition returned non integer.");
                  			}
                  		} else {
                  			runtime_die("Non list passed to `ifthen`.");
                  		}
                  }

              pops:
                  - type: list
                    desc: Condition to run before running truthy or falsy blocks
                  - type: list
                    desc: Truthy (> 0) block
                  - type: list
                    desc: Falsy (<= 0) block
              pushes:
        - inline:
              desc: Shows the result of an inlining optimization on a function.
              source: |
                addBuiltinFunction("inline", [](Runner* r, RunnerContext* context) {
                	//the boxed function to take in
                	CharmFunction f1 = r->getCurrentStack()->pop();
                	if (f1.functionType == LIST_FUNCTION) {
                		CharmFunction out;
                		out.functionType = LIST_FUNCTION;
                		for (CharmFunction f : f1.literalFunctions) {
                			if (f.functionType == DEFINED_FUNCTION) {
                				if (!context->fA->doInline(out.literalFunctions, f)) {
                					out.literalFunctions.push_back(f);
                				}
                			} else {
                				out.literalFunctions.push_back(f);
                			}
                		}
                		r->getCurrentStack()->push(out);
                	} else {
                		runtime_die("Non list passed to `inline`.");
                	}
                });
              pops:
                  - type: list
                    desc: The function to inline
              pushes:
                  - type: list
                    desc: The completed inline optimization
    - category: Boolean Operations
      functions:
        - xor:
              desc: Exclusive or.
              note:
                  - This considers any value greater than 0 as true and less than 0 as false. It is not a bitwise call.
              source: |
                void PredefinedFunctions::exor(Runner* r) {
                  	CharmFunction f1 = r->getCurrentStack()->pop();
                  	CharmFunction f2 = r->getCurrentStack()->pop();
                  	if (Stack::isInt(f1) && Stack::isInt(f2)) {
                  		CharmFunction out;
                  		out.functionType = NUMBER_FUNCTION;
                  		CharmNumber outNum;
                  		outNum.whichType = INTEGER_VALUE;
                  		//cancer incoming
                  		outNum.integerValue = ((f1.numberValue.integerValue > 0) ^ (f2.numberValue.integerValue > 0));
                  		//no more cancer
                  		out.numberValue = outNum;
                  		r->getCurrentStack()->push(out);
                  	} else {
                  		runtime_die("Non integer passed to logic function.");
                  	}
                }
              pops:
                  - type: int
                    desc: The first value to xor
                  - type: int
                    desc: The second value to xor
              pushes:
                  - type: int
                    desc: The result of the xoring
    - category: Type Inspecific Math
      functions:
        - abs:
              desc: Absolute value.
              source: |
                void PredefinedFunctions::abs(Runner* r) {
                	CharmFunction f1 = r->getCurrentStack()->pop();
                	if (Stack::isInt(f1)) {
                		std::abs(f1.numberValue.integerValue);
                	} else if (Stack::isFloat(f1)) {
                		if (f1.numberValue.floatValue < 0) {
                			f1.numberValue.floatValue = -f1.numberValue.floatValue;
                		}
                	} else {
                		runtime_die("Non number passed to `abs`.");
                	}
                }
              pops:
                  - type: int/float
                    desc: The value to find the absolute value of
              pushes:
                  - type: int/float
                    desc: The absolute value
    - category: Integer Operations
      functions:
        - +:
              desc: Addition.
              source: |
                void PredefinedFunctions::plusI(Runner* r) {
                	CharmFunction f1 = r->getCurrentStack()->pop();
                	CharmFunction f2 = r->getCurrentStack()->pop();
                	if (Stack::isInt(f1) && Stack::isInt(f2)) {
                		f1.numberValue.integerValue = f1.numberValue.integerValue + f2.numberValue.integerValue;
                	} else {
                		runtime_die("Non integer passed to `+`.");
                	}
                	r->getCurrentStack()->push(f1);
                }
              pops:
                  - type: int
                    desc: The first value to add
                  - type: int
                    desc: The second value to add
              pushes:
                  - type: int
                    desc: The added values
        - -:
              desc: Subtraction.
              source: |
                void PredefinedFunctions::minusI(Runner* r) {
                	CharmFunction f1 = r->getCurrentStack()->pop();
                	CharmFunction f2 = r->getCurrentStack()->pop();
                	if (Stack::isInt(f1) && Stack::isInt(f2)) {
                		f1.numberValue.integerValue = f2.numberValue.integerValue - f1.numberValue.integerValue;
                	} else {
                		runtime_die("Non integer passed to `-`.");
                	}
                	r->getCurrentStack()->push(f1);
                }
              pops:
                  - type: int
                    desc: The first value to subtract from
                  - type: int
                    desc: The second value to subtract
              pushes:
                  - type: int
                    desc: The subtracted values
        - "*":
              desc: Multiplication.
              source: |
                void PredefinedFunctions::timesI(Runner* r) {
                	CharmFunction f1 = r->getCurrentStack()->pop();
                	CharmFunction f2 = r->getCurrentStack()->pop();
                	if (Stack::isInt(f1) && Stack::isInt(f2)) {
                		f1.numberValue.integerValue = f1.numberValue.integerValue * f2.numberValue.integerValue;
                	} else {
                		runtime_die("Non integer passed to `*`.");
                	}
                	r->getCurrentStack()->push(f1);
                }
              pops:
                  - type: int
                    desc: The first value to multiply
                  - type: int
                    desc: The second value to multiply
              pushes:
                  - type: int
                    desc: The multiplied values
        - /:
              desc: Division.
              source: |
                void PredefinedFunctions::divI(Runner* r) {
                	CharmFunction f1 = r->getCurrentStack()->pop();
                	CharmFunction f2 = r->getCurrentStack()->pop();
                	if (Stack::isInt(f1) && Stack::isInt(f2)) {
                		//f1 used as answer
                		f1.numberValue.integerValue = f2.numberValue.integerValue / f1.numberValue.integerValue;
                		//f2 used as modulus
                		f2.numberValue.integerValue = f2.numberValue.integerValue % f1.numberValue.integerValue;
                	} else {
                		runtime_die("Non integer passed to `+`.");
                	}
                	r->getCurrentStack()->push(f2);
                	r->getCurrentStack()->push(f1);
                }
              pops:
                  - type: int
                    desc: The numerator
                  - type: int
                    desc: The denominator
              pushes:
                  - type: int
                    desc: The remainder
                  - type: int
                    desc: The divided value
        - toint:
              desc: Convert a floating point value to an integer through truncation.
              source: |
                void PredefinedFunctions::toInt(Runner* r) {
                	CharmFunction f1 = r->getCurrentStack()->pop();
                	if (Stack::isFloat(f1)) {
                		f1.numberValue.whichType = INTEGER_VALUE;
                		f1.numberValue.integerValue = (long long)f1.numberValue.floatValue;
                	} else if (Stack::isInt(f1)) {
                		//do nothing, it's already an int
                	} else {
                		runtime_die("Non number passed to `toInt`.");
                	}
                }
              pops:
                  - type: float
                    desc: The floating point value to convert
              pushes:
                  - type: int
                    desc: The integer representation
    - category: Stack Creation and Destruction
      functions:
        - createstack:
              desc: Creates a new named stack to work with.
              note:
                  - This function does not switch to the specified stack. Use <span class="code">switchstack</span> for that.
                  - The default stack is 20,000 functions long and named <span class="code">0</span>.
              source: |
                 void PredefinedFunctions::createStack(Runner* r) {
                 	//name of the stack
                 	CharmFunction f1 = r->getCurrentStack()->pop();
                 	//length of the stack
                 	CharmFunction f2 = r->getCurrentStack()->pop();
                 	if (Stack::isInt(f2)) {
                 		if (f2.numberValue.integerValue > 0) {
                 			r->createStack(f2.numberValue.integerValue, f1);
                 		} else {
                 			runtime_die("Negative integer or zero passed to `createStack`.");
                 		}
                 	} else {
                 		runtime_die("Non integer passed to `createStack`.");
                 	}
                 }
              pops:
                  - type: int
                    desc: The size of the stack to create
                  - type: any
                    desc: The name of the stack
              pushes:
        - getstack:
              desc: Gets the name of the current stack.
              source: |
                addBuiltinFunction("getstack", [](Runner* r) {
                    //name of the stack
                    r->getCurrentStack()->push(r->getCurrentStack()->name);
                });
              pops:
              pushes:
                  - type: any
                    desc: The name of the current stack
        - switchstack:
              desc: Switches to a named stack.
              note:
                  - The default stack is named <span class="code">0</span>.
              source: |
                  void PredefinedFunctions::switchStack(Runner* r) {
                  	CharmFunction f1 = r->getCurrentStack()->pop();
                  	r->switchCurrentStack(f1);
                  }
              pops:
                  - type: any
                    desc: The name of the stack to switch to
              pushes:
    - category: Reference Getting and Setting
      functions:
        - getref:
              desc: Gets the value of a global reference.
              source: |
                 void PredefinedFunctions::getRef(Runner* r) {
                 	CharmFunction f1 = r->getCurrentStack()->pop();
                 	r->getCurrentStack()->push(r->getReference(f1));
                 }
              pops:
                  - type: any
                    desc: The name of the reference to get
              pushes:
        - setref:
              desc: Sets the value of a global reference.
              note:
                  - Though this is not enforced, it's canonical to use <span class="code">" &lt;description&gt;&lt;function&gt;ref "</span> as the reference name.
              source: |
                  void PredefinedFunctions::setRef(Runner* r) {
                  	//the value of the reference
                  	CharmFunction f1 = r->getCurrentStack()->pop();
                  	//the name of the reference
                  	CharmFunction f2 = r->getCurrentStack()->pop();
                  	r->setReference(f2, f1);
                  }
              pops:
                  - type: any
                    desc: The name of the reference
                  - type: any
                    desc: The value of the reference
              pushes:
    - category: Library Interaction
      functions:
        - include:
              desc: Includes a Charm library into another file.
              note:
                  - No inline optimization is done for functions called from a library. This is because all inlining is indexed and performed at compile time, whereas library includsion is performed at runtime.
                  - For proper calling syntax and usage (as the quick view does not do this function justice), visit <a href="https://github.com/Aearnus/charm/blob/master/test/include-test">https://github.com/Aearnus/charm/blob/master/test/include-test</a> for a real world usage example.
              source: |
                addBuiltinFunction("include", [](Runner* r) {
                	//NOTE: no inlining is done for included files
                	//this is because all inlining is done at compiletime,
                	//and this inclusion happens at run-time

                	//the namespace to place functions in
                	CharmFunction f1 = r->getCurrentStack()->pop();
                	//the path of the file to import
                	CharmFunction f2 = r->getCurrentStack()->pop();
                	if ((f1.functionType != STRING_FUNCTION) || (f2.functionType != STRING_FUNCTION)) {
                		runtime_die("Non string passed to `include`.");
                	}
                	std::string line;
                	std::ifstream importFile(f2.stringValue);
                	Parser parser = Parser();
                	while (std::getline(importFile, line)) {
                		r->run(parser.lex(line), f1.stringValue);
                	}
                });
              pops:
                  - type: string
                    desc: The path to the Charm file to include
                  - type: string
                    desc: The namespace, which gets prepended to the functions in the library
              pushes:


prelude_functions:
    - category: Output Functions
      functions:
        - put:
              desc: Prints without popping, adding a newline.
              source: |
                 put := dup p newline
              pops:
                  - type: any
                    desc: The value to print
              pushes:
                  - type: any
                    desc: The value to print
    - category: Debugging Functions
      functions:
        - clearstack:
              desc: Clears the stack to a certain depth.
              note:
                  - This pushes a variadic amount of zeroes to the stack, but that isn't significant to pay attention to.
              source: |
                 _clearstack_args := " clearstackref " flip setref
                 _clearstack_cond := " clearstackref " getref 1 - dup " clearstackref " flip setref
                 _clearstack      := [ _clearstack_cond ] [ 0 _clearstack ] [ ] ifthen
                 clearstack       := _clearstack_args _clearstack
              pops:
                  - type: int
                    desc: The depth to clear up to
              pushes:
        - pause:
              desc: Require the user to hit return to continue execution.
              source: |
                 pause := " Press return to continue... " pstring getline pop
              pops:
              pushes:
        - printstack:
              desc: Prints the stack to a certain depth.
              source: |
                 _printstack_args       := " printstackref " flip setref
                 _printstack_correction := " printstackref " getref rotate
                 printstack             := _printstack_args [ put " printstackref " getref rotate ] " printstackref " getref repeat i _printstack_correction
              pops:
                  - type: int
                    desc: The depth to print up until
              pushes:
        - stepthrough:
              desc: Interactively steps through a function in a sandboxed stack.
              note:
                  - This creates a dummy stack named <span class="code">" stepthroughstack "</span>.
                  - After this code runs, your current stack will be stack <span class="code">0</span>. If you don't want to return to the main stack, make sure to switch back after using this function.
              source: |
                20000 " stepthroughstack " createstack

                _stepthrough_pop_args          := " stepthroughdepthref " flip setref   inline " stepthroughcoderef " flip setref   " stepthroughargsref " flip setref
                _stepthrough_stack_init&switch := " stepthroughstack " switchstack clearstack " stepthroughargsref " getref i
                _stepthrough_init_cursor       := " stepthroughcursor " 0 setref
                _stepthrough_init              := _stepthrough_pop_args _stepthrough_init_cursor _stepthrough_stack_init&switch " Initial stack: " pstring newline _stepthrough_print_stack pause newline

                _stepthrough_arg_depth := " stepthroughdepthref " getref
                _stepthrough_arg_code  := " stepthroughcoderef " getref

                _stepthrough_set_headref := " stepthroughheadref " flip setref
                _stepthrough_get_headref := " stepthroughheadref " getref

                _stepthrough_func_string_len     := tostring len 4 -
                _stepthrough_move_cursor_int     := " stepthroughcursor " getref + " stepthroughcursor " flip setref
                _stepthrough_move_cursor_len     := _stepthrough_func_string_len 1 + _stepthrough_move_cursor_int pop
                _stepthrough_move_cursor_headref := _stepthrough_get_headref _stepthrough_move_cursor_len

                _stepthrough_print_func   := tostring 2 flip len 2 - 1 2 swap substring flip pop pstring
                _stepthrough_print_stack  := " Stack: " pstring newline _stepthrough_arg_depth printstack
                _stepthrough_print_cursor := " " [ space concat ] " stepthroughcursor " getref repeat i " ^ " concat pstring newline
                _stepthrough_print_info   := " Running functions... " pstring newline _stepthrough_arg_code _stepthrough_print_func newline

                _stepthrough_iter       := _stepthrough_print_info _stepthrough_print_cursor _stepthrough_set_headref " stepthroughstack " switchstack _stepthrough_get_headref i _stepthrough_print_stack _stepthrough_move_cursor_headref 0 switchstack pause newline [ ]
                _stepthrough_map        := 0 switchstack _stepthrough_arg_code [ _stepthrough_iter ] map 0 switchstack
                stepthrough             := _stepthrough_init _stepthrough_map

              pops:
                  - type: list
                    desc: The list of arguments for the functions to step through
                  - type: list
                    desc: The program to step through
                  - type: int
                    desc: The stack depth to print
              pushes:
    - category: Stack Manipulation
      functions:
        - flip:
              desc: Flips two elements on the stack.
              source: |
                 flip := 0 1 swap
              pops:
                  - type: any
                    desc: One value to flip
                  - type: any
                    desc: The other value to flip
              pushes:
                  - type: any
                    desc: One value to flip
                  - type: any
                    desc: The other value to flip
        - swapnth:
              desc: Swap the top value with the value at an index on the stack.
              note:
                  - This function is magic-ish. It doesn't push another top value, but it replaces the previous one.
              source: |
                  swapnth := dup 1 + swap
              pops:
                  - type: int
                    desc: The stack index to swap the top value to
              pushes:
        - copyfrom:
              desc: Copy a value from an index on the stack.
              note:
                  - Unlike swap, this does not move any values from their place in the stack.
              source: |
                  copyfrom := " copyfromref " flip setref 0 " copyfromref " getref swap dup 1 " copyfromref " getref 1 + swap
              pops:
                  - type: int
                    desc: The stack index to copy from
              pushes:
                  - type: any
                    desc: The value copied from the stack
        - pushto:
              desc: Push a value to an index on the stack.
              note:
                  - This function is SLOW! Don't use it unless you absolutely understand it -- it can turn a relatively fast function from O(n) to O(n^2) just like it did to <a href="#printstack-id">printstack</a>.
              source: |
                  _pushto_args := 0 flip
                  _pushto_cond := print flip print flip dup 2 copyfrom -
                  _pushto_inc  := flip 1 + flip
                  _pushto      := [ _pushto_cond ] [ 1 copyfrom 2 + swapnth _pushto_inc _pushto ] [ pop pop ] ifthen
                  pushto       := _pushto_args _pushto
              pops:
                  - type: any
                    desc: The object to push
                  - type: int
                    desc: The stack index to push the object to
              pushes:
        - rotate:
              desc: Rotate values up through the stack, down to a certain depth.
              note:
                  - See <a href="#pushto-id">pushto</a>.
              source: |
                  rotate := pushto
              pops:
                  - type: int
                    desc: The depth of rotation
              pushes:
        - stack:
              desc: Duplicates a value multiple times.
              source: |
                  stack := [ 1 - dup ] [ flip dup 0 2 swap stack ] [ pop ] ifthen
              pops:
                  - type: any
                    desc: The object to duplicate
                  - type: int
                    desc: The amount of times to duplicate
              pushes:
                  - type: ...
                    desc: All of the duplicated objects
    - category: String Manipulation
      functions:
        - substring:
              desc: Gets a substring of a string.
              source: |
                 _substring_args     := " " 3 pushto
                 _substring_distance := dup 2 copyfrom - 1 -
                 _substring_iter     := 0 2 swap 1 copyfrom at 1 4 swap concat 0 3 swap 0 2 swap flip succ flip
                 _substring          := [ _substring_distance succ ] [ _substring_iter _substring ] [ pop pop flip ] ifthen
                 substring           := _substring_args _substring
              pops:
                  - type: string
                    desc: Stirng to get a substring of
                  - type: int
                    desc: Starting index of substring
                  - type: int
                    desc: Ending index of substring
              pushes:
                  - type: string
                    desc: Original string
                  - type: string
                    desc: Cut string
        - space:
              desc: Pushes a space to the top of the stack.
              note:
                  - Due to the intracacies of the parser, <span class="code">"   "</span> simply pushes an empty string to the stack.
              source: |
                space := 32 char
              pops:
              pushes:
                  - type: string
                    desc: Space character
    - category: List Manipulation
      functions:
        - cut:
              desc: Gets a sublist of a list.
              note:
                  - Just like <span class="code">at</span>, accessing an element out of bounds causes this function to repeat the list.
              source: |
                 _cut_args     := [ ] 3 pushto
                 _cut_distance := dup 2 copyfrom - 1 -
                 _cut_iter     := 0 2 swap 1 copyfrom at 1 4 swap concat 0 3 swap 0 2 swap flip succ flip
                 _cut          := [ _cut_distance succ ] [ _cut_iter _cut ] [ pop pop flip ] ifthen
                 cut           := _cut_args _cut
              pops:
                  - type: list
                    desc: List to cut
                  - type: int
                    desc: Starting index of sublist
                  - type: int
                    desc: Ending index of sublist
              pushes:
                  - type: list
                    desc: Cut list
                  - type: list
                    desc: Original list
        - repeat:
              desc: Repeats a list a certain number of times.
              note:
                  - Using this as <span class="code"> [ &ltfunction&gt; ] flip repeat i</span> works as something akin to a for-loop construct!
              source: |
                 _repeat_args := flip type " repeattyperef " flip setref dup 0 2 swap 1 -
                 _repeat_iter := 0 2 swap dup 0 2 swap concat flip 2 0 swap 1 -
                 _repeat_zero := [ " repeattyperef " getref " LIST_FUNCTION " eq ] [ [ ] ] [ " " ] ifthen
                 _repeat      := [ dup ] [ _repeat_iter _repeat ] [ pop flip pop ] ifthen
                 repeat       := _repeat_args [ dup ] [ _repeat ] [ pop pop pop _repeat_zero ] ifthen
              pops:
                  - type: list/string
                    desc: List or string to repeat
                  - type: int
                    desc: Number of times to repeat
              pushes:
                  - type: list/string
                    desc: Repeated list or string
        - map:
              desc: Applies a function to every element in a list.
              note:
                  - The function passed to <span class="code">map</span> must pop exactly 1 boxed value and must push exactly 1 list. If not, it will break the internal workings of <span class="code">map</span> and you will get strange, arcane error messages!
                  - A good example of a proper <span class="code">map</span> call is <span class="code">[ 1 2 3 ] [ i 1 + q ] map</span>. Note how the value is unquoted (<span class="code">i</span>) and quoted again (<span class="code">q</span>) afterwards.
              source: |
                 _map_args    := " mapfuncref " flip setref [ ]
                 _map_iter    := flip 1 split flip " mapfuncref " getref i 1 2 swap concat
                 _map_cond    := flip len 1 2 swap
                 _map_cleanup := flip pop
                 _map         := [ _map_cond ] [ _map_iter _map ] [ _map_cleanup ] ifthen
                 map          := _map_args _map_iter
              pops:
                  - type: list
                    desc: List to map over
                  - type: function(list -> list)
                    desc: Function to apply to every element in the list
              pushes:
                  - type: list
                    desc: Mapped list
        - for:
              desc: Applies a function to every element in a list but returns nothing.
              note:
                  - The function passed to <span class="code">for</span> has no requirements, unlike with <span class="code">map</span>. It may do whatever it likes to the stack.
                  - A good example of a proper <span class="code">for</span> call is <span class="code">[ 1 2 3 ] [ item i put ] for</span>. Note how the value is unquoted (<span class="code">i</span>) but not quoted again due to there being no point in re-quoting.
              source: |
                 _for_args := " for_function " flip setref " for_iterable " flip setref
                 _for_body := " for_iterable " getref len flip pop [ " for_iterable " getref " for_index " getref at flip pop " for_item " flip setref " for_function " getref i " for_index " getref [ " for_rev " getref 1 eq ] [ 1 - ] [ 1 + ] ifthen " for_index " flip setref ] flip repeat i
                 item := " for_item " getref
                 for := _for_args " for_index " 0 setref _for_body
                 revfor := _for_args " for_index " " for_iterable " len flip pop 1 - setref " for_rev " 1 setref _for_body
              pops:
                  - type: list
                    desc: List to iterate through
                  - type: function
                    desc: Function to apply, may pop or push as it pleases
        - reverse:
              desc: Reverses a list.
              source: |
                 reverse := [ ] flip [ item concat ] revfor
              pops:
                  - type: list
                    desc: List to reverse
              pushes:
                  - type: list
                    desc: Reversed list
    - category: Named Reference Manipulation
      functions:
        - modref:
              desc: Modifies a named reference in-place.
              note:
                  - An example of usage is <span class="code">" my_ref " [ 1 + ] modref</span> to add 1 to <span class="code">" my_ref "</span>.
              source: |
                 _modref_args := " modref_function " flip setref " modref_reference " flip setref
                 modref := _modref_args " modref_reference " getref getref " modref_function " getref i " modref_reference " getref flip setref
              pops:
                  - type: any
                    desc: Name of a named reference to modify
                  - type: function
                    desc: Function to apply on the named reference
        - setrefs:
              desc: Performs batch definition of named references.
              note:
                  - This function goes through the list in reverse order and pops values from the stack to define references until the list is done. This is useful for taking arguments in a function.
              source: |
                 setrefs := [ item i flip setref ] revfor
              pops:
                  - type: list
                    desc: List of named references to define
    - category: Micellaneous
      functions:
        - sinclude:
              desc: Includes a library and automatically sets the namespace to <span class="code">library:</span>.
              source: |
                 sinclude := dup " arg " flip setref " .charm " concat " arg " getref " : " concat include
              pops:
                  - type: string
                    desc: Name of a library without the extension
{"version":3,"sources":["PredefinedFunctions.cpp","/home/tyler/packages/emsdk/emscripten/1.37.37/system/include/libcxx/vector","/home/tyler/packages/emsdk/emscripten/1.37.37/system/include/libcxx/string","./ParserTypes.h","/home/tyler/packages/emsdk/emscripten/1.37.37/system/include/libcxx/new","/home/tyler/packages/emsdk/emscripten/1.37.37/system/include/libcxx/memory","/home/tyler/packages/emsdk/emscripten/1.37.37/system/include/libcxx/__string","/home/tyler/packages/emsdk/emscripten/1.37.37/system/include/libcxx/functional","/home/tyler/packages/emsdk/emscripten/1.37.37/system/include/libcxx/__hash_table","/home/tyler/packages/emsdk/emscripten/1.37.37/system/include/libcxx/variant","/home/tyler/packages/emsdk/emscripten/1.37.37/system/include/libcxx/typeinfo","./Runner.h","Runner.cpp","/home/tyler/packages/emsdk/emscripten/1.37.37/system/include/libcxx/iterator","/home/tyler/packages/emsdk/emscripten/1.37.37/system/include/libcxx/unordered_map","Stack.cpp","/home/tyler/packages/emsdk/emscripten/1.37.37/system/include/libcxx/__split_buffer","/home/tyler/packages/emsdk/emscripten/1.37.37/system/include/libcxx/deque","/home/tyler/packages/emsdk/emscripten/1.37.37/system/include/libcxx/algorithm","/home/tyler/packages/emsdk/emscripten/1.37.37/system/include/libcxx/stdexcept","/home/tyler/packages/emsdk/emscripten/1.37.37/system/include/libcxx/type_traits","./PredefinedFunctions.h","/home/tyler/packages/emsdk/emscripten/1.37.37/system/include/libcxx/array","Parser.cpp","/home/tyler/packages/emsdk/emscripten/1.37.37/system/include/libcxx/istream","/home/tyler/packages/emsdk/emscripten/1.37.37/system/include/libcxx/ios","/home/tyler/packages/emsdk/emscripten/1.37.37/system/include/libcxx/sstream","FFI.cpp","/home/tyler/packages/emsdk/emscripten/1.37.37/system/include/libcxx/iosfwd","/home/tyler/packages/emsdk/emscripten/1.37.37/system/include/libcxx/utility","./Stack.h","/home/tyler/packages/emsdk/emscripten/1.37.37/system/include/libcxx/ostream","/home/tyler/packages/emsdk/emscripten/1.37.37/system/include/libcxx/__locale","./Error.h","/home/tyler/packages/emsdk/emscripten/1.37.37/system/include/libcxx/fstream","/home/tyler/packages/emsdk/emscripten/1.37.37/system/include/libcxx/streambuf","/home/tyler/packages/emsdk/emscripten/1.37.37/system/include/libcxx/tuple","/home/tyler/packages/emsdk/emscripten/1.37.37/system/include/libcxx/locale","/home/tyler/packages/emsdk/emscripten/1.37.37/system/include/libcxx/math.h","FunctionAnalyzer.cpp","CInterpretationCapsule.cpp","/home/tyler/packages/emsdk/emscripten/1.37.37/system/include/libcxx/initializer_list"],"names":[],"mappings":";;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;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;;;;;;;;AACA;;;;;;;AGlMA;;AD9JA;;AC8JA;;;;;;;;;;;;;;;;AD9JA;;AC8JA;;AD9JA;AFyXA;;AA1BA;AAAA;;;;;;;;AACA;AAAA;;AIqoCA;AAAA;;;;;;;AJtoCA;;;;;;;;AACA;;;;;;;AGlMA;;AD9JA;;;;;;AC8JA;;;;;;;;;;;;;;;;;;;;;;;;;ACi8DA;AAAA;AAAA;;ADz8DA;;;;;;;;;;AFkjCA;AAPA;AAVA;AIzhCA;AAAA;AAAA;;AAAA;AAAA;AAAA;;AAjBA;;AN4SA;;;;;;;;;;;AI3RA;;;;;;;;;AAAA;;;;;;;;;;AD9JA;;AC8JA;;AD9JA;AFyXA;;AA1BA;AAAA;;;;;;;;AACA;AAAA;;AIqoCA;AAAA;;;;;;;AJtoCA;;;;;;;;AACA;;;;;;;AGlMA;;AD9JA;;AC8JA;;AD9JA;;AC8JA;;AD9JA;AFyXA;;AA1BA;AAAA;;;;;;;;AACA;AAAA;;AIqoCA;AAAA;;;;;;;AJtoCA;;;;;;;;AACA;;;;;;;AGlMA;;AD9JA;;AC8JA;;AD9JA;;AC8JA;;AD9JA;AFyXA;;AA1BA;AAAA;;;;;;;;AACA;AAAA;;AIqoCA;AAAA;;;;;;;AJtoCA;;;;;;;;AACA;;;;;;;AGlMA;;AD9JA;;AI+8CA;;;AHjzCA;AGizCA;;;AJ/8CA;;AC8JA;;AD9JA;AFyXA;;AA1BA;AAAA;;;;;;;;AACA;AAAA;;AIqoCA;AAAA;;;;;;;AJtoCA;;;;;;;;AACA;;;;;;;AGlMA;;AD9JA;;AC8JA;;;;;;;;;;;;;;AD9JA;;AC8JA;;AD9JA;AFyXA;;AA1BA;AAAA;;;;;;;;AACA;AAAA;;AIqoCA;AAAA;;;;;;;AJtoCA;;;;;;;;AACA;;;;;;;AGlMA;;AD9JA;;AC8JA;;;;;;;;;;;;;;AD9JA;;AC8JA;;AD9JA;AFyXA;;AA1BA;AAAA;;;;;;;;AACA;AAAA;;AIqoCA;AAAA;;;;;;;AJtoCA;;;;;;;;AACA;;;;;;;AGlMA;;AD9JA;;;;AC8JA;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;ACm8DA;AAAA;AAAA;AAAA;AAAA;AAAA;AAFA;AAAA;AAAA;AHz8BA;AAAA;AIx/BA;AAjBA;AC2gDA;AA9QA;AAqRA;;APtqDA;;;;;;;AO6wDA;;AACA;;;AAEA;;;;AH3mDA;;;;;;;;AGwmDA;;AACA;;;AAEA;;;;AH3mDA;;ACi8DA;AHz8BA;AAAA;AIx/BA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAjBA;AC2gDA;AA9QA;AAqRA;;APnqDA;;;;;;AO0wDA;;AACA;;;AAEA;;;;;;;;AH3mDA;;;;;AGwmDA;;AACA;;;AAEA;;;;AH3mDA;;ACi8DA;AHz8BA;AAAA;AIx/BA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAjBA;AC2gDA;AA9QA;AAqRA;;AP3pDA;;;;;;AOkwDA;;AACA;;;AAEA;;;;;;;;AH3mDA;;;;;AGwmDA;;AACA;;;AAEA;;;;AH3mDA;;ACi8DA;AHz8BA;AAAA;AIx/BA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAjBA;AC2gDA;AA9QA;AAqRA;;APxpDA;;;;;;AO+vDA;;AACA;;;AAEA;;;;;;;;AH3mDA;;;;;AGwmDA;;AACA;;;AAEA;;;;AH3mDA;;ACi8DA;AAAA;AAAA;AHz8BA;AAAA;AIx/BA;AAjBA;AC2gDA;AA9QA;AAqRA;;AP/oDA;;;;;;AOsvDA;;AACA;;;AAEA;;;;;;;;AH3mDA;;;;;AGwmDA;;AACA;;;AAEA;;;;AH3mDA;;ACi8DA;AAAA;AAAA;AHz8BA;AAAA;AIx/BA;AAAA;AAAA;AAjBA;AC2gDA;AA9QA;AAqRA;;APhnDA;;;;;;AOutDA;;;AACA;;;;;AAEA;;;;;;;;AH3mDA;;;;;AGwmDA;;AACA;;;AAEA;;;;AH3mDA;;ACi8DA;AAAA;AAAA;AHz8BA;AAAA;AIx/BA;AAAA;AAAA;AAjBA;AC2gDA;AA9QA;AAqRA;;APjlDA;;;;;;AOwrDA;;;AACA;;;;;AAEA;;;;;;;;AH3mDA;;;;;AGwmDA;;;AACA;;;;;AAEA;;;;AH3mDA;;ACi8DA;AAAA;AAAA;AHz8BA;AAAA;AIx/BA;AAjBA;AC2gDA;AA9QA;AAqRA;;APlkDA;;;;;;AOyqDA;;;AACA;;;;;AAEA;;;;;;;;AH3mDA;;;;;AGwmDA;;;AACA;;;;;AAEA;;;;AH3mDA;;ACi8DA;AAAA;AAAA;AHz8BA;AAAA;AIx/BA;AAAA;AAAA;AAjBA;AC2gDA;AA9QA;AAqRA;;APtjDA;;;;;;AO6pDA;;;AACA;;;;;AAEA;;;;;;;;AH3mDA;;;;;AGwmDA;;;AACA;;;;;AAEA;;;;AH3mDA;;ACi8DA;AAAA;AAAA;AHz8BA;AAAA;AIx/BA;AAAA;AAAA;AAjBA;AC2gDA;AA9QA;AAqRA;;APjjDA;;;;;;AOwpDA;;;AACA;;;;;AAEA;;;;;;;;AH3mDA;;;;;AGwmDA;;;AACA;;;;;AAEA;;;;AH3mDA;;ACi8DA;AAAA;AAAA;AHz8BA;AAAA;AIx/BA;AAjBA;AC2gDA;AA9QA;AAqRA;;AP9iDA;;;;;;AOqpDA;;;AACA;;;;;AAEA;;;;;;;;AH3mDA;;;;;AGwmDA;;;AACA;;;;;AAEA;;;;AH3mDA;;ACi8DA;AAAA;AAAA;AHz8BA;AAAA;AIx/BA;AAAA;AAAA;AAjBA;AC2gDA;AA9QA;AAqRA;;AP3hDA;;;;;;AOkoDA;;;AACA;;;;;AAEA;;;;;;;;AH3mDA;;;;;AGwmDA;;;AACA;;;;;AAEA;;;;AH3mDA;;ACi8DA;AAAA;AAAA;AHz8BA;AAAA;AIx/BA;AAjBA;AC2gDA;AA9QA;AAqRA;;APrgDA;;;;;;AO4mDA;;;AACA;;;;;AAEA;;;;;;;;AH3mDA;;;;;AGwmDA;;;AACA;;;;;AAEA;;;;AH3mDA;;ACi8DA;AAAA;AAAA;AHz8BA;AAAA;AIx/BA;AAAA;AAAA;AAAA;AAAA;AAAA;AAjBA;AC2gDA;AA9QA;AAqRA;;APz+CA;;;;;;AOglDA;;;AACA;;;;;AAEA;;;;;;;;AH3mDA;;;;;AGwmDA;;;AACA;;;;;AAEA;;;;AH3mDA;;ACi8DA;AAAA;AAAA;AHz8BA;AAAA;AIx/BA;AAAA;AAAA;AAAA;AAAA;AAAA;AAjBA;AC2gDA;AA9QA;AAqRA;;APv8CA;;;;;;AO8iDA;;;AACA;;;;;AAEA;;;;;;;;AH3mDA;;;;;AGwmDA;;;AACA;;;;;AAEA;;;;AH3mDA;;ACi8DA;AAAA;AAAA;AHz8BA;AAAA;AIx/BA;AAAA;AAAA;AAAA;AAAA;AAjBA;AC2gDA;AA9QA;AAqRA;;APx7CA;;;;;;AO+hDA;;;AACA;;;;;AAEA;;;;;;;;AH3mDA;;;;;AGwmDA;;;AACA;;;;;AAEA;;;;AH3mDA;;ACi8DA;AAAA;AAAA;AHz8BA;AAAA;AIx/BA;AAAA;AAAA;AAjBA;AC2gDA;AA9QA;AAqRA;;APt5CA;;;;;;AO6/CA;;;AACA;;;;;AAEA;;;;;;;;AH3mDA;;;;;AGwmDA;;;AACA;;;;;AAEA;;;;AH3mDA;;ACi8DA;AAAA;AAAA;AHz8BA;AAAA;AIx/BA;AAjBA;AC2gDA;AA9QA;AAqRA;;AP/4CA;;;;;;AOs/CA;;;AACA;;;;;AAEA;;;;;;;;AH3mDA;;;;;AGwmDA;;;AACA;;;;;AAEA;;;;AH3mDA;;ACi8DA;AAAA;AAAA;AHz8BA;AAAA;AIx/BA;AAAA;AAAA;AAjBA;AC2gDA;AA9QA;AAqRA;;AP53CA;;;;;;AOm+CA;;;AACA;;;;;AAEA;;;;;;;;AH3mDA;;;;;AGwmDA;;;AACA;;;;;AAEA;;;;AH3mDA;;ACi8DA;AAAA;AAAA;AHz8BA;AAAA;AIx/BA;AAjBA;AC2gDA;AA9QA;AAqRA;;APv2CA;;;;;;AO88CA;;;AACA;;;;;AAEA;;;;;;;;AH3mDA;;;;;AGwmDA;;;AACA;;;;;AAEA;;;;AH3mDA;;ACi8DA;AAAA;AAAA;AHz8BA;AAAA;AIx/BA;AAjBA;AC2gDA;AA9QA;AAqRA;;AP71CA;;;;;;AOo8CA;;;AACA;;;;;AAEA;;;;;;;;AH3mDA;;;;;AGwmDA;;;AACA;;;;;AAEA;;;;AH3mDA;;ACi8DA;AAAA;AAAA;AHz8BA;AAAA;AIx/BA;AAAA;AAAA;AAAA;AAAA;AAAA;AAjBA;AC2gDA;AA9QA;AAqRA;;APt1CA;;;;;;AO67CA;;;AACA;;;;;AAEA;;;;;;;;AH3mDA;;;;;AGwmDA;;;AACA;;;;;AAEA;;;;AH3mDA;;ACi8DA;AAAA;AAAA;AHz8BA;AAAA;AIx/BA;AAAA;AAAA;AAAA;AAAA;AAAA;AAjBA;AC2gDA;AA9QA;AAqRA;;APnuCA;;;;;;AO00CA;;;AACA;;;;;AAEA;;;;;;;;AH3mDA;;;;;AGwmDA;;;AACA;;;;;AAEA;;;;AH3mDA;;ACi8DA;AAAA;AAAA;AHz8BA;AAAA;AIx/BA;AAAA;AAAA;AAjBA;AC2gDA;AA9QA;AAqRA;;AP5sCA;;;;;;AOmzCA;;;AACA;;;;;AAEA;;;;;;;;AH3mDA;;;;;AGwmDA;;;AACA;;;;;AAEA;;;;AH3mDA;;ACi8DA;AAAA;AAAA;AHz8BA;AAAA;AIx/BA;AAAA;AAAA;AAjBA;AC2gDA;AA9QA;AAqRA;;APxrCA;;;;;;AO+xCA;;;AACA;;;;;AAEA;;;;;;;;AH3mDA;;;;;AGwmDA;;;AACA;;;;;AAEA;;;;AH3mDA;;ACi8DA;AAAA;AAAA;AHz8BA;AAAA;AIx/BA;AAjBA;AC2gDA;AA9QA;AAqRA;;APzqCA;;;;;;AOgxCA;;;AACA;;;;;AAEA;;;;;;;;AH3mDA;;;;;AGwmDA;;;AACA;;;;;AAEA;;;;AH3mDA;;ACi8DA;AAAA;AAAA;AHz8BA;AAAA;AIx/BA;AAjBA;AC2gDA;AA9QA;AAqRA;;AP/pCA;;;;;;AOswCA;;;AACA;;;;;AAEA;;;;;;;;AH3mDA;;;;;AGwmDA;;;AACA;;;;;AAEA;;;;AH3mDA;;ACi8DA;AAAA;AAAA;AHz8BA;AAAA;AIx/BA;AAjBA;AC2gDA;AA9QA;AAqRA;;APrpCA;;;;;;AO4vCA;;;AACA;;;;;AAEA;;;;;;;;AH3mDA;;;;;AGwmDA;;;AACA;;;;;AAEA;;;;AH3mDA;;ACi8DA;AAAA;AAAA;AHz8BA;AAAA;AIx/BA;AAjBA;AC2gDA;AA9QA;AAqRA;;APvoCA;;;;;;AO8uCA;;;AACA;;;;;AAEA;;;;;;;;AH3mDA;;;;;AGwmDA;;;AACA;;;;;AAEA;;;;AH3mDA;;ACi8DA;AAAA;AAAA;AHz8BA;AAAA;AIx/BA;AAAA;AAAA;AAAA;AAAA;AAjBA;AC2gDA;AA9QA;AAqRA;;AP7nCA;;;;;;AOouCA;;;AACA;;;;;AAEA;;;;;;;;AH3mDA;;;;;AGwmDA;;;AACA;;;;;AAEA;;;;AH3mDA;;ACi8DA;AAAA;AAAA;;ADz8DA;;;;;AFkjCA;AAPA;AAVA;AIzhCA;AAAA;AAAA;;AAAA;AAAA;AAAA;;AAjBA;AC2gDA;AA9QA;AAqRA;;AP/mCA;;;;;;AOstCA;;;AACA;;;;;AAEA;;;;;;;;AH3mDA;;;;;AGwmDA;;;AACA;;;;;AAEA;;;;AH3mDA;;ACi8DA;AAAA;AAAA;AHz8BA;AAAA;AIx/BA;AAAA;AAAA;AAjBA;AC2gDA;AA9QA;AAqRA;;APhmCA;;;;;;AOusCA;;;AACA;;;;;AAEA;;;;;;;;AH3mDA;;;;;AGwmDA;;;AACA;;;;;AAEA;;;;AH3mDA;;ACi8DA;AAAA;AAAA;;ADz8DA;;;;;;AFkjCA;AAPA;AAVA;AIzhCA;AAAA;AAAA;;AAAA;AAAA;AAAA;;AAjBA;AC2gDA;AA9QA;AAqRA;;AP5lCA;;;;;;AOmsCA;;;AACA;;;;;AAEA;;;;;;;;AH3mDA;;;;;AGwmDA;;;AACA;;;;;AAEA;;;;AH3mDA;;ACi8DA;AAAA;AAAA;AHz8BA;AAAA;AIx/BA;AAAA;AAAA;AAAA;AAAA;AAAA;AAjBA;AC2gDA;AA9QA;AAqRA;;APrlCA;;;;;;AO4rCA;;;AACA;;;;;AAEA;;;;;;;;AH3mDA;;;;;AGwmDA;;;AACA;;;;;AAEA;;;;AH3mDA;;ACi8DA;AAAA;AAAA;AHz8BA;AAAA;AIx/BA;AAAA;AAAA;AAAA;AAAA;AAAA;AAjBA;AC2gDA;AA9QA;AAqRA;;APjlCA;;;;;;AOwrCA;;;AACA;;;;;AAEA;;;;;;;;AH3mDA;;;;;AGwmDA;;;AACA;;;;;AAEA;;;;AH3mDA;;ACi8DA;AHz8BA;AAAA;AIx/BA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAjBA;AC2gDA;AA9QA;AAqRA;;APvkCA;;;;;;AO8qCA;;;AACA;;;;;AAEA;;;;;;;;AH3mDA;;;;;AGwmDA;;;AACA;;;;;AAEA;;;;AP9pCA;;;AI7cA;AJ6cA;;;;;;;;;AQowBA;;;;;;AA4CA;AAiBA;AC30BA;AAAA;;;AArPA;;;;;;;AA6SA;;AL3fA;;AAAA;;;;;;AK2fA;;;AJuhEA;AACA;;;;ADnhFA;;;;;;;;;;;;;;;;AF89BA;AAAA;AAAA;AAAA;AA8DA;AAAA;AA5BA;AAlWA;AA4jFA;;AA1qEA;AAYA;AAZA;AAYA;;;;;AIpiCA;;;;;;;;;AJssGA;;;;;;;;AAEA;AAAA;AAAA;AAAA;;;;;AACA;;;;;;;;;;;;;;;;;;;;;;;;;AF5hGA;AAAA;AAAA;AEyxBA;;;;;AAAA;AAAA;;AA8DA;AA5BA;AAlWA;AAAA;;;AA8ZA;AAAA;AAAA;;;;;AIpiCA;;;;;;AJssGA;AAAA;AAGA;AAAA;;;;;;;;AADA;;;;;;;;;;;;;;;;;;AD/zDA;;;AA/tCA;AEhWA;;;AD2sCA;;;;;ADl1BA;;;AA1BA;;;;AIsoCA;;;;;;;;AJtoCA;;;;;;AGjMA;;;;;AF89BA;;;AE99BA;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AHyZA;AAAA;AAAA;AAAA;;AAsjBA;;;;;;;;;AGv9BA;;AHssBA;AACA;AAAA;AAAA;;;;;;;;;;;;AIyrBA;AAAA;AAAA;;AAAA;;;;;;;;;;;;;;;;;;;;;;;;ALzqCA;;;;;;;;;;;;;;;;;;;;;AE81BA;;;;;;;AD32BA;AAAA;;;;AADA;AAAA;;;;;;;;;;AC6xBA;;;;AF5wBA;AAAA;AAAA;;;AKuvDA;AJhjDA;AAAA;AAAA;;AAsjBA;;;;;;;;;;AAjRA;;;AACA;AIyrBA;;;;;;;;;;;;AAAA;;;;ALrqCA;;;;AE2wBA;AAAA;;;;;;;;;;ADrkBA;;;AAmSA;;;;;;;;;;AAGA;;;;;;;;;;;;;;;;;;;;;;;;;;AD1eA;;;;;;;;;AEq1BA;AAAA;;AI1iCA;;;;;;;;;AJ6iCA;;;;;;;;AD52BA;;;;;AACA;;;;;;;;;;;;;;;;;;AC4xBA;AAAA;;;;;;;;;;;;ADjSA;;;;;;;;;;;;;;;;;ACiSA;AAAA;;;;;;;;;;;;;;;;;;;;;;AAAA;AAAA;AAAA;AAAA;AAAA;;;;;;;;AD7xBA;AAAA;AAAA;AAAA;AAAA;;;;;;;AIsoCA;;;;;;;;;;;;AJroCA;;;;;;;;;;;;;;AC22BA;AE7iCA;;;;;;;;;;;AJmNA;;;;;;;;;AE2wBA;;;AE99BA;;;;;;AF89BA;AAAA;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AAAA;;;;;;;AD7xBA;AAAA;;AACA;;AIqoCA;AAAA;;;;;;AJtoCA;;;;;;;;;;;AACA;;;;;;;;;;;;;;;;;;;;;ADyEA;;;;ACzEA;AEhWA;AD4nCA;AAAA;;;;;;;;AD7xBA;;;;;;;;;;;;;;;AAAA;;;;AGjMA;;AD9JA;AAAA;;AD4nCA;;;AE99BA;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;ACy8DA;;;AJhjDA;;;;;;;;;;;;;;;;AAsSA;AIyrBA;;;;;;;AAgKA;;;;;;AAhKA;;AAAA;;ALppCA;;;;;AE0vBA;AAAA;;;;;;;;;;;;;AFzvBA;;;;;;;;;;;;;;;;;;;;;AIrOA;;;;;;;AHiMA;;;;AIsoCA;AAAA;AAAA;;;;;AJtoCA;;;;;;;;;;;;AC42BA;;;;AFt0BA;AAAA;AAAA;AAAA;;;;;AKkuDA;;;AJ1/BA;;;AAnRA;;;;AGpsBA;;;;;;;AHssBA;;AI0rBA;;AAgKA;;;;;;;;AAhKA;;;;;;;;;;;;;;;;;;;;;ADx3CA;;AJwOA;;;;;;ACrBA;AAsMA;;;AAmSA;;;;;;;;;;;;;AI4rBA;;;;;;;;;AAAA;AAAA;;AAAA;;;;;;;;;ACz4CA;AAAA;;;;;;;;;AJ8jCA;;AFh0BA;;;;;;;;;;AE4yBA;;;AFzyBA;;;;;;;;;;;;;;AE8uBA;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AAAA;;;;;ADnwBA;;;;AAzBA;AAAA;;AIqoCA;;;;;;AJtoCA;;;;;;;;;;;;;;;AC6xBA;;;;;;;;AE99BA;;;;;;;;;;;;;;;;;;;AH6rBA;;;;;;;;ACiSA;;;AE99BA;;;;AF89BA;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AAAA;;;AE99BA;;;AHiMA;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AACA;;;AGlMA;;AF89BA;AAAA;;;;;AA+EA;;;;;;;AA/EA;AAAA;;;;;;;;;;;;;AE99BA;;;;;;;;;;;AHmNA;AIsvDA;;AJhjDA;AAAA;AAAA;AAAA;;AAsjBA;;;;;AAnRA;;;;;;;;;;;AAEA;AAAA;;;;;;;;;;;;;;;;;;AI0rBA;AAAA;;;;;;;;;;;;;AJpaA;AAAA;;;;;;AKr+BA;;;;;;;AJ++BA;;;;;AFhtBA;AAAA;;;;;;;;;AAAA;;;;;;;AAEA;;;;;;;;;;;;AG9aA;AD4nCA;AAAA;AAAA;;AA+EA;;;AC3sCA;;;AF+VA;;;;;;;;;;;;;;;AAAA;;;;;AACA;AAAA;AAAA;;;;;;;;AEhWA;;;;;;;;;;;;;;;;;AC8JA;;AD9JA;;;;AF+VA;AAAA;;AACA;AAAA;;;;;;;;;;;;;;;;;;;;;;;;AGlMA;;AAAA;;;;;AJkRA;;;AAAA;;;;AAAA;AAAA;;;;;;ACuIA;AAAA;;;AAsjBA;AAAA;AAAA;;;;;;;;;;AGv9BA;;;;;;AHssBA;AACA;AAAA;;;;;;;AIy1BA;;;;;;;;AAhKA;AAAA;AAAA;;;;;;;;;;;;;;;;;;;;;;;AH1ZA;AAAA;;;AF3sBA;;;;;AE2sBA;AA+EA;;;;;;;;;;;;;;;;;;;AG0RA;AAAA;AAAA;;;;;;;AJtoCA;AAAA;;;;;;;;;;AACA;AAAA;;;;;;;;;;;AC4xBA;AAAA;;;;;;;;;;AC5nCA;AD4nCA;;;;;AA+EA;;;;;AD52BA;AAAA;;;;;;;;;;;AIsoCA;;;;;;;;;;;;;;;;;;;AJroCA;;;;;;;;AGlMA;;AF89BA;AAAA;AAAA;;AA+EA;AE7iCA;;AD9JA;AD4nCA;AAAA;;;AA+EA;;;AC3sCA;;;AF+VA;;;;AACA;;AIqoCA;AAAA;;;;;;;;;;;;;;;;;;;;;;;;;AHzWA;;AAAA;AAAA;;;;;;;ADnwBA;;;;;;;;;;;AI4mCA;;;;;;;;;;;;;;;;;;;;;;;;;;ADv0CA;;;AF6iCA;AE7iCA;AAAA;;;;;;;;AF89BA;;;;;;;;;;;AD5xBA;AAAA;;;;AADA;AAAA;;;;;;;;;AACA;;;;;;;;;;AEhWA;AAAA;AD4nCA;;;;;;;;;;;;;;;;;;;AAAA;;AC5nCA;;AF+VA;;;;;;AIsoCA;;;;;;;;AJtoCA;;;;;;;;;;;;;AC42BA;AE7iCA;;;;;;;;;;;AF89BA;AAAA;ADnwBA;;;AA1BA;;;;;;AIsoCA;AAAA;AAAA;;;;;;;;;;;;;;;;;;;;;;;;ADv0CA;;;;;;;AM3DA;;;;;;;;;;;;;;;;;;;;;;;;AHq2CA;;;;;;;;;;;;;;;;;AP/9BA;;;;;;;;AAAA;;;;;;AChHA;;;AA1BA;AAAA;AAAA;;AACA;AAAA;;;;;;;;;AADA;;;;;;;;;;;;AC6xBA;;;;;;AA+EA;AE7iCA;;;;AF89BA;AAAA;AAAA;AAAA;AAAA;;;;AD7xBA;;AAAA;;;;;;;;;;;;;;;;;;;AACA;AAAA;AAAA;AAAA;AAAA;;;AGlMA;;;;;AF89BA;AAAA;AAAA;AAAA;AAAA;;;;;;;;;;;;;;;;AFjpBA;AAAA;AAAA;AAAA;AAAA;;;;;;;AEguBA;;AC3sCA;;;;;;;;;;AEq+CA;;;;;;;;AJtoCA;;;;;;;AACA;;;;;;;;;;AC4xBA;AAAA;;;;AC5nCA;AD4nCA;AAAA;AAAA;;AA+EA;;;AC3sCA;;;AF+VA;;;;;;;;;AIsoCA;AAAA;;;;;;;;;;;;;;;;;;;;AJroCA;;;AGlMA;;;;AF89BA;;;AA+EA;;;AF/tBA;;;AACA;;;AKknDA;;ADz8DA;;AF2iCA;AAAA;AAVA;AAAA;;AA2QA;;;;;;;;;;;;;;AAvPA;AE7iCA;;;;AAAA;;;;;;;;;;;;;;AAAA;;;AH2NA;;AA1BA;;;AACA;AAAA;AAAA;;AIqoCA;;;;;;AJtoCA;;;;;;;AACA;;;;;;;;;;AEhWA;;AC8JA;AGizCA;;;;;;;;;;;;;ANtlCA;AAAA;;;;;;;;;;;;;;;;;;;;;;;;;;;;AAzBA;AAAA;;;;;;;;;;AC4xBA;;AAA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;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AjBzIA;;AAEA;;;;;;;AAAA;;;;;;;AACA;;;;;;;;AAAA;;;;;;;AAAA;;;;;;AG/JA;;AC8JA;;AD9JA;AFyXA;;AA1BA;AAAA;;;;;;;;AACA;AAAA;;AIqoCA;AAAA;;;;;;;AJtoCA;;;;;;;;AACA;;;;;;;AGlMA;;AD9JA;;;;;;AC8JA;;;;;AD9JA;;AC8JA;;AD9JA;AFyXA;;AA1BA;AAAA;;;;;;;;AACA;AAAA;;AIqoCA;AAAA;;;;;;;AJtoCA;;;;;;;;AACA;;;;;;;AGlMA;;AD9JA;;AC8JA;;;AJEA;;;;;;;AAAA;;;;;;AGhKA;;AC8JA;;AD9JA;AFyXA;;AA1BA;AAAA;;;;;;;;AACA;AAAA;;AIqoCA;AAAA;;;;;;;AJtoCA;;;;;;;;AACA;;;;;;;AGlMA;;AD9JA;;;;;;AC8JA;;;;;AD9JA;;AC8JA;;AD9JA;AFyXA;;AA1BA;AAAA;;;;;;;;AACA;AAAA;;AIqoCA;AAAA;;;;;;;AJtoCA;;;;;;;;AACA;;;;;;;AGlMA;;AD9JA;;AC8JA;;;;AD9JA;ADiuCA;AAAA;AAAA;AD13BA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;;;;ADpMA;ACoZA;;;AIwiDA;AAAA;AAAA;;ADz8DA;;;;;;;AFkjCA;AAPA;AAVA;AIzhCA;AAAA;AAAA;;AAAA;AAAA;AAAA;;AAjBA;;ANuBA;;;;;;;;;;;AINA;;;;;;;;AAAA;;;;;AJQA;AACA;ACgZA;AAAA;ADhZA;;;;AAAA;;;;;;;;AC2UA;;;;;;AElfA;;AC8JA;;AD9JA;AFyXA;;AA1BA;AAAA;;;;;;;;AACA;AAAA;;AIqoCA;AAAA;;;;;;;AJtoCA;;;;;;;;AACA;;;;;;;AGlMA;;AD9JA;;;;;;AC8JA;;;;;AD9JA;;AC8JA;;AD9JA;AFyXA;;AA1BA;AAAA;;;;;;;;AACA;AAAA;;AIqoCA;AAAA;;;;;;;AJtoCA;;;;;;;;AACA;;;;;;;AGlMA;;AD9JA;;AC8JA;;;;;;AH0wCA;;;;;;;;;;;;;;;;AD/vCA;AEm9BA;AAAA;AA8DA;;;AGq6BA;AAAA;AAAA;;ADz8DA;;;;;;;AFkjCA;AAPA;AAVA;AIzhCA;AAAA;AAAA;;AAAA;AAAA;AAAA;;AAjBA;;AN6BA;;;;;;;;;;;AIZA;;;;;;;;AAAA;;;;;AJcA;AACA;AAAA;AAAA;AE+8BA;;AF/8BA;;;;AAAA;;;;;AAAA;;;;;;;;;;;;AKk7DA;AAAA;AAAA;;ADz8DA;;;;;;AFkjCA;AAPA;AAVA;AIzhCA;AAAA;AAAA;;AAAA;AAAA;AAAA;;AAjBA;;ANkCA;;;;;;;;;;;AIjBA;;;;;;;;;AAAA;;;;;;;;;;;AJmBA;;;;;;;AAAA;;;;;;;AAAA;;;;;;AGjLA;;AC8JA;;AD9JA;AFyXA;;AA1BA;AAAA;;;;;;;;AACA;AAAA;;AIqoCA;AAAA;;;;;;;AJtoCA;;;;;;;;AACA;;;;;;;AGlMA;;AD9JA;;;;;;AC8JA;;;;;AD9JA;;AC8JA;;AD9JA;AFyXA;;AA1BA;AAAA;;;;;;;;AACA;AAAA;;AIqoCA;AAAA;;;;;;;AJtoCA;;;;;;;;AACA;;;;;;;AGlMA;;AD9JA;;AC8JA;;AD9JA;;AC8JA;;AD9JA;AFyXA;;AA1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PA;;;AIsyBA;;AAGA;ADphDA;;;;AeUA;AAAA;;;;;AAAA;AAAA;AAAA;;;;;;AAzFA;AAAA;AAAA;AAAA;AAAA;AAAA;AAyFA;AAAA;;;AHuFA;AACA;;;;;;AA6BA;;;;;ALnUA;;;AAAA;;;;AVkhDA;AAAA;;AA/qBA;;;;;;;;;AErzBA;AAAA;AAAA;;ADiuCA;;;ACjuCA;;AFgXA;AACA;;AACA;AIqvDA;AJp9BA;AAAA;AACA;AAAA;AAAA;;AACA;;;AACA;;AEtpCA;;;;;AAAA;AAAA;;ADuhDA;;;;;ACvhDA;;;AFmpCA;;AACA;;;;;AACA;;;;;AACA;AEtpCA;;AAAA;AAAA;AAAA;AAAA;;AEwjDA;;;;;;;;;;;;AeitFA;;AJniIA;;;;;AAAA;;;;;;;;AA+CA;;AfitCA;;AIuMA;AD/gDA;AHw0CA;;;;AEt+CA;AD4nCA;AAAA;;;;;;AC5nCA;AFyXA;AAAA;;AA1BA;;;;;;;;;;;;;;AAAA;;;;;;;;;;;;;;;;;AGjMA;;;;AF89BA;;;AA+EA;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AU9qCA;;;;;;;AH0iBA;;AA0BA;;;;;;;;;AA2GA;AY9vBA;;AnB8qCA;AA8FA;AAAA;;AOznBA;;;AaneA;;Ab8OA;;;;;AA6SA;;;;;AD5XA;;AAeA;;;;;;;;;;AC6WA;;;;;AA7DA;;;;;;;;;;;;;AA6DA;;;;APkjBA;AAAA;AE7iCA;;;;;;;;;AQ1HA;;AJwQA;;AIvQA;;;;;AAKA;;AAAA;;;;;;;;AVklCA;;;;;AA+EA;;;;;AA/EA;;;AU/iCA;;;;;AAjCA;;;;;;;AVglCA;AAAA;;;;;;;;AA+EA;;;;AU9nCA;;AV8nCA;AE7iCA;;;AQ3GA;;;;;;;;;;;;;AJmOA;AAAA;;AG1UA;;;;;;;;;;;;;AAAA;;;;;ACyGA;;;AVspCA;;;AA/EA;AAAA;;;;;;;;;;;;;;AAAA;;AA+EA;AE7iCA;;;;;;;;;;AF89BA;AAAA;;;;;AA+EA;;;;;AUppCA;;;;;AVmmHA;;;;;;;;AUhlHA;;;AVkjCA;;;;;;;;;;;AC5nCA;AD4nCA;;AE99BA;AH2NA;;;;;;;;;AI4mCA;;;;;;;;;;;;;;;AJroCA;;;;;AEhWA;AD4nCA;;;AA+EA;AAAA;AAAA;AAAA;AAAA;AAAA;;;;;AC3sCA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;;;;;AC8JA;;;AH2NA;AA1BA;;;AACA;;;;;;;;;;;;;;;;;;;;;;;;AAAA;;;;;;;;AGlMA;;AmBRA;;;ArBwjCA;;;;;AqBvjCA;;ArBq+BA;;;;;;;;;;;;AqBp+BA;AAAA;;AAAA;AAAA;AAAA;;AAAA;ArBo+BA;;AE99BA;;;;;AF89BA;;;;AqBl+BA;;;;;;;ArBk+BA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;;AE99BA;;;;;;;;;;;;;;;;;;;;;;AF89BA;AAAA;AAAA;;AAAA;AE99BA;;AF89BA;AAAA;;;;;ADnwBA;;;;;AA1BA;;;;;;AACA;AAAA;;AIqoCA;AAAA;AAAA;AAAA;;;;;;;;;;;AJtoCA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;;;;;;;;;;;;;;;;AACA;AAAA;;;;;;AGlMA;;AF89BA;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;;AAkFA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;;;;;AqBv5BA;;;AlB0yDA;;AmBr+DA;;ACkfA;;;;;;;;;;;;;;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;;;;;;;;;;;;;;;;AClbA;;AADA;;;;;;;;;;;;;;;;;AxBqiCA;AAAA;AAAA;;;;;;;;;;;;;;;;;;;AqBr6BA;AAAA;;AAAA;AAAA;;AEyKA;AAAA;AAAA;AAAA;;;;;;;;;;;AFtKA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;ArB6zBA;AAAA;AA+EA;;;AqB14BA;;;;;;;;AtB+rCA;;AEhgDA;;ADuhDA;;ACvhDA;;AFiXA;;AIsvDA;;AJn9BA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;;AIq+BA;;AJn+BA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;;ACiYA;;ACvhDA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;;AFugDA;;;;;;;;;;;;;;;;;AC3YA;AE99BA;;AH2NA;AAAA;;AA1BA;;;;;;;;AIsoCA;;;;;;AJtoCA;AAAA;;;;;;;;;;;;;;;;;;;;;;AC6xBA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AqB1zBA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;ArB0zBA;;;;;;;;;;;AAkCA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;;;;;AA6vEA;;;;;;;AqB/kGA;;;;;ArB+3BA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;;;;AA/EA;;;;;;;;;;;;;;AqBzzBA;;;;;;;;;;;;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;;;;;;;;AtB4BA;;;;;;;;;;;;;;;;;AA0BA;AAAA;;AA1BA;;;AACA;AADA;AAAA;;AACA;;AAAA;AAAA;AAAA;;;;;AADA;;;;;;;AC6xBA;;;;;;;;;;;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;;;;;AE99BA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;;;;;;;;;;;;;;;;;;;;;;;;;;AF89BA;;;;;;;;;;;;;;;;;;;;;AA+EA;;ADl1BA;;AA1BA;AAAA;;;;;;;;;;;;;;;;;;;;;;;;;;;;AD9SA;;AAEA;;;;;;;AAAA;;;;;;;;;;AK4iEA;AAAA;AAAA;;ADz8DA;;;;;;AFkjCA;AAPA;AAVA;AIzhCA;AAAA;AAAA;;AAAA;AAAA;AAAA;;AAjBA;;ANxFA;;;;;;;;;;;AIyGA;;;;;;;;;AAAA;;;;;;;;;;;ACi8DA;AAAA;AAAA;;ADz8DA;;;;;;;AFkjCA;AAPA;AAVA;AIzhCA;AAAA;AAAA;;AAAA;AAAA;AAAA;;AAjBA;;ANrFA;;;;;;;;;;;AIsGA;;;;;;;;AAAA;;;;;AD9JA;AFuWA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AD1SA;AAAA;AADA;AAAA;AAAA;AAAA;;AACA;;;;;;AACA;ACwsCA;;AAAA;;;;;;AA/5BA;AAAA;AAAA;AAAA;AAAA;AAAA;;ADtSA;;;;;;;AACA;ACosCA;;AAAA;;;;;;ADjsCA;AAAA;;AAAA;;;;;;;;AAAA;;;;;;AGrEA;;AC8JA;;AD9JA;AFyXA;;AA1BA;AAAA;;;;;;;;AACA;AAAA;;AIqoCA;AAAA;;;;;;;AJtoCA;;;;;;;;AACA;;;;;;;AGlMA;;AD9JA;;;;;;AC8JA;;;;;AJzFA;AGrEA;;AC8JA;;AD9JA;AFyXA;;AA1BA;AAAA;;;;;;;;AACA;AAAA;;AIqoCA;AAAA;;;;;;;AJtoCA;;;;;;;;AACA;;;;;;;AGlMA;;AD9JA;;AC8JA;;;;AJvFA;;AAAA;;;;;;;;AAAA;;;;;;AGvEA;;AC8JA;;AD9JA;AFyXA;;AA1BA;AAAA;;;;;;;;AACA;AAAA;;AIqoCA;AAAA;;;;;;;AJtoCA;;;;;;;;AACA;;;;;;;AGlMA;;AD9JA;;;;;;AC8JA;;;;;AD9JA;;AC8JA;;AD9JA;AFyXA;;AA1BA;AAAA;;;;;;;;AACA;AAAA;;AIqoCA;AAAA;;;;;;;AJtoCA;;;;;;;;AACA;;;;;;;AGlMA;;AD9JA;;;;AC8JA;;;;;AJrFA;;AAAA;;;;;;;AAAA;;;;;;AGzEA;;AC8JA;;AD9JA;AFyXA;;AA1BA;AAAA;;;;;;;;AACA;AAAA;;AIqoCA;AAAA;;;;;;;AJtoCA;;;;;;;;AACA;;;;;;;AGlMA;;AD9JA;;;;;;AC8JA;;;;;AJrFA;AGzEA;;AC8JA;;AD9JA;AFyXA;;AA1BA;AAAA;;;;;;;;AACA;AAAA;;AIqoCA;AAAA;;;;;;;AJtoCA;;;;;;;;AACA;;;;;;;AGlMA;;AD9JA;;AC8JA;;AJnFA;AAAA;AAAA;;AW/HA;;;;;;;AAAA;AVoaA;AACA;AAAA;AIsvDA;AJhjDA;AAAA;AAAA;AAAA;AAsjBA;AAAA;;;;;;AAlRA;;;;AGrsBA;;;;;;AHssBA;AAAA;AACA;;;;;;;;;AIy1BA;;;;;;AAhKA;AAAA;AAAA;;;;;;;;;AJpaA;;;;;;AGp9BA;;;;;;AOlNA;;AXgIA;;;;;;AWhIA;;;;;;APkNA;;;;;AOlNA;;APkNA;;AOlNA;;APkNA;;;AAAA;;AD9JA;AFyXA;;AA1BA;;;;;;;;AACA;AAAA;;AIqoCA;AAAA;;;;;;;AJtoCA;;;;;;;;AACA;;;;;;;AGlMA;;;AAAA;;AD9JA;;AC8JA;;AD9JA;AFyXA;;AA1BA;AAAA;;;;;;;;AACA;AAAA;;AIqoCA;AAAA;;;;;;;AJtoCA;;;;;;;;AACA;;;;;;;AGlMA;;;AAAA;;AD9JA;;AC8JA;;AD9JA;AFyXA;;AA1BA;;;;;;;;AACA;AAAA;;AIqoCA;AAAA;;;;;;;AJtoCA;;;;;;;;AACA;;;;;;;AGlMA;;AD9JA;;AI+8CA;;;AHjzCA;AGizCA;;;;;;;;;;;;;;;;;;;;AIngDA;;APkNA;;;;;;;;;;;;AAAA;;AD9JA;AFyXA;;AA1BA;AAAA;;;;;;;;AACA;AAAA;;AIqoCA;AAAA;;;;;;;AJtoCA;;;;;;;;AACA;;;;;;;AGlMA;;;AAAA;;;;;;;;;;;AD9JA;;AC8JA;;AD9JA;AFyXA;;AA1BA;AAAA;;;;;;;;AACA;AAAA;;AIqoCA;AAAA;;;;;;;AJtoCA;;;;;;;;AACA;;;;;;;AGlMA;;AD9JA;;AC8JA;;;;;;;;;;;;;;AD9JA;;AC8JA;;AD9JA;AFyXA;;AA1BA;AAAA;;;;;;;;AACA;AAAA;;AIqoCA;AAAA;;;;;;;AJtoCA;;;;;;;;AACA;;;;;;;AGlMA;;AD9JA;;;;AC8JA;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AuBjLA;AAAA;;;;;;AzB+oCA;AAAA;;;;;AE99BA;;;AF89BA;;;AA+EA;;A0BjpCA;AAAA;;A1BkkCA;AAAA;AAAA;;AE99BA;;AwBpGA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;;;;;;;;;;;;;AANA;;A1BwkCA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;;AE99BA;AAAA;;;AwBpGA;AAAA;;;;;AFspBA;;;;;;;;;;;;;;;;AChuBA;;;;AAMA;;;;;;;;;AALA;;;;;;;AzB2oCA;;AAkFA;;;;;;;AyB3tCA;;;;AACA;;;;;AJtBA;;;;;;;;;;;;AnBwLA;;;AETA;;;;;;;AO6uCA;AAAA;AAAA;AAAA;;;;;;;;;;;;;;;;;;;;;;AX9PA;;;;;;;;;;;AqBtoCA;AAAA;AAAA;;;;AnBgKA;AAAA;AAAA;;;AETA;;;;;;;;;;;;;;;;;;;AiB7JA;AAAA;AAAA;;;AV04CA;;;;;;;;;;;AT5tCA;;;;;;;;;;;;;;;AsBgrBA;AAAA;;AAFA;AFhtBA;AAAA;;;;ACkfA;AAAA;AAAA;;;;;;;;;AACA;AAAA;AAAA;;;;;;;;;;;;AC3dA;AAAA;AAAA;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AHtJA;;AEueA;AAAA;AAAA;;;;;;AFteA;;;;;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AAAA;;ADz8DA;;;;;;AFkjCA;AAPA;AAVA;AIzhCA;AAAA;AAAA;;AAAA;AAAA;AAAA;;AAjBA;;ANoHA;;;;;;;;;;;AInGA;;;;;;;;;AAAA;;;;;;;;;;AJqGA;;;;;;;AAAA;;;;;;;AAAA;;;;;;AGnQA;;AC8JA;;AD9JA;AFyXA;;AA1BA;AAAA;;;;;;;;AACA;AAAA;;AIqoCA;AAAA;;;;;;;AJtoCA;;;;;;;;AACA;;;;;;;AGlMA;;AD9JA;;;;;;AC8JA;;;;;AD9JA;;AC8JA;;AD9JA;AFyXA;;AA1BA;AAAA;;;;;;;;AACA;AAAA;;AIqoCA;AAAA;;;;;;;AJtoCA;;;;;;;;AACA;;;;;;;AGlMA;;AD9JA;;AC8JA;;;AJsGA;;;;;;;AAAA;;;;;;;AAAA;;;;;;AGpQA;;AC8JA;;AD9JA;AFyXA;;AA1BA;AAAA;;;;;;;;AACA;AAAA;;AIqoCA;AAAA;;;;;;;AJtoCA;;;;;;;;AACA;;;;;;;AGlMA;;AD9JA;;;;;;AC8JA;;;;;AD9JA;;AC8JA;;AD9JA;AFyXA;;AA1BA;AAAA;;;;;;;;AACA;AAAA;;AIqoCA;AAAA;;;;;;;AJtoCA;;;;;;;;AACA;;;;;;;AGlMA;;AD9JA;;AC8JA;;AD9JA;;AC8JA;;AD9JA;AFyXA;;AA1BA;AAAA;;;;;;;;AACA;AAAA;;AIqoCA;AAAA;;;;;;;AJtoCA;;;;;;;;AACA;;;;;;;AGlMA;;;AAAA;;AD9JA;;AC8JA;;AD9JA;AFyXA;;AA1BA;AAAA;;;;;;;;AACA;AAAA;;AIqoCA;AAAA;;;;;;;AJtoCA;;;;;;;;AACA;;;;;;;AGlMA;;;AAAA;;AD9JA;;AC8JA;;AD9JA;AFyXA;;AA1BA;AAAA;;;;;;;;AACA;AAAA;;AIqoCA;AAAA;;;;;;;AJtoCA;;;;;;;;AACA;;;;;;;AGlMA;;AD9JA;;AC8JA;;AD9JA;;AC8JA;;AD9JA;AFyXA;;AA1BA;AAAA;;;;;;;;AACA;AAAA;;AIqoCA;AAAA;;;;;;;AJtoCA;;;;;;;;AACA;;;;;;;AGlMA;;AD9JA;;AI+8CA;;;AHjzCA;AGizCA;;;;;;;;;;;;;AJ/8CA;;AC8JA;;AD9JA;AFyXA;;AA1BA;AAAA;;;;;;;;AACA;AAAA;;AIqoCA;AAAA;;;;;;;AJtoCA;;;;;;;;AACA;;;;;;;AGlMA;;;AAAA;;AD9JA;;AC8JA;;AD9JA;AFyXA;;AA1BA;AAAA;;;;;;;;AACA;AAAA;;AIqoCA;AAAA;;;;;;;AJtoCA;;;;;;;;AACA;;;;;;;AGlMA;;;AAAA;;AD9JA;;AC8JA;;AD9JA;AFyXA;;AA1BA;AAAA;;;;;;;;AACA;AAAA;;AIqoCA;AAAA;;;;;;;AJtoCA;;;;;;;;AACA;;;;;;;AGlMA;;AD9JA;;AC8JA;;;;;;;;;;;;;;AD9JA;;AC8JA;;AD9JA;AFyXA;;AA1BA;AAAA;;;;;;;;AACA;AAAA;;AIqoCA;AAAA;;;;;;;AJtoCA;;;;;;;;AACA;;;;;;;AGlMA;;AD9JA;;;;AC8JA;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AF89BA;AAAA;;AAAA;;;;;;;;;;;AAAA;AAAA;AAAA;AAAA;;;;;ADnwBA;;;;;;;;;;;AI4mCA;AAAA;;;;;;;;;;;;AJroCA;;;;;;;;;AGlMA;AAAA;;AF89BA;AAAA;;;;;;;AqBt+BA;AAAA;AAAA;;ArBs+BA;;;AAkFA;;;;;;AqBvjCA;AAAA;AAAA;AAAA;;ArBq+BA;;AAkFA;AAAA;AAAA;;;;;AqBtjCA;AAAA;;AAAA;;AAAA;AAAA;AAAA;AAAA;;;;AnBMA;;AF89BA;AAAA;;AqBl+BA;ArBijCA;AE7iCA;AAAA;AAAA;;;;;;;;AF89BA;;AAAA;;AA+EA;AAAA;;;;;;;;;;;;;;;;;A2Bv9BA;A3Bw4BA;AAAA;;;;AE99BA;;AF89BA;AAAA;;;;;AC5nCA;AD4nCA;AAAA;AAAA;AAAA;;AE99BA;;;AH2NA;AAAA;;;;AA1BA;;;;AACA;AAAA;;;;;;;;;;;AADA;AAAA;;;;;;;;;;;;;;;;;;;;AGjMA;AAAA;;AF89BA;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AAAA;AAAA;;;;;;;AqBr0BA;AAAA;AtBgDA;AAAA;;AAEA;AyBqeA;AAAA;AAAA;AAAA;;;AFltBA;AAAA;AADA;AAAA;;;;;;;;;;;;;ACqfA;AC8NA;AAAA;AAAA;AAAA;AAAA;;;;;;;;;AA1rBA;AAwCA;AAAA;AAAA;AADA;;;;;;AxBi8BA;;AAAA;;;;AA+EA;;;;;AAsBA;;;;;;;;;;;;;;;;;;;;;;;;;AqBr6BA;AAAA;AAAA;AAAA;AAAA;;;AEyKA;AAAA;AAAA;AAAA;;;;;AFtKA;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AtBisCA;AAAA;AAAA;AAAA;;;;;AC/RA;ACjuCA;;AFgXA;AACA;AAAA;AAAA;AAAA;;;;;AAoyBA;AAAA;;AC4EA;ACjuCA;AAAA;AAAA;;AFugDA;;;AAGA;;;;;;;;;;AC9YA;;;;;;;ADnwBA;;AA1BA;AAAA;;;;;AACA;AAAA;;AIqoCA;AAAA;AAAA;AAAA;;;;;AJtoCA;;;;;;;;;;;;AC6xBA;;;AE99BA;;;;AF89BA;;;;;;AqB1zBA;;;;;;;;;;;;;;AnBpKA;;;;;;;;;;AFmkCA;;;;;;;;;;;;AArGA;;;;;AA8DA;AAAA;;AAguEA;;;;;;;;;;;;;;;;;;;;;;;;;;AA9xEA;;;AE99BA;;;;;;;;;;;;AmBqKA;;;;;;;;;;;;;AtB4BA;AAAA;AAAA;;;;AACA;AAAA;AAyBA;AAAA;AAAA;;;;;;AA1BA;;AACA;AAAA;;AAAA;;;AAAA;AAAA;;;;AAyBA;;;AA1BA;AAAA;;AACA;AAAA;;AAAA;AAAA;AAAA;AAAA;;AGlMA;AHiMA;AAAA;;;;;;;;;;;;;;;;;AC42BA;AE7iCA;AAAA;;AF89BA;;;AA+EA;AE7iCA;;;;;AHkMA;AAAA;;;;;;;;;;;;;AC4xBA;AAAA;;AA+EA;AAAA;;;;;;;;;;;;;;;;;;;;;AA/EA;AAAA;;;;;;;ADnwBA;AAAA;;;;;;;;;;;;;;;;;;;AA1BA;AAAA;;;;;;;;;;;;AACA;AAAA;AAAA;;;;;;;;;;AC4xBA;;;AE99BA;;;;;;;;;;;;AF89BA;AAAA;;AA+EA;;;;;;;;;;;;;;;;;;;;;;;;;;;ADl1BA;AAAA;AAAA;;AAAA;;;AA1BA;;;;AACA;;;;;;AADA;AAAA;;AACA;AAAA;;AAAA;AAAA;AAAA;;AAAA;AGlMA;;AHiMA;;;;;;;;;;;;AGjMA;;;;;;;AH2NA;;;AA1BA;AAAA;AAAA;;;;;;;;;;;;;;;;;;;;AAAA;AAAA;;;;;;;;;;AACA;;;;;;;;;AEhWA;;;AD4nCA;AA+EA;;;;;;;;AC3sCA;;;AD4nCA;AAAA;;;AA+EA;AE7iCA;AAAA;;AD9JA;;AF+VA;;;;;;;;AACA;AAAA;;AIqoCA;;;;;;;;AJtoCA;;;;;;;;AACA;;;;;;;AGlMA;;;AF89BA;;AA+EA;;;;;;;;A2Bv9BA;AlBxSA;AAAA;AAAA;;ATgrCA;;AA+EA;AA/EA;AAAA;AA+EA;AE7iCA;;;;;;;;ACohFA;;;;;;;;;;;AJn1EA;;;;;;;;;;AGjMA;;AH2NA;AAAA;;AA1BA;AAAA;;;;;;AACA;AAAA;;AADA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;;;;;;;;;;;AGjMA;;AD9JA;AAAA;;AD4nCA;;;;;;ADnwBA;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AG3NA;AAAA;;;;;AF6iCA;AE7iCA;AAAA;;;;;;;;;;;AD9JA;AAAA;AAAA;AAAA;;AAAA;;;AAAA;AAAA;AFgXA;AACA;AAAA;AAAA;;AAAA;AAAA;AAAA;;AACA;AIqvDA;AJhjDA;AAAA;AAAA;;AAAA;;;;;;AAoSA;;;;AGrsBA;;;;AHssBA;;;AI6xCA;AJ5xCA;AAmRA;AAAA;;AAAA;;;;;;;;;;;;;;AEhnCA;;;;;;;;;;AAAA;AAAA;AAAA;;AAAA;;;;AD4nCA;;;;;;;;;;;;;;;;;ADrkBA;AAAA;;AAAA;AAAA;;;AAsUA;;AI6vCA;AAAA;;AJ/0DA;;;;AAolBA;;;;;;AIwyBA;AAAA;;ADjhDA;;;;AeUA;;;;;;;;AAAA;;AAzFA;AAyFA;;;;AHuFA;AAAA;;AACA;;;;;AcpTA;;;;;A3B4DA;AAAA;AAAA;AAAA;AAAA;;ADuhDA;;;ACvhDA;;AFiXA;AACA;AIqvDA;AAAA;;AJn9BA;;;AIq+BA;AAAA;;;;AJn+BA;AAAA;AAAA;AEtpCA;AAAA;AAAA;;;;Aa8RA;;;AACA;AAAA;AACA;AAAA;;AAAA;;;AACA;AAAA;AC2vBA;AAAA;AACA;;;;AhBxOA;AAAA;;;AIgwBA;;;;AAEA;AyBnnDA;AAAA;;;;AAAA;;;AAAA;A3B4DA;AAAA;AAAA;;AAAA;;;ADiuCA;ACjuCA;AAAA;AAAA;AFiXA;;;;AAmyBA;AIq+BA;;;AJn+BA;AAAA;AAAA;;ACiYA;AAtTA;;ACjuCA;A2B5DA;AAAA;AAAA;;Ad2VA;;;AAAA;AAAA;;;;AACA;AACA;AAAA;AAAA;AC2vBA;AAAA;;;AACA;;;AZ2hBA;AAAA;AAAA;AAAA;;;;;;;;;AeitFA;;;AJliIA;;;;;;;;;Af+vCA;;;;;;;;;;;;;;;Aex9CA;AAAA;ACogCA;;AACA;;;;;;;;;AD5yBA;AAAA;;;;AAAA;;;AZzEA;;AD9JA;;AD4nCA;;AD7xBA;;;;;;;;;;;;;;;;;;;;;;AACA;;;;;;;;;;;;;AC4xBA;AAAA;AAAA;;;;;;AE99BA;AAAA;A0B1NA;;;;;;;;;;;;;A5BwrCA;;;;;ADnwBA;;;;;AA1BA;;;;;;AACA;;;;AIqoCA;;;;;;;;;AJtoCA;;;;;;;;;;;AACA;;;;;;;;;;AGlMA;;;;;AF6iCA;;;;;AA/EA;AAAA;;AA+EA;;;;;ADl1BA;AAAA;;AA1BA;;;;;;;;;;;;;AACA;;;;;;;;AADA;AAAA;AAAA;;;;;;;;;;;;;;AACA;;;;;;;;;;;;;AEhWA;;AD4nCA;;;;AE99BA;;;;;;;;;;;;;Aas0BA;;AAAA;AZqpCA;;;;;;AYvyDA;;;;AbpLA;;;AF89BA;;;;AA+EA;;;;;Aep9BA;AAAA;AAAA;;;;;;AAEA;AAAA;AACA;;;;;;Ab5FA;AYhHA;AAAA;AAAA;;;AAxBA;AAAA;AC0jCA;;;;;;;;;;;;AAcA;;;;;;;;;;;;;;AhBwRA;;AAgBA;AYZA;;;;;;;;;AiBt7CA;;AAAA;AAAA;AAAA;AAAA;;;AAAA;AAAA;AAAA;;AAAA;;AlByBA;;;;;;;;AAAA;;;;;;AX4ZA;;;AA1BA;;;;;;;;;;;;;AAAA;AAAA;AAAA;;;;;;;;;;AW/XA;;;;;;AC05CA;;;;AV13CA;;AD4nCA;AAAA;;;;AE99BA;AD9JA;AAAA;;;;AF+VA;;;;;;;;;AACA;;AIqoCA;;;;;;;;;;;;;;AHzWA;;AAAA;;;;;;AD5xBA;;;;;;;;;;;;;;;AC2lDA;AAAA;AA1tBA;ACjuCA;AAAA;AAAA;AAAA;AFivCA;AAEA;AAAA;;AACA;AAAA;AAAA;;AACA;AIo4BA;AAAA;AAAA;AJp4BA;;;AErvCA;AAAA;AD4nCA;AAAA;;;AA2DA;;;;;AA/WA;;;;;;;AAAA;AAyZA;ACjuCA;AAAA;;;AFyXA;;;;;;AAzBA;AAAA;AAAA;;AIqoCA;;;;;;;;AJtoCA;;;;;;;;;;;;;;;AC6xBA;;AA+EA;AE7iCA;;;;;;;AmB6HA;;;;;;;;;ApB3RA;AAAA;AD4nCA;AAAA;;;;AI/+BA;AJ0iCA;AAAA;AAAA;;AAjCA;;;AA9UA;;;;;AAAA;AAAA;;;AAyZA;ACjuCA;AAAA;AAAA;;AAAA;;;AFmvCA;;;;;;;;;;;;ACvHA;AAAA;AAAA;AAAA;;AI/+BA;;;;AAAA;AJygCA;AAAA;;AA9UA;;;;;AAAA;AAAA;;;;ACx0BA;;;AAAA;;;;;AF+VA;;;;;;;;;AACA;;;;;;;;;;;;;;;;;;;;;AAAA;AAAA;;;;;;;;;AGlMA;;;;AF89BA;;;;;;;;;ADiXA;AI4oBA;;;;;AJnoBA;;;;;;;;;AIgMA;AAAA;;;;;AJnMA;AAAA;AAAA;;AsBptCA;AAAA;;AV2lCA;;;;;;;;;;;;;;;;;;;;;;;;;;AUzlCA;AAAA;;;;;;AAAA;;;;;;;;;;ArBy7BA;AqBz7BA;;ArB21BA;;;;AA+EA;;;;;AE7iCA;AH2NA;;;AA1BA;AAAA;AAAA;AAAA;;;;;AACA;AIqoCA;;;;;;;;;;;;;;;;AHzWA;AAAA;AAAA;;AE99BA;AF89BA;AAAA;;AA+EA;AE7iCA;;AH2NA;;;AA1BA;AAAA;;;;;;;AACA;;AIqoCA;AAAA;;;;;;AJtoCA;AAAA;;;;;;;;;;;;AC6xBA;;;;AA+EA;;;;;;;;;;;;;;;;;AD32BA;;;;;;;;;;;;;;;AGlMA;;AH2NA;AAAA;;AA1BA;;;;;;;AACA;;;AIqoCA;AAAA;;;;;;;AJtoCA;AAAA;;;;;;;;;;AACA;AAAA;AAAA;AAAA;;;;;;AGlMA;;AF89BA;AAAA;AAAA;AAAA;;;;;;;;;AAAA;AAAA;AAAA;AAAA;;;;;;AD7xBA;;;;;;;;;;;;;;;;;;;;;;;;AACA;AAAA;;;;;;;;;;;;;;AC22BA;AE7iCA;AAAA;;;;;;;;AmBqIA;AAAA;AAAA;ApBnSA;;;;;AD2sCA;AE7iCA;;AD9JA;AFyXA;AAAA;AAAA;AAAA;;;;;;;;;AAzBA;AAAA;AAAA;AAAA;;;;;;;;AADA;;;;;;;;;;AACA;;;;;;;;AC4xBA;AAAA;;AqBv1BA;;ArBs6BA;AE7iCA;;;;;;;;;;;;;;;;;;;AHiMA;AAAA;AAAA;;;;;;;;;;;AIsoCA;;;;;;;;;;;;;;;;;;;;AJroCA;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A;AAAA;;AAjBA;;ANkDA;;;;;;;;;;;AIjCA;;;;;;;;AAAA;;;;;;;;;;AJqCA;ACmrCA;ADlrCA;AAAA;Aa4/BA;Ab3/BA;AACA;;AAHA;AAAA;AAAA;AAAA;;;;;;;;;;;AK45DA;AAAA;AAAA;;ADz8DA;;;;;;;AFkjCA;AAPA;AAVA;AIzhCA;AAAA;AAAA;;AAAA;AAAA;AAAA;;AAjBA;;AN4DA;;;;;;;;;;;AI3CA;;;;;;;;AAAA;;;;;;;;AJgDA;AACA;AE66BA;AF76BA;AACA;AE46BA;AAAA;;AAmtCA;;;;;;;;;;AGhPA;AAAA;AAAA;;ADz8DA;;;;;;;AFkjCA;AAPA;AAVA;AIzhCA;AAAA;AAAA;;AAAA;AAAA;AAAA;;AAjBA;;ANsEA;;;;;;;;;;;AIrDA;;;;;;;;AAAA;;;;;;;;;;AJwDA;;;;;;;AAAA;;;;;;;AAAA;;;;;;AGtNA;;AC8JA;;AD9JA;AFyXA;;AA1BA;AAAA;;;;;;;;AACA;AAAA;;AIqoCA;AAAA;;;;;;;AJtoCA;;;;;;;;AACA;;;;;;;AGlMA;;AD9JA;;;;;;AC8JA;;;;;AD9JA;;AC8JA;;AD9JA;AFyXA;;AA1BA;AAAA;;;;;;;;AACA;AAAA;;AIqoCA;AAAA;;;;;;;AJtoCA;;;;;;;;AACA;;;;;;;AGlMA;;AD9JA;;AC8JA;;AD9JA;;AC8JA;;AD9JA;AFyXA;;AA1BA;AAAA;;;;;;;;AACA;AAAA;;AIqoCA;AAAA;;;;;;;AJtoCA;;;;;;;;AACA;;;;;;;AGlMA;;AD9JA;;AC8JA;;AD9JA;;AC8JA;;AD9JA;AFyXA;;AA1BA;AAAA;;;;;;;;AACA;AAAA;;AIqoCA;AAAA;;;;;;;AJtoCA;;;;;;;;AACA;;;;;;;AGlMA;;AD9JA;;AC8JA;;AD9JA;;AC8JA;;AD9JA;AFyXA;;AA1BA;AAAA;;;;;;;;AACA;AAAA;;AIqoCA;AAAA;;;;;;;AJtoCA;;;;;;;;AACA;;;;;;;AGlMA;;AD9JA;;AI+8CA;;;AHjzCA;AGizCA;;;;;;;;;;;AJ/8CA;;AC8JA;;AD9JA;AFyXA;;AA1BA;AAAA;;;;;;;;AACA;AAAA;;AIqoCA;AAAA;;;;;;;AJtoCA;;;;;;;;AACA;;;;;;;AGlMA;;AD9JA;;AC8JA;;;;;;;;;;;;;;AD9JA;;AC8JA;;AD9JA;AFyXA;;AA1BA;AAAA;;;;;;;;AACA;AAAA;;AIqoCA;AAAA;;;;;;;AJtoCA;;;;;;;;AACA;;;;;;;AGlMA;;AD9JA;;AC8JA;;;;;;;;;;;;;;AD9JA;;AC8JA;;AD9JA;AFyXA;;AA1BA;AAAA;;;;;;;;AACA;AAAA;;AIqoCA;AAAA;;;;;;;AJtoCA;;;;;;;;AACA;;;;;;;AGlMA;;AD9JA;;;;AC8JA;;;;;;;;;;;;;;;;;;;;AJsTA;;AACA;;;;;;;AAAA;;;;;;;AACA;;;;;;;;AAAA;;;;;;;;;;AAAA;;;;;;;;AAAA;;;;;;AGtdA;;AC8JA;;AD9JA;AFyXA;;AA1BA;AAAA;;;;;;;;AACA;AAAA;;AIqoCA;AAAA;;;;;;;AJtoCA;;;;;;;;AACA;;;;;;;AGlMA;;AD9JA;;;;;;AC8JA;;;;;AD9JA;;AC8JA;;AD9JA;AFyXA;;AA1BA;AAAA;;;;;;;;AACA;AAAA;;AIqoCA;AAAA;;;;;;;AJtoCA;;;;;;;;AACA;;;;;;;AGlMA;;AD9JA;;;;;AC8JA;;;;;;;;AD9JA;;AC8JA;;AD9JA;AFyXA;;AA1BA;AAAA;;;;;;;;AACA;AAAA;;AIqoCA;AAAA;;;;;;;AJtoCA;;;;;;;;AACA;;;;;;;AGlMA;;AD9JA;;AC8JA;;;;AD9JA;ADiuCA;AAAA;AAAA;AD13BA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;ADiHA;AAIA;AAAA;AAAA;AAAA;AAAA;AAEA;AAAA;AAAA;AAAA;;AACA;;;;;;;;AAAA;;;;;;;AAAA;;;;;;AG/dA;;AC8JA;;AD9JA;AFyXA;;AA1BA;AAAA;;;;;;;;AACA;AAAA;;AIqoCA;AAAA;;;;;;;AJtoCA;;;;;;;;AACA;;;;;;;AGlMA;;AD9JA;;;;;;AC8JA;;;;;AD9JA;;AC8JA;;AD9JA;AFyXA;;AA1BA;AAAA;;;;;;;;AACA;AAAA;;AIqoCA;AAAA;;;;;;;AJtoCA;;;;;;;;AACA;;;;;;;AGlMA;;AD9JA;;AC8JA;;AD9JA;;AC8JA;;AD9JA;AFyXA;;AA1BA;AAAA;;;;;;;;AACA;AAAA;;AIqoCA;AAAA;;;;;;;AJtoCA;;;;;;;;AACA;;;;;;;AGlMA;;;AAAA;;;;;;;;;;;AD9JA;;AC8JA;;AD9JA;AFyXA;;AA1BA;AAAA;;;;;;;;AACA;AAAA;;AIqoCA;AAAA;;;;;;;AJtoCA;;;;;;;;AACA;;;;;;;AGlMA;;;AAAA;;;;;;ACi8DA;AAAA;AAAA;;ADz8DA;;;;;;;AFkjCA;AAPA;AAVA;AIzhCA;AAAA;AAAA;;AAAA;AAAA;AAAA;;AAjBA;;ANoVA;;;;;;;;;;;AInUA;;;;;;;;AAAA;;;;;AD9JA;;AC8JA;;AD9JA;AFyXA;;AA1BA;AAAA;;;;;;;;AACA;AAAA;;AIqoCA;AAAA;;;;;;;AJtoCA;;;;;;;;AACA;;;;;;;AGlMA;;AD9JA;;AC8JA;;AD9JA;;AC8JA;;AD9JA;AFyXA;;AA1BA;AAAA;;;;;;;;AACA;AAAA;;AIqoCA;AAAA;;;;;;;AJtoCA;;;;;;;;AACA;;;;;;;AGlMA;;AD9JA;;AI+8CA;;;AHjzCA;AGizCA;;;;;;;;;AJ/8CA;;AC8JA;;AD9JA;AFyXA;;AA1BA;AAAA;;;;;;;;AACA;AAAA;;AIqoCA;AAAA;;;;;;;AJtoCA;;;;;;;;AACA;;;;;;;AGlMA;;AD9JA;;AC8JA;;;;;;;;;;;;;;AD9JA;;AC8JA;;AD9JA;AFyXA;;AA1BA;AAAA;;;;;;;;AACA;AAAA;;AIqoCA;AAAA;;;;;;;AJtoCA;;;;;;;;AACA;;;;;;;AGlMA;;AD9JA;;AC8JA;;;;;;;;;;;;;;AD9JA;;AC8JA;;AD9JA;AFyXA;;AA1BA;AAAA;;;;;;;;AACA;AAAA;;AIqoCA;AAAA;;;;;;;AJtoCA;;;;;;;;AACA;;;;;;;AGlMA;;AD9JA;;;;AC8JA;;;;;;;;;;;;;;;;;;;;AJ6WA;;AACA;;;;;;;AAAA;;;;;;;AACA;;;;;;;;AAAA;;;;;;;;;;AAAA;;;;;;;;AAAA;;;;;;AG7gBA;;AC8JA;;AD9JA;AFyXA;;AA1BA;AAAA;;;;;;;;AACA;AAAA;;AIqoCA;AAAA;;;;;;;AJtoCA;;;;;;;;AACA;;;;;;;AGlMA;;AD9JA;;;;;;AC8JA;;;;;AD9JA;;AC8JA;;AD9JA;AFyXA;;AA1BA;AAAA;;;;;;;;AACA;AAAA;;AIqoCA;AAAA;;;;;;;AJtoCA;;;;;;;;AACA;;;;;;;AGlMA;;AD9JA;;;;;AC8JA;;;;;;;;AD9JA;;AC8JA;;AD9JA;AFyXA;;AA1BA;AAAA;;;;;;;;AACA;AAAA;;AIqoCA;AAAA;;;;;;;AJtoCA;;;;;;;;AACA;;;;;;;AGlMA;;AD9JA;;AC8JA;;;;AJiXA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAEA;AAAA;AAAA;AAAA;;AK8kDA;AAAA;AAAA;;ADz8DA;;;;;;;AFkjCA;AAPA;AAVA;AIzhCA;AAAA;AAAA;;AAAA;AAAA;AAAA;;AAjBA;;ANsYA;;;;;;;;;;;AIrXA;;;;;;;;AAAA;;;;;;AJuXA;;;;;;;;AAAA;;;;;;;;AAAA;;;;;;AGrhBA;;AC8JA;;AD9JA;AFyXA;;AA1BA;AAAA;;;;;;;;AACA;AAAA;;AIqoCA;AAAA;;;;;;;AJtoCA;;;;;;;;AACA;;;;;;;AGlMA;;AD9JA;;;;;;AC8JA;;;;;AD9JA;;AC8JA;;AD9JA;AFyXA;;AA1BA;AAAA;;;;;;;;AACA;AAAA;;AIqoCA;AAAA;;;;;;;AJtoCA;;;;;;;;AACA;;;;;;;AGlMA;;AD9JA;;AC8JA;;;AJwXA;;;;;;;;AAAA;;;;;;;;AAAA;;;;;;AGthBA;;AC8JA;;AD9JA;AFyXA;;AA1BA;AAAA;;;;;;;;AACA;AAAA;;AIqoCA;AAAA;;;;;;;AJtoCA;;;;;;;;AACA;;;;;;;AGlMA;;AD9JA;;;;;;AC8JA;;;;;AD9JA;;AC8JA;;AD9JA;AFyXA;;AA1BA;AAAA;;;;;;;;AACA;AAAA;;AIqoCA;AAAA;;;;;;;AJtoCA;;;;;;;;AACA;;;;;;;AGlMA;;AD9JA;;AC8JA;;AD9JA;;AC8JA;;AD9JA;AFyXA;;AA1BA;AAAA;;;;;;;;AACA;AAAA;;AIqoCA;AAAA;;;;;;;AJtoCA;;;;;;;;AACA;;;;;;;AGlMA;;AD9JA;;AC8JA;;AD9JA;;AC8JA;;AD9JA;AFyXA;;AA1BA;AAAA;;;;;;;;AACA;AAAA;;AIqoCA;AAAA;;;;;;;AJtoCA;;;;;;;;AACA;;;;;;;AGlMA;;AD9JA;;AI+8CA;;;AHjzCA;AGizCA;;;;;;;;;AJ/8CA;;AC8JA;;AD9JA;AFyXA;;AA1BA;AAAA;;;;;;;;AACA;AAAA;;AIqoCA;AAAA;;;;;;;AJtoCA;;;;;;;;AACA;;;;;;;AGlMA;;AD9JA;;AC8JA;;;;;;;;;;;;;;AD9JA;;AC8JA;;AD9JA;AFyXA;;AA1BA;AAAA;;;;;;;;AACA;AAAA;;AIqoCA;AAAA;;;;;;;AJtoCA;;;;;;;;AACA;;;;;;;AGlMA;;AD9JA;;AC8JA;;;;;;;;;;;;;;AD9JA;;AC8JA;;AD9JA;AFyXA;;AA1BA;AAAA;;;;;;;;AACA;AAAA;;AIqoCA;AAAA;;;;;;;AJtoCA;;;;;;;;AACA;;;;;;;AGlMA;;AD9JA;;;;AC8JA;;;;;;;;;;;;;;;;;AF89BA;;AA+EA;;;;;;AF3xBA;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;AACA;ACjEA;AACA;AAAA;AACA;AIqvDA;AJhjDA;AAAA;AAAA;AAAA;AAAA;AAsjBA;AAAA;AAAA;;;;;;;;;;;;;;AGv9BA;;;;;;;;;;;AHusBA;AAAA;;;;;;;AIyrBA;AAAA;;;;AJpaA;;;;;;;;;;;;;;;AGp9BA;;;AF89BA;AAAA;;;AA+EA;AAAA;;;;;;;ADz1BA;AAAA;AAAA;AAAA;AAAA;;AAqMA;AAAA;AAAA;AAAA;AAAA;;AAAA;;;;AAsjBA;AAnRA;AAAA;;;;;;;;;;;;;;;;;;;AI+xCA;AAAA;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AAnmBA;AAAA;AAAA;;;;;;;;;;;;;;;;;;;AHhYA;;;;;AA1BA;AE99BA;;AJqRA;;;;;;;AIrRA;;;;;ACi8DA;;;;;;;;;;;AH95BA;AAVA;AAAA;;;;;;;AA3DA;;;;;;;;;;;;AAAA;AAAA;AAAA;;;AA+EA;AAAA;AAAA;AE7iCA;;;;;;AAAA;;AD9JA;;;;;AF+VA;;;;;;;;;;;AACA;AAAA;AAAA;AAAA;;;AIqoCA;;;;;;;AJtoCA;AAAA;;;;;;;;;;;AACA;AAAA;;;;;;;;;;AGlMA;;;;;;;;;;;;;;;;;;;;;;;;;AF89BA;;;;;AC5nCA;AFyXA;;AA1BA;;;;;;;AACA;AAAA;AAAA;;;AIqoCA;AAAA;AAAA;AAAA;;;;;;AJtoCA;AAAA;AAAA;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AC6xBA;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AAqEA;AAAA;AAVA;;;AA2QA;;;;;;;;;;AAtUA;AAAA;;;;;;;AE99BA;AAAA;AAAA;AAAA;AAAA;AAAA;;;;AF89BA;;;;;;;;;;;;;;;;;;AC5nCA;AAAA;AAAA;AAAA;AAAA;AAAA;;;;;;;AFyXA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;;AA1BA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;;;;;AIsoCA;;;;;;;;AJtoCA;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AC6xBA;AAAA;AAAA;AAAA;AAAA;;AE99BA;;;;;;;;;;;;;;;;;;;;;;;;;;;;AHiMA;;;;;;AACA;AIqoCA;;;;;;;AJtoCA;;;;;;;;;;;;;;;;;;;AACA;;;;;;;;;;;;;AC4xBA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;;;;AC5nCA;;;AAAA;;;AF+VA;;;;;;;;;;AIsoCA;;;;;;;;;;;;AJtoCA;;;;;;;;;AACA;;;;AEhWA;;AD4nCA;;;AKmVA;;;AHjzCA;;;;;;;;;;;;;;;;;;;;AHkMA;AAAA;AAAA;AAAA;AAAA;AAAA;;;;;;;;;;;AADA;AAAA;AAAA;AAAA;AAAA;;;;;;AACA;;;;;;AGlMA;;;AF89BA;AAAA;AAAA;AAAA;;;;;;;;;;;;;;;;;;;AC5nCA;AAAA;AAAA;AAAA;;;;;AC8JA;;AD9JA;;;;;AF+VA;;;;;;;;;;;;;;;;;;;;;;;;;AGjMA;;AF89BA;AAAA;AAAA;;AA+EA;AE7iCA;;AD9JA;AAAA;AAAA;AAAA;AAAA;AAAA;;;;AAAA;;;;AF+VA;;;;;;;;;;;;;;;;;;;;;;;;;;AE/VA;AAAA;;;;;AI+8CA;AAAA;;;;;;;;ALpQA;AAAA;;;AC3sCA;AAAA;;;;AF+VA;;;;;;;;;AACA;AAAA;AAAA;AAAA;AAAA;;;;;;;;;;;;;;;;;;;;AAAA;AAAA;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AC4xBA;AAAA;;;;;AA+EA;AAAA;AE7iCA;;;;AF89BA;AA+EA;;AC3sCA;AFyXA;;;;AA1BA;AAAA;;;;;;;;;;;;AIsoCA;AAAA;AAAA;AAAA;AAAA;;;;;;;;;;;;;;;;;ADv0CA;;AF89BA;AAAA;;;;;;;;;;;AQzhCA;AHs3CA;;;;;;;;;;;;;;;;;;;AHn0CA;;;;;;AGwvCA;AAwCA;AAAA;AAAA;AAAA;AAAA;;;;;;AAOA;;;;AH/xCA;AG0yCA;;;;;;;;;;;;;;;;;;;;;;;;;;AP9oCA;AAAA;AACA;AAAA;;;;;;ACqDA;AAAA;AACA;;;;;;AAsMA;;;;;;AAsjBA;AAAA;;;;;AAnRA;AAAA;;;;;;;AGpsBA;;AHssBA;AACA;;AAAA;;;;AIy1BA;AAAA;;;;;;;;;AAhKA;AAAA;;;;;;;;;;AJpaA;;;;;;A4BjwBA;;AvBpOA;AAAA;;;;;;;;;AJ++BA;;AA+EA;AAAA;AAAA;;;A2Bv9BA;;;;;AzBtFA;;;;;;;;;;;;AFmiCA;AAAA;AAAA;;;;;;;;;;;;;;;AArEA;;;;;;;;AAAA;;;;AA+EA;;;;;;;;;;;;;;AA/EA;AAAA;AAAA;;;AE99BA;AAAA;AAAA;AAAA;;;;AH2NA;;AA1BA;AAAA;AAAA;;;;;;;;;;AACA;;;;;AADA;;;;;;;;;AACA;;;AGlMA;;;AF89BA;AAAA;AAAA;;;;;;;;;;;;AAAA;;;ADnwBA;;AA1BA;;;;;;;;;;;AIsoCA;;;;;AJtoCA;;;;;;AACA;AAAA;AAAA;AAAA;;;;;;;;;;;;AC22BA;;;;;AQxmCA;AAAA;AAAA;AAAA;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AN2DA;AG0yCA;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;APnqCA;;;;;;;;;AEu1BA;AA8DA;AAAA;AAAA;;;;;;;AGq6BA;AAAA;AAAA;;;;;;;;;;;;;;;;;AHx6BA;AAAA;AAAA;;;;;;;;;;;;;;;;AA3DA;AAAA;AAAA;AAAA;;;;;;;;;;;AFl1BA;AAAA;AAAA;AAAA;AAAA;;;;AAEA;AAAA;AAAA;;AAAA;AACA;;;;;;;;;;;;;;AAAA;;;;;;;;;;;AC4EA;;AA1BA;;;;;;;;;;;;;AACA;AAAA;AAAA;AAAA;AAAA;;;;;;;;;AGlMA;AAAA;AAAA;AAAA;;;;;;;;AD9JA;;;AD4nCA;AAAA;AAAA;;;;;ADnwBA;AAAA;AAAA;;;AA1BA;AAAA;AAAA;AAAA;;;;;;;;;;;;AACA;;AIqoCA;;;;;;;AJtoCA;AAAA;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AAuhCA;AAgBA;;AW7uCA;AACA;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AAvCA;AVygCA;;;AA+xEA;;;;;;;;;;;;;;;;;;;;;;AUtyGA;AAAA;;AACA;;;;;;;;AAAA;;;;;;;;ARwCA;;;;;;AQpCA;;AAEA;;;;;;;;AAAA;;;;;;;;AAAA;;;;;;;;ARkCA;;AH2NA;;AA1BA;;;;;;AACA;AAAA;;AIqoCA;AAAA;;;;;;;AJtoCA;;;;AGjMA;;;AAAA;;;;;;AQ/BA;;AAEA;;;;;;;;AAAA;;;;;;;;AAAA;;;;;;;;AR6BA;;AH2NA;;AA1BA;;;;;;AACA;AAAA;;AIqoCA;AAAA;;;;;;;AJtoCA;;;;AGjMA;;;AAAA;;;;;;AQ1BA;;AAEA;;;;;;;;AAAA;;;;;;;;AAAA;;;;;;;;ARwBA;;AH2NA;;AA1BA;;;;;;AACA;AAAA;;AIqoCA;AAAA;;;;;;;AJtoCA;;;;AGjMA;;;AAAA;;;;;;AQrBA;AX8NA;AAAA;AAAA;AAAA;AAAA;AAAA;;AW3NA;;;;;;;;AX0nCA;;;;;;;AWxnCA;;ADlMA;;;;;;;;AAAA;;;;;;;AAAA;;AG2kCA;;;;;;;;;AFzkCA;;;;;;;;ADFA;;;;;;;;;AV0zCA;;;;;;;;AU1zCA;;AAAA;;APkNA;;AQdA;AAAA;ADpMA;;APkNA;;;;;;AQXA;;AAEA;;;;;;;;AAAA;;;;;;;;ARSA;;AH2NA;;AA1BA;;;;;;AACA;AAAA;;AIqoCA;AAAA;;;;;;;AJtoCA;;;;AGjMA;;;AAAA;;;;;;;;AAAA;;AH2NA;;AA1BA;;;;;;AACA;AAAA;;AIqoCA;AAAA;;;;;;;AJtoCA;;;;AGjMA;;;AAAA;;ASqlCA;;;;;;;;;AD1lCA;AACA;;;;;AVkwGA;;;;;;;;;;;;;;;AE9vGA;;;;;;;;;;;AHkMA;;;;;;;;AGlMA;;AH2NA;;AA1BA;;;;;;;AACA;AAAA;;AIqoCA;AAAA;;;;;;;AJtoCA;;;;;;;;AACA;;;;;;;AGlMA;;;AAAA;;;;;;;;;;;AHkMA;;;;;;;;AGlMA;;AH2NA;;AA1BA;;;;;;;AACA;AAAA;;AIqoCA;AAAA;;;;;;;AJtoCA;;;;;;;;AACA;;;;;;;AGlMA;;;AAAA;;;;;;;;;;;AHkMA;;;;;;;;AGlMA;;AH2NA;;AA1BA;;;;;;;AACA;AAAA;;AIqoCA;AAAA;;;;;;;AJtoCA;;;;;;;;AACA;;;;;;;AGlMA;;;AAAA;;;;;;;;;;;;;;AAAA;;;;;;;;;;;;;;;;;;;;;;;AOlNA;;APkNA;;;;;;;;;;;;;AHkMA;;;;;;;;AGlMA;;AH2NA;;AA1BA;;;;;;;AACA;AAAA;;AIqoCA;AAAA;;;;;;;AJtoCA;;;;;;;;AACA;;;;;;;AGlMA;;;AAAA;;;;;;;;;;;AHkMA;;;;;;;;;;AUpZA;;APkNA;;;;;;AAAA;;AH2NA;;AA1BA;;;;;;;AACA;AAAA;;AIqoCA;AAAA;;;;;;;AJtoCA;;;;;;;;AACA;;;;;;;AGlMA;;;;;AAAA;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AHyZA;AWnlBA;AAAA;AXm7CA;;;AW76CA;;;;;;;;;;;;;;;;;AVkpCA;;AA+EA;AE7iCA;;AH2NA;AAAA;;AA1BA;;;;;;AACA;AIqoCA;AAAA;;;;;;AJtoCA;AAAA;;;;;;;;;;AGjMA;;AF89BA;AAAA;AAAA;AAAA;AAAA;;AA+EA;AE7iCA;;;;;;;AQ1LA;;;;;;;;;;;;;;;;AX4XA;AAAA;;;;;AC4xBA;AAAA;;AA+EA;AE7iCA;;AH2NA;AAAA;;AA1BA;;;;;;;;;;;AAAA;;;;;;;;;;;;AACA;AAAA;AAAA;;;;;;;;;;;;;;AGlMA;;;;;AHyvCA;AAAA;;AW76CA;;;AAAA;;;;;;;;;;;;;;;;;;;;;;;;;;;;ATsBA;AD4nCA;AAAA;AAAA;AAAA;AAAA;AAAA;AA+EA;AC3sCA;;AFyXA;;AA1BA;AAAA;;;;;;AACA;;;AIqoCA;;;;;;AJtoCA;;;;;;;;;;;;;AACA;;AGlMA;;AD9JA;;;;;;;;;;AD4nCA;AAAA;AAAA;AAAA;;AE99BA;;;AH2NA;AAAA;;;;AA1BA;;;;;;;;AIsoCA;AAAA;AAAA;;;;;;;;;AJtoCA;;;;;;;;;;;;;;;;;;;AE/VA;;;;;;;;AAAA;AAAA;AAAA;;AAAA;;;;;AAAA;;;;;;;AAAA;AAAA;AAAA;AAAA;;;;;ADisCA;AAAA;AAVA;AAAA;;AA2QA;;;AUl9CA;;;;;;;;AV4oCA;;;;AA+EA;;;;;;AA/EA;;AU1oCA;;;;;;;AV0oCA;;AA8DA;AAAA;;;;;;;;A8BjqBA;;AAAA;;;APuJA;;;;;;;;;;;;;;;AQvuBA;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;ArB4CA;;;;;;;;;;ARyKA;;AH2NA;;;AA1BA;;;;;;;;;AACA;AAAA;;AIqoCA;;;;;;;;;;;;;AJroCA;;;;;;;;;AEhWA;AAAA;AD4nCA;;AAAA;AAAA;;;;;;;AA+EA;AE7iCA;;AD9JA;AD4nCA;AAAA;;AAAA;AAAA;;;;;;AC5nCA;AFyXA;AAAA;;;;;;;;;;;;AAzBA;;AIqoCA;;;;;;AJtoCA;AAAA;;;;AACA;;;;;;;AC22BA;;;;AErjCA;;;;;;;AFs+BA;AAAA;AAAA;;;;;;;;;;;;;;;;AUloCA;AVitCA;AAAA;AE7iCA;;;;;AQtKA;;;;;;AXwgDA;AIynBA;AAAA;AJznBA;;;;A6B5jDA;;;;;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;A3B4DA;AAAA;AAAA;AAAA;AAAA;;;;;AAAA;AAAA;AFgXA;;AACA;AACA;AIqvDA;AAAA;;AJn9BA;AAAA;AACA;;;;AACA;AAAA;;;ACiYA;AAtTA;ACjuCA;AAAA;;;;A2B5DA;Ad0VA;AACA;;;;;;;;AAEA;AAGA;ACwvBA;AAAA;AAAA;;;;AACA;;AhB0eA;;AW/gDA;;;;;;;;;AAAA;;;AVooCA;AAAA;;AA+EA;AE7iCA;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AHkMA;;;;;;;AC4xBA;;AAAA;;AA+EA;AE7iCA;AAAA;;AQpKA;;;AVkoCA;AAAA;AAAA;;;AA+EA;AAAA;AE7iCA;;;;;;;;;;;;;;;;;;;;;AJgSA;;;AG9bA;ADiuCA;AAAA;AAAA;AD13BA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AD0FA;ACq7BA;AAgBA;;;;;;;;;;;;;;;;;;;;;;;;;;ADp8BA;;;;;;;;;AAEA;;AAAA;;;;;;;;AAAA;;;;;;;;AItSA;;AH2NA;;AA1BA;;;;;;AACA;AAAA;;AIqoCA;AAAA;;;;;;;AJtoCA;;;;AGjMA;;;AAAA;;;AH+0CA;;;AASA;;;;;;;;;;;AIgMA;;;;;;;AJnMA;;;AANA;;;AASA;;;;;;;;;;;AIgMA;;;;;;;AJnMA;;;;AGr1CA;;AH2NA;;AA1BA;;;;;;AACA;AAAA;;AIqoCA;AAAA;;;;;;;AJtoCA;;;;AGjMA;;;AAAA;;ASqlCA;;;;;;;;AZn5BA;;;;;;;;;;;;;;AGlMA;;AH2NA;;AA1BA;;;;;;;AACA;AAAA;;AIqoCA;AAAA;;;;;;;AJtoCA;;;;;;;;AACA;;;;;;;AGlMA;;;AAAA;;;;;;;;;;;AHkMA;;;;AGlMA;;AH2NA;;AA1BA;;;;;;;AACA;AAAA;;AIqoCA;AAAA;;;;;;;AJtoCA;;;;;;;;AACA;;;;;;;AGlMA;;;AAAA;;;;;;;;;;;;;;;AJ6SA;;;;;AAAA;;;;;AAAA;;;;;;AG3cA;;AC8JA;;AD9JA;AFyXA;;AA1BA;AAAA;;;;;;;;AACA;AAAA;;AIqoCA;AAAA;;;;;;;AJtoCA;;;;;;;;AACA;;;;;;;AGlMA;;AD9JA;;;;;;AC8JA;;;;;AD9JA;;AC8JA;;AD9JA;AFyXA;;AA1BA;AAAA;;;;;;;;AACA;AAAA;;AIqoCA;AAAA;;;;;;;AJtoCA;;;;;;;;AACA;;;;;;;AGlMA;;AD9JA;;AC8JA;;AD9JA;;AC8JA;;AD9JA;AFyXA;;AA1BA;AAAA;;;;;;;;AACA;AAAA;;AIqoCA;AAAA;;;;;;;AJtoCA;;;;;;;;AACA;;;;;;;AGlMA;;;AAAA;;;;;;;;;;;AD9JA;;AC8JA;;AD9JA;AFyXA;;AA1BA;AAAA;;;;;;;;AACA;AAAA;;AIqoCA;AAAA;;;;;;;AJtoCA;;;;;;;;AACA;;;;;;;AGlMA;;;AAAA;;;;;;ACi8DA;AAAA;AAAA;;ADz8DA;;;;;;;;;;AFkjCA;AAPA;AAVA;AIzhCA;AAAA;AAAA;;AAAA;AAAA;AAAA;;AAjBA;;ANgUA;;;;;;;;;;;;AI/SA;;;;;;;;;;AAAA;;;;;;;AD9JA;;AC8JA;;AD9JA;AFyXA;;AA1BA;AAAA;;;;;;;;AACA;AAAA;;AIqoCA;AAAA;;;;;;;AJtoCA;;;;;;;;AACA;;;;;;;AGlMA;;AD9JA;;AI+8CA;;;AHjzCA;AGizCA;;;AJ/8CA;;AC8JA;;AD9JA;AFyXA;;AA1BA;AAAA;;;;;;;;AACA;AAAA;;AIqoCA;AAAA;;;;;;;AJtoCA;;;;;;;;AACA;;;;;;;AGlMA;;AD9JA;;;;AC8JA;;;;;;;;;;;;;;;;;;;;;AJ5CA;;AACA;;;;;;;AAAA;;;;;;;AAEA;;;;;;;;AAAA;;;;;;;;;;AAAA;;;;;;;;AAAA;;;;;;AGrHA;;AC8JA;;AD9JA;AFyXA;;AA1BA;AAAA;;;;;;;;AACA;AAAA;;AIqoCA;AAAA;;;;;;;AJtoCA;;;;;;;;AACA;;;;;;;AGlMA;;AD9JA;;;;;;AC8JA;;;;;AD9JA;;AC8JA;;AD9JA;AFyXA;;AA1BA;AAAA;;;;;;;;AACA;AAAA;;AIqoCA;AAAA;;;;;;;AJtoCA;;;;;;;;AACA;;;;;;;AGlMA;;AD9JA;;;;;AC8JA;;;;;;;;AD9JA;;AC8JA;;AD9JA;AFyXA;;AA1BA;AAAA;;;;;;;;AACA;AAAA;;AIqoCA;AAAA;;;;;;;AJtoCA;;;;;;;;AACA;;;;;;;AGlMA;;AD9JA;;AC8JA;;;;AJxCA;;;;;;;;;;AKy+DA;AAAA;AAAA;;ADz8DA;;;;;;;AFkjCA;AAPA;AAVA;AIzhCA;AAAA;AAAA;;AAAA;AAAA;AAAA;;AAjBA;;ANtBA;;;;;;;;;;;AIuCA;;;;;;;;AAAA;;;;;AJrCA;AAAA;AAAA;;AAAA;AAAA;;;;;;;;;AKs+DA;AAAA;AAAA;;ADz8DA;;;;;;;AFkjCA;AAPA;AAVA;AIzhCA;AAAA;AAAA;;AAAA;AAAA;AAAA;;AAjBA;;ANnBA;;;;;;;;;;;AIoCA;;;;;;;;AAAA;;;;;;AJlCA;;;;;;;AAAA;AAAA;;AAAA;;;;;;;;AKm+DA;AAAA;AAAA;;ADz8DA;;;;;;;AFkjCA;AAPA;AAVA;AIzhCA;AAAA;AAAA;;AAAA;AAAA;AAAA;;AAjBA;;ANfA;;;;;;;;;;;AIgCA;;;;;;;;AAAA;;;;;AD9JA;;AC8JA;;AD9JA;AFyXA;;AA1BA;AAAA;;;;;;;;AACA;AAAA;;AIqoCA;AAAA;;;;;;;AJtoCA;;;;;;;;AACA;;;;;;;AGlMA;;AD9JA;;AC8JA;;AD9JA;;AC8JA;;AD9JA;AFyXA;;AA1BA;AAAA;;;;;;;;AACA;AAAA;;AIqoCA;AAAA;;;;;;;AJtoCA;;;;;;;;AACA;;;;;;;AGlMA;;AD9JA;;AI+8CA;;;AHjzCA;AGizCA;;;;;;;;;AJ/8CA;;AC8JA;;AD9JA;AFyXA;;AA1BA;AAAA;;;;;;;;AACA;AAAA;;AIqoCA;AAAA;;;;;;;AJtoCA;;;;;;;;AACA;;;;;;;AGlMA;;AD9JA;;AC8JA;;;;;;;;;;;;;;AD9JA;;AC8JA;;AD9JA;AFyXA;;AA1BA;AAAA;;;;;;;;AACA;AAAA;;AIqoCA;AAAA;;;;;;;AJtoCA;;;;;;;;AACA;;;;;;;AGlMA;;AD9JA;;AC8JA;;;;;;;;;;;;;;AD9JA;;AC8JA;;AD9JA;AFyXA;;AA1BA;AAAA;;;;;;;;AACA;AAAA;;AIqoCA;AAAA;;;;;;;AJtoCA;;;;;;;;AACA;;;;;;;AGlMA;;AD9JA;;;;AC8JA;;;;;;;;;;;;AF0iCA;AAAA;AAPA;AAAA;AAVA;AAAA;AIzhCA;AJoyCA;AAAA;;;;;;;;;;;;;;;;;;;;;;;AAvPA;;AA/EA;;;;;AE99BA;AAAA;;;;;;;;;;AH2NA;;;AA1BA;AAAA;;;;;;AACA;AIqoCA;;;;;AJtoCA;AAAA;;;;;;;;;;;;;;;;;;;;AACA;;;;;;;;;;;;;;;;;;;;AEhWA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;;;;;AD2sCA;AE7iCA;;;;;;;;;;;;;;;AD9JA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;;AD2sCA;;;;AD52BA;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AACA;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AC4xBA;AAAA;;;;;;;;;;;;;;;;;;;;;;;;;;;;AK6VA;AADA;;;AASA;;;;;AAlGA;AAAA;;;;;;;AAgDA;AAAA;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AHjxCA;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AJ6XA;;AAAA;;;;;AEimBA;;;;ADnwBA;AAAA;;;;;;;;;;;AAzBA;;;;;;;;;;;;;AC4xBA;;AAAA;;;;;AE99BA;;AH2NA;AAAA;AAAA;AAAA;;AA1BA;;;;;;;;AACA;AAAA;AAAA;AAAA;;;AIqoCA;;;;AJtoCA;;;;;;;;;;;;;;;;AC6xBA;AAAA;AAAA;AAAA;;;;;;AA+EA;AAAA;;;;;;;;;;;AA/EA;AAAA;AAAA;AAAA;;;;AE99BA;AAAA;AAAA;;AD9JA;AFyXA;;AA1BA;AAAA;;;AACA;AIqoCA;AAAA;;;;;;AJtoCA;;;;;;;;;AACA;;;;;;;;AC4xBA;AA+EA;;AF/qBA;AAAA;;AAAA;;AAAA;AAAA;AAAA;AAAA;AAAA;;;AAAA;AAAA;AAAA;AAAA;AAAA;;AAAA;AAAA;AAAA;AAAA;;AKmkDA;;;;;;;;AH95BA;AAVA;;AI1iCA;;;;;;;AJ++BA;;;;;;;;;;;;;;;;;;AE99BA;;;;;;;;;;;;;;;;AJkYA;;;;AAAA;;;AE4lBA;;;;;;;;;;;;;;;;;AGyWA;AAAA;AAAA;AAAA;;;;;;;;;;;AJroCA;AAAA;;;;;;;;AGlMA;;AD9JA;AD4nCA;;;AE99BA;;AF89BA;AAAA;AAAA;;;;;;;;ADnwBA;;AA1BA;;;;;AACA;;;;;;;;;;;;;;;;;;;;;AC4xBA;;AE99BA;;;AF89BA;;;AA+EA;;;AD52BA;;;;;;;;;;;AAAA;AAAA;;;;;;;;;;;;;;;;;;;;;;;;;;;;ADkKA;;AACA;;;;;;;AAAA;;;;;;;AACA;;;;;;;;AAAA;;;;;;;;;;AAAA;;;;;;;;AAAA;;;;;;AGngBA;;AC8JA;;AD9JA;AFyXA;;AA1BA;AAAA;;;;;;;;AACA;AAAA;;AIqoCA;AAAA;;;;;;;AJtoCA;;;;;;;;AACA;;;;;;;AGlMA;;AD9JA;;;;;;AC8JA;;;;;AD9JA;;AC8JA;;AD9JA;AFyXA;;AA1BA;AAAA;;;;;;;;AACA;AAAA;;AIqoCA;AAAA;;;;;;;AJtoCA;;;;;;;;AACA;;;;;;;AGlMA;;AD9JA;;;;;AC8JA;;;;;;;;AD9JA;;AC8JA;;AD9JA;AFyXA;;AA1BA;AAAA;;;;;;;;AACA;AAAA;;AIqoCA;AAAA;;;;;;;AJtoCA;;;;;;;;AACA;;;;;;;AGlMA;;AD9JA;;AC8JA;;;;AJsWA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;AK2lDA;AAAA;AAAA;;ADz8DA;;;;;;;AFkjCA;AAPA;AAVA;AIzhCA;AAAA;AAAA;;AAAA;AAAA;AAAA;;AAjBA;;ANyXA;;;;;;;;;;;AIxWA;;;;;;;;AAAA;;;;;;AJ0WA;;;;;;;;AAAA;;;;;;;;AAAA;;;;;;AGxgBA;;AC8JA;;AD9JA;AFyXA;;AA1BA;AAAA;;;;;;;;AACA;AAAA;;AIqoCA;AAAA;;;;;;;AJtoCA;;;;;;;;AACA;;;;;;;AGlMA;;AD9JA;;;;;;AC8JA;;;;;AD9JA;;AC8JA;;AD9JA;AFyXA;;AA1BA;AAAA;;;;;;;;AACA;AAAA;;AIqoCA;AAAA;;;;;;;AJtoCA;;;;;;;;AACA;;;;;;;AGlMA;;AD9JA;;AC8JA;;AD9JA;;AC8JA;;AD9JA;AFyXA;;AA1BA;AAAA;;;;;;;;AACA;AAAA;;AIqoCA;AAAA;;;;;;;AJtoCA;;;;;;;;AACA;;;;;;;AGlMA;;AD9JA;;AC8JA;;AD9JA;;AC8JA;;AD9JA;AFyXA;;AA1BA;AAAA;;;;;;;;AACA;AAAA;;AIqoCA;AAAA;;;;;;;AJtoCA;;;;;;;;AACA;;;;;;;AGlMA;;AD9JA;;AI+8CA;;;AHjzCA;AGizCA;;;;;;;;;AJ/8CA;;AC8JA;;AD9JA;AFyXA;;AA1BA;AAAA;;;;;;;;AACA;AAAA;;AIqoCA;AAAA;;;;;;;AJtoCA;;;;;;;;AACA;;;;;;;AGlMA;;AD9JA;;AC8JA;;;;;;;;;;;;;;AD9JA;;AC8JA;;AD9JA;AFyXA;;AA1BA;AAAA;;;;;;;;AACA;AAAA;;AIqoCA;AAAA;;;;;;;AJtoCA;;;;;;;;AACA;;;;;;;AGlMA;;AD9JA;;AC8JA;;;;;;;;;;;;;;AD9JA;;AC8JA;;AD9JA;AFyXA;;AA1BA;AAAA;;;;;;;;AACA;AAAA;;AIqoCA;AAAA;;;;;;;AJtoCA;;;;;;;;AACA;;;;;;;AGlMA;;AD9JA;;;;AC8JA;;;;;;;;;;;;;;;;;;;AJ2XA;;AACA;;;;;;;AAAA;;;;;;;AACA;;;;;;;;AAAA;;;;;;;;;;AAAA;;;;;;;;AAAA;;;;;;AG3hBA;;AC8JA;;AD9JA;AFyXA;;AA1BA;AAAA;;;;;;;;AACA;AAAA;;AIqoCA;AAAA;;;;;;;AJtoCA;;;;;;;;AACA;;;;;;;AGlMA;;AD9JA;;;;;;AC8JA;;;;;AD9JA;;AC8JA;;AD9JA;AFyXA;;AA1BA;AAAA;;;;;;;;AACA;AAAA;;AIqoCA;AAAA;;;;;;;AJtoCA;;;;;;;;AACA;;;;;;;AGlMA;;AD9JA;;;;;AC8JA;;;;;;;;AD9JA;;AC8JA;;AD9JA;AFyXA;;AA1BA;AAAA;;;;;;;;AACA;AAAA;;AIqoCA;AAAA;;;;;;;AJtoCA;;;;;;;;AACA;;;;;;;AGlMA;;AD9JA;;AC8JA;;;;AJ8XA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;AKmkDA;AAAA;AAAA;;ADz8DA;;;;;;;AFkjCA;AAPA;AAVA;AIzhCA;AAAA;AAAA;;AAAA;AAAA;AAAA;;AAjBA;;ANiZA;;;;;;;;;;;AIhYA;;;;;;;;AAAA;;;;;;AJkYA;;;;;;;;AAAA;;;;;;;;AAAA;;;;;;AGhiBA;;AC8JA;;AD9JA;AFyXA;;AA1BA;AAAA;;;;;;;;AACA;AAAA;;AIqoCA;AAAA;;;;;;;AJtoCA;;;;;;;;AACA;;;;;;;AGlMA;;AD9JA;;;;;;AC8JA;;;;;AD9JA;;AC8JA;;AD9JA;AFyXA;;AA1BA;AAAA;;;;;;;;AACA;AAAA;;AIqoCA;AAAA;;;;;;;AJtoCA;;;;;;;;AACA;;;;;;;AGlMA;;AD9JA;;AC8JA;;AD9JA;;AC8JA;;AD9JA;AFyXA;;AA1BA;AAAA;;;;;;;;AACA;AAAA;;AIqoCA;AAAA;;;;;;;AJtoCA;;;;;;;;AACA;;;;;;;AGlMA;;AD9JA;;AC8JA;;AD9JA;;AC8JA;;AD9JA;AFyXA;;AA1BA;AAAA;;;;;;;;AACA;AAAA;;AIqoCA;AAAA;;;;;;;AJtoCA;;;;;;;;AACA;;;;;;;AGlMA;;AD9JA;;AI+8CA;;;AHjzCA;AGizCA;;;;;;;;;AJ/8CA;;AC8JA;;AD9JA;AFyXA;;AA1BA;AAAA;;;;;;;;AACA;AAAA;;AIqoCA;AAAA;;;;;;;AJtoCA;;;;;;;;AACA;;;;;;;AGlMA;;AD9JA;;AC8JA;;;;;;;;;;;;;;AD9JA;;AC8JA;;AD9JA;AFyXA;;AA1BA;AAAA;;;;;;;;AACA;AAAA;;AIqoCA;AAAA;;;;;;;AJtoCA;;;;;;;;AACA;;;;;;;AGlMA;;AD9JA;;AC8JA;;;;;;;;;;;;;;AD9JA;;AC8JA;;AD9JA;AFyXA;;AA1BA;AAAA;;;;;;;;AACA;AAAA;;AIqoCA;AAAA;;;;;;;AJtoCA;;;;;;;;AACA;;;;;;;AGlMA;;AD9JA;;;;AC8JA;;;;;;;;;;;;;;;;;;;AJyVA;;AACA;;;;;;;AAAA;;;;;;;AACA;;;;;;;;AAAA;;;;;;;;;;AAAA;;;;;;;;AAAA;;;;;;AGzfA;;AC8JA;;AD9JA;AFyXA;;AA1BA;AAAA;;;;;;;;AACA;AAAA;;AIqoCA;AAAA;;;;;;;AJtoCA;;;;;;;;AACA;;;;;;;AGlMA;;AD9JA;;;;;;AC8JA;;;;;AD9JA;;AC8JA;;AD9JA;AFyXA;;AA1BA;AAAA;;;;;;;;AACA;AAAA;;AIqoCA;AAAA;;;;;;;AJtoCA;;;;;;;;AACA;;;;;;;AGlMA;;AD9JA;;;;;AC8JA;;;;;;;;AD9JA;;AC8JA;;AD9JA;AFyXA;;AA1BA;AAAA;;;;;;;;AACA;AAAA;;AIqoCA;AAAA;;;;;;;AJtoCA;;;;;;;;AACA;;;;;;;AGlMA;;AD9JA;;AC8JA;;;;AJ4VA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;AKqmDA;AAAA;AAAA;;ADz8DA;;;;;;;AFkjCA;AAPA;AAVA;AIzhCA;AAAA;AAAA;;AAAA;AAAA;AAAA;;AAjBA;;AN+WA;;;;;;;;;;;AI9VA;;;;;;;;AAAA;;;;;;AJgWA;;;;;;;;AAAA;;;;;;;;AAAA;;;;;;AG9fA;;AC8JA;;AD9JA;AFyXA;;AA1BA;AAAA;;;;;;;;AACA;AAAA;;AIqoCA;AAAA;;;;;;;AJtoCA;;;;;;;;AACA;;;;;;;AGlMA;;AD9JA;;;;;;AC8JA;;;;;AD9JA;;AC8JA;;AD9JA;AFyXA;;AA1BA;AAAA;;;;;;;;AACA;AAAA;;AIqoCA;AAAA;;;;;;;AJtoCA;;;;;;;;AACA;;;;;;;AGlMA;;AD9JA;;AC8JA;;AD9JA;;AC8JA;;AD9JA;AFyXA;;AA1BA;AAAA;;;;;;;;AACA;AAAA;;AIqoCA;AAAA;;;;;;;AJtoCA;;;;;;;;AACA;;;;;;;AGlMA;;AD9JA;;AC8JA;;AD9JA;;AC8JA;;AD9JA;AFyXA;;AA1BA;AAAA;;;;;;;;AACA;AAAA;;AIqoCA;AAAA;;;;;;;AJtoCA;;;;;;;;AACA;;;;;;;AGlMA;;AD9JA;;AI+8CA;;;AHjzCA;AGizCA;;;;;;;;;AJ/8CA;;AC8JA;;AD9JA;AFyXA;;AA1BA;AAAA;;;;;;;;AACA;AAAA;;AIqoCA;AAAA;;;;;;;AJtoCA;;;;;;;;AACA;;;;;;;AGlMA;;AD9JA;;AC8JA;;;;;;;;;;;;;;AD9JA;;AC8JA;;AD9JA;AFyXA;;AA1BA;AAAA;;;;;;;;AACA;AAAA;;AIqoCA;AAAA;;;;;;;AJtoCA;;;;;;;;AACA;;;;;;;AGlMA;;AD9JA;;AC8JA;;;;;;;;;;;;;;AD9JA;;AC8JA;;AD9JA;AFyXA;;AA1BA;AAAA;;;;;;;;AACA;AAAA;;AIqoCA;AAAA;;;;;;;AJtoCA;;;;;;;;AACA;;;;;;;AGlMA;;AD9JA;;;;AC8JA;;;;;;;;;;;AAAA;;;ACi8DA;AHz8BA;AAAA;AIx/BA;AJo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;;;;;;;;AI3ZA;;;;;;;;AAAA;;;;;AJyZA;;;;;;;;AAAA;;;;;;AGvjBA;;AC8JA;;AD9JA;AFyXA;;AA1BA;AAAA;;;;;;;;AACA;AAAA;;AIqoCA;AAAA;;;;;;;AJtoCA;;;;;;;;AACA;;;;;;;AGlMA;;AD9JA;;;;;;AC8JA;;;;;AD9JA;;AC8JA;;AD9JA;AFyXA;;AA1BA;AAAA;;;;;;;;AACA;AAAA;;AIqoCA;AAAA;;;;;;;AJtoCA;;;;;;;;AACA;;;;;;;AGlMA;;AD9JA;;;;AC8JA;;;;ACi8DA;AAAA;AAAA;;ADz8DA;;;;;;;AFkjCA;AAPA;AAVA;AIzhCA;AAAA;AAAA;;AAAA;AAAA;AAAA;;AAjBA;;AN+aA;;;;;;;;;;;AI9ZA;;;;;;;;AAAA;;;;;AD9JA;;AC8JA;;AD9JA;AFyXA;;AA1BA;AAAA;;;;;;;;AACA;AAAA;;AIqoCA;AAAA;;;;;;;AJtoCA;;;;;;;;AACA;;;;;;;AGlMA;;AD9JA;;AC8JA;;AD9JA;;AC8JA;;AD9JA;AFyXA;;AA1BA;AAAA;;;;;;;;AACA;AAAA;;AIqoCA;AAAA;;;;;;;AJtoCA;;;;;;;;AACA;;;;;;;AGlMA;;AD9JA;;AI+8CA;;;AHjzCA;AGizCA;;;;;;;;;AJ/8CA;;AC8JA;;AD9JA;AFyXA;;AA1BA;AAAA;;;;;;;;AACA;AAAA;;AIqoCA;AAAA;;;;;;;AJtoCA;;;;;;;;AACA;;;;;;;AGlMA;;AD9JA;;AC8JA;;;;;;;;;;;;;;AD9JA;;AC8JA;;AD9JA;AFyXA;;AA1BA;AAAA;;;;;;;;AACA;AAAA;;AIqoCA;AAAA;;;;;;;AJtoCA;;;;;;;;AACA;;;;;;;AGlMA;;AD9JA;;;;AC8JA;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AD9JA;ADiuCA;AAAA;AAAA;AD13BA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AWrZA;AXsZA;AWtZA;AXsZA;AWtZA;AP+oEA;AAAA;AAAA;AAAA;AAAA;AJ1vDA;AAAA;AAAA;AAAA;AAAA;AAAA;AI0vDA;AMnnEA;AAAA;;AC1BA;;;;;;;;AT4CA;AAAA;;AAAA;;;;;;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;;AFswCA;;;;;;;;AEtwCA;;AAAA;;;;;;AAAA;AS1CA;;AAAA;;;;;;;;;AAAA;;;;;;;;;AX0iDA;;A6B5jDA;AAAA;AAAA;AAAA;AAAA;A3B4DA;AAAA;AAAA;ADuhDA;AAAA;AAAA;AAtTA;AAAA;AAAA;ACjuCA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AFgXA;AACA;AAAA;AIsvDA;AJp9BA;AACA;AAAA;AIq+BA;AJp+BA;AACA;AAAA;AAAA;AEtpCA;AAAA;ADuhDA;AAAA;AAAA;AAtTA;AAAA;AAAA;ACjuCA;A2B5DA;Ad0VA;AACA;AACA;AACA;AAGA;AAAA;AAAA;AAAA;ACwvBA;AAAA;AACA;AAAA;AAEA;AACA;AhBueA;;;AAGA;;;;;;AWpjDA;;;;;;AAAA;AT0CA;;AC8JA;;AD9JA;AFyXA;;AA1BA;AAAA;;;;;;;;AACA;AAAA;;AIqoCA;AAAA;;;;;;;AJtoCA;;;;;;;;AACA;;;;;;;AGlMA;;AD9JA;;AC8JA;;;AQvMA;;;;;;;;AAAA;;;;;;AAAA;;;;;;AAAA;;AACA;;;;;;;;AAAA;;;;;;AAAA;;;;;;AAAA;;ARsMA;;AD9JA;AFyXA;;AA1BA;AAAA;;;;;;;;AACA;AAAA;;AIqoCA;AAAA;;;;;;;AJtoCA;;;;;;;;AAC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AAA;;AAAA;AAAA;AAAA;;AAjBA;;ANwIA;;;;;;;;;;;AIvHA;;;;;;;;;AAAA;;;;;AD9JA;ADiuCA;AAAA;AAAA;AD13BA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AD/EA;AKu0DA;AAAA;AAAA;AHn+BA;AI/+BA;AJygCA;;AA9UA;;;;;AAAA;;AAmnCA;AAAA;AAAA;AAAA;AAAA;AAAA;;AFjqDA;;;;;;;;AAAA;;;;;;;AAAA;;;;;;AG1RA;;AC8JA;;AD9JA;AFyXA;;AA1BA;AAAA;;;;;;;;AACA;AAAA;;AIqoCA;AAAA;;;;;;;AJtoCA;;;;;;;;AACA;;;;;;;AGlMA;;AD9JA;;;;;;AC8JA;;;;;AD9JA;;AC8JA;;AD9JA;AFyXA;;AA1BA;AAAA;;;;;;;;AACA;AAAA;;AIqoCA;AAAA;;;;;;;AJtoCA;;;;;;;;AACA;;;;;;;AGlMA;;AD9JA;;AC8JA;;AD9JA;;AC8JA;;AD9JA;AFyXA;;AA1BA;AAAA;;;;;;;;AACA;AAAA;;AIqoCA;AAAA;;;;;;;AJtoCA;;;;;;;;AACA;;;;;;;AGlMA;;;AAAA;;;;;;;;;;;;AD9JA;;AC8JA;;AD9JA;AFyXA;;AA1BA;AAAA;;;;;;;;AACA;AAAA;;AIqoCA;AAAA;;;;;;;AJtoCA;;;;;;;;AACA;;;;;;;AGlMA;;;AAAA;;;;;ACi8DA;AAAA;AAAA;;ADz8DA;;;;;;AFkjCA;AAPA;AAVA;AIzhCA;AAAA;AAAA;;AAAA;AAAA;AAAA;;AAjBA;;ANmJA;;;;;;;;;;;AIlIA;;;;;;;;;AAAA;;;;;;;;;;;;AD9JA;;AC8JA;;AD9JA;AFyXA;;AA1BA;AAAA;;;;;;;;AACA;AAAA;;AIqoCA;AAAA;;;;;;;AJtoCA;;;;;;;;AACA;;;;;;;AGlMA;;AD9JA;;AI+8CA;;;AHjzCA;AGizCA;;;AJ/8CA;;AC8JA;;AD9JA;AFyXA;;AA1BA;AAAA;;;;;;;;AACA;AAAA;;AIqoCA;AAAA;;;;;;;AJtoCA;;;;;;;;AACA;;;;;;;AGlMA;;AD9JA;;;;AC8JA;;;;;;;;;;;;;;;;;AJ7IA;AGjBA;ADiuCA;AAAA;AAAA;AD13BA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;ADpVA;;;;;AE4uBA;;;;;;;;;;;;;AAAA;;;;;;;;;;;;;AAAA;;;;;;;;;;;;;AAAA;;;;;;;;;;;;;AAAA;;;;;;;;;;;;;;;;;;AFttBA;;;;;;;AAAA;;;;;;;AAAA;;;;;;AGzCA;;AC8JA;;AD9JA;AFyXA;;AA1BA;AAAA;;;;;;;;AACA;AAAA;;AIqoCA;AAAA;;;;;;;AJtoCA;;;;;;;;AACA;;;;;;;AGlMA;;AD9JA;;;;;;AC8JA;;;;;AD9JA;;AC8JA;;AD9JA;AFyXA;;AA1BA;AAAA;;;;;;;;AACA;AAAA;;AIqoCA;AAAA;;;;;;;AJtoCA;;;;;;;;AACA;;;;;;;AGlMA;;AD9JA;;AC8JA;;;AJpHA;;;;;;;AAAA;;;;;;;AAAA;;;;;;AG1CA;;AC8JA;;AD9JA;AFyXA;;AA1BA;AAAA;;;;;;;;AACA;AAAA;;AIqoCA;AAAA;;;;;;;AJtoCA;;;;;;;;AACA;;;;;;;AGlMA;;AD9JA;;;;;;AC8JA;;;;;AD9JA;;AC8JA;;AD9JA;AFyXA;;AA1BA;AAAA;;;;;;;;AACA;AAAA;;AIqoCA;AAAA;;;;;;;AJtoCA;;;;;;;;AACA;;;;;;;AGlMA;;AD9JA;;AC8JA;;AD9JA;;AC8JA;;AD9JA;AFyXA;;AA1BA;AAAA;;;;;;;;AACA;AAAA;;AIqoCA;AAAA;;;;;;;AJtoCA;;;;;;;;AACA;;;;;;;AGlMA;;;AAAA;;AD9JA;;AC8JA;;AD9JA;AFyXA;;AA1BA;AAAA;;;;;;;;AACA;AAAA;;AIqoCA;AAAA;;;;;;;AJtoCA;;;;;;;;AACA;;;;;;;AGlMA;;AD9JA;;AI+8CA;;;AHjzCA;AGizCA;;;;;;;;;;;;;AJ/8CA;;AC8JA;;AD9JA;AFyXA;;AA1BA;AAAA;;;;;;;;AACA;AAAA;;AIqoCA;AAAA;;;;;;;AJtoCA;;;;;;;;AACA;;;;;;;AGlMA;;;AAAA;;AD9JA;;AC8JA;;AD9JA;AFyXA;;AA1BA;AAAA;;;;;;;;AACA;AAAA;;AIqoCA;AAAA;;;;;;;AJtoCA;;;;;;;;AACA;;;;;;;AGlMA;;AD9JA;;;;AC8JA;;;;;;;;;AH8rBA;AACA;AA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toCA;;;;;;;;AACA;;;;;;;AGlMA;;;AAAA;;AD9JA;;AC8JA;;AD9JA;AFyXA;;AA1BA;AAAA;;;;;;;;AACA;AAAA;;AIqoCA;AAAA;;;;;;;AJtoCA;;;;;;;;AACA;;;;;;;AGlMA;;;AAAA;;AD9JA;;AC8JA;;AD9JA;AFyXA;;AA1BA;AAAA;;;;;;;;AACA;AAAA;;AIqoCA;AAAA;;;;;;;AJtoCA;;;;;;;;AACA;;;;;;;AGlMA;;;AGizCA;;;AHjzCA;AGizCA;;;;;AHjzCA;;;;;;;;;AAAA;;;;;;;;;;;;;;AD9JA;;AC8JA;;AD9JA;AFyXA;;AA1BA;AAAA;;;;;;;;AACA;AAAA;;AIqoCA;AAAA;;;;;;;AJtoCA;;;;;;;;AACA;;;;;;;AGlMA;;AD9JA;;AC8JA;;;;;;;;;;;;;;AD9JA;;AC8JA;;AD9JA;AFyXA;;AA1BA;AAAA;;;;;;;;AACA;AAAA;;AIqoCA;AAAA;;;;;;;AJtoCA;;;;;;;;AACA;;;;;;;AGlMA;;AD9JA;;AC8JA;;;;;;;;;;;;;;AD9JA;;AC8JA;;AD9JA;AFyXA;;AA1BA;AAAA;;;;;;;;AACA;AAAA;;AIqoCA;AAAA;;;;;;;AJtoCA;;;;;;;;AACA;;;;;;;AGlMA;;AD9JA;;;;AC8JA;;;;;;;;;;;;;;;;;AJxBA;;AAEA;;;;;;;;AAAA;;;;;;;AAAA;;;;;;AGxIA;;AC8JA;;AD9JA;AFyXA;;AA1BA;AAAA;;;;;;;;AACA;AAAA;;AIqoCA;AAAA;;;;;;;AJtoCA;;;;;;;;AACA;;;;;;;AGlMA;;AD9JA;;;;;;AC8JA;;;;;AD9JA;;AC8JA;;AD9JA;AFyXA;;AA1BA;AAAA;;;;;;;;AACA;AAAA;;AIqoCA;AAAA;;;;;;;AJtoCA;;;;;;;;AACA;;;;;;;AGlMA;;AD9JA;;AC8JA;;AD9JA;ADiuCA;AAAA;AAAA;AD13BA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AD7NA;;;;;;;;;;AEk/BA;;;;;;;;;;;;;;;;AFr+BA;AAAA;AAAA;AAAA;;AACA;;;;;;;;AAAA;;;;;;;AAAA;;;;;;AGxJA;;AC8JA;;AD9JA;AFyXA;;AA1BA;AAAA;;;;;;;;AACA;AAAA;;AIqoCA;AAAA;;;;;;;AJtoCA;;;;;;;;AACA;;;;;;;AGlMA;;AD9JA;;;;;;AC8JA;;;;;AD9JA;;AC8JA;;AD9JA;AFyXA;;AA1BA;AAAA;;;;;;;;AACA;AAAA;;AIqoCA;AAAA;;;;;;;AJtoCA;;;;;;;;AACA;;;;;;;AGlMA;;AD9JA;;AC8JA;;AD9JA;;AC8JA;;AD9JA;AFyXA;;AA1BA;AAAA;;;;;;;;AACA;AAAA;;AIqoCA;AAAA;;;;;;;AJtoCA;;;;;;;;AACA;;;;;;;AGlMA;;;AAAA;;AD9JA;;AC8JA;;AD9JA;AFyXA;;AA1BA;AAAA;;;;;;;;AACA;AAAA;;AIqoCA;AAAA;;;;;;;AJtoCA;;;;;;;;AACA;;;;;;;AGlMA;;AD9JA;;AI+8CA;;;AHjzCA;AGizCA;;;;;;;;;;AJ/8CA;;AC8JA;;AD9JA;AFyXA;;AA1BA;AAAA;;;;;;;;AACA;AAAA;;AIqoCA;AAAA;;;;;;;AJtoCA;;;;;;;;AACA;;;;;;;AGlMA;;;AAAA;;;;;;;;;;;;AD9JA;;AC8JA;;AD9JA;AFyXA;;AA1BA;AAAA;;;;;;;;AACA;AAAA;;AIqoCA;AAAA;;;;;;;AJtoCA;;;;;;;;AACA;;;;;;;AGlMA;;AD9JA;;;;AC8JA;;;;;;;;;;;;;;;;;AAAA;;AF89BA;AAAA;;AA+EA;AE7iCA;;AF89BA;AAAA;AAAA;AAAA;;;;;AD7xBA;;;;;AIsoCA;;;;;;;;AJtoCA;AAAA;;;;;;;;;;;;;;;;;;;;AYo5BA;;;;;;;;;;;;;;;;;;;;;;;;;;;;AXvHA;AAAA;AAAA;;;AE99BA;;;;;AF89BA;AAAA;AAAA;;AA+EA;AAAA;AAAA;;ADl1BA;;AA1BA;AAAA;;;;;;;;;;;;;;;;;;;AGjMA;;;;;;;;;;;;;AHkMA;;;;;;;;;;;;;;;;;;;;AAAA;AAAA;AAAA;AAAA;;;;;;AC4xBA;;;;;;;;A6B3VA;;;;;A5B/vBA;AAAA;;;;;AAAA;;;;;AAIA;AAAA;;;;;;;;;;;;;;;;;;;;;;AAMA;;;;;;;AAAA;;;;ADknCA;;;A6BtMA;;;;;;;AAvLA;;;;;;;A5BjvBA;AD4kCA;AAkFA;AApBA;;;;AAgCA;;;;;;;;;;;;;;;;;;;;;;;;;;AA9FA;AAAA;AAAA;AAAA;;;;;;;AA+EA;AAAA;AAAA;;;;;;;;;A0B9oCA;AAAA;AAAA;;;;;;;AATA;AAAA;AAAA;;;;;;AxB0GA;AwB1GA;AAAA;AAAA;;;;;;;AFmxBA;AAAA;AAAA;;;;;;;AE1wBA;AAAA;AAAA;AAAA;AAAA;;;;;;A1B+jCA;AAAA;AAAA;;;;;;;;;A0B/jCA;AAAA;AAAA;;;;;;;A1B8oCA;AAAA;AAAA;;;;;;A0B9oCA;AAAA;;AAAA;;AAAA;AATA;A1BwkCA;AAAA;AAAA;AAAA;AAAA;;;AE99BA;AwB1GA;AASA;;;;;;;;;;;AAAA;AAAA;AAAA;;;;;A1B+jCA;;;;;A0B/jCA;AATA;A1BwkCA;AAAA;AA+EA;;A0B9oCA;;;;;;;;;;;;;AAAA;AAAA;AAAA;AAAA;;;;;;;;;;;A1B+jCA;AAAA;AE99BA;;AwBjGA;AAAA;;;ArBk0CA;AAAA;AAAA;;;;;;;;;;;;;;;;;;AAeA;;;;;AA+CA;AAAA;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;APptCA;AAEA;;;;;;;;;;;;;;AC4HA;;AC03BA;;;AFn/BA;;;AAAA;;;;;;;AAEA;;;AAAA;;;;AAAA;;AAAA;;;;;;;;;AK+2DA;;;;;;;;;;;;;;;;;;;;;;;;;;;;AOlkEA;AACA;;;;;;;;;;AJwPA;AqBtBA;ApBuUA;AAkFA;AAxDA;AAAA;;;AAjQA;;;;;;AA4WA;;AY9vBA;ATiFA;AAAA;AHkkBA;;;AArPA;;;;;;;;AA6SA;;AL3fA;;;;;;;;;AK2fA;;;AAxDA;;;;AArPA;;;;;AA6SA;;;;;;AAAA;;;;AL3fA;;;;AQ7HA;AAEA;AJyQA;AIxQA;AJwQA;AIvQA;AAAA;AAAA;;AAKA;AAAA;;AAAA;;;;;;;;;;;ARoHA;;;;;;AQjFA;;;ARiFA;AQjFA;;;;;AAjCA;AAAA;;AAAA;;;;;;;;;;;ARkHA;;;;;;AQjFA;;;ARiFA;AQjFA;;;;AA1BA;;;;;;;;;;;;AJmOA;AqBtBA;;AlBpTA;;;;;;;;AAAA;;;;;;;AAAA;ACyGA;AAAA;ADzGA;;APkNA;;;AAAA;;;;;;;;;;;AAAA;;;;;;;;;;;;;;;AAAA;;;;AQvGA;AEg+BA;;AF78BA;;AVglHA;;;;;;;;;AAnoEA;AAAA;AAAA;AAtTA;AAAA;AAAA;;AUvpCA;;;;;;;;;;;ARoFA;;;;;;AAAA;;;AAAA;;AQjFA;;;;;ARiFA;;;;;;AOlNA;AAAA;;AAAA;;;;;;;;APkNA;;;AOlNA;AAAA;;;AC2HA;;AACA;;;;;;;;;AV8kCA;AIzgCA;AAAA;AAAA;;AMrEA;;;;;;;ARsFA;;AQtFA;;;;;;ARsFA;;AQtFA;AD5HA;;APkNA;;AQjFA;;;;AAbA;;;;;;;;AX+/CA;AAAA;AAAA;;;AA/tCA;AEhWA;;AC8JA;;AD9JA;AFyXA;;AA1BA;AAAA;;;;;;;AACA;AAAA;;AIqoCA;AAAA;;;;;;;AJtoCA;;;;AGjMA;;AD9JA;;AC8JA;;AHiMA;;;;AACA;;;;;;;A4BiBA;;;;;;;AAAA;AvBpOA;AAAA;AAAA;;AM1EA;;;;;;;;AR2FA;;AyBsFA;;;;;;;;;;AzBtFA;;AyBsFA;;;;AjB/KA;;;;;;;;ADzHA;;APkNA;;;;;;;;;;;;;;;;;;;;;;;;AJ4DA;;AAEA;;;;;;;AAAA;;;;;;;;;;;AAGA;Aai+BA;Abj+BA;AAAA;;AAAA;AAAA;AAAA;AAAA;;;;;;;;;;;;;;;;;;AAEA;;AAAA;;;;;;;;;AE25BA;;AI/+BA;AJ0iCA;;AI1iCA;AJygCA;;;AA9UA;;;;;AAAA;;AAmnCA;AAAA;AAAA;;;;;;;;;;;;;;;;;AGoKA;AAAA;AAAA;;ADz8DA;;;;;;AFkjCA;AAPA;AAVA;AIzhCA;AAAA;AAAA;;AAAA;AAAA;AAAA;;AAjBA;;ANsFA;;;;;;;;;;;AIrEA;;;;;;;;;AAAA;;;;;;;;;;AJuEA;;;;;;;AAAA;;;;;;;AAAA;;;;;;AGrOA;;AC8JA;;AD9JA;AFyXA;;AA1BA;AAAA;;;;;;;;AACA;AAAA;;AIqoCA;AAAA;;;;;;;AJtoCA;;;;;;;;AACA;;;;;;;AGlMA;;AD9JA;;;;;;AC8JA;;;;;AD9JA;;AC8JA;;AD9JA;AFyXA;;AA1BA;AAAA;;;;;;;;AACA;AAAA;;AIqoCA;AAAA;;;;;;;AJtoCA;;;;;;;;AACA;;;;;;;AGlMA;;AD9JA;;AC8JA;;AD9JA;;AC8JA;;AD9JA;AFyXA;;AA1BA;AAAA;;;;;;;;AACA;AAAA;;AIqoCA;AAAA;;;;;;;AJtoCA;;;;;;;;AACA;;;;;;;AGlMA;;AD9JA;;AC8JA;;AD9JA;;AC8JA;;AD9JA;AFyXA;;AA1BA;AAAA;;;;;;;;AACA;AAAA;;AIqoCA;AAAA;;;;;;;AJtoCA;;;;;;;;AACA;;;;;;;AGlMA;;AD9JA;;AI+8CA;;;AHjzCA;AGizCA;;;;;;;;;;;AJ/8CA;;AC8JA;;AD9JA;AFyXA;;AA1BA;AAAA;;;;;;;;AACA;AAAA;;AIqoCA;AAAA;;;;;;;AJtoCA;;;;;;;;AACA;;;;;;;AGlMA;;AD9JA;;AC8JA;;;;;;;;;;;;;;AD9JA;;AC8JA;;AD9JA;AFyXA;;AA1BA;AAAA;;;;;;;;AACA;AAAA;;AIqoCA;AAAA;;;;;;;AJtoCA;;;;;;;;AACA;;;;;;;AGlMA;;AD9JA;;;;AC8JA;;;;;;;AFoyCA;AIrzCA;AAAA;;AyB20BA;;;;;;A7BoKA;AAAA;;AAAA;AAAA;;AAAA;;AA+EA;AE7iCA;;;;AF89BA;;;;AE99BA;AGizCA;;;;AG52CA;AAAA;AAAA;AHs3CA;AAAA;;;;;;AAQA;;;;;;;;;;;;;;;;;;;;;AApCA;;;;;;;;;;;;;;;;;;;;;APh8CA;AACA;;;;AACA;;;;;;;AE6nCA;AAAA;AA8DA;AAgCA;AAAA;A6BlQA;;;;;;A7BoKA;;;;;AA+EA;AE7iCA;AAAA;;;;;;;;;;;;ACi8DA;ADz8DA;;;AFkjCA;AAPA;AAAA;AAVA;AAAA;;AA2QA;;;;;;;;;AAtUA;;;;;AA+EA;;;AA/EA;;;;;AA+EA;;;;;;;;;AC3sCA;AAAA;;AD4nCA;;;AC5nCA;AFyXA;AAAA;;AA1BA;AAAA;;;;;;AACA;;AIqoCA;AAAA;;;;;;;;;;;;AJroCA;;;;;;AGlMA;;;;AF89BA;;;AA+EA;AE7iCA;AAAA;;AD9JA;AD4nCA;;;AE99BA;;;;AHiMA;AAAA;AAAA;;;;;;;;;;;;AAAA;;;;;;;;;AACA;;;;;;;;;;AEhWA;AAAA;AAAA;AD4nCA;;;;;AA+EA;;;;;;;;AQxmCA;AHs3CA;AADA;;;;;;;;;;;;AAzFA;;;;;;;;;;;;;;AAuDA;;;;;;;;AHxxCA;;;;;;;;;;;;;;;;;;;;;;;;;;;AF89BA;AAAA;;AAkCA;AA4DA;AAAA;A6BlQA;;;;;;A7BoKA;AAAA;;;;;AE99BA;;;;;AF89BA;;;;;AAAA;AAAA;;AA+EA;AE7iCA;;;AH2NA;;;;;;;;;;;AI4mCA;;;;;AJtoCA;;;;;;;;;;;;;AGjMA;;;AF89BA;;;;;;AAAA;;AA+EA;;ADl1BA;AAAA;;;;AA1BA;;;;;;;;;;;AAAA;;;;;;;;AACA;;;;;;;;;;;;AGlMA;;;;;;;;;AF89BA;AAAA;;AA+EA;;;;AA/EA;;;;AA+EA;;;;;;ADl1BA;;;AAzBA;AAAA;;AAAA;AAAA;AAAA;AAAA;AAAA;;;;;;;AAAA;;;AAAA;AAAA;AAAA;;AGlMA;;;;;;;;;;AH2NA;AAAA;;;;;;;;;;AAzBA;AAAA;AAyBA;AAAA;;;AA1BA;AAAA;AAAA;;AACA;AAAA;;AAAA;AAAA;;AAAA;AAAA;;;;AAyBA;AAAA;;;;AA1BA;;AACA;AAAA;;AAAA;AAAA;AAAA;AAAA;;;AGlMA;;;;;;;;;;;;;;;AF89BA;AAAA;AAAA;;;;;;;;;;;;;;;;;;;;;;AA8DA;AAAA;AA5BA;AAlWA;AAAA;;;;;;;;;;;;AA+lFA;;;;;;AAnWA;AqB5wFA;;;;;;;ArB0kFA;AA1vDA;AAAA;;;;AI/+BA;AJ0iCA;AAAA;AAAA;;;;;AA/WA;;;;;;AAAA;AAAA;;;;;;AAoTA;;AA+EA;AAAA;;;;AArDA;;;;;;;;;AA9UA;AAAA;;;;AqBphBA;;;;;;;;AtBmQA;AAAA;AAAA;;;;AAqUA;;AACA;AAAA;;;;AAllBA;AAAA;AAolBA;AAAA;;;;AezoBA;;;;;;;AXo7CA;ADphDA;;;;;;Ae/EA;;;;;;;;;;;;;;;;AHgLA;AAAA;;;;Af6uCA;AAAA;AIqGA;AAAA;;;;;AegsFA;AAAA;AAAA;;;;;Af5lFA;AD/gDA;AAAA;;;;;;;;;;;;;AHyZA;AAAA;;;;AA06BA;AArmBA;;;;;;AAjlBA;AAAA;AAAA;AAAA;;;;AAolBA;AezoBA;;;;;;;AXo7CA;ADphDA;AAAA;;;;;Ae/EA;;;;;;AAyFA;;;;;;;;;;;;;;;AhBzMA;;;;;;;Aa8TA;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AfgiBA;AAAA;AIgwBA;;;;;;;AAEA;AAAA;;AJvsCA;AACA;AAAA;;AACA;AIqvDA;;;;;;;;;;;;;;;;ALzgEA;;AACA;;;;;;;AAAA;;;;;;AG/FA;ADiuCA;AAAA;AAAA;AD13BA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;ADtQA;AACA;;AACA;;;;;;;AAAA;AAAA;AAAA;;AACA;;;;;;;AAAA;;;;;;;AAAA;;;;;;AGpGA;;AC8JA;;AD9JA;AFyXA;;AA1BA;AAAA;;;;;;;;AACA;AAAA;;AIqoCA;AAAA;;;;;;;AJtoCA;;;;;;;;AACA;;;;;;;AGlMA;;AD9JA;;;;;;AC8JA;;;;;AD9JA;;AC8JA;;AD9JA;AFyXA;;AA1BA;AAAA;;;;;;;;AACA;AAAA;;AIqoCA;AAAA;;;;;;;AJtoCA;;;;;;;;AACA;;;;;;;AGlMA;;AD9JA;;AC8JA;;AD9JA;;AC8JA;;AD9JA;AFyXA;;AA1BA;AAAA;;;;;;;;AACA;AAAA;;AIqoCA;AAAA;;;;;;;AJtoCA;;;;;;;;AACA;;;;;;;AGlMA;;;AAAA;;AD9JA;;AC8JA;;AD9JA;AFyXA;;AA1BA;AAAA;;;;;;;;AACA;AAAA;;AIqoCA;AAAA;;;;;;;AJtoCA;;;;;;;;AACA;;;;;;;AGlMA;;AD9JA;;AC8JA;;AD9JA;;AC8JA;;AD9JA;AFyXA;;AA1BA;AAAA;;;;;;;;AACA;AAAA;;AIqoCA;AAAA;;;;;;;AJtoCA;;;;;;;;AACA;;;;;;;AGlMA;;AD9JA;;AI+8CA;;;AHjzCA;AGizCA;;;;;;;;;;;AJ/8CA;;AC8JA;;AD9JA;AFyXA;;AA1BA;AAAA;;;;;;;;AACA;AAAA;;AIqoCA;AAAA;;;;;;;AJtoCA;;;;;;;;AACA;;;;;;;AGlMA;;;AAAA;;AD9JA;;AC8JA;;AD9JA;AFyXA;;AA1BA;AAAA;;;;;;;;AACA;AAAA;;AIqoCA;AAAA;;;;;;;AJtoCA;;;;;;;;AACA;;;;;;;AGlMA;;AD9JA;;AC8JA;;;;;;;;;;;;;;AD9JA;;AC8JA;;AD9JA;AFyXA;;AA1BA;AAAA;;;;;;;;AACA;AAAA;;AIqoCA;AAAA;;;;;;;AJtoCA;;;;;;;;AACA;;;;;;;AGlMA;;AD9JA;;;;AC8JA;;;;;;;;;;;;;;;;;;AJ4GA;AG1QA;ADiuCA;AAAA;AAAA;AD13BA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AD3FA;;AACA;;;;;;;;;;;AAAA;;;;;;AG7QA;;AC8JA;;AD9JA;AFyXA;;AA1BA;AAAA;;;;;;;;AACA;AAAA;;AIqoCA;AAAA;;;;;;;AJtoCA;;;;;;;;AACA;;;;;;;AGlMA;;AD9JA;;;;;;;AC8JA;;;;;;AF89BA;;AI/+BA;AJ0iCA;;AI1iCA;AJygCA;;;AA9UA;;;;;AAAA;;AAmnCA;AAAA;AAAA;AA1tBA;AAAA;AAAA;;;AEnkCA;;AD9JA;AFyXA;;AA1BA;AAAA;;;;;;;;AACA;AAAA;;AIqoCA;AAAA;;;;;;;AJtoCA;;;;;;;;AACA;;;;;;;AGlMA;;AD9JA;;AC8JA;;;AJgHA;;;;;AAAA;;;;;AAAA;;;;;;AG9QA;;AC8JA;;AD9JA;AFyXA;;AA1BA;AAAA;;;;;;;;AACA;AAAA;;AIqoCA;AAAA;;;;;;;AJtoCA;;;;;;;;AACA;;;;;;;AGlMA;;AD9JA;;;;;;AC8JA;;;;;AD9JA;;AC8JA;;AD9JA;AFyXA;;AA1BA;AAAA;;;;;;;;AACA;AAAA;;AIqoCA;AAAA;;;;;;;AJtoCA;;;;;;;;AACA;;;;;;;AGlMA;;AD9JA;;AC8JA;;AD9JA;;AC8JA;;AD9JA;AFyXA;;AA1BA;AAAA;;;;;;;;AACA;AAAA;;AIqoCA;AAAA;;;;;;;AJtoCA;;;;;;;;AACA;;;;;;;AGlMA;;;AAAA;;AD9JA;;AC8JA;;AD9JA;AFyXA;;AA1BA;AAAA;;;;;;;;AACA;AAAA;;AIqoCA;AAAA;;;;;;;AJtoCA;;;;;;;;AACA;;;;;;;AGlMA;;AD9JA;;AI+8CA;;;AHjzCA;AGizCA;;;;;;;;;;;;;AJ/8CA;;AC8JA;;AD9JA;AFyXA;;AA1BA;AAAA;;;;;;;;AACA;AAAA;;AIqoCA;AAAA;;;;;;;AJtoCA;;;;;;;;AACA;;;;;;;AGlMA;;;AAAA;;AD9JA;;AC8JA;;AD9JA;AFyXA;;AA1BA;AAAA;;;;;;;;AACA;AAAA;;AIqoCA;AAAA;;;;;;;AJtoCA;;;;;;;;AACA;;;;;;;AGlMA;;AD9JA;;;;AC8JA;;;;;;;;;;;;;;;;;AJkbA;;AAEA;;;;;;;AAAA;;;;;;;AACA;;;;;;;;;AAAA;;;;;;;;;;AAAA;;;;;;AGnlBA;;AC8JA;;AD9JA;AFyXA;;AA1BA;AAAA;;;;;;;;AACA;AAAA;;AIqoCA;AAAA;;;;;;;AJtoCA;;;;;;;;AACA;;;;;;;AGlMA;;AD9JA;;;;;;AC8JA;;;;;AD9JA;;AC8JA;;AD9JA;AFyXA;;AA1BA;AAAA;;;;;;;;AACA;AAAA;;AIqoCA;AAAA;;;;;;;AJtoCA;;;;;;;;AACA;;;;;;;AGlMA;;AD9JA;;AC8JA;;AD9JA;;AC8JA;;AD9JA;AFyXA;;AA1BA;AAAA;;;;;;;;AACA;AAAA;;AIqoCA;AAAA;;;;;;;AJtoCA;;;;;;;;AACA;;;;;;;AGlMA;;AD9JA;;AC8JA;;AD9JA;;AC8JA;;AD9JA;AFyXA;;AA1BA;AAAA;;;;;;;;AACA;AAAA;;AIqoCA;AAAA;;;;;;;AJtoCA;;;;;;;;AACA;;;;;;;AGlMA;;AD9JA;;AC8JA;;AD9JA;;AC8JA;;AD9JA;AFyXA;;AA1BA;AAAA;;;;;;;;AACA;AAAA;;AIqoCA;AAAA;;;;;;;AJtoCA;;;;;;;;AACA;;;;;;;AGlMA;;AD9JA;;AI+8CA;;;AHjzCA;AGizCA;;;;AJ/8CA;;AC8JA;;AD9JA;AFyXA;;AA1BA;AAAA;;;;;;;;AACA;AAAA;;AIqoCA;AAAA;;;;;;;AJtoCA;;;;;;;;AACA;;;;;;;AGlMA;;AD9JA;;AC8JA;;;;;;;;AD9JA;;AC8JA;;AD9JA;AFyXA;;AA1BA;AAAA;;;;;;;;AACA;AAAA;;AIqoCA;AAAA;;;;;;;AJtoCA;;;;;;;;AACA;;;;;;;AGlMA;;AD9JA;;AC8JA;;;;;;;;;;;;;;AD9JA;;AC8JA;;AD9JA;AFyXA;;AA1BA;AAAA;;;;;;;;AACA;AAAA;;AIqoCA;AAAA;;;;;;;AJtoCA;;;;;;;;AACA;;;;;;;AGlMA;;AD9JA;;;;AC8JA;;;;;;;;;;;;;;;;;;;AmBvJA;;;;;;ArBqnCA;;;;;;;;;;;;;AE99BA;;;;;;;;;AF89BA;AAAA;;AA+EA;AE7iCA;;;;;;;AF89BA;;;AA+EA;AE7iCA;;;;;;;;;;;;;;;AwBjGA;AATA;A1BwkCA;;;;;;;;;;;;;;;AqB/mCA;;;;;;;;;;;;;AKuCA;A1BwkCA;;;;A0B/jCA;;;;;;;AAAA;;;;;;;;;;;;;;;;;;A1B61GA;;;;;;;;;;;;;;;;;;;;;;;;;;;AA9xEA;;AA8xEA;;;;;;;;AAEA;;;;;;;;;;;;;;;;;;;;;AAAA;;;;AqB7yGA;;;;;;;ArB2kCA;AA5BA;;;;;;;;;;;;AIjhCA;;;;;AO6uCA;;;;;;;;;;;;;;;;;;;AU14CA;AV04CA;;;;;;;;;;;;;;;;;;;;;;AX/KA;AE7iCA;;;;;;;AAAA;;;;;;;;;;;;;;;;;;;;;AsBgrBA;AAFA;;;;;;;;;;;;;;;;;;;;;AD7NA;;;;;;AC+NA;;;;;;;;;;;;AAnpBA;;;;;;;;;;;;AtB7BA;;;;;AFmkCA;;;;;AqB7sCA;;;;;;AAAA;AAAA;AEidA;;;;;;;;;;;;;;;;;;;;;;;;;;;;ArBvUA;;;;AmBxIA;;;;;;ArBwoCA;AA4vEA;;;;;;;;;AqBl4GA;;;;;;;;;;;;;;;;;;;;;;;;AnBsIA;AmBrIA;;;;AAGA;;;;;;;ArBkoCA;AA4vEA;;;;;;;;;;;;;;;;;;;;;;;;;;;AE5vGA;;;;;;;;;AF8vGA;;;;;;;;AAhyEA;AA+EA;;;;;;;;;;;;AA/EA;;;;A0B/jCA;AAAA;;AATA;A1BwkCA;AAAA;A0BxkCA;AASA;AAAA;;;AxBiGA;AwBjGA;AL1BA;;;;;;;;AK0BA;AAAA;;;;A1B+jCA;;;;;;A0B/jCA;;;;;;;;AAAA;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;A5BuOA;;;AAEA;AEs1BA;AAAA;;AGm+BA;AAAA;AAAA;;ADz8DA;;;;;;;AFkjCA;AAPA;AAVA;AIzhCA;AAAA;AAAA;;AAAA;AAAA;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;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AlC6OA;;AACA;;;;;;;;AAAA;;;;;;AGpiBA;;AC8JA;;AD9JA;AFyXA;;AA1BA;AAAA;;;;;;;;AACA;AAAA;;AIqoCA;AAAA;;;;;;;AJtoCA;;;;;;;;AACA;;;;;;;AGlMA;;AD9JA;;;;;;AC8JA;;;;;AD9JA;;AC8JA;;AD9JA;AFyXA;;AA1BA;AAAA;;;;;;;;AACA;AAAA;;AIqoCA;AAAA;;;;;;;AJtoCA;;;;;;;;AACA;;;;;;;AGlMA;;AD9JA;;AC8JA;;;;AJuYA;AACA;AAAA;AAAA;AAAA;AAAA;;;AACA;;;;;;;;AAAA;;;;;;AGviBA;;AC8JA;;AD9JA;AFyXA;;AA1BA;AAAA;;;;;;;;AACA;AAAA;;AIqoCA;AAAA;;;;;;;AJtoCA;;;;;;;;AACA;;;;;;;AGlMA;;AD9JA;;;;;;AC8JA;;;;;AD9JA;;AC8JA;;AD9JA;AFyXA;;AA1BA;AAAA;;;;;;;;AACA;AAAA;;AIqoCA;AAAA;;;;;;;AJtoCA;;;;;;;;AACA;;;;;;;AGlMA;;AD9JA;;AC8JA;;;ACi8DA;AAAA;AAAA;;ADz8DA;;;;;;;AFkjCA;AAPA;AAVA;AIzhCA;AAAA;AAAA;;AAAA;AAAA;AAAA;;AAjBA;;AN6ZA;;;;;;;;;;;AI5YA;;;;;;;;AAAA;;;;;;AD9JA;;AC8JA;;AD9JA;AFyXA;;AA1BA;AAAA;;;;;;;;AACA;AAAA;;AIqoCA;AAAA;;;;;;;AJtoCA;;;;;;;;AACA;;;;;;;AGlMA;;AD9JA;;AI+8CA;;;AHjzCA;AGizCA;;;;;;;;;AJ/8CA;;AC8JA;;AD9JA;AFyXA;;AA1BA;AAAA;;;;;;;;AACA;AAAA;;AIqoCA;AAAA;;;;;;;AJtoCA;;;;;;;;AACA;;;;;;;AGlMA;;AD9JA;;;;AC8JA;;;;;;;;;;;;;;;;;;;;;;AFmkCA;AAAA;AAAA;AArGA;;;;;AAAA;AAAA;;AA8DA;AA5BA;AAlWA;AAAA;;;AA6lBA;;;;;;;AAGA;AAAA;;;AArLA;AAAA;AAAA;;;;;;;;;;;AAhDA;;;AIzhCA;;;;;;;AJ45GA;;;;;AA97EA;AAAA;;;;AA+EA;AE7iCA;;;;;;;;;;;;;AGwmDA;;AAEA;;AE/2CA;AAAA;;;;AFg3CA;;;;;;AAHA;;;;;AACA;AAAA;AAAA;;;AE92CA;;;AAAA;;AFg3CA;;;;;;;;;AAtLA;;;;;;AAIA;AAAA;;;;AAGA;;;AAAA;AAAA;AAAA;;;;;;;;;;;;;;AARA;;;AEzrCA;AF6rCA;;AACA;AAAA;AE9rCA;AAAA;;;;;;;;;ANzZA;ADiuCA;AD13BA;AAAA;;;;Ac5ZA;AAAA;AAAA;;;;;;;;;;AAWA;AAAA;;;;;;;AAGA;;;AACA;AAAA;AAAA;;;;;;;AAKA;;;;;;;;;;;;;;;;;;;;;;;;;;;;AAOA;AAAA;AAAA;AAAA;;AAAA;AACA;AAAA;AAAA;;;;;;;;;;;;;;;;Ab0vCA;;AatxCA;AAAA;AC2EA;AAAA;;;;ACsyCA;;;;;;;;;;;;;;;;ADryCA;;AC89BA;;;;;;;Af4OA;;;ADh3BA;;;AAkyBA;AACA;;;;;;AAEA;;;;;;;;AgBwkBA;;;;AFvvDA;;AAAA;AAAA;AAAA;;;;;;;;;;;;;;;;;;;;AZyBA;AAAA;AAAA;AAAA;;;;;;;;AAAA;AAAA;;;;;;;;;;;;;;;AHweA;;AACA;;;;;;;;AAAA;;;;;;AGzeA;;AC8JA;;AD9JA;AFyXA;;AA1BA;AAAA;;;;;;;;AACA;AAAA;;AIqoCA;AAAA;;;;;;;AJtoCA;;;;;;;;AACA;;;;;;;AGlMA;;AD9JA;;;;;;AC8JA;;;;;AD9JA;;AC8JA;;AD9JA;AFyXA;;AA1BA;AAAA;;;;;;;;AACA;AAAA;;AIqoCA;AAAA;;;;;;;AJtoCA;;;;;;;;AACA;;;;;;;AGlMA;;AD9JA;;AC8JA;;;;;AJ6UA;;;;;;;;AAAA;;;;;;AG3eA;;AC8JA;;AD9JA;AFyXA;;AA1BA;AAAA;;;;;;;;AACA;AAAA;;AIqoCA;AAAA;;;;;;;AJtoCA;;;;;;;;AACA;;;;;;;AGlMA;;AD9JA;;;;;;AC8JA;;;;;AD9JA;;AC8JA;;AD9JA;AFyXA;;AA1BA;AAAA;;;;;;;;AACA;AAAA;;AIqoCA;AAAA;;;;;;;AJtoCA;;;;;;;;AACA;;;;;;;AGlMA;;AD9JA;;AC8JA;;;AJ8UA;AAAA;;;;AACA;;;AKknDA;AAAA;AAAA;;ADz8DA;;;;;;;AFkjCA;AAPA;AAVA;AIzhCA;AAAA;AAAA;;AAAA;AAAA;AAAA;;AAjBA;;ANmWA;;;;;;;;;;;AIlVA;;;;;;;;AAAA;;;;;AD9JA;;AC8JA;;AD9JA;AFyXA;;AA1BA;AAAA;;;;;;;;AACA;AAAA;;AIqoCA;AAAA;;;;;;;AJtoCA;;;;;;;;AACA;;;;;;;AGlMA;;AD9JA;;AI+8CA;;;AHjzCA;AGizCA;;;;;;;;;AJ/8CA;;AC8JA;;AD9JA;AFyXA;;AA1BA;AAAA;;;;;;;;AACA;AAAA;;AIqoCA;AAAA;;;;;;;AJtoCA;;;;;;;;AACA;;;;;;;AGlMA;;AD9JA;;;;AC8JA;;;;;;;;;;;AHiMA;AAAA;AAAA;;;;;;AACA;AAAA;;AIqoCA;AAAA;AAAA;AAAA;;;;;AJtoCA;;;;;;;;;;;;AC6xBA;;;AA+EA;AE7iCA;AAAA;;;;;;;;;;;;;;;;;AF89BA;;AAAA;;;;AD7xBA;;;;;;;;AACA;AAAA;;;;;;;;AADA;AAAA;AAAA;AAAA;;;;;;;;;;;;;;;;;;;;;;AGjMA;;;;;;;;;;;;;;;;;AF89BA;AAAA;;;;;;ADnwBA;;;;;;AAzBA;AAAA;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AC4xBA;AAAA;;;;;;;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;AE99BA;;;;;;;AD9JA;;AD4nCA;;AE99BA;AAAA;AAAA;AAAA;AAAA;AAAA;;AD9JA;AFyXA;AAAA;;;;;;;;AAzBA;;;;AIqoCA;;;;;AJtoCA;AAAA;AAAA;AAAA;AAAA;AAAA;;;;;;;;;;;;;;;;;;;;;;;;;;AsBtOA;AAAA;AAAA;AAAA;AAAA;AAAA;;;;;ArBmgCA;AAAA;AAAA;;;ADnwBA;;;;;;;AA1BA;;;;AIsoCA;;;;AJtoCA;AAAA;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AE/VA;AAAA;AAAA;AAAA;AAAA;AAAA;;;AD4nCA;AAAA;AAAA;AAAA;AAAA;AAAA;;;;;;AE99BA;;;;;AmBrCA;ApBzHA;AD4nCA;;;;;;;;;;;;;;;;;;;AFlhCA;;AACA;;;;;;;;AAAA;;;;;;;AAAA;;;;;;AG3GA;;AC8JA;;AD9JA;AFyXA;;AA1BA;AAAA;;;;;;;;AACA;AAAA;;AIqoCA;AAAA;;;;;;;AJtoCA;;;;;;;;AACA;;;;;;;AGlMA;;AD9JA;;;;;;AC8JA;;;;;AD9JA;;AC8JA;;AD9JA;AFyXA;;AA1BA;AAAA;;;;;;;;AACA;AAAA;;AIqoCA;AAAA;;;;;;;AJtoCA;;;;;;;;AACA;;;;;;;AGlMA;;AD9JA;;AC8JA;;;AJlDA;;;;;;;AAAA;;;;;;;AAAA;;;;;;AG5GA;;AC8JA;;AD9JA;AFyXA;;AA1BA;AAAA;;;;;;;;AACA;AAAA;;AIqoCA;AAAA;;;;;;;AJtoCA;;;;;;;;AACA;;;;;;;AGlMA;;AD9JA;;;;;;AC8JA;;;;;AD9JA;;AC8JA;;AD9JA;AFyXA;;AA1BA;AAAA;;;;;;;;AACA;AAAA;;AIqoCA;AAAA;;;;;;;AJtoCA;;;;;;;;AACA;;;;;;;AGlMA;;AD9JA;;AC8JA;;AD9JA;;AC8JA;;AD9JA;AFyXA;;AA1BA;AAAA;;;;;;;;AACA;AAAA;;AIqoCA;AAAA;;;;;;;AJtoCA;;;;;;;;AACA;;;;;;;AGlMA;;AD9JA;;AI+8CA;;;AHjzCA;AGizCA;;;;;;;;;;;;AJ/8CA;;AC8JA;;AD9JA;AFyXA;;AA1BA;AAAA;;;;;;;;AACA;AAAA;;AIqoCA;A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ARwKA;;;;;;AQpKA;;;ARoKA;AQpKA;;;;AAFA;;AAAA;;;;;;;;;AXwgDA;AAAA;;A6B5jDA;AAAA;AAAA;AAAA;AAAA;A3B4DA;AAAA;AAAA;ADuhDA;AAAA;AAAA;AAtTA;AAAA;AAAA;ACjuCA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AFgXA;AACA;AAAA;AIsvDA;AJp9BA;AACA;AAAA;AIq+BA;AJp+BA;AACA;AAAA;AAAA;AEtpCA;AAAA;ADuhDA;AAAA;AAAA;AAtTA;AAAA;AAAA;ACjuCA;A2B5DA;Ad0VA;AACA;AACA;AACA;AAGA;AAAA;AAAA;AAAA;ACwvBA;AAAA;AACA;AAAA;AAEA;AACA;AhBueA;;;AAGA;;;;;;AWlhDA;;;;;;AAAA;ATQA;;AC8JA;;AD9JA;AFyXA;;AA1BA;AAAA;;;;;;;;AACA;AAAA;;AIqoCA;AAAA;;;;;;;AJtoCA;;;;;;;;AACA;;;;;;;AGlMA;;AD9JA;;AC8JA;;AQpKA;;;;ATMA;;AC8JA;;AD9JA;AFyXA;;AA1BA;AAAA;;;;;;;;AACA;AAAA;;AIqoCA;AAAA;;;;;;;AJtoCA;;;;;;;;AACA;;;;;;;AGlMA;;AD9JA;;AC8JA;;;;;;;;;;;;;;;;;AD9JA;ADiuCA;AAAA;AAAA;AD13BA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AEvWA;ADiuCA;AAAA;AAAA;AD13BA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AEvWA;;AAAA;;;;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;;AFswCA;;;;;;;AEtwCA;;AAAA;;;;AAAA;AAAA;ASQA;ATRA;;AAAA;;;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;;AFswCA;;;;;;;AEtwCA;;AAAA;;;;AAAA;AAAA;ASSA;AX8iBA;AAAA;AAAA;;;;;;;;;;AW7iBA;;;;;;;AADA;AAAA;;;;AX8iBA;AAAA;;;;;;;;;;;;AWriBA;;;AXq4CA;AAAA;AEv5CA;;AAAA;;;;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AFmwCA;;;AAGA;;;;;;;;AEtwCA;;;;AAAA;AAAA;;AAAA;;;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;;AFswCA;;;;;;;;AEtwCA;;;;AAAA;ASkBA;AAAA;;;;;;;;;;AAAA;;;;AX29CA;;;AASA;;;;;;AWp+CA;AAAA;;;;ADhEA;;;;;AAAA;;;;AViiDA;AWj+CA;AAAA;;;;;ATlBA;;AC8JA;;AD9JA;AFyXA;;AA1BA;AAAA;;;;;;;;AACA;AAAA;;AIqoCA;AAAA;;;;;;;AJtoCA;;;;;;;;AACA;;;;;;;AGlMA;;AD9JA;;;;ASkBA;;;AR4IA;;;AQ5IA;;;;;;;;;;;AAAA;;;;;;;;;;;;;;;;AZyjBA;;AACA;;;;;;;AAAA;;;;;;;AAAA;;;;;;;;;;AAAA;;;;;;AG5kBA;;AC8JA;;AD9JA;AFyXA;;AA1BA;AAAA;;;;;;;;AACA;AAAA;;AIqoCA;AAAA;;;;;;;AJtoCA;;;;;;;;AACA;;;;;;;AGlMA;;AD9JA;;;;;;AC8JA;;;;;AD9JA;;AC8JA;;AD9JA;AFyXA;;AA1BA;AAAA;;;;;;;;AACA;AAAA;;AIqoCA;AAAA;;;;;;;AJtoCA;;;;;;;;AACA;;;;;;;AGlMA;;AD9JA;;AC8JA;;AD9JA;;AC8JA;;AD9JA;AFyXA;;AA1BA;AAAA;;;;;;;;AACA;AAAA;;AIqoCA;AAAA;;;;;;;AJtoCA;;;;;;;;AACA;;;;;;;AGlMA;;AD9JA;;AC8JA;;AD9JA;;AC8JA;;AD9JA;AFyXA;;AA1BA;AAAA;;;;;;;;AACA;AAAA;;AIqoCA;AAAA;;;;;;;AJtoCA;;;;;;;;AACA;;;;;;;AGlMA;;AD9JA;;AI+8CA;;;AHjzCA;AGizCA;;;;AJ/8CA;;AC8JA;;AD9JA;AFyXA;;AA1BA;AAAA;;;;;;;;AACA;AAAA;;AIqoCA;AAAA;;;;;;;AJtoCA;;;;;;;;AACA;;;;;;;AGlMA;;AD9JA;;AC8JA;;;;;;;;;;;;;;AD9JA;;AC8JA;;AD9JA;AFyXA;;AA1BA;AAAA;;;;;;;;AACA;AAAA;;AIqoCA;AAAA;;;;;;;AJtoCA;;;;;;;;AACA;;;;;;;AGlMA;;AD9JA;;;;AC8JA;;;;;;;;;;;;;;;;AF6iCA;AAAA;AE7iCA;;;;;;;;;;;AD9JA;;;AD2sCA;AE7iCA;AD9JA;;AFyXA;;AA1BA;;AAAA;;;;;;;;;;;AIsoCA;;;;;;AJtoCA;;;;;;AACA;;;;;;;;;;AEhWA;AD4nCA;AAAA;;;;;AE99BA;AAAA;AAAA;;;;;;;;;;;;;;;;;;AF0iCA;;AAPA;AAVA;AAAA;;AA2QA;AIrzCA;;;;;;;AJ++BA;AAAA;AAAA;AAAA;;;;;;;;AAAA;;AA+EA;;;;;;;;AC3sCA;AD4nCA;;AAAA;;AA+EA;AAAA;;AC3sCA;AFyXA;;AA1BA;AAAA;AAAA;AAAA;;;;;;AACA;;AIqoCA;;;;;;;;;;;;;;;;;;;ADv0CA;;;AF89BA;AAAA;AAAA;AAAA;;AE99BA;AD9JA;;AD4nCA;AAAA;AAAA;;;;;;;AD7xBA;;;;;;AIsoCA;AAAA;;;;;;AJtoCA;;;;;;;;;;AACA;AAAA;AAAA;AAAA;;;;;;AGlMA;;AD9JA;AD2sCA;AA/EA;AE99BA;;;;AHiMA;AAAA;;;;;;;;AACA;AAAA;AAAA;;AIqoCA;;;;;;;;;;;;;;;;;;;;ADv0CA;AD9JA;;AD4nCA;AAAA;;;;AA+EA;AE7iCA;AAAA;;AD9JA;AD4nCA;;AA+EA;AAAA;AAAA;AE7iCA;;;;;AHiMA;;;;AACA;;;AIqoCA;;;;;;;AgChPA;AAIA;AF1lCA;AAAA;;;;;;AEunCA;;AnCuSA;;;;AAvaA;;;AAiFA;AEjlCA;AF2iCA;AAAA;AAAA;;AAVA;AAAA;AAAA;;;;;AAoBA;AAYA;;;;;;AiCxjCA;;;;;;;;;;;;;;;;AjC69BA;;;;;;AE99BA;;;AiCwnCA;;;AAXA;;;AF5mCA;;AE+mCA;;;AAQA;;AZv1BA;;;;;;;;;ACvDA;;AACA;;;AAAA;;AxBmvBA;;AwBjvBA;;;;;ASxNA;;;AT6NA;;AAUA;;;;AxBgyBA;AAAA;;AwBvyBA;;;AxBizBA;;AwBjzBA;;;AxBibA;AAwTA;;AA8DA;;;;;;AiC1/BA;AACA;;;;;;;;;;;;;;;;;;ATuLA;;;;;;;ASjMA;;;;;AjCkhDA;AAAA;;;;AAnjBA;;;;;AAkDA;;AAPA;;;;;;;;;;;;;;;;;;;AAgCA;;;;;AiCvjCA;;;AjC8hDA;;AACA;;;AAnjBA;;;;;AAiFA;AEjlCA;AF2iCA;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;ADqEA;;AAAA;;;;;AWtzCA;;;;;;;;;;;;;;AV4qCA;AAAA;AAkFA;;AAYA;AGotDA;;;AAGA;AAEA;;;AA9BA;AAAA;;;;;;AAqCA;;;;;;;;;;;;;;;;;AAEA;AAAA;;;;;;;;AAGA;AAAA;;;AAEA;AACA;;AAx0BA;AG7DA;;;AAsBA;;AA3hEA;;;;;;;;AH2lFA;;;;AGhkBA;;;;;AAAA;;;;;AAzjEA;AA0iEA;AA5gEA;AA6gEA;;;;;;;;;;;;;;;;;ARjoDA;;;;AEwrBA;AAAA;;;;;ADnwBA;AAAA;;;;;;;AAzBA;;AIqoCA;;;;;;;;AJtoCA;;;;;;;;;;;AC6xBA;;AA+EA;ADkSA;AAAA;;AASA;;;;;;;;;;AIgMA;;;;;;;AJnMA;AAAA;AAAA;;;;;;AAGA;;;;;;AAHA;AAAA;;ACvXA;AAAA;;AE99BA;;AH2NA;AAAA;;;AA1BA;;;;;;AACA;;AIqoCA;AAAA;AAAA;;;;;;AJtoCA;;;;;;;AC6xBA;;AA+EA;;;AW+KA;;;;;;;;;;AZ1hCA;;;;;;;;;;;;;;AC22BA;;;AD52BA;AAAA;;;;;;;;AIsoCA;AAAA;;;;;;AJtoCA;;;;;;;;;;AACA;AAAA;AAAA;AAAA;;;;;;AGlMA;;AF89BA;AE99BA;;;;;;;;AHkMA;AAAA;;;AC4xBA;AAAA;;;;;ADnwBA;;AA1BA;AAAA;AAAA;;;;;;AACA;AIqoCA;;;;;;;;AJroCA;;;;;;;;;;AC4xBA;AAAA;AAAA;;AE99BA;;;;;;;;;;;;;;AJ6SA;;AAAA;;;;AG3cA;AD4nCA;;;AA+EA;AE7iCA;;AD9JA;AFyXA;AAAA;AAAA;;AA1BA;;;;;;;;;;;AIsoCA;;;;;;;;;;;;;;;;;;;;;;;ALlqCA;AGnUA;ADiuCA;AAAA;AAAA;AD13BA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;ADlCA;ACwqCA;;AASA;;;;;;;;AD/qCA;;;;;;;AAAA;;;;;;;AAAA;;;;;;AGvUA;;AC8JA;;AD9JA;AFyXA;;AA1BA;AAAA;;;;;;;;AACA;AAAA;;AIqoCA;AAAA;;;;;;;AJtoCA;;;;;;;;AACA;;;;;;;AGlMA;;AD9JA;;;;;;AC8JA;;;;;AD9JA;;AC8JA;;AD9JA;AFyXA;;AA1BA;AAAA;;;;;;;;AACA;AAAA;;AIqoCA;AAAA;;;;;;;AJtoCA;;;;;;;;AACA;;;;;;;AGlMA;;AD9JA;;AC8JA;;AD9JA;;AC8JA;;AD9JA;AFyXA;;AA1BA;;;;;;;;AACA;AAAA;;AIqoCA;AAAA;;;;;;;AJtoCA;;;;;;;;AACA;;;;;;;AGlMA;;;AAAA;;AD9JA;;AC8JA;;AD9JA;AFyXA;;AA1BA;AAAA;;;;;;;;AACA;AAAA;;AIqoCA;AAAA;;;;;;;AJtoCA;;;;;;;;AACA;;;;;;;AGlMA;;AD9JA;;AI+8CA;;;AHjzCA;AGizCA;;;;;;;;;;;AJ/8CA;;AC8JA;;AD9JA;AFyXA;;AA1BA;;;;;;;;AACA;AAAA;;AIqoCA;AAAA;;;;;;;AJtoCA;;;;;;;;AACA;;;;;;;AGlMA;;;AAAA;;AD9JA;;AC8JA;;AD9JA;AFyXA;;AA1BA;AAAA;;;;;;;;AACA;AAAA;;AIqoCA;AAAA;;;;;;;AJtoCA;;;;;;;;AACA;;;;;;;AGlMA;;AD9JA;;;;AC8JA;;;;;;;;;;AHkMA;AAAA;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AEhWA;AD4nCA;AAAA;;;;;;;;;;;;AQzhCA;;AHw3CA;;;;;;AAMA;;;;;;;AH30CA;AG6vCA;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AAqDA;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AL5UA;AAAA;AAAA;AAAA;;;AE99BA;;;;;;;;;;;;;;;;;;;;;;;ACu0CA;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AHzWA;;;AA+EA;;;;;;AE7iCA;AAAA;AAAA;;AD9JA;;AFyXA;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;ACmwBA;AAAA;;AA+EA;AE7iCA;AAAA;;;;AJuYA;AACA;AAAA;;AAAA;;;AAAA;;;;;;;AGtiBA;AD4nCA;;ADnwBA;AA1BA;;;;;;;;;;AIsoCA;;;;;AJtoCA;AAAA;AAAA;AAAA;;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87CA;AW1+CA;AAAA;AHqyBA;;;;;AOwxGA;AAAA;AAAA;AAAA;;;;AhB3mIA;;;;;;;ACwhDA;AW3sCA;ACg5DA;;;AAnBA;AAAA;AZhXA;AAAA;;Acx1DA;;AAzFA;;;;;AAyFA;;;AAzFA;AAyFA;;;AfVA;AYgGA;AACA;AAAA;AAAA;AAAA;AAAA;AXkxDA;AWjxDA;;AZlGA;;;;;;;;;Aa0tEA;;AAAA;;;;;;AbltEA;;;;;;;AYhJA;;;;ACu2EA;;AAAA;;;;;;;;;;;;;;;;AAFA;AGq5DA;AACA;AACA;AADA;AACA;AAFA;AACA;AACA;AAFA;AACA;AACA;AJpiIA;;AACA;;;AZzEA;;Aa6tEA;;;;ADt2EA;AAiNA;;AACA;;AA8CA;;;;AZvHA;;;;;;;;;;;;;;;;AD9JA;ADiuCA;AAAA;AAAA;AD13BA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AD9VA;AEwtCA;AAAA;AAAA;;AuBjjBA;;;;;;;;AOtjBA;;;;;AA+ZA;;;;APuJA;;ADs1BA;;;;;;;AtB1YA;;AI/+BA;AJ0iCA;;AI1iCA;AJygCA;;;AA9UA;;;;;AAAA;;AAmnCA;AAAA;AAAA;;AFh7DA;;;;;AAAA;;;;;AAAA;;;;;;AGXA;;AC8JA;;AD9JA;AFyXA;;AA1BA;AAAA;;;;;;;;AACA;AAAA;;AIqoCA;AAAA;;;;;;;AJtoCA;;;;;;;;AACA;;;;;;;AGlMA;;AD9JA;;;;;;AC8JA;;;;;AD9JA;;AC8JA;;AD9JA;AFyXA;;AA1BA;AAAA;;;;;;;;AACA;AAAA;;AIqoCA;AAAA;;;;;;;AJtoCA;;;;;;;;AACA;;;;;;;AGlMA;;AD9JA;;AC8JA;;AD9JA;;AC8JA;;AD9JA;AFyXA;;AA1BA;AAAA;;;;;;;;AACA;AAAA;;AIqoCA;AAAA;;;;;;;AJtoCA;;;;;;;;AACA;;;;;;;AGlMA;;;AGizCA;;;AHjzCA;AGizCA;;;;;;;;;;;;AkB/xBA;;;;;;;;;;;;;;ArBlhBA;;;;;AD9JA;;AC8JA;;AD9JA;AFyXA;;AA1BA;AAAA;;;;;;;;AACA;AAAA;;AIqoCA;AAAA;;;;;;;AJtoCA;;;;;;;;AACA;;;;;;;AGlMA;;;;;AAAA;;;;;;;;AYwEA;;;;;AACA;AbvOA;;;;;;;AD4nCA;AAAA;;;;;;;;;;;;Acv2BA;AfitCA;AIuMA;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AHjjBA;;;AqBt3BA;;;;;;;;;;;;;ArBs3BA;;;;;;;;;;AAAA;AA+EA;;;;;;;;;;;;AqBl8BA;;;;;;;ArBm3BA;;;;;;;AE99BA;;;;;AD9JA;;AD4nCA;;;AI/+BA;AAAA;;;;;;;;;;AJolCA;;ACjuCA;;;AFivCA;;;;AAGA;;;;;;;AAEA;;AEtvCA;;;AD4nCA;;AA+EA;;;AArDA;;AA9UA;;;;;;;;;;;;;;;;;;;;;;;;;;AG6pBA;;;;;;;;;;;;;;;;;;;;;;;;ADv0CA;;AmB8GA;;;;;;;;;ApB5QA;AD4nCA;AAAA;;AE99BA;;AHiMA;;;;;AIsoCA;;;;;;;;;;;;;;AJroCA;;;;;;;;;;;;;AEhWA;;;AD4nCA;;;;AD7xBA;;;;;AACA;;AIqoCA;;;;;;;AJtoCA;;;AACA;AAAA;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AAAA;;;;;AEhWA;AD4nCA;AA+EA;;;;;;;;;;;;AFhuBA;AAAA;;;;;AG3eA;AD4nCA;;;;;;;AC5nCA;AF+VA;;;;;;;;;;AACA;;;;;;AIqoCA;;;;;;;;;;;;;;;;;AJroCA;;;;;;;;;;;;;;;AC4xBA;AAAA;AAAA;;AAAA;AAAA;;;;;AE99BA;;;;;;;;;AD9JA;;AF+VA;AAAA;AAAA;AAAA;AAAA;AAAA;;;;;;;;;;;;;;AIsoCA;;;AJroCA;;;;;;;AADA;;;;;;;;;;;;;;AACA;;;;;;;;;;;;;;;;;;;;AEhWA;;;AD4nCA;AAAA;AAAA;AAAA;AAAA;;;;;;;;;;AF/oBA;;AIvVA;AAAA;;;AFkjCA;AAAA;;AAPA;AAVA;AAAA;AIzhCA;AJoyCA;AAAA;AAAA;;AFl9BA;;;;;;;;;;;;AE4oBA;;;;;AA+EA;;;;;;ADl1BA;AAAA;;;;AAzBA;AAAA;;;;;;;AADA;;;;;;;;;AACA;;;;;;;;AGlMA;AAAA;;;;;;AGizCA;;;AHjzCA;;AD9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7oBA;AAAA;;;;;AA+EA;AAAA;;;;;;;;;AK4jBA;;;;;AAEA;AAAA;;;;;AL7oBA;AAAA;;AE99BA;AAAA;;;;;;;;;;AFyhCA;AAAA;AIzhCA;AJoyCA;AKsNA;AAAA;;;;;;;;AA+GA;;;AAEA;;;;;;AL7oBA;AAAA;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AM8uBA;;;;;;;;;;;;;;;;;;;;;AJ5sDA;;;;;;;AIu/DA;AA5RA;AAAA;AAAA;;AAAA;AAAA;AAAA;;;AAEA;AAAA;;AA10DA;AA00DA;AAAA;;AAAA;AAAA;AAAA;AACA;;;;;;;;;ANhwBA;AAAA;AAAA;;AE99BA;;;;;AF6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;;;;;AACA;;;;;;;;;;AAHA;;;;;;;;;AAEA;;;;;AL5oBA;AAAA;;;;;;AA0BA;AIx/BA;AJoyCA;AIrzCA;AN7HA;;;;;;;AOsvDA;AACA;AAAA;AAAA;;;;;;;AAEA;AAAA;;;;;;;;AL9jBA;AE7iCA;AAAA;;;;;AGymDA;AAAA;;;;;;AAEA;AAAA;;;;;;;;;;;;AFsVA;AAAA;;;AAAA;AAAA;AHz8BA;AAAA;AAAA;;;;AKygBA;;APhnDA;AAAA;;;;;AOutDA;AAAA;;;AACA;AAAA;;;;;;AAEA;;;;AL9jBA;AE7iCA;AAAA;;;;AGymDA;;;;;AAEA;AAAA;;;;;;AL9jBA;;;AGo5BA;AAAA;;;;ACj8DA;AJoyCA;AIrzCA;AAAA;;;;AN/DA;AAAA;AAAA;;;;;AOyrDA;;;AAEA;AAAA;AAAA;;;;AH3mDA;AAAA;;;;AGymDA;AAAA;;;;AACA;;;AACA;AAAA;AAAA;;AL7oBA;;;;;AA0BA;AAAA;;AIx/BA;;AC0/CA;;;;;;;;;;;;;;;AA+GA;;;;;AAEA;;;AL7oBA;AAAA;;;;;;AE99BA;;;AGwmDA;;;AACA;;AACA;AAAA;;;;AACA;AAAA;;AL7oBA;;;AGm+BA;AAAA;AAAA;;AHz8BA;AIx/BA;ANrDA;;;;;;;AO6pDA;;;;;;;;;;;;;;;;;ANv6CA;;;;;;;;;;;;;;;;;;AC6xBA;AAAA;;AAAA;AAAA;;;AAAA;;;;;;;;;;;;;;AD7xBA;;;;;;AIsoCA;AAAA;;;;;;;;;;;;;;;;;;;;AJroCA;;;;;;;;;;;AGlMA;AAAA;AAAA;;AD9JA;AAAA;AAAA;;AD4nCA;AAAA;;;;;AC5nCA;AD4nCA;;;;;;;AC5nCA;AF+VA;;;;;;;;;;;;;AACA;AAAA;;;;;;;;;;AIqoCA;;;AJtoCA;;;;;;;;;;;;;;;;;;;;;;;;;AGjMA;;;;;;;;AF89BA;AAAA;AAAA;AAAA;AAAA;;;;AA+EA;AAAA;AAAA;AAAA;AAAA;AE7iCA;;;;;;;AD9JA;AD4nCA;AAAA;;AC5nCA;AAAA;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AAAA;AD4nCA;;AAAA;AAAA;;;;;;;;;;;;AAAA;;;AE99BA;AAAA;;;;;;;AHiMA;;;;;;;;;AIsoCA;;;;AJtoCA;AAAA;AAAA;;;;;;;;;;;;;;;;;;;;;;;;;;;AGjMA;AAAA;AAAA;AAAA;;AF89BA;;AA+EA;;;;AFhwBA;;;;AAAA;AAAA;AAAA;;;;;;;;;AG3cA;AAAA;;;AC8JA;;;;;;;AHiMA;;;;;;;;;;AIsoCA;AAAA;;;;;;;;;;;;;;;AJroCA;AAAA;;;;;;;;;AGlMA;AAAA;;;;;;;;AF89BA;AAAA;AAAA;;;;;;;;;AE99BA;AAAA;;AD9JA;AD4nCA;;;;;;;AC5nCA;AF+VA;;;;;;;;;;;;AACA;;;;;;;;AIqoCA;;;;;;;;;;;;;;;;;;;AJroCA;;;;;;;;;;;;;;;;;;;AC4xBA;AAAA;AAAA;AAAA;;;;AC5nCA;AD4nCA;AAAA;;;ADnwBA;AAAA;;AA1BA;;;;;;;;;AIsoCA;;;;;;;;;;;;;;AHzWA;AAAA;;;AA+EA;;;;;;;;AA/EA;;AA+EA;;;;;;AD52BA;AAAA;;;;;;;;;;;;;AAAA;AAAA;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AE/VA;AAAA;AD4nCA;AAAA;AAAA;;AA+EA;AE7iCA;;AD9JA;AFyXA;;AA1BA;AAAA;AAAA;;;;;;;AACA;A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AA;;AAAA;AAAA;;;;;AG6IA;AJ0iCA;;AI1iCA;AAAA;;;;;;;AJ2rBA;;;;ACx0BA;;;AFmvCA;AACA;AIq4BA;AJn4BA;AAAA;AC1HA;AI/+BA;AJygCA;;;;;;;AA9UA;;AAmnCA;AA1tBA;;ACjuCA;;;;;;;AFgWA;AIqoCA;;;;;;;;;;;;;;;;;;;AJroCA;;;;;;;;;AGlMA;;AF89BA;;;;;;;;;;;;ADiXA;AI4oBA;;;;AJnoBA;;;;;AIgMA;;;;;;;;AJnMA;;AsBptCA;AtBulCA;;;;;;;;;;;;;;;;;AsBtlCA;;;;AACA;;;;;;;;;;AAAA;;;;;;ArB21BA;AAkFA;AAAA;AAAA;;;;AAlFA;;;AAAA;;;;;;;;;;;;;;AD5xBA;AIqoCA;;;;;;;;;AJtoCA;;;;;;;;;AC6xBA;;;;;;;;;;ADnwBA;;;;;;;AAzBA;;;;;;;;;;;;;;;;;;;;;;ADtCA;;;AAGA;ACmDA;AACA;AAAA;AIsvDA;AJhjDA;AAAA;AAAA;AAAA;AAsjBA;AAAA;;;;;;AAlRA;;;;AGrsBA;;;;AHssBA;AAAA;AACA;;;;;;;;;AIy1BA;;;;;;AAhKA;AAAA;AAAA;;;;;;;;;;AJpaA;;;;;;;A4BjwBA;A3BqyBA;AIzgCA;AAAA;AAAA;;ANgLA;;;;;;;AI/JA;;AyBsFA;;;;;;AzBtFA;;AyBsFA;;;;;AxB22DA;AAAA;AAAA;;ADz8DA;;;;;;;;;;AFkjCA;AAPA;AAVA;AIzhCA;AAAA;AAAA;;AAAA;AAAA;AAAA;;AAjBA;;ANkLA;;;;;;;;;;;AIjKA;;;;;;;;;AAAA;;;;;;;;;;AD9JA;;AC8JA;;AD9JA;AFyXA;;AA1BA;AAAA;;;;;;;;AACA;AAAA;;AIqoCA;AAAA;;;;;;;AJtoCA;;;;;;;;AACA;;;;;;;AGlMA;;AD9JA;;AI+8CA;;;AHjzCA;AGizCA;;;AJ/8CA;;AC8JA;;AD9JA;AFyXA;;AA1BA;AAAA;;;;;;;;AACA;AAAA;;AIqoCA;AAAA;;;;;;;AJtoCA;;;;;;;;AACA;;;;;;;AGlMA;;AD9JA;;;;AC8JA;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;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4xBA;;;;;;;;AF7mBA;;;;;AAAA;;;AAAA;;AAAA;;;AAAA;;;AAEA;;AAAA;;;;;;;;AEurBA;;;;;;;;;;;;;;;;AE1iCA;;;;;AF89BA;;;;AE99BA;;;;;;;;;;AJuXA;;;;;AAAA;;;;;;;;;;;;AEsrBA;;;;;ADl1BA;;AA1BA;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AGjMA;AD9JA;AD4nCA;AAAA;AAAA;;;;AA+EA;;;;;;;;AAAA;;;;;;;;;;;;AD32BA;;;;;;;;;;;;;;;;;;AAAA;;;;;;;AEhWA;;;;;;;;;;;;;AAAA;;;;;AAAA;;;AF+VA;;AAAA;;;;;;AACA;;;;;;;AADA;;;;;;;;;;;;;;;;;AE/VA;;;AD4nCA;;;;;;;AFhmBA;;;AAAA;;AAAA;;;;;;AAAA;;AAAA;;;;;AItYA;;;;;;;;AFiiCA;;;;AFzpBA;;;;;AE8lBA;;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;;;;;;;;;;;AACA;;;;;;;;AC4xBA;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;Acr4BA;AAAA;AAAA;AACA;AAAA;;AX87CA;;;;;AWj6CA;;;;;AZvHA;AAAA;;;AHs0CA;AA/qBA;AAAA;AAAA;AAAA;;;AIgwBA;;;;;AFrjDA;AAAA;;AAAA;AAAA;AAAA;ADiuCA;ACjuCA;AAAA;AAAA;AAAA;AAAA;AAAA;;;;AFmpCA;;AACA;AIq+BA;AJp+BA;AAAA;;AACA;AAAA;AEtpCA;;;AEwjDA;AAAA;AAAA;AAAA;;;;;;;;;;;;AWl1CA;;;;;;;Ads5BA;;AA+EA;;;;;;;;;;;;;;;;;;;;;AE7iCA;;;;;;;;;;;;;;AGgvCA;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;APzjCA;AAAA;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AGrVA;;;AD4nCA;;;;;;;;;;;;;;AC5nCA;;;;;;;;;;;;;;AF+VA;;;;;;;;;;AACA;;;;;;;;;;;;;;AADA;;;;;;;;;;;;;;;;;;;;AGjMA;AAAA;AAAA;;AD9JA;;;;;;;;;;;;;;;;;;AD2sCA;;AC3sCA;AAAA;;AFyXA;AAAA;AAAA;;AA1BA;AAAA;;;;;;;;;;;;AIsoCA;;;;;;AJtoCA;;;;;;;;;;;;;;AACA;AAAA;AAAA;AAAA;;;;;;;;;;;AC4xBA;AAAA;AAAA;;;;;;;;;AC5nCA;;AD4nCA;;;;;;;;AD7xBA;AAAA;AAAA;;;;;;;;;AIsoCA;AAAA;AAAA;;;;;;;;;;;;;;;;;;AJroCA;AAAA;AAAA;;;;;;;;;;;;AGlMA;AAAA;AAAA;;;;;AF89BA;AAAA;AAAA;;;;;;;;;AK6VA;;;;;;;;;;;;;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;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AHvEA;;AA6pBA;AACA;;AD5gFA;;AI22DA;;;;AWz2DA;;AAzFA;;;;;AAyFA;;;AAzFA;AAyFA;;;AfVA;ACmhFA;AACA;;AD5gFA;;AI22DA;;;AAIA;AADA;;AH6GA;AG1GA;;;;AAr/DA;AA8BA;AAAA;;;;;;;;;;AA29DA;;;;;;;;;;;;;;;;;AAz/DA;;;;;;;;;;;;;AHynFA;;;;AG7mBA;;;;;;;;;;;;;;;AAEA;AN56BA;AAAA;;;;;;;;;;;AM06BA;;;;;;;;;;;;;;;AN16BA;;;;;AM06BA;;;;;;;;;;;;;;AAEA;AN56BA;AAAA;;;;;AA8FA;;;;;;;;;;AAoqEA;AAAA;;;;AAAA;;;;;;AMx1CA;;;;;;;;;;;;AAKA;AACA;AACA;;;;;;;;;;;;;;;;;;AAdA;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AA0CA;AN78BA;AAAA;;AA8DA;AA5BA;AAlWA;;AAkZA;AAYA;;;;;AIpiCA;;;;;;;;;;;;;;;;;;;AJysGA;;;;;;;;;;;;;AM1zCA;AAAA;AAAA;AAAA;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;ANz8BA;AAAA;AA8DA;AAAA;AA5BA;;AA4DA;AAAA;;;;AG2rDA;;AAyBA;;;;;AAzBA;;;;;;;;;AAqCA;AAAA;AAAA;;;;;;;;;;;;;;;;;;AAEA;AAAA;AAAA;;;;;;;;AAEA;AAAA;;AAKA;;;;;AG34FA;AAAA;AAAA;;;;;;AACA;;;;;;;;;;;;;;;;;;;;;;;AAkzDA;;AN/uBA;AA8DA;;AA9XA;;;;;;;;;;;;;;;AYiiBA;AAFA;;;;;ANj0CA;AAAA;AAAA;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;APqUA;AAAA;;;;;;;;;;;;;;;AACA;;;;;;;AC4xBA;AAAA;;;;;AE99BA;;;;;;;;AJrFA;;;;AEmjCA;AAAA;;AA+EA;AE7iCA;;AH2NA;;AA1BA;AAAA;;;;;;;;AACA;AAAA;;AIqoCA;;;;;;;;;;;;;;;;;AJroCA;;;;;;;AGlMA;;AD9JA;;AD4nCA;AAAA;;;;;AE99BA;;;;;AJrFA;;;;;AIqFA;AD9JA;;AFyXA;;AA1BA;AAAA;;;;;;;AACA;;AIqoCA;;;;;;;;AJtoCA;;;;;;;;;;AACA;;;;;;;;;AEhWA;AD4nCA;AAAA;;AA+EA;AE7iCA;;;AJnFA;AAAA;AAAA;AAAA;;;;;;;;AW/HA;;;;;AV2mBA;AAAA;;AAsjBA;AAAA;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AuCppCA;;;;;;;;;;;;AAXA;;;;;;;;;;AACA;;;;AtC+vCA;;;;;;;;;;;;;;;;;AsChvCA;;;AdivBA;;AK3mBA;AN0gBA;;AAAA;;;;;;;;;AACA;AAAA;;;AC7dA;;;;;;;;AAiCA;;;AAEA;;;;;;;;AxBshCA;AE7iCA;;;;;;;AAAA;;;;;;;;;AAAA;;;AoC9LA;AAAA;;;;;;;;;;;AAIA;;;;;;AACA;;;;;;;;;AACA;;;;;AAAA;;;;;;;;;;;;;;;;;AAEA;Af2SA;;;;;;;;ACwfA;;;;;;;;;;;;;AxBiXA;;A0BxkCA;;;;A1BupCA;;;;;AsChuCA;;;;;;;;AZyEA;;A1BwkCA;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AA8DA;AAAA;AAAA;AA5BA;AAlWA;AA8lFA;;AACA;;;;;;;AAAA;;;;;;AAnWA;;AqBpwFA;;;;;AjBvKA;AAAA;;;;;;AJ2rBA;;AAAA;;AAmnCA;;AA/zBA;AA+EA;;;;;;;;;;;;;;;;;;;;;;;;;AG+6BA;AJ/0DA;;;AerDA;;;;;AXi7CA;;AAGA;;;;AcnmDA;;;;;AAyFA;;AAAA;AAAA;;;;;AHuFA;;;Af6uCA;;;;AIuGA;;;;;AWtzCA;;;AZvHA;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;ACygDA;;;;;;AchmDA;;;;;;;;;;AAyFA;;;;;;;;;;AHqHA;;;;;;;;;;;;;Af0EA;;AACA;AAAA;;;;;;AGlMA;;;AHs0CA;;AA/qBA;AAAA;;;;;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AAiJA;AAAA;;AAAA;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AFlSA;AAAA;AAAA;;;;;;;AJtoCA;;;;;;AACA;;;;;;;AGlMA;AF89BA;AAAA;;;;;;AA+EA;AE7iCA;;;;;;;;AM3DA;AAAA;;;;;;;;;;;;;;;;;;;;;;;;;;;ATwwDA;AYvZA;AAAA;;AZwZA;;AAiCA;;AI4OA;AAAA;;AJ3QA;;;AAAA;AAKA;AAAA;AACA;AAAA;;;AYzmBA;AA+GA;;;;;;AR4TA;AQncA;ARmSA;AAAA;AAAA;;;;;;;;;;;;;;;;;;;;AJ2FA;AAAA;AEjnDA;AAAA;AAAA;AAAA;;AFiXA;AAAA;AACA;AIqvDA;AAAA;;;AJl9BA;AIo+BA;AJp+BA;AAAA;;;;;AErpCA;ADiuCA;AAAA;ACjuCA;;;AAAA;AAAA;;AFknDA;AAAA;AAAA;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AkCh8CA;AACA;;A7BXA;;;;;;;;;;;AAAA;;;A6BAA;;;AAWA;;;;;;ADyZA;;;;;;;ACnaA;;;;ADmbA;;;;;;;;;;AATA;AAAA;;;AAAA;;;;;;;;;;;;;;;;;;;;AAIA;;;;;;;;;;;;;;;;;;;AAWA;AAAA;;;;;AAmTA;;;;ACpuBA;;;;;ADyuBA;;;AAIA;;;;AAHA;AACA;;;;;;;;AC5tBA;;;ADkuBA;;;;;;;AAbA;;;;;;;;ACrtBA;;;;;;;A7B1BA;A4BscA;;;;;AAKA;;;;AAkBA;;;AAUA;AACA;;AAAA;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AjC9SA;AAAA;;;;;;;;;;;AAylBA;AI6lBA;;AJ3lBA;;;;;AE37BA;AAAA;AAAA;;AAAA;AAAA;AAAA;;AAAA;;;;;;;AAAA;;AAAA;;;;;AAAA;AAAA;AAAA;AAAA;AEshDA;AAAA;;AAAA;;;;;;;;;;;;;;;;;AJ3lBA;;ACiMA;;;;;;;;;;;;;;;;AD7xBA;AAAA;AAAA;;;;;;;AACA;AEhWA;;AD4nCA;AA+EA;;AD52BA;AAAA;AAAA;;;;;;AACA;AAAA;;AIqoCA;;AJtoCA;;;AC6xBA;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AWpnBA;ARknDA;AJ/0DA;AA+/BA;;AAkBA;;AA/bA;;AAllBA;AAslBA;AAF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CA;AAAA;;AAqMA;AAAA;;;;;;;;;;;AGjaA;;;;AHssBA;AACA;;;AIyrBA;;;;;;;;;AFthDA;AAAA;;;;;;AAAA;AAAA;;AAAA;;;;;;;;;AAAA;;AAAA;;;AAAA;AAAA;;;AEshDA;;AAAA;AAAA;;;;;;;;;;;;;;;;;;;;;AFthDA;AAAA;;;;;;;;;;AD4nCA;AAAA;;;;;;;;;;;;;;;;;;;;;;ADnwBA;;;AA1BA;;;;;;AACA;AAAA;;AC4xBA;AAAA;AAAA;AAAA;;;;;;;;;;;;;;;AD5xBA;;AIqoCA;AAAA;;;;;;;;AJroCA;;;;;;;;;AGlMA;;;AF89BA;;AAAA;;;;;;AKmVA;;;;;;AG52CA;;AHs3CA;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;ANhmCA;;AA1BA;;;;;;;;;;;;;;;;;AAAA;;;;;;;;;;;;;;;;;;;;;;AC6xBA;;;;;AA+EA;;;;;AA/EA;;AE99BA;;;;AHiMA;;;;;AACA;AIqoCA;;;;;AJroCA;;;;;;;;AEhWA;AD4nCA;;;;;AFhhCA;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;ACmPA;AAAA;AAAA;AAAA;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AGjMA;;AAAA;AGizCA;;;;;;;;;;;AkB/xBA;;;;;AvB4cA;AAAA;AAAA;AAAA;AAAA;;;;;AC5nCA;AD4nCA;;;AA+EA;AAAA;AAAA;AE7iCA;;;;;AHiMA;;;;;;;;;;;;AIsoCA;;;;;;;;;;;;;;;;;AJroCA;AAAA;;;;;;;;;AGlMA;AAAA;;AF89BA;AAAA;;;;;;AA+EA;AE7iCA;;;;;;;;;;;AM3DA;AAAA;;AHw3CA;;;;;;;;AHr0CA;;;AGwvCA;;;;;;AP70CA;;;;;;;;;ACqsCA;AAAA;AAAA;AAAA;;;;;;ADjsCA;;;;;AAAA;;;;;;;;;;;AEsoCA;;;ADl1BA;;;;;;;;;AAzBA;;;;;;;;AADA;;;;;;;;;;;;;;;AG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;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AAmsBA;;;;;;;;;;;;;;;;;;AD5xBA;;;AIqoCA;;;;;;AJtoCA;;;;;;;;;;;;;;;;;;;;AGjMA;;;;;;;ADtIA;;;;;;;;;;;;;;;;;;;;;;;;;;;AACA;;;;;;;;;;;;;;;;;;ADisCA;;A6BlQA;;;;;;;;;;;;;A7BoKA;;;;AAAA;AA+EA;;;;;AD52BA;;;;;;;;;;;;;;;;AAAA;;;;;;;;;;;;AC42BA;;;AD52BA;;;;;AACA;AAAA;;;;AIqoCA;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AFr+CA;;AFyXA;;AA1BA;;;;;;;;;;;;;;;AAAA;;;;AACA;;;;;;AGlMA;;;;AF89BA;;;;;;;;;;;;AAAA;;;;;;;ADnwBA;;;;AAzBA;;;;;;;AADA;AAAA;;;;;AACA;;;;;;;;;;AC4xBA;;;;;;;;AA4EA;;;AI1iCA;;;;;;;;;AJ89BA;;;;AAAA;;;AE99BA;;;;;;;AF89BA;;;;;;;;ADnwBA;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;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;;;;;;;;;;;;;;;;;;;;AGl9BA;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AF89BA;AAAA;AAAA;;AE99BA;;;;;;;;;;;AF8vGA;;;;;;;;;;AqB7pGA;;;;;;;;ArB63BA;;AA+EA;AE7iCA;;;AmBiGA;AtBk/BA;AAEA;;AACA;;AACA;AIo4BA;AJp4BA;AAAA;;AACA;;;;AC1HA;;;;;A0B/jCA;;AAAA;;A1B+jCA;;;AA+EA;AE7iCA;AAAA;;;AwBjGA;;AAAA;;;;A1B+jCA;AAAA;;A0B/jCA;;ALoMA;;;;;;AKpMA;ALoMA;AAAA;;;;;;ArB23BA;AAAA;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AAAA;AAAA;AAAA;AAAA;;AA+EA;AE7iCA;;;;;;;;;;;;;;AQvMA;;;;;;;AACA;;;;;;AAAA;AAAA;;AVoqCA;AAAA;AA+EA;AC3sCA;AFyXA;AAAA;;;;;;;;;;AAzBA;;;;;;;;;;;;;AADA;;;;;;;AACA;;;;;;AGlMA;;;;;AAAA;;;;AD9JA;;;AD2sCA;AE7iCA;;;;;;;;;;;;;;;;;;;;;AHkMA;;;;;;;;;;;AEhWA;AD4nCA;;AAAA;;;AE99BA;AAAA;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AJmaA;AAAA;;AAAA;;;;;AGjkBA;;AC8JA;;AD9JA;AFyXA;;AA1BA;AAAA;;;;;;;;AACA;AAAA;;AIqoCA;AAAA;;;;;;;AJtoCA;;;;;;;;AACA;;;;;;;AGlMA;;AD9JA;;;;AC8JA;;;AD9JA;;AC8JA;;AD9JA;AFyXA;;AA1BA;AAAA;;;;;;;;AACA;AAAA;;AIq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;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;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;;;;ACwhDA;AW3uCA;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AhB/SA;AAAA;;;;;AAEA;;;;;AACA;;;;;AAAA;;;;;;;;;AE69BA;;AA+EA;;ADl1BA;;;;AA1BA;;;;;;;;;;AIsoCA;;;;;;;;AJtoCA;AAAA;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AE/VA;;;;;;;;;;;;;;AAAA;AD4nCA;AAAA;AAAA;;AE99BA;;;;AH2NA;AAAA;;;;;;;;;;;;;;;;;;;;;;;;;;;;AA1BA;;;;;AACA;;;;;;;;;;AC4xBA;AE99BA;;;;;AJ4VA;;;;;AAAA;;;;;;;;;;;;;AE6rBA;;;;;;;;AA3DA;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;A+BnrCA;;;;;;;ACsPA;AAAA;AACA;AAAA;AACA;AAIA;AAOA;AAXA;AClHA;AAAA;;AHmCA;;;;;;AAAA;AAAA;;AE4FA;;;AC/HA;;;;;;;AjC4nCA;AE7iCA;;;;;;;;;;;;;;;;;;;;;;AJqGA;;;;;;;;AEw8BA;AE7iCA;AAAA;;AH2NA;;;;;;;;;AAzBA;AAAA;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AEhWA;AD4nCA;AAAA;AAAA;;;;;;AC5nCA;;;AD4nCA;;AA+EA;;;;ADl1BA;;;AA1BA;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;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;;AACA;;;;AGlMA;AH2NA;AAAA;;AA1BA;AAAA;;;AACA;;AAAA;;AAAA;AAAA;;;;AADA;;;;;;;;;AC6xBA;;AqBxhCA;;;;;;;;;;;;;;;;;;;;;;;;;;;;AtB2PA;;;;;;;AACA;;;;;;;;;;;;;;;;;;;AEhWA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AFgXA;AACA;AAAA;AIsvDA;AJhjDA;AAAA;AAAA;;;;;;;AAoSA;;;;AGrsBA;;;;AHssBA;AAAA;AACA;;AAmRA;;;;;;;;;;;AAEA;;;;;;;;AElnCA;;;;;;AAAA;;;;;AAAA;;;;;;;;AC8JA;;;;;;;;;AF89BA;;AAAA;;AA+EA;;AC3sCA;AD4nCA;AE99BA;;AH2NA;;;AA1BA;AAAA;;;;;;;AACA;AAAA;;AIqoCA;AAAA;;;;;;;AJtoCA;AAAA;;;;;;AACA;AAAA;;;;;;;AC4xBA;AE99BA;;AD9JA;;;;AD2sCA;;;AC3sCA;AFyXA;;;;;;;;;;;AI4mCA;;;;;AJtoCA;;;;;;;;;;AACA;AAAA;;;;;;;;;;AEhWA;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AoC7CA;;AAAA;;;;;AAAA;;;AAAA;;;AAHA;;;;;;AAAA;AAAA;AACA;ApC+CA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AoC3CA;;;AtCizCA;AEtwCA;AAAA;AAAA;AAAA;AAAA;AAAA;AoC3CA;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;A1BmjBA;AAAA;AAAA;AAAA;ARknDA;AJ/0DA;AAAA;AA+/BA;;AAnvBA;AAAA;AAuvBA;AAAA;AiByUA;AAAA;AAAA;;AAEA;;AACA;;AbnFA;;;;AAGA;AACA;;;AJ5sCA;;;;AACA;;;;AAqgBA;;;;AAtgBA;AAAA;;AACA;;AGlMA;AH2sBA;AAAA;AAAA;;;;AAoBA;;AAIA;AAFA;;AApCA;;AGrsBA;AHssBA;AAAA;AAAA;AACA;;;;AI6sBA;AACA;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AJ5sCA;AAAA;;;;;;AIsoCA;;;;;;AJtoCA;AAAA;;;;;;;;;;;;;;;;;AC6xBA;;;;;;;;;;ADnwBA;AAAA;;AA1BA;;;;;;;AIsoCA;;;AJtoCA;AAAA;;;;;;;AACA;;;;AGlMA;AF89BA;;AKmVA;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AL66DA;AAGA;AAAA;AAAA;;;;;;;;;;;;;;;;AM5zCA;;;;;;;;;AAziEA;AAAA;AA0iEA;AAAA;;;;;ANx8BA;AA8DA;AA5BA;AAAA;AAAA;AAlWA;;;;AA8ZA;;;;;;;;;;;;;;;;;AAkqEA;AAAA;;AAGA;;;AADA;;;;;;;;;;;AAnrEA;AE7iCA;AAAA;;;;;;;AHmNA;AAAA;;AIsvDA;;AJhjDA;;AAAA;;;;;;AGjaA;;;;;AHusBA;;;;;;;;;AIyrBA;AAAA;AAAA;;;;;;;;AJpaA;;;AKr+BA;AN+RA;;;;;;AI9QA;AJ8QA;;;AE+xBA;;;AF/xBA;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AkC1SA;AA2EA;AAfA;AACA;AACA;AACA;AAIA;AAOA;AAXA;AAAA;;AAAA;AAAA;;AAAA;AAAA;AClHA;AAAA;;AHmCA;;;;;AAAA;;AE4FA;;;AC/HA;;AH2CA;;;;AEsFA;AAAA;AACA;AAAA;;;;;AADA;;;AAIA;;;;;AADA;;;;AACA;;;;;;AAAA;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AJhRA;Ab2kCA;ADjgCA;AAAA;AAEA;AAAA;;;;AZ8IA;Aao3BA;;;;;AD3yBA;;;AA8CA;;AZvHA;;AD9JA;;AC8JA;;AD9JA;AFyXA;;AA1BA;AAAA;;;;;;;;AACA;AAAA;;AIqoCA;AAAA;;;;;;;AJtoCA;;;;;;;;AACA;;;;;;;AGlMA;;AD9JA;;A2B5DA;;;A1B0NA;A0B1NA;;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AAA;;AA8DA;AwBvyBA;;;;AxB2wBA;AwB3wBA;;;;AxBibA;AAwTA;;;;;;;;AiC57BA;AAAA;AAAA;AACA;;;;AALA;;;;;;;;;;;;;;AlCoKA;;;;;;;;AC4xBA;;;;;;;;;;;;;;;;;AAAA;;;AE99BA;;AD9JA;;;;;AF+VA;;;;;;;AACA;;;;;;;;;AADA;;;;;;;;;;AACA;AAAA;;;;;;;;;;;AADA;;;;;;AACA;;;;;;;;;AEhWA;;AD4nCA;;;AA+EA;;;;;AC3sCA;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AD4nCA;;;;AC5nCA;;;;;AF+VA;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AACA;;;AIqoCA;AAAA;;;;;;AJtoCA;;;;;;AGjMA;;;AF89BA;;;;;;;ADjSA;;;;;;;;;;;;;ACiSA;AA+EA;AE7iCA;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AAAA;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AF89BA;;;A6BlNA;;;;;;;;;;ACjZA;AAAA;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;A9By6BA;AIrzCA;AAAA;;ANiHA;;;;AE83BA;AAAA;;;;AA+EA;AE7iCA;;;;AF89BA;AAAA;;;;;;;;;;;;;;;;;;;;;AA2DA;;AIzhCA;AAAA;;;ANmGA;;;;;AE23BA;AAAA;;;;;;;;;;;;;;AM6wBA;;AAj1DA;AAAA;;;;;AACA;;;AAAA;;;;;;AH0lFA;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AQ3oEA;;;AAAA;;;;AZ7NA;;AA+/BA;AAAA;;;;;;;;;;AC9KA;AAAA;A6BpKA;ANxSA;;AOtjBA;;;;;;APsjBA;;;;AOv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;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AGq+BA;AAAA;AsBppEA;;;;;;;;;;;;;;;;;;;;;;;;;;;;AzB+qCA;;AwB/aA;AKzmBA;AN0gBA;AAAA;AAAA;AAAA;ACkGA;;;;;;;;;;;;;;;;;;;;;;AzBhXA;AAAA;;;;;;;;;;AEhWA;;;AD2sCA;;;AC3sCA;AD4nCA;AAAA;;AE99BA;AD9JA;;;;;AF+VA;AAAA;;;;;;;;;;;;;;AACA;AAAA;;;;;;;;;;AC4xBA;;;;;AA+EA;;AA/EA;AAAA;AA+EA;;AC3sCA;AFyXA;;;AA1BA;;;;;;;;;;;;;AAAA;;;;;;;;;AE/VA;AD4nCA;;AE99BA;;;;;;;;AHkMA;AAAA;;;;;;;AGlMA;;;;;;;;;;;AD9JA;AD4nCA;;;;AA+EA;;AC3sCA;AFyXA;;;AA1BA;;;;;;;;AIsoCA;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AHzWA;;;;;;;;;;;;AD5xBA;;;;;;;;;;;;;;;;;;;;;;;AAAA;;;;AC4xBA;;;;;;;;;;;;AC5nCA;AFyXA;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AuB6oCA;AAAA;;;;;;;;;;;;;;AQ7+BA;AAAA;AAAA;;;;;;;;;;AhC8EA;AAAA;AAAA;AAAA;;;AyBlIA;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AflYA;;;;;;;;;;;AH2yCA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AUlaA;;;AAjoBA;AAAA;;AAipBA;;AACA;;AACA;;;;;;;;;;;;;;;AAiBA;ADjgCA;AAAA;;AAEA;;;;AZ8IA;Aao3BA;;;;;;;AD3yBA;;AAAA;AAAA;;;;;;;;;;;;;;;;;;AbvOA;;AC8JA;;AD9JA;AFyXA;;AA1BA;AAAA;;;;;;;;AACA;AAAA;;AIqoCA;AAAA;;;;;;;AJtoCA;;;;;;;;AACA;;;;;;;AGlMA;;AD9JA;;AEymDA;;;AD38CA;AC28CA;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;ADn9CA;AG6vCA;AAAA;;;;AALA;;;;;;;;AA0DA;;;;;;;;;;;;;;AP73BA;;;;;;;;;;;AACA;;;;;;;;;AEgjBA;;AA+EA;;;ADl1BA;;AA1BA;;;;;;AIsoCA;;;AJroCA;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AGlMA;AAAA;;AD9JA;AD4nCA;;;;;;;;AK6VA;;;;;AAQA;;;;AFgoBA;;;;;;AkCtpEA;;ApCgBA;AF2yCA;AAAA;;AAAA;AAAA;AAAA;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AIsrDA;AAAA;AAAA;;;;;AAOA;AAAA;AAz0BA;AAAA;;;;;;AGlkEA;;;;AH2lFA;;;;;;;;;;;;;AGznFA;;;AAi1DA;AAAA;AAAA;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AH8QA;AYiXA;AAAA;AD59EA;AC69EA;AAEA;Ad7+EA;;AC8JA;;AD9JA;AFyXA;;AA1BA;AAAA;;;;;;AACA;AAAA;AI64CA;AJ94CA;;;;AGjMA;;AD9JA;;AC8JA;;Aag1EA;AAAA;ADx9EA;AAAA;AAAA;;;;AZwIA;AYyEA;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;Adq5BA;;;AA+EA;;AA/EA;;;;;AD7xBA;;;;;AIsoCA;;;;;;;;;;;;;ADv0CA;;AF6iCA;;;AGo5BA;;;;;AHx6BA;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;ADv1BA;AAAA;AAAA;;;;;AGlMA;;AF89BA;;;AE99BA;;;;;;AF89BA;AAAA;;;ADnwBA;AAAA;AA1BA;AAAA;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;A0BnYA;AAAA;;;;;;AzBgqCA;;;;;AA+EA;AAAA;AE7iCA;;;;;;AF89BA;A0BlkCA;A1BkkCA;AAAA;AAAA;;AuB5cA;;;AGtnBA;;;;;;;;;ApB6yDA;AACA;AAAA;;;;;;;;;AA90DA;AAAA;AAi1DA;AAnzDA;AAmzDA;AAAA;;;;AN/uBA;AAAA;AAAA;AAAA;;AAkCA;AA0tEA;;;;;;;;;;;AY3hEA;;;;;AN8gBA;;AAAA;;;;;AAGA;AAAA;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AJhtDA;AAAA;;AF89BA;AAAA;AAAA;;;;AAAA;;AE99BA;;;;;;;ACu0CA;AAAA;;;;;;;;;;;;;;;AJroCA;;;;;;;;;;;;;;;;;;;;;;;;;;AC4xBA;;;;;AA+EA;AAAA;;;;;AA/EA;AAAA;;;AC5nCA;;;;AF+VA;AAAA;AAAA;;;;;;;;;;AIsoCA;;;;;;;;;;AFr+CA;;;;;;AD4nCA;;;AE99BA;;;;;;AHiMA;;;;AACA;AIqoCA;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AHpQA;AAAA;AAAA;AI3kCA;AJs+BA;AAAA;AAhUA;AAuwFA;;;;AAzqEA;;;;AApQA;;;AAiFA;;AEjlCA;;;;;;AFkjCA;AAPA;AAVA;;;;AIzhCA;;AAjBA;;AJu7GA;;;;;;;;;;;;AEt6GA;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AkBhCA;Ab8OA;;;;;;;;;;;;;AA6SA;;;;;;;;;;;AFipBA;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AL/FA;;;;;;;AK8QA;;AAEA;;;;;;;;AFsoBA;AkC1pEA;;AlC0pEA;;;;;;;;;;;;;AkCrpEA;AtC0zCA;AAAA;;AAAA;AAAA;;;;;;;;;;;;AA3aA;;AI+0BA;ADphDA;;;ACk5CA;;;AAEA;;;;;;;;;AJn/BA;;;;;;;;;;;;;;;AAsSA;AAmRA;AAEA;;AIybA;;;;;;;;;;AJ3sCA;AAAA;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AI00CA;ADphDA;AAAA;ACmhFA;;AD3gFA;;AI22DA;AAAA;;AH0oBA;;AGpoBA;;;AAr/DA;AAAA;AA8BA;AAAA;AAAA;;AACA;;;;;;;;;;;;;;;;AADA;;;AACA;;;AAAA;;;;;;;;;AA6+DA;;;;;;;;;;AAEA;;AN56BA;AA8DA;;AA5BA;;;;;AAgDA;AAAA;AAYA;;;;;;;;AM40BA;AAAA;;;;;;;;;;;;AN16BA;AAAA;;AA8DA;AAAA;;AA8rEA;;;;;;;;;;;;;;AgCrwFA;AACA;;;;;;;;;;ACpbA;;;;;;;;;;;;;;AP9HA;AAAA;AAAA;AAAA;AAAA;;AAAA;AAAA;;;;;;;AAAA;AAAA;;AAAA;AAAA;;;;;;;;;;;AxB4FA;;;;AM3DA;AAAA;AHw3CA;;;;;;;;;;;;;;;AHr0CA;AAAA;AG6vCA;;;;;;;AALA;AAwCA;;;;;;;;;;;;;;;;;;;;;;;;;;;AL1TA;AAAA;AAAA;;AA+EA;;;AA/EA;;;;;ADnwBA;AAAA;;AA1BA;AAAA;;;AACA;;AIqoCA;;;AJtoCA;;;;;;;;;;;;AGjMA;;AF89BA;;;;;;;;;;;AE99BA;;;;;;;;;;;;;;;;AHkMA;;AIqoCA;;;;AJtoCA;;;;;;;AACA;;;;;;;;AGlMA;AAAA;;AF89BA;AAAA;;;;AA+EA;;;;AC3sCA;AD4nCA;AAAA;;;;;;;;;;;;;;;;;AFh+BA;;;;;AAEA;;;;AACA;;;;;;;;;;;;;;;;;AE69BA;AAAA;;;;;ADnwBA;AAAA;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AA1BA;AAAA;;;;AACA;;;;;;AC4xBA;;;;;;;;;AC5nCA;AFyXA;AA1BA;;;;;;;;;;;;;;;;;;;;;;AC0FA;AAAA;AAAA;AAAA;AAAA;AAAA;;;;;;;;;;;;AgCycA;;;;AClsBA;;ADqsBA;AAAA;AAAA;AAEA;AAFA;;ACptBA;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AlC+KA;AAAA;;;;;;;;;;;AC4xBA;;;AA+EA;;;;AA/EA;AAAA;;;AE99BA;AAAA;;AD9JA;AFyXA;AAAA;;;AA1BA;;;;;;;;;;;;AACA;;;;;;;;;ADmPA;;;;;;;;;;;;AGnlBA;AD4nCA;AA+EA;AE7iCA;AD9JA;AFyXA;AA1BA;AAAA;;;AACA;;;;AADA;AAAA;;;;;;;;;;;;;;;;AoBjZA;;;;;;;AZ8ZA;AAAA;;;;;;AA6SA;;;;;;AAzTA;;;AYlZA;AAAA;;ACgLA;;;Ab2hBA;AAAA;;;AAxDA;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AP2hBA;;;;;;AC5nCA;AD4nCA;AAAA;;AAAA;AAAA;;;AC5nCA;AFyXA;AA1BA;AAAA;;;;;AIsoCA;;;AJtoCA;;;;;AACA;;;;AGlMA;AF89BA;AAAA;;;;;;;;AAAA;AAAA;AAAA;;;;;AC5nCA;AD4nCA;AAAA;;;AE99BA;AAAA;;AH2NA;;AA1BA;;;AAAA;;;;;;;;;AACA;;AIqoCA;AAAA;;;;;;;;;AJtoCA;AAAA;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AACA;AAAA;AAAA;;;;;;;AGlMA;;;;;AAAA;;;;;;;;;;;;;;;AF89BA;;;;;;;;ADnwBA;;AA1BA;;;;;AACA;;AIqoCA;;;;;;;;;;;;;;;;AH1RA;AAAA;AE7iCA;AwBjGA;AAAA;;A1B8oCA;AE7iCA;AAAA;;AwBjGA;;;;;;AFkxBA;;;;AAAA;;;;;;;;;;;;;;;;;AzBxRA;AAAA;;AAAA;AAAA;;;;;;;ACqkBA;AAAA;AAAA;AAAA;AE99BA;;AF89BA;AAAA;AAAA;AAAA;;A0B/jCA;ALsRA;AAAA;;ArBw3BA;;A0B9oCA;;;ALsRA;AAAA;;;;;ArByyBA;AAAA;;AA+EA;AE7iCA;;;;;;;;;;;AF89BA;AAAA;;;;;;;;;;;AAAA;AAAA;AA8FA;AAAA;AGotDA;AAAA;;;AAGA;AAAA;;AAEA;;AALA;;;AAAA;;;;;;AAzBA;AAAA;;AAAA;AAAA;AAAA;;;;;;;;;;AAqCA;AAAA;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AJ1lFA;;;;;;;;;;AC4xBA;;;;;;;AA+EA;;;;;;;AQxmCA;AHq3CA;AAGA;;;;AHr0CA;AGwvCA;;;;;;;;;;;;;;;;;;;;;;;A6BpIA;;;;;;A5B24BA;AACA;AAAA;AH7BA;;;AGhQA;AHgQA;AGhQA;AAAA;AAAA;AAAA;AAAA;;AAx0DA;AAAA;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AN0pCA;AE7iCA;AAAA;;;;;;;;;;AD9JA;AAAA;;AD4nCA;;;;AC5nCA;AFyXA;AAAA;AAAA;;AA1BA;;;;;AACA;AAAA;;;AIqoCA;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AJroCA;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AC4xBA;AE99BA;AF89BA;ADnwBA;AAAA;;;;;;;;;;;AAzBA;;;;;;;;;;;AgBpEA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;;;;;;AAOA;AAAA;;AAEA;AAAA;AAAA;AAAA;;AAgdA;AAAA;AAAA;AAAA;;AACA;AAEA;AAAA;AC8hCA;AAAA;;;AACA;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AlB1jDA;;;;AAAA;;;AACA;AAAA;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AQrMA;AAAA;AAAA;AA8BA;AAAA;AAAA;;AAAA;;;AACA;;AH0lFA;;AGpwBA;;;;;AMljBA;;;;;;;;;;AL5vBA;;AAkOA;AACA;AA3aA;;;AFyrCA;;;;;;;;;;;;;AN5UA;AAAA;;;;;;AWxnCA;ADlMA;;;;;;;;;;;AG2kCA;;AN3uBA;;;;;;;;;;AGhWA;;;;;;;;;;;;;;AAAA;;AAAA;AAAA;;;;;;APkNA;AAAA;;;;;;;;;;;;;;;;AF89BA;AAAA;;AA+EA;AE7iCA;;AD9JA;AAAA;;;;AF+VA;;;;;;;AACA;;;;AIqoCA;;;;;AJtoCA;AAAA;;;;;;AC42BA;AAAA;AE7iCA;;;;;;;AF6iCA;;;ADl1BA;AAAA;;;;;;;;;AAzBA;AAAA;AAAA;;;;;;;;;AADA;;;;;;;;;;;;;;;;;;AOghCA;AAAA;AAAA;;;;AJjtCA;AAAA;AAAA;AI2vCA;;;;;;;;AHyxCA;;;AGn0CA;AAAA;AAAA;AHi0CA;AAAA;;;;;;;;;AuB9mFA;AAAA;AAAA;;;;;;;;;AM46BA;AAAA;;;;;;;;;;;;;;;;;;;A9Bh1BA;;;;;;;AF6iCA;AE7iCA;;;;;;;;AM3DA;AAAA;AAAA;;AHq3CA;;;;;;AASA;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AP54CA;AAAA;AAAA;;AAAA;;;;;;;;;;;;;;;;;;;AE4mCA;AAVA;AA2QA;AF52CA;;;;;AEsiCA;;;;;;;;;;;;AAAA;;;;;;AA+EA;;;;;;;;;AFnnCA;;;;;;;;;;;;;;;;;;;AEoiCA;AA8DA;AAAA;AAAA;;AA9DA;AAAA;AAAA;AAAA;;;;;;;AA8FA;;;;;;AIpiCA;AAAA;;;;;;;;AJssGA;AAAA;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;ADngGA;;;;;;;;;;AAzBA;AAAA;;;;;;;;;AADA;AAAA;AAAA;;;;;;;;;;;;;;;;AE/VA;AD4nCA;AAAA;AAAA;;AKmVA;ALpQA;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AFltBA;;;;;;;;;;;;;;;;AEmoBA;AE99BA;;AD9JA;;;;;;;;AD4nCA;;;;;AA+EA;;AC3sCA;AD4nCA;;AI/+BA;;AJ0iCA;;;;;;;;;;;AA/WA;;AAmnCA;;;AC37DA;;;;;AFmvCA;AACA;AACA;;AACA;;;AC1HA;;AA+EA;;AApBA;;;;;;;;;;;;;AA/WA;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AWhUA;AAAA;ARknDA;;AJh1BA;;AAkBA;;;AA/bA;AAAA;;AAllBA;AAAA;;;;;AAolBA;AApCA;AAAA;;;AI+0BA;AAAA;AAAA;ADphDA;;AHssBA;AAkeA;AAAA;AAAA;AAGA;;;;AAnBA;AAAA;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;ACglEA;AAAA;AAAA;AAAA;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AA7pEA;AD13BA;AAAA;;;;;;;;;AOsoDA;;;;;;AH6IA;;;AG7HA;;;;;;;;A8Br3CA;;;;;;A9Bk3CA;;;;;;;;;;AHkBA;;;;AA8pBA;;;;;;;;;;;;AJ10EA;AAAA;AIqoCA;;;;;AJtoCA;;;;;;;;;;;;;;;;;;;AE/VA;;AC8JA;;;AF89BA;;AE99BA;;;;AHiMA;;;;;;AACA;;;;AIqoCA;;;;;;;;;;;;;;;;AHzWA;;;;;;;;;;;;;;;AA+EA;;;ADl1BA;;;AA1BA;AAAA;;;;;AACA;;;;;AADA;AAAA;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AOsYA;;AA4wCA;;;;;;;;;;;;AAGA;;;;AAOA;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AAtxCA;;AA4wCA;;;;;;;;;;;;AAGA;;;;AAOA;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AAtxCA;;AA4wCA;;;;;;;;;;;;AAGA;;;;AAOA;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AAtxCA;;AA4wCA;;;;;;;;;;;;AAGA;;;;AAOA;;;;;;;;;;;AP3pDA;AAAA;;AIqoCA;AAAA;;;;;AJtoCA;;;;;;;AC6xBA;;AAAA;;;AE99BA;;AAAA;AI2vCA;;;;;;;;;;;;;;;;;;;;;;;AJ3vCA;;AF89BA;;;AE99BA;;AF6iCA;;;;;;;AMsrBA;AACA;;AAGA;AAAA;;;;;AA32DA;AA8BA;;AAAA;;;;AAAA;;;;;;AACA;;;;;;;AAs1DA;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;ANnxBA;;;AAhUA;;AAkZA;;;;;;;;;;;AAirEA;;AADA;;;;AAAA;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AK9lDA;;;AATA;;AACA;AACA;AAAA;AAAA;AAAA;;;;;;AACA;;;;;;;AAIA;AAAA;;;;AAmBA;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AHnpDA;AD9JA;AD4nCA;;;;;;;;;;;;;;;;;;;;;;;;AE99BA;;;;;;AHkMA;AAAA;;;;;;;;;;;;;;;;;;;;AC4xBA;;;;;ADnwBA;;;;;;AAzBA;AAAA;;AIqoCA;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AuB36CA;AAAA;AAAA;;;;;;;;;;A3B+TA;;;;;AA1BA;AAAA;AAAA;;;;;;;;;AACA;;;;;;AEhWA;AAAA;;;;;;;;AFgWA;;;;;;;;AEhWA;AAAA;AAAA;AAAA;AAAA;AAAA;;AAAA;AAAA;AFswCA;AAAA;AsCjzCA;;;;;;;;;;;;;;;;;;;;;AhCozDA;;AL7oBA;AAAA;;;;;AA0BA;AIx/BA;;AAjBA;AC6vCA;AAqRA;;APnqDA;AAAA;;;;AO0wDA;AAAA;;;;;AACA;;;;AAEA;AAAA;AAAA;;;;;;;;;;;;;;;;;AAFA;;;AACA;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AsBphDA;A1BzRA;AF8ZA;;AA1BA;AAAA;;;;;;AACA;AAAA;AAyBA;;AA1BA;AAAA;;AACA;;AGlMA;;AH2NA;;AA1BA;AAAA;;AACA;;AGlMA;;AHiMA;;;;AGjMA;;;AAAA;;;;;AAAA;;;;;;;AHkNA;AACA;AAAA;AIsvDA;AJhjDA;AAAA;AAAA;;;;;;AAoSA;;;;AGrsBA;;;;AHssBA;AAAA;AACA;AAmRA;AIubA;;;;AAGA;AACA;;;;;AJlrCA;;;;AA1BA;;AACA;;AGlMA;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;A8BwIA;AA+MA;AAAA;;;;AAIA;;;;;A7Bi/DA;A6B7rEA;;AAGA;;;;;;;AAMA;AAAA;;;;;AAsMA;;;;;;AAzMA;;AAAA;;;;AAGA;;;AADA;;AACA;;;AADA;AACA;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;A/BtTA;;AD4nCA;;;;;;AA+EA;AE7iCA;AAAA;;;;;;AH2NA;AAAA;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AEzXA;AAAA;;AD2sCA;;;;;;;;;ADsHA;;AA1wBA;;;;AEvjBA;;AAAA;;;AAAA;;;;AAAA;AAAA;;;;;AAAA;AAAA;AewmDA;;;;;;;;;;;;;;;;;;;AjBxwCA;;;;;;;;;AAyBA;;;AA1BA;AAAA;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AC42BA;AE7iCA;AAAA;;;;AF89BA;AAAA;;AC5nCA;;AFyXA;;AA1BA;;;;;;;;AACA;;;;;;;;;;;;;;;;AAAA;;;;;;;;;;;AC4xBA;AAAA;;;AA+EA;AE7iCA;AAAA;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AHkMA;AAAA;;;;;;;;;AC4xBA;AAAA;;;;;;;;;;;;;;;;AK6VA;;AAEA;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AN3nCA;AAAA;;AIqoCA;AAAA;AAAA;;AAAA;AAAA;AAAA;;AAAA;;;;;;;;;;;;AJtoCA;;;;;;;AACA;;;;;;;;;AGlMA;;AD9JA;AAAA;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AAAA;AAAA;AAAA;AAAA;;AAAA;AewmDA;AAAA;;;;;;AjBjjCA;AAAA;;AAxNA;;;AAk+BA;;;;;AEj0CA;AAAA;AAAA;;;;AFyXA;;;;;;;;;;;AO+qDA;AN14BA;;;;AAiuEA;;;;AAAA;;;;AG5uBA;AGvmBA;AACA;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AAdA;AAVA;;;;;;;;;;;;;;;;;;;;;;;;;;;A+B3jEA;;;;;;;;;;AAPA;AAAA;;AAAA;;;;AAAA;AAAA;;;ArCyqCA;AAAA;;;;;;;AqC5qCA;;;AACA;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;A/BkoEA;;;;;;;;;;AIr7DA;;;;;;;;;;;;;AAEA;AAAA;;;;;;;;;;;;;ARFA;;AD9JA;;;AAAA;;AD4nCA;AA+EA;;ADl1BA;;;AA1BA;;;;;AACA;;;AIqoCA;;;;;;AJtoCA;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;ACyhGA;;;;;AA9pEA;;;;;;;AAoqEA;;;;;;;;;;;;;;;;;;;;;AG3uBA;AGvmBA;AAAA;;;;;;;;;;;;;APhtCA;AAAA;AACA;AAAA;;;;;;;;;AIyrBA;;AAAA;AAAA;;;;;;;;;;;;;;;;;;;;;AH3UA;;AG45BA;AJhjDA;;AAAA;AAAA;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AA+vBA;;;;AIgYA;;AAhKA;AAAA;AAAA;;;AJrNA;;AAl+BA;;AAk+BA;;;AAj+BA;;AC4xBA;AAAA;;;;ADnwBA;;;;;AA1BA;;;;;;;;AIsoCA;AAAA;;;;;AHzWA;AAAA;;;;;;;;;;AAAA;;;;;;;ADnwBA;;;;;;;;;;;;;AI4mCA;AAAA;;AJtoCA;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AAAA;;AACA;;AAAA;;AAAA;;AAyBA;;;;;;;;;;AAzBA;;;;;;;AADA;;;;;;;;;;AGjMA;;;AF89BA;;;;;;AAAA;;;;;;;AE99BA;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AHiMA;;;;;;;;;;;;;AC6xBA;AAAA;;AA+EA;;;;;;;;;;AC3sCA;AD4nCA;;AE99BA;;;;;;AHiMA;;;;;;;;;;;AACA;;;;;AEhWA;AD4nCA;;AE99BA;;;;;AF6iCA;;;ADl1BA;;AA1BA;;;;;;;;AACA;;AIqoCA;;;;;;;;;;;;;;;;;ADv0CA;;AF89BA;;;;;;;;;;;;;;;;AD0PA;;AYIA;;;;;;;;;;;;;;;;AVj2CA;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AFuUA;AAAA;;;;;;;;AC4xBA;;;;;;;AFxnBA;AAAA;;AAAA;;AAAA;;;;;;AAAA;AAAA;AAAA;AAAA;;;;AEosBA;AAPA;AAVA;;AIzhCA;;AAjBA;;;;;;;;;AJygCA;;;AKoPA;AAqRA;;;;;AAwGA;AAAA;;;;;;;;;;AL5jBA;AE7iCA;;;;;AG2mDA;;AL7oBA;;;;;AMmPA;AA4CA;AC/zBA;;;;;AAhPA;;;;;;;;;;;;;AJmvDA;AHz8BA;AAAA;AAAA;AIx/BA;AJoyCA;AIrzCA;AC2gDA;AA9QA;AAAA;;APt4CA;;;;AOkwDA;AAAA;;AACA;AAAA;;;;;;;;AL3oBA;AAAA;;;;;;;;;AK0oBA;;;;;;;;;;;;;;;ACmUA;;;AN/4BA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ADtaA;;AE2+BA;AA8DA;;;;;;;;;;;AFniCA;;;AAAA;;AAAA;AAAA;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AOigDA;AAAA;AAAA;;AAOA;;;;;;;;AAwGA;;;;;;AAEA;AAAA;;;;;AL7oBA;AAAA;;;AA+EA;;;;;;;;;;AK4jBA;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AHzmDA;;AD9JA;AD4nCA;AAAA;;;AE99BA;;;AF89BA;AAAA;AA+EA;AE7iCA;;AH2NA;AAAA;;;;;;;;;;;;AC8zBA;AAAA;AAAA;AIzhCA;AJoyCA;AIrzCA;;ANqdA;;;;;AE0hBA;AAAA;;;;AA+EA;AE7iCA;;;;;AF89BA;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AE99BA;AD9JA;AD4nCA;AAAA;;AKmVA;;;;;;ALnVA;AAAA;;ADnwBA;AA1BA;;AAAA;;;;AIsoCA;;;;;;;;;AJtoCA;AAAA;;;;;;;;;;;;AC6xBA;;;;AA+EA;;;AQxmCA;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AN2DA;;AF89BA;AAAA;;;AA+EA;AE7iCA;;AH2NA;;;AA1BA;;;;;AIsoCA;;;;;;;;;;;;;;;;;;AoBv3BA;;;;;;;;AAEA;ACsNA;AAAA;;;;;;AAlpBA;AAFA;;;;;;;;;;;AxB08BA;;;AE99BA;AAAA;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AHyMA;AAAA;AD9VA;AEwtCA;;;;AuBjjBA;;;;;;AOvJA;AAAA;AAAA;;AAAA;;;;;;;;;;;;;;;;;;;;;;;A9B+SA;;;;;;;;;ADzeA;;;;;;;;AACA;;;AIqoCA;AAAA;;;;;AJtoCA;;;;;;;AACA;;;;;;AC4xBA;;AE99BA;;AD9JA;AD4nCA;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AA+EA;;;;;;;;;AQxmCA;AAAA;AHs3CA;AAEA;;;;;;;;;;;;;;;AN+YA;;AACA;;AYvZA;AAAA;;;AZwZA;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AYznBA;;;;;;AXm5CA;AAAA;;;;;;;;AqB1/EA;;;;;;;;;ArBg/BA;;;;;;;;;;;;;;;;;AAAA;;;;;;AGyWA;;;;;;;;;;;;;;;;;;;AJroCA;AAAA;AAAA;;;;;;;;;;AC4xBA;;;AE99BA;;;;AD9JA;AD4nCA;AAAA;AAAA;AE99BA;AD9JA;;AF+VA;;;;;;;;AACA;AAAA;;;;;;;AC22BA;AE7iCA;AAAA;;;;;;;;;;;;AD9JA;AD4nCA;;AE99BA;;;;;;;;;;;AHkMA;;;AADA;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AACA;;;;;;;;;;;;;AC4xBA;AAAA;;;;;AE99BA;AAAA;AAAA;;;;AJwZA;AAAA;AAAA;;;AAAA;;AAAA;AAAA;;;;;AEkpBA;;;AAjBA;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AA3DA;AAAA;AAAA;;;;AE99BA;AAAA;AAAA;;;;;;;;AF89BA;;;ADnwBA;;;AA1BA;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AA0BA;;AA1BA;AAAA;AAAA;;;;;;;;AAAA;;;;AC6xBA;;;;;;;;;AQzhCA;;;;;;;;;;AT6PA;;;;;;;;;;AC4xBA;;;AA+EA;AE7iCA;;;;;;;;;;;;AF89BA;;;;AD7xBA;;;;;;;;AACA;;;;;;;;;;;;;;;;;;;;;ADjJA;AE66BA;AAAA;AAAA;AAAA;AA8DA;AA5BA;AF/8BA;AACA;AE46BA;;AA8DA;;AA5BA;AA4DA;AAqnCA;;;;;AGhPA;ADz8DA;;;;;AFkjCA;AAAA;;;;;;;;;;;;AF5kCA;;;;;;;AE4kCA;;;;;AI1iCA;;AAjBA;;;;;;;AJ++BA;;;AA+EA;;;;;;;;AA/EA;;;AE99BA;;AD9JA;;;;;;;;;;;;;;;;;;;;;;;;AC8JA;;;;AF89BA;;;;;;;;AD7xBA;;;AACA;;;AIqoCA;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AHzWA;;AA8FA;;;;;;;;;;;AA9FA;;;AAAA;;AA+EA;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AC3sCA;;;;AAAA;;AFyXA;;;AA1BA;AAAA;;;;;;;AACA;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AD3OA;;;;;AAAA;;;;;;;;;AGrHA;;;;;;;;AFyXA;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AG3NA;;;;;;;AD9JA;AD4nCA;;AE99BA;AD9JA;AF+VA;;AAAA;AAAA;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AOtSA;AAkzDA;;;;AN/uBA;AAhUA;AA4jFA;;;;;;;;AM91GA;AAAA;AAi1DA;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AR7+CA;ACisCA;AAAA;;;AA/tCA;AEhWA;;AD4nCA;AA+EA;;ADl1BA;;;AA1BA;;;;;AACA;;;AIqoCA;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AHzWA;;;;;;;;;;;;;;;;AK4VA;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;ANznCA;AAAA;;;;;;;;;;;;;;;;AC6xBA;;;;AE99BA;;;;AH2NA;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AEzXA;ADiuCA;AD13BA;;;;;;;;;;;;;;;;;;;ACqxBA;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AMi5BA;AADA;;;AH6GA;;;AG/lEA;AA8BA;AAAA;;;AACA;;AH0lFA;;;;;;AGznFA;;;;;;AA+/DA;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;APzrDA;AAAA;;AIqoCA;;;;;AJtoCA;;;;;;;AACA;;;;;;;;AGlMA;AAAA;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AH2NA;AAAA;AA1BA;;;;;;AACA;;AIqoCA;AAAA;;;;;;;;;;;;;;;AJroCA;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AGlMA;;;;;AF6iCA;;ADl1BA;;AA1BA;;;;AACA;;AIqoCA;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AiC71BA;;;ApBkGA;AAAA;;AV1qBA;AAAA;AAAA;AAAA;;;AAw7DA;;AAKA;AAAA;;;AAAA;;;;;;;;;;;;;AH4qBA;;AAEA;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;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;;;;;;AQxmCA;AAAA;AAAA;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AT4PA;;;;;AACA;;;AIqoCA;;;;;;AJtoCA;;;;;;;;;;;;;AIgwDA;AAAA;AAAA;AHz8BA;AAAA;AIx/BA;AAjBA;;AyB20BA;;;;;;;;A3B1zBA;;;;AGizCA;;;AHjzCA;AGizCA;;;;;;;;;ANtlCA;AAAA;;AA1BA;AAAA;;;;;;;;;;AIsoCA;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AOxhDA;;;;AACA;ADFA;;AV0zCA;;AU1zCA;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AAAA;;;ATgrCA;;AE99BA;AAAA;;;AF89BA;;;;;AE99BA;;;;;;;;;ACq/EA;AGlxBA;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;APliDA;;;AA0BA;AAAA;AAAA;;AAAA;AAAA;;;;;;;;;AAzBA;;AGlMA;;AH2NA;AAAA;;;AA1BA;AAAA;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AC6xBA;AA+EA;AE7iCA;AH2NA;;AA1BA;;;;;;AIsoCA;;;;;;;AJtoCA;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AGjMA;;;AH2NA;;AA1BA;;;;;AACA;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AS7PA;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;APnGA;AAAA;AAAA;AAAA;;AFswCA;;;AAAA;;AEtwCA;;AAAA;AAAA;;AewmDA;;;;;;;;;;;;;;Ab8EA;AAhKA;;AAAA;;;;;;;;;;;;;;;;;;;;;;AJtrCA;;;;;;AC4xBA;;;;;;;;;;;;;AgCz0BA;;;AAAA;;;;AAGA;;AADA;AACA;;AAAA;;;;;;;;;A7B+qCA;;;;;;;;;;;;;;;;;;;;;;;;;AFr+CA;AD4nCA;;;AE99BA;;AD9JA;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AHwgBA;;;;;;;;AEonBA;;AE99BA;;;AHiMA;;AAAA;;;;AACA;AAAA;;;;;;;;AiC4PA;;ACnbA;AAAA;;;ADmbA;;;AC/aA;;AD+aA;;;A5BtbA;A4B8aA;;;;;;AAQA;;;;;;AC/aA;AD0aA;;AAKA;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;ARjaA;;AAGA;;;;;AxB87BA;;;AA+EA;;AwB5gCA;;;;;;;AH8CA;;;;;;;;;;;AAAA;;;;;;;AGzDA;;AAFA;;AxB+iCA;;;;;;AArGA;;;;AE99BA;AF89BA;;AE99BA;AsBwBA;;;;;;;AxBs8BA;AAAA;;;;AE99BA;;;;;;;AqBgdA;;;;;;AACA;;;ACgGA;;AA7jBA;;;;;;;AAiCA;;;;AxBy8BA;;;;;;AAAA;;;;;;;;;;;;AE99BA;;;AD9JA;AFyXA;AAAA;AA1BA;;;;;;AIsoCA;;;;;;;;;;;;;;AAqgCA;AAAA;A6B7rEA;;AAGA;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AhC40BA;;;;AD7xBA;;;;;;;;;AACA;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AGlMA;;AF89BA;AAAA;;;;;AA+EA;AE7iCA;;;AF89BA;AAAA;;;AE99BA;;;;AHiMA;;;;;;;;;;AC6xBA;AE99BA;;AH2NA;;;;;;AAzBA;;;;;;;AADA;;;;;;AACA;;;;;;;;;AGlMA;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AHiMA;;;;;;;;;;AACA;;;AEhWA;;AC8JA;;AD9JA;AHkKA;AACA;AAAA;;;;;;;;;;AC6LA;AAAA;;;;;;;AEhWA;;AD4nCA;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AMt2BA;AAAA;AqBtBA;;;AAAA;;AEiiBA;AAAA;;;;;;A7B2VA;AAkCA;;;;;;;;;;AuB9eA;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AtBhrBA;;;;;;;;AD4nCA;;;ADnwBA;;;;AA1BA;;;;;;;;;;;;;;;;;;AAAA;;;;;;;;AACA;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AAAA;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AC4xBA;;;;;ADiXA;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;ACjXA;;;AE99BA;;;;;;;;;;;AHkMA;;;;AGlMA;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AI2tDA;AAAA;AAAA;;AAx0DA;AAAA;AAAA;AA00DA;AAAA;AAAA;AUlvCA;;;;;;;;;;;;AVjlBA;;;;;;AACA;;;;;;;ACwiBA;AAAA;;;;;AaneA;;;Ab8OA;AAAA;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AP2qCA;AAtTA;AAAA;ACjuCA;AAAA;;AFknDA;;AAAA;;;;;;;;;;;;;;;;AA2RA;;;;;;;;;;;;;;;ACl9CA;AAAA;AgC2UA;AhCzUA;AAAA;AgC4UA;AAAA;AACA;AhCjVA;AAAA;AAAA;AAAA;;;;;;;;;ADzFA;;;;AIqoCA;;;AJtoCA;;;;;;;;;;;;;;AGjMA;;AF89BA;AAAA;;;;;;;;;;;;;;;;AG2aA;AAAA;AAAA;AACA;;;;AAEA;;AJvDA;AAAA;AAAA;;;;;;;;;;;;;;AA57BA;AAAA;AAAA;AAAA;AAsjBA;;;;;AGv9BA;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AJ9FA;;;;;;;AEokCA;;;AA+EA;AE7iCA;;;;;;;;;;;;;;;AM3DA;AAAA;AAAA;AHs3CA;AADA;AAGA;;;AAMA;;;;;AAlGA;AAAA;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AN/gCA;AAAA;AAAA;;;;;AA6vBA;;;;;;;ACeA;AAAA;AAAA;;AE99BA;;AS4tCA;;;;;AZ1hCA;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AGlMA;;;;AF6iCA;;;;;;;;;;AD52BA;;;;;;;;;;;;;;;;;;;AE/VA;AD4nCA;AAAA;AAAA;AAAA;;;AE99BA;;AH2NA;;;;;;;;;AI4mCA;;;;;;AJtoCA;;;;;;;;;;;;;AC6xBA;AAAA;;;AC5nCA;;AFyXA;;AA1BA;;;;;;AIsoCA;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AJ5mCA;AAAA;;AA1BA;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AD3JA;;;AACA;;ACisCA;;;;;ADnsCA;;;;;;;;;;;;;;;;;;;AEqgCA;AAjBA;;AI1iCA;;;;;;;;;;;;;;;;;;;ALmNA;;;AIqoCA;AAAA;;;;;;AJtoCA;;;;;;;AGjMA;AF89BA;;;;;;;;;;;;;;;;;;AF9xBA;;;;;AACA;;;;;;;;;;ACwNA;;;;;;;;;;ACqkBA;;;;;AAhUA;;;;;AA8XA;;;;;AAoBA;;;;;;;;;;;;;;;;;;;;AAirEA;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AsCj7GA;;AAAA;;;;;;AAAA;;;;;AAAA;AACA;;AAAA;;;;AAAA;AACA;;;;;AADA;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AjC0gDA;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;APh/BA;;;;AEmpBA;AAAA;;;AE99BA;;;;AHiMA;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AC6xBA;;;;;AE99BA;;;AF89BA;;;;;;;;;;;;;;;;AFv5BA;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AEs+BA;;;;AA/EA;;AA+EA;;;;ADl1BA;;;AA1BA;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AIi1EA;AACA;AACA;;;ADphFA;;;;;;;;;;;;;;;;;;;;;;AAAA;AD9JA;AD4nCA;AAAA;AAAA;;;;;;;;;;;;;;;;;;;;;;;;;;;;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;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AX6OA;;;;;;;;;AI4mCA;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AHzWA;AAAA;AAAA;;;AE99BA;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AF89BA;AAAA;AAAA;AAAA;AAAA;;AAAA;AAAA;;;;;AA+EA;;;;AFppBA;;;;;AGvjBA;;;;;;;;;;;AEq+CA;AAAA;AAAA;;;;;;;;;;AJroCA;;;;;;;;;;;;;;;AiCiMA;AAAA;AAAA;;AAEA;;AADA;AAAA;;;AACA;;AACA;;;;AAAA;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AhC21FA;AAAA;;;;AMrhDA;;;;;;;;AM7gBA;AAFA;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AZ/NA;;;;AE99BA;AAAA;;;AGwmDA;AAAA;;;;;;;;;;;;;;;;;;;;;;;;AFyVA;;;AHz8BA;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AQnjCA;AAAA;AHs3CA;AAAA;AAAA;;;;;;;AA1FA;AAAA;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;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;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AqBz7BA;;;;AAEA;;;;;;;;;;;;;;;;ArBk1CA;AqB90CA;;;;;;;;;AtBsJA;;;;;;;;;;AIsoCA;AAAA;;;;;;;;;;AHzWA;;;;;ADnwBA;AAAA;;;;;AAzBA;;;AIqoCA;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AFr+CA;AD4nCA;;;;AE99BA;;AH2NA;;;;;;;;;;;AI4mCA;AAAA;;;;;;;;;;;;;;;;;;;;AHzWA;;;;;;;;AA+EA;AC3sCA;;;;AF+VA;;;;;;;;;;;;AO4gDA;AAAA;;AAlzDA;;AAAA;AAAA;AAAA;;;;;;;;;;AAizDA;;;AM/gBA;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AZ/NA;;;;;AA+EA;AAAA;;;;;;;;;;AE7iCA;;;AHiMA;;AAAA;;;;;;AACA;;AAAA;;;;;;;;;;;;;;;;;;;AgB+jEA;AAAA;;;;AbzwEA;;AYhIA;AAAA;AAAA;;ACy4EA;AAAA;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AfxuCA;;AA2QA;;;AFx0CA;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AIoCA;;;;;;;AHkMA;AAAA;;;;;;;;;;;;;;;;;;;;;;;;AC4xBA;;;AAAA;;;;AC5nCA;;;;;;;;;;;;AFgWA;;;AIqoCA;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AJ1oBA;;;;;;;;;;;;ACiSA;;;;;;;;;;;;;;;;;;ADjSA;;;;;;;;;;;;;;;;;;;;;;;;;;;;ADxZA;;AACA;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AO8oCA;AAAA;;AACA;;;;AAGA;AACA;AAAA;;;AAGA;;;;;;;;;AARA;AAAA;;AACA;;;;AAGA;AACA;AAAA;;;AAGA;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AN3vCA;AAAA;;;;;;;;;;;;AACA;AIqoCA;AAAA;;;;;;;;;;;;;;;;;;;;;;;AKl4CA;AHs3CA;AADA;;;AASA;;;;;;;;;;;;AA3CA;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AJt7CA;;AC8JA;;AD9JA;AFyXA;;AA1BA;AAAA;;;;;;AACA;AAAA;AI64CA;AJ94CA;;;;AGjMA;;AD9JA;;;;AC8JA;;;;;;;;;;;;;AGixCA;;;;;AAyBA;;;;AJx8CA;;;;;;;;;;;;;AI+8CA;;AHjzCA;AGizCA;;;;;;;;;;;;;ALnVA;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AD7xBA;AAAA;AAAA;;;;;;AIsoCA;;;;;;;;;;;;;;;;;;AJ5mCA;;;;;;;;AI4mCA;;;;;AJtoCA;;;;;;;;AACA;;;;;;;;;AC4xBA;;;;;;;;;;;;;;;AAAA;;;AAAA;AAAA;;;AC5nCA;AFyXA;;;AA1BA;;;;;;;;;;;;;;;;;;;;;;;AyBiEA;AAAA;ASxOA;;ATyOA;;;;;;;AASA;;AShQA;AAAA;;AASA;;;;;AAVA;;;ATiQA;;;AAAA;;;;;;;;;;;;;;;;;;;;;;;;;AxBktBA;;;;;;;;;;;;;;;AQzhCA;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AT4PA;AAAA;;;;;;;;;;;;;;;;;;AAAA;;;;;;;;AACA;AAAA;;;;;;;;;;;;;;;;;;;;;;AEhWA;AD4nCA;;;;AE99BA;;AF89BA;AAAA;;;;AC5nCA;;AF+VA;AAAA;;;;;;;;;;;;;;;;;;;;;;;AAwNA;AAAA;AAAA;;;;;AAg2BA;;AAAA;;;;;;;;;;;;;;;AI8EA;AAAA;;;;;;;;;;AJroCA;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AC4xBA;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AsBiYA;;;;;;;AAFA;AAEA;;;;AAFA;;;;;;;;;;;;;;;;;;AjBnDA;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;ACgjBA;;;AAEA;;;AAGA;AAAA;;;;;;;;;;;;AP7pDA;AAAA;AAAA;;AIqoCA;;;;;;AJtoCA;;;;;AACA;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AImzEA;;;AGvmBA;;;;;;;;;;;;;;;;;;;;;;AH6EA;AJn+BA;AAAA;AE/rCA;;;AF2ZA;AIqvDA;AJp9BA;AAAA;;AACA;AAAA;AIq+BA;AAAA;;;;;AJn+BA;AIkaA;AAAA;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AG5IA;AHkMA;AAAA;ADh9CA;AI2vCA;;;;AHgnBA;AAuqBA;AAEA;;ADphFA;;AwB5FA;;AAAA;AAAA;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;A3B6RA;AAAA;;;;;AACA;;;;;;;;;;;;;;;AAAA;;;;;;;;;;;;;;AMy6CA;;AL7oBA;AE99BA;;AFw/BA;AAAA;;AA4SA;AIrzCA;;;;ACynDA;;;;AACA;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AShiDA;AAAA;;;AAAA;;AA8CA;;;;;AA9CA;;;;AAAA;AAAA;;AA8CA;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;Ads7BA;AE7iCA;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AkC0eA;;;;A9BxkBA;AU0qBA;AV1qBA;;;;;AA27DA;;;;;;;;AH8qBA;;;;;;;;;;;;;;;AH7iDA;;AA+EA;AAAA;;;ADl1BA;AAAA;;AA1BA;;;;;;;;AACA;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AAAA;AAAA;;AIqoCA;;;;AJtoCA;;;;;;;;;;;;;;;AE/VA;;;;;;;;AKg/DA;;;;;;;AA/7DA;AAAA;;AAAA;AAAA;;;;;;;;A8BulBA;;;;;A9BxkBA;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AN4jCA;AAAA;AA8DA;AAAA;AA5BA;AAlWA;;;;;;AAkZA;AAAA;AIxhCA;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AD+yCA;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AA68CA;AACA;AAEA;;;;;;AAhCA;AAAA;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AJtjFA;AAAA;;;;;;;AACA;AAAA;;AIqoCA;;;;;AJtoCA;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AD+FA;AAAA;;;;;AEmyBA;AAAA;;;;;ADqJA;AAgBA;;;;;;;;;;;;;;;;;;;;;;;AEt4CA;AD4nCA;;AAAA;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AqBlgCA;;AnBoCA;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AF89BA;;;AA+EA;AE7iCA;;;;;;;AD9JA;;;;;;;;;;;AeyoBA;A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E49BA;;;;;;ADnwBA;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;ADpJA;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AQ0qDA;AAAA;;;;;;AAKA;;;;;;;;;;;;;;;;;;;;AHwiCA;AAAA;;;;;;;;;;;;;;;;;;;;;;;;;AErqCA;AAAA;AAAA;AACA;AACA;;;;;AAOA;;;;;;;;;;;;;;;;;;;;;;;;;A2Bh9BA;;;AA7DA;AAAA;;;AAGA;;AAAA;;;;;;;;;;;;;;A9BxnBA;;;;;;;;;AF89BA;;;AA+EA;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AE7iCA;;AF89BA;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AM06BA;AAAA;;;;;;;;AAKA;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AALA;AAAA;;;;;;;;;;AN16BA;;;;;;;;;;AAkwEA;AAAA;;;;;;;AACA;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AM/8DA;;;;;;;AJlxCA;;AD9JA;;AFyXA;AAAA;;;;;;;;;;;;;;;;;;;;;;;;;AMslCA;;;;;;AJ/8CA;;;;AC8JA;;;;;;;;;;AoBnCA;;ACmfA;;;;;;AACA;AACA;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AxBhRA;AAAA;;AIqoCA;;;;;;;;;;;;;;;AkB52CA;AAAA;;;;;;ArBmgCA;AAAA;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AAAA;;;;;;;;AAAA;;AE99BA;;;;;;AHiMA;;;;;;AMw6CA;;AAAA;;AACA;AACA;AAAA;AAAA;;;;;;;;;AD3mDA;;;;;;AiBbA;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AvBoGA;AAAA;ACioCA;ADjoCA;;AAAA;;;;;;;;;;;;;;;;AIvFA;;;;;;;;;;;AHmlCA;;;;;;;;;;;;;;;;;ACrHA;AAAA;;;;;;;;AA+EA;;;;;AWyQA;AAzMA;;;AU9kCA;;;;;;;AtB4LA;;;;;;;;;;;;AI4mCA;;;;;;;;AJtoCA;;;;;;;AA0BA;;;AA1BA;;;;;AACA;AAAA;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AC4xBA;;;AA+EA;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AD32BA;AAAA;AAAA;AAAA;;;;;;AADA;;;;;;;;;;;;;;;;AC6xBA;AAAA;AAAA;;;;;;;;;;;AD5xBA;;;;;;;;;;;;;;;;;;;;;;;;;AADA;AAAA;AAAA;;;;;;;;;;;;;;;;ACy2BA;AAjBA;AIzhCA;AAjBA;ANsCA;;;;;;;;;;;;;;AC6KA;;;;;;;;;;;;;;;;;;;;;;AAyBA;;;AA1BA;;;;;;;;;;AIsoCA;;;;;;;;;;;;;;;;AmB12CA;;ACmfA;;;;;AAEA;ACsNA;;AAAA;;;;;;;;;;;AtBxqBA;AAAA;;AF89BA;AAAA;AA+EA;;AD52BA;AAAA;;;;;;;AC6xBA;AAAA;AAAA;;AE99BA;AD9JA;AFyXA;AA1BA;AAAA;AAAA;;;;;;;AAAA;AAAA;AAAA;;;;;AACA;;;;;;;;;;;;;;;;;;;;;AA4fA;AACA;;AEt4BA;;;;;;;;;AE+jDA;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AErDA;;;;;AAlGA;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;APltCA;AAAA;AAAA;AAAA;AE+8BA;AAAA;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AAAA;;;AA+EA;;ADl1BA;;AA1BA;AAAA;AAAA;;;;;;AC6xBA;;;AA+EA;;;ADl1BA;AAAA;;;;;;;;;;;ACk1BA;AE7iCA;;;;;;;;;ACu0CA;;;;;;;;AJtoCA;;;;;AGjMA;AHiMA;;;;;;AA0gBA;;;;;;;;;;;;;;;AOooCA;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AAgEA;;AAxBA;;;;;;AAAA;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;APltCA;;;;;;;AIovBA;AHhCA;;ACvhDA;;AAAA;AAAA;;AFiXA;;;;;;;AIusCA;;;;;;;;AAHA;;AemtFA;;AAEA;AADA;;AACA;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AnB16HA;;;;;;;;;;;;;;;;AAAA;;AIqoCA;;;;;;;;;;AJroCA;;;;;;;;;;AG1MA;;;;AF2iCA;AAAA;AAVA;;;;;;AEzhCA;AD9JA;AD4nCA;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AE99BA;;;;AF89BA;AA+EA;AE7iCA;;AF89BA;;;;;;;;;;;;;;;;;;;;;;;;;;A0B1jCA;AAAA;;AAAA;;;AAAA;AAAA;;;;;;;;;AvB+hEA;AAAA;AAAA;AAAA;AAAA;AAAA;AkC1pEA;AlC0pEA;AAAA;AAAA;AAAA;AAAA;AAAA;;;;;;;;;ADn8DA;AF89BA;;AE99BA;;ACi8DA;AAAA;;;;;;;;;;;;;;;;;AJ/vDA;;;;;;;;;;;;AAuNA;;;;;AIwiDA;;;;;AHv5BA;;AAPA;AAVA;;AA2QA;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AF93BA;;;;;AACA;AGrkBA;AC8JA;;;;;;;;;;;;;;;;;;;;;;AHkMA;;AAAA;AAAA;AAAA;;AAAA;AGlMA;;;;;;;;;;AHkMA;AAAA;AAAA;AAAA;AAAA;;AGlMA;;;;;;;;;;;AeaA;;AA1FA;;;;;AA0FA;;;AA1FA;AA0FA;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;Ad47DA;;AJp9BA;AACA;;AIq+BA;;AAAA;AJn+BA;AEtpCA;AAAA;;;AEwjDA;;;;;;;;;;;;;;;;;;;;;;;;;;AH5bA;;;;;;AD7xBA;;;;;;;;;;;;;AC6xBA;;;;AA4vEA;;;;;;;;;;AIlsGA;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AL0KA;AAAA;AAAA;;AIqoCA;;;;;;;;;;;AJroCA;;;;;;AC4xBA;;AC5nCA;;AFyXA;;;;;;;;;;;;;;;AEzXA;AAAA;AAAA;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AAAA;AFyXA;AAAA;;AA1BA;AAAA;;;;;;;;;;;;;;;;;AAAA;AAAA;AAAA;;;;;;;;;;;;;;;;;;;AD6OA;;;;;;AAAA;;;;;;;;AAAA;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AE+nBA;AE7iCA;AAAA;;;;;;;;;;;AF6iCA;;;;;;;;AA/EA;AAAA;;;;;ADnwBA;;AA1BA;;;;;;;;;;;;A2B7RA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;;;;;;;;;;;;;;;;;;;;;;;;;;;ARssIA;;;AACA;;AAAA;;;AACA;;AH/hEA;AAAA;;;;;;AiBzmDA;AFoIA;AEnIA;AAAA;;;;AxB/fA;AAAA;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;A+BxGA;;;;;AvCgmCA;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AD0HA;AAAA;AAAA;A4BlgCA;A3Bw4BA;AAAA;;;AE99BA;;;;;;;;;;;;;;AI4sDA;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AW1sDA;AAAA;;;AAAA;;;;;;;;AH1IA;;;;AZwIA;AD9JA;AFyXA;AA1BA;AAAA;;;;;;;;;AAAA;;;;;;;ADqKA;AAAA;AAAA;AAAA;AAAA;AAAA;;;;;;;;;ACpKA;AAAA;;;;;;;;;;;AEhWA;AD4nCA;;;;AE99BA;;AH2NA;AAAA;;;;AA1BA;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AIsoCA;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AYrsCA;;;AAKA;AACA;AAAA;;;AAVA;AAAA;AAAA;;;;;;;;;;;;;;;;;;AZ+4EA;;;AGvnBA;;;;;;;;;;;;ANt5BA;;;AA4BA;;AA5BA;;;;;;;;AIx+BA;;;;;;;;;;;;;;;;AFxBA;;AF89BA;AAAA;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AFpiCA;AAAA;;;;;AEoiCA;;;;;;;AD5xBA;AAAA;AAAA;;AIqoCA;;;;;;;;;;AuBn6CA;AAAA;AAAA;AAAA;AAAA;AAAA;;;;;;;;;AF6wBA;AElxBA;AAAA;;AAAA;AAAA;;A1B+jCA;;;;;;A0B/jCA;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;A1B+1GA;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AsBx6DA;;AAAA;;;ACpiCA;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AvB4qBA;AAAA;;AAkCA;;AA4vEA;;;;;;;;;;;;AA9xEA;;;;;;;;;;AAAA;AAAA;AAAA;;;;;AA+EA;AE7iCA;AAAA;;;;;;;;;;;;;;;;;;;;;AD9JA;AAAA;AFyXA;;AA1BA;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AmB06HA;AAAA;;AJniIA;;;;;AfmJA;;;;;;;;;ACmwBA;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AD5xBA;AAAA;AAAA;;;;;;;;;;;;;;;AADA;;;;;;;;;;;;AAAA;AAAA;AAAA;;;;;;;;;;;;;AKjMA;;AAjBA;AC2gDA;AA9QA;AAAA;;APh4BA;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;ACjJA;;;;;;;;;;;;;;;;AA1BA;;;;;;AE/VA;AFyXA;AAAA;AAAA;AA1BA;;;;;;;;;;;;;;;AGjMA;AD9JA;AD4nCA;AAAA;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;ADrkBA;AAAA;AAuvBA;AAAA;;;;;;;;;;;;;;;;;;;;;;;;;;AClLA;;;;;;;;;;;;;;;;;;;;;;;;;;;AD5xBA;;;;;;;;;;;;;;;;;;;;;;;;;AGlMA;AAAA;;AF89BA;AAAA;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AAqEA;AAVA;AIzhCA;AJoyCA;AAAA;;;;;;;;;;ADlmCA;;;;;AADA;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AA0BA;;AA1BA;;;;AACA;;;;;;;;;;AImzEA;AGjxBA;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;APliDA;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AiCuKA;;;;;;;;;;;AjCxKA;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AGjMA;AAAA;;AD9JA;AF+VA;AAAA;AAAA;;;;;;;;AGjMA;;;AD9JA;AFyXA;;AA1BA;AAAA;AAAA;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AC6xBA;AA+EA;AE7iCA;;;;AH2NA;AA1BA;AAAA;;;;;;;;;;;;AKlNA;;;AJ2rBA;;;;;;;;AE1qBA;;;;;;;;;;AF89BA;;;;;;;AA+EA;AC3sCA;AFyXA;AAAA;AAAA;;AA1BA;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AyBweA;;;;;;;;AxBqTA;AAAA;AAAA;;;;;;;;;;;;;;;;;;;;;;;;AKiUA;;;;;;AAWA;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AJx8CA;AAAA;;;;;AEw/CA;;;;;;;;;;;AFx/CA;;;AD2sCA;AAAA;;;AC3sCA;;AF+VA;;;AAAA;;;;;;;AACA;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AD5QA;;;;;AAAA;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AGpFA;;AD4nCA;;;;;;;;;;AC5nCA;;AD4nCA;;;;;;;;;;;;;;;;;;;;;;AkB6oGA;;AJp/HA;;;;;;;;;;;;;;;;;;;;;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;;;;;;;;;;;;AAAA;AAAA;AIqoCA;AAAA;AAAA;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AHzWA;;AA+EA;;;;;;;;;;;;AKkPA;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AH/xCA;AD9JA;;;;AD2sCA;;;;;;;;;;;;;;;;;;;;;;;;;AKkgBA;AAAA;AAyDA;AAAA;;AACA;AAAA;;;;;;;;;;;;;;;;;;;AHzmDA;AF6iCA;;;;;;;;AAGA;AAAA;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AC9sCA;AD4nCA;;;;;AC5nCA;AD4nCA;AAAA;;;;;AD5xBA;;;;;;;;;;;;;;;;;AAAA;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AEhWA;AD4nCA;AAAA;AAAA;AAAA;;AA+EA;AAAA;;;;;;;;;AG0RA;;;;;;;;;AJtoCA;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AACA;;;;;;;;;;AAAA;;;;;;;;;;;;;;;;AD1IA;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AEs6BA;AAAA;;;;;;;;;;;;;;;;;;;;;;;;;;;;AD7xBA;;;;;;;;;;;;;;AIsoCA;AAAA;AAAA;AAAA;;;;;AJtoCA;;;;;;;;;;;;;;;;;;;;;;;;AGjMA;;;AF89BA;AAAA;AAAA;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AKiUA;;;;;AAWA;;;;;;;;;;;;;;;;;AJx8CA;AD4nCA;;;;;;;;AE99BA;AAAA;AAAA;;;;;;AHiMA;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AAAA;AAAA;AAAA;AAAA;;;;;;AACA;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AC4xBA;;;;;;;;;;;AKmVA;;;;;;;;;;;;;;;AmB5xCA;AxB8iCA;AArGA;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AC5nCA;AAAA;;;;;AAAA;AFiXA;AAAA;;AACA;;;;AAo5BA;AAAA;AAAA;AAAA;;AAAA;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AAv6BA;;;;;;;;;;;;;;;AACA;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AM+hCA;;;;;;AAoBA;;;;;;;;Aas3FA;AAAA;AACA;AAAA;;AAFA;AACA;;AnB77GA;;;;;;;;ACsnBA;AIrzCA;AAAA;;ANsEA;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AIrDA;AAAA;;;;;;AAAA;AAAA;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AaqwEA;;AAAA;AACA;;;;;;;;;;AhBrkEA;;;;;;;AACA;;;;;;;;;AC4xBA;AAAA;;;;;;AD7xBA;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;ADvKA;AAEA;;;;;;;;;;;;;;;;AAIA;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AE87BA;AAAA;AAAA;AAAA;;AE99BA;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AoCrMA;;AAAA;;;;;AAAA;;;AAAA;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AtCs6GA;;AADA;;;;;;;;;AK/8DA;;;;;;;;;;;;;ALpOA;AE7iCA;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AF89BA;AA+EA;;AC3sCA;;AD4nCA;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AAAA;AAAA;;AE99BA;;;;;;;;;ACygDA;;;AAGA;AWp7CA;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;Af0GA;AAAA;;AIqoCA;;;;;;;AJtoCA;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AAAA;;;;;;;;;;;;;AE/VA;;AD4nCA;;AA+EA;;;;;AA/EA;;;;;;AApTA;;;AAmnCA;;;;;;;;;;;AAhgDA;AwB2GA;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;ArB+7BA;AAAA;;;;;;;;;;;AkCz9CA;;;;;;ArCg3GA;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AK/7DA;;;AH/xCA;;;;;;;;;;;;;AwB1GA;AAAA;;AxB0GA;;AwB1GA;AAAA;;;;;;;;;;;;;;;;;;;;;;;;;;;;AzBpDA;AD4nCA;;AA+EA;;;ADl1BA;AAAA;;AA1BA;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AKlNA;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AJivGA;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;ADrgGA;;;;;;AAzBA;;AIqoCA;;;;;;;;;;;;;;;;;;;;;;;;;;AH1RA;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AwB/gCA;AAEA;;;;;;;;;;;;;;;ADibA;AACA;;;;;;;;;;;;;;;;AvB2yFA;;;;;;;;;;;;;;;;;;;;;;;;AqB3qGA;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AEqPA;;;;;;;;;;;;;;;;AxBtIA;AAAA;AAAA;;;;;;;;;;;;AACA;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AGlMA;AF89BA;;AA+EA;;;;;;;;;;;;;;;;;;;;;;;;;AF5xBA;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;A4B3XA;AAAA;;AxB0GA;;AwB1GA;;;;;;;A3BsvCA;;AAkBA;;;;AAjhCA;;AAAA;;;AAslBA;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AAliBA;;;;;;AACA;;;;;;;;;;;;;;;;;;;;A2BtSA;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;A3BsSA;;;;;;;;;;;;;AEzYA;;AF0ZA;;;AACA;AIqvDA;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AW7oDA;;AACA;;AEuyCA;;;;;;;;;ATtqCA;Aa9dA;Ab8OA;;;;;;;;AL9MA;;;;AF89BA;;;;;;;;;;;;;;;;;;;;AD7xBA;AAAA;;;;;;;;;;;;;;;;;;;;;;;;;;;AA6fA;AACA;;;;;;;;;;;;;;AAFA;;;;;;;;;;;;;;;;AD3nBA;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AC+HA;AAAA;AAAA;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AGjMA;;;;;;;;;;;;;;;;;;;;;;;;AF6iCA;;;AA/EA;;;;;;;;;;;;;;;;;AwBtTA;AAprBA;;;;;;;;AAAA;;;;;;;AFvBA;ACmfA;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AxB9QA;;AIqoCA;;;;AJtoCA;;;;AGjMA;;;AF89BA;AAAA;AAAA;;;;;;;;;;;;;;;;;;;;;;AE99BA;;AD9JA;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AE0qDA;;;;;;;;ALjjDA;;;;;;;;;;;;;;;;ACsOA;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AAAA;;;;;;;;;AyB+eA;AAFA;;;;;;;;AxBgTA;;;;;;;;AAAA;;;;;;;;;;;;;;;;;;;;A6B3VA;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AvBhvBA;AAAA;AAAA;AAAA;AHwkEA;;;;;;;;;;;;;;;;;;;;;;;;;AJzxDA;;;;;;;;;;;;;;;;;;;;;;;;;AC4xBA;AA+EA;;;;;;;AAjBA;AAgCA;;;;;;;;;;;;;;;;;;;;;AE5jCA;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AIq6DA;;;;;;ANl2BA;AD13BA;;;;;;;;;;;;;;;;;;;;;;;;;;AOugDA;ANlvBA;AA8DA;;;;;AA9DA;;;;;;;AM+uBA;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;APrtBA;;AEtpCA;;ADuhDA;;;;;;;;;;;;;;;;AFvqCA;;;;;AAAA;;;;;AAAA;;;ACAA;;;;;;;;AAhBA;AAAA;;;;AADA;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AC6xBA;AAAA;AAAA;;;;AGyWA;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AFr+CA;;;;;;;;;;;;AI67CA;AAAA;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AG11CA;;AHs3CA;AADA;;;;;;AL5VA;AAAA;AAAA;;AA+EA;AAAA;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AA/EA;AA+EA;;;;;AD52BA;;;;;;;AACA;;;;;;;;;AO6oDA;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AP7oDA;;;;;;;;;;;AAAA;;;;;;;;;;;;;;;;;;;;;;;;;;;;AGlMA;;AF89BA;;;;;;;;;AC5nCA;AD4nCA;;;AC5nCA;;;AD4nCA;;;;;;;;;;;;;;;;;;;;;AM+uBA;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AJ7sDA;AGizCA;;;;;;;;;;;;;AN/mCA;;;;;;;;;;;ACi4BA;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;Ae57BA;AACA;;AAAA;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AhBmFA;;;AA1BA;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AC6xBA;AAAA;;;;;;;AD7xBA;AAAA;AAAA;AAAA;AAAA;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AAuoCA;;;;;;;;;;;;;;;;;;;;;;AD7nCA;;ACstCA;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AchmDA;;;;AAAA;;;;;;;;;;;;Ad0ZA;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AI4mCA;;;;;;AJ5mCA;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;ACmwBA;;;;;;AAAA;;AE99BA;;AD9JA;AFyXA;;;;;;;;;;;;;AA1BA;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AE/VA;;;;;;AD2sCA;;;;;AE7iCA;;;AF89BA;AAAA;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AEt+BA;AG6vCA;AA4BA;;;;;AHzxCA;AG6vCA;AA4BA;;;;;AHzxCA;AG6vCA;AA4BA;;;;;;;;AQz9CA;;;;AAAA;;;;;;;;;;;;;;;;;;;;;;;AXgMA;AG6vCA;AA4BA;;;;AHzxCA;AGyxCA;;;;AAjCA;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;APhzBA;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AG9iBA;AD4kCA;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AK+VA;;;;;AAAA;;;;;AAAA;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AAAA;;;;;;;ANlmCA;;;AA1BA;;;;;;;;;AAAA;;AAAA;;;;;;;;AACA;;;;;;;;AGlMA;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AHkMA;AAAA;AAAA;AAAA;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AC4xBA;AAAA;AAAA;AAAA;;;;;;;;;;;;;;;;;;;;;;;;;AAgyEA;AAAA;;;;;;;;AAhyEA;;;;;;AEt+BA;AG6vCA;AA4BA;;;;;AHzxCA;AG6vCA;AA4BA;;;;;AHzxCA;AG6vCA;AA4BA;;;;;AHzxCA;AG6vCA;AA4BA;;;;;AHzxCA;AG6vCA;AA4BA;;;;;AHzxCA;AG6vCA;AA4BA;;;;;AHzxCA;AG6vCA;AA4BA;;;;;AHzxCA;AG6vCA;AA4BA;;;;;AHzxCA;AG6vCA;AA4BA;;;;;AHzxCA;AG6vCA;AA4BA;;;;;AHzxCA;AG6vCA;AA4BA;;;;;AHzxCA;AG6vCA;AA4BA;;;;;AHzxCA;AG6vCA;AA4BA;;;;;AHzxCA;AG6vCA;AA4BA;;;;;AHzxCA;AG6vCA;AA4BA;;;;;AHzxCA;AG6vCA;AA4BA;;;;;AHzxCA;AG6vCA;AA4BA;;;;;AHzxCA;AG6vCA;AA4BA;;;;;AHzxCA;AG6vCA;AA4BA;;;;;AHzxCA;AG6vCA;AA4BA;;;;;AHzxCA;AG6vCA;AA4BA;;;;;AHzxCA;AG6vCA;AA4BA;;;;;AHzxCA;AG6vCA;AA4BA;;;;;AFsDA;AAAA;;;;;AH1RA;AE7iCA;;;;;;;;;;;;;AARA;AG6vCA;AA4BA;;;;;AHzxCA;AG6vCA;AA4BA;;;;;AHzxCA;AG6vCA;AA4BA;;;;;AHzxCA;AG6vCA;AA4BA;;;;;AHzxCA;AG6vCA;AA4BA;;;;;AHzxCA;AG6vCA;AA4BA;;;;;AHzxCA;AG6vCA;AA4BA;;;;;AHzxCA;AG6vCA;AA4BA;;;;;AHzxCA;AG6vCA;AA4BA;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AHjxCA;AAAA;;;;;;;AFguGA;AAAA;AAAA;;;;;;;;;;;;;;;;AqC34GA;AAAA;;;;;;;;;;;;;;;;A/BqjEA;;;;;AApJA;AAAA;;AMvjBA;;;;;;;;;;;;;;;AN8sBA;AAAA;;;;;;;AN/6BA;AAAA;;;;;;;;;;;;;;;;;;;;;;;;;;;;AE99BA;;;;;;;AF89BA;;AA+EA;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AOlzBA;;;;;;;;;AT5ZA;AACA;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AE2bA;;;;;AAAA;;;AAAA;;;;;AK+tCA;AAAA;AAOA;;;;;;;;;;;;;;;;;;AApMA;;;;;AAAA;;;;;AAAA;;;;;AAAA;;;;;AAAA;;;;;AAAA;;;;;AAAA;;;;;AAAA;;;;;AAAA;;;;;AAAA;;;;;AAAA;;;;;AAAA;;;;;AAAA;;;;;AAAA;;;;;AAAA;;;;;AAAA;;;;;AAAA;;;;;AAAA;;;;;AAAA;;;;;AAAA;;;;;AAAA;;;;;AAAA;;;;;AAAA;;;;;;;;;;;;;;;;;;AAAA;;;;;AAAA;;;;;AAAA;;;;;AAAA;;;;;AAAA;;;;;AAAA;;;;;AAAA;;;;;AAAA;;;;;AAAA;;;;;;;;;;;;;;AJ39CA;;;;;;AFkXA;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AAlBA;;;;;;;;;;;;;;;;;;;;;;;;;;AgBuzDA;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AVxxBA;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;ALpLA;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AA/EA;AAAA;;;;;;;;AKuRA;AA4BA;;;;;;;;;;;;;;;;;;;;;ACr5CA;;;;;;ANirCA;AE7iCA;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AF89BA;;;;;;;;;;AGyWA;;;;;;;;AL70CA;;;;;;;;;AKk+DA;AJ/0DA;;;;;AMmmCA;;;;;;AAAA;;;;;;AAAA;;;;;;;;;;;;;;;;;;;;;;;;;;;ALlRA;;;;;;;;;;;;;A0BlkCA;;;;;;;;;;;;;AAAA;;;;;;;;;;;;;;;;;ArBo1CA;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AF0KA;;;;;;AFxjDA;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AD4nCA;;;;;;;;AC5nCA;;;;;;;;;AH6KA;AE8hCA;;;;;;;;;;;;;;ADh6BA;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AAqDA;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AAAA;;;;AGlMA;;;;;;;;;;;;;;;AHiMA;;;;;;;;;AC6xBA;AAAA;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AA8DA;AA5BA;;;;;;;;;;;;;;;;;;;;;;;AA6CA;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AqBllCA;;;;;;ArBmgCA;;;;;;AD5xBA;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;Ae3EA;;;;;;Af2EA;;;;;;AAyBA;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AMqhCA;;;;;;AAAA;;;;;;AAAA;;;;;;AAAA;;;;;;AAAA;;;;;;AAAA;;;;;;AAAA;;;;;;AAAA;;;;;;AAAA;;;;;;AAAA;;;;;;AAAA;;;;;;AAAA;;;;;;AAAA;;;;;;AAAA;;;;;;AAAA;;;;;;AAAA;;;;;;AAAA;;;;;;AAAA;;;;;;AAAA;;;;;;AAAA;;;;;;AAAA;;;;;;AAAA;;;;;;AAAA;;;;;;;;;;;;;;;;ANv1BA;AAAA;;;;;;;;;;;;;AAyjBA;AIubA;;;;;;;;;;;;;AH3aA;;;;;;;;;;;;;;;;;;AD5xBA;;;;;;AM8iCA;;;;;;AAAA;;;;;;AAAA;;;;;;AAAA;;;;;;AAAA;;;;;;AAAA;;;;;;AAAA;;;;;;AAAA;;;;;;AAAA;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AJ94CA;AAAA;;;;;;;;;;;;;;;;;;;;;;;;AKo5DA;AMvjBA;;;;;Ab9/BA;;;;;;;;;;;;;;;;;;;ADvQA;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AGxFA;;;;;;AFyXA;;;;;;ACmwBA;;;;;;AD7xBA;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AACA;AAAA;;;;;;;AAAA;;;;;;;;;AA2fA;;;;;;;;;AAleA;;;;;;AA1BA;;AAAA;;;;;;;;;;;;AAAA;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AGjMA;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AS0WA;;AAAA;;;;;;;AG5CA;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AdgqBA;;;;;;AAkCA;;AA0tEA;;AA1qEA;;;;;;;;AAirEA;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AC/3GA;;;;;;;;;;;;;;;AC8JA;;;;;AAAA;;;;;AAAA;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AAAA;;;;;;;;AG2mDA;;AAAA;;;;;;;;;;;;;;ALj8BA;;;;;;;;;;;;;;;;ADzeA;;;;;AsB3OA;AAAA;;;;;ApBpHA;;;;;;;AEujDA;;AFvjDA;;ADiuCA;;;;;;AgBxlBA;;AjBsPA;;;;;;;AiCzIA;AAEA;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;A7BssEA;;;;;;AGztEA;;;;;;;;;;;;A+B/vBA;;;;;;;;;;;;ArCovCA;;;;;;;AD33BA;AAAA;;;;;;;;;;;;;;;;;;;;;;;;;;AiCzDA;AAAA;;;;;;AhCslGA;;;;;;;;;;;;;;;;;;ADz4DA;;;;;;;;;;;;;;;;;;;;;;;;;;ACvXA;;;;;;AGuhDA;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AHvhDA;AAAA;;;;;;AD7xBA;;;;;;;;;;;;AMgnCA;;;;;;;;;;;;;;;;;;;ALnVA;AAAA;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AE99BA;;;;;;;AI23DA;;;;;;;;;;;;;;;;;;;;;;;;AN75BA;;;;;;;;;;;;;;;;;;;;;;;AD5xBA;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AGlMA;;;;ACu0CA;AAAA;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AFr+CA;;AF+VA;;;;;;;;;;;;;;;;;AGjMA;;;;;AAAA;;;;;AAAA;;;;;AAAA;;;;;AAAA;;;;;AAAA;;;;;AAAA;;;;;AAAA;;;;;AAAA;;;;;AAAA;;;;;AAAA;;;;;AAAA;;;;;AAAA;;;;;AAAA;;;;;AAAA;;;;;AAAA;;;;;AAAA;;;;;AAAA;;;;;AAAA;;;;;AAAA;;;;;AAAA;;;;;AAAA;;;;;AAAA;;;;;AGm0CA;;;;AAAA;;;;AAAA;;;;AAAA;;;;;;;;ANloCA;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AGjMA;;;;;AAAA;;;;;AAAA;;;;;AAAA;;;;;AAAA;;;;;AAAA;;;;;AAAA;;;;;AAAA;;;;;AAAA;;;;;;;;AHiMA;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AMgiCA;;;;;AAAA;;;;;AAAA;;;;;;;;;AFsGA;;;;;;;;;;;;;;;;;;AEtGA;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AN/hCA;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AM8iCA;AA+CA;;;;;;AH/xCA;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AItGA;AA6gEA;;;;;;AHy2BA;AAAA;;;;;;;;;;;;;;AkCl9FA;;;;;;;;;;;;;;;;;;;;;;;AvCgOA;;;;;;;;;;;;;AmCKA;AD4bA;;;;;;;;;;;;;AhC+fA;AA+EA;;;;;;;;;;ADppBA;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;ACqkBA;;;;AG8zDA;;;;AArCA;;;;;;;;;;;;AJx6CA;;;;AAvGA;;;;;;;AkBtuCA;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;ANmlCA;;;;;;;;;;;;;AZn5BA;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AC4xBA;AA8FA;;;;;;;;;;;;;;;;;;;;;;AD33BA;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AC6xBA;;;A0B/jCA;AAAA;;;;;;;;;;;;;;;;;;ArBo6CA;;;;AAAA;;;;AAAA;;;;AAAA;;;;AAAA;;;;AAAA;;;;AAAA;;;;AAAA;;;;AAAA;;;;AAAA;;;;AAAA;;;;AAAA;;;;AAAA;;;;AAAA;;;;AAAA;;;;AAAA;;;;AAAA;;;;AAAA;;;;AAAA;;;;AAAA;;;;AAAA;;;;AAAA;;;;AAAA;;;;AAAA;;;;AAAA;;;;AAAA;;;;AAAA;;;;AAAA;;;;AAAA;;;;AAAA;;;;AAAA;;;;;;;;;;;;;;;;;;;;;ANjoCA;;;;;;;;;AC4xBA;;;;AA+EA;AE7iCA;;;;;;;;;;;;;;;AGm0CA;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;ANloCA;;;;;;;;;;;;;;;;;AA0BA;;;;AEzXA;AD4nCA;;;;;;;;;;;AKmQA;;;;;AAAA;;;;;AAAA;;;;;AAAA;;;;;AAAA;;;;;AAAA;;;;;AAAA;;;;;AAAA;;;;;AAAA;;;;;AAAA;;;;;AAAA;;;;;AAAA;;;;;AAAA;;;;;AAAA;;;;;AAAA;;;;;AAAA;;;;;AAAA;;;;;AAAA;;;;;AAAA;;;;;AAAA;;;;;AAAA;;;;;AAAA;;;;;AAAA;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;ALpLA;;;;;;;;;;;;;AqBvlCA;;;;;AtBqQA;;;;;;AMsgCA;;;;;AAAA;;;;;AAAA;;;;;AAAA;;;;;AAAA;;;;;AAAA;;;;;AAAA;;;;;AAAA;;;;;AAAA;;;;;;;;;;;;;;;;;;;;;;;;;;;;;ANuGA;;;;;;;;;;;;;;;AC1WA;;;;;;AAAA;;;;;AGyWA;;;;;AJroCA;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AADA;;;;;;;;;;;;;;AACA;;;;;;;;AADA;;;;AIsoCA;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AJroCA;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AMy6CA;;;;;AChtDA;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;ANkpCA;;;;;;;;;;;;;;;;;;AA/EA;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;ADrkBA;;;;;;;;;AGzZA;;;;;;;AJsCA;;;;;AA+KA;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;ACkyBA;;;;;AIgVA;;;;;AHzWA;;;;;Aa1pCA;;;;;;;;;;;;;;;;;;;;Ad8XA;;;;AC22BA;AE7iCA;;;;AF6iCA;AE7iCA;;;;AHkMA;;;;;;;;;;;;;;;;;AC4xBA;;;;AF7gCA;;;;;;;;;;;;;;;;;;;;;;;;AKs3CA;;;;;;;;;;;AJtoCA;;;;;;;;;;;AyBueA;AAAA;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AvBt0BA;AFyXA;;;;;;;;;;;AG3NA;;;;;;;AHiMA;;;;;;;;;;;AC6xBA;;;;;;;;;;;;;AD7xBA;;;;;AA0BA;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AAzBA;AAAA;;;;;ADvOA;;;;;;;;;AEmgCA;AAAA;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AAAA;;;;;;;;AD5xBA;;;;;;;;;;;;;;;;;;;;;;;;;;;;AGlMA;;;;;;;;AHiMA;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AIsoCA;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AAAA;;;;;;;;AL5zCA;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AGvIA;AAAA;;;;;;;;;;;AD4nCA;AAlWA;;;;;;AA+YA;;;;;;;;;;AD52BA;AAAA;;;;;;;;;;;AGjMA;AH2NA;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AAAA;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AStRA;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AN2DA;;;;;;;;;;;;;;;;;;;;;;;;;;;;AF89BA;AAAA;;;;;;;;;;;;AD7xBA;AAAA;;;;;AC6xBA;AAAA;;;;;;;;;;;;;;;;;;;;;;;;;;;ADnwBA;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AWnaA;;;;;AT0CA;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AFgWA;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;ADnJA;;;;;;;;;;;AQ6pDA;;;;;AHrYA;;;;;;AHzWA;AAAA;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AA+EA;;;;;;AG0RA;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AJtoCA;AAAA;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AyB7MA;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AzBqaA;;;;;;;;;;;;;;;;;;;;;;;;;;;;AAxNA;;;;;;;;;;AAiBA;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AQySA;;;;;;AF4oCA;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AA5BA;;;;;;;;;;;;;;;;;;;;AJzwDA;AAAA;;;;;;AE0nEA;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AH9/BA;;;;;;;;;;;;;;;AD7xBA;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AC6xBA;;;;;;;;;;;;;;;;;;;;;;;;;;;;Act5BA;;;;;;;;;;;;;;;;;;AdkmBA;;;;;AD4UA;;;;;;;;;;;;;;;;;;;;;;;;;;;;Ae/3BA;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;Af2EA;;;;;;;;;;;;AC4xBA;;;;AE99BA;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AHiMA;;;;;;;AIsoCA;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AJroCA;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AIqoCA;;;;;;ALxzCA;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AE8hCA;;;;;;;;;;;;;;;;;;;;;;;;;AAAA;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AF5+BA;;;;;;;;;;;;;;;;ACgIA;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AACA;;;;;;;;;;;;;;;;;;;;;;;;;;;;AADA;;;;;;;;;;;;;;;;;;;;;AIsoCA;;;;;;;AJroCA;;;;;;;;;;;;;;;;;;;;;AADA;;;;;;;AA0BA;;;;;;;;;;;;;;;;;;;;;ACmwBA;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AD5xBA;;;;;;;;;;;;;;;;;;;;;;;;;;;;AADA;;;;;;;AC42BA;;;;;;;AA/EA;;;;;;;;;;;;;;AD7xBA;;;;;;;;;;;;;;;;;;;;;;AE/TA;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AF+TA;;;;;;;;;;;;;;;;;;;AC42BA;;;;AE7iCA;;;;;;;;AHkMA;;;;;;;;;;;;;;;;;;;;;;AADA;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AC42BA;;;;;;AD8NA;;;;;;AC7SA;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AFr9BA;;;;;;;;AEoiCA;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AAAA;;;;;;;;;AC3sCA;;;;;AFujBA;;;;;;;;;;;;;;;;;;AM+3BA;;;;;;;;;;;;;;;;;;;;;AL1TA;;;;;;;;;;AAAA;;;;;AC5nCA;;;;;;;;;AEq+CA;;;;;;;;;AH1RA;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AAeA;;;;;ADjZA;;;;;;;;;;;;;;;;;;;;;AA1eA;;;;;;;;;;;;;;;;;;;;;;AC23BA;;;;;;;;;AK8PA;;;;;;;;;;;;;;;;;;;;;;;;;AN/lCA;;;;;;;;;;;;;;;;;;;;;;;;Ac1YA;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AZiBA;;;;;;;;;;;;;;;;;;;;;;;;;;AHwJA;;;;;;;;AGxJA;;;;;;;;;;;;;;;;;;;;;AG6IA;;;;;;;;;;;;;;;;;;;;;;;;;;ALkNA;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AAAA;;;;;;;;;;;;AE/VA;;;;;;AD2sCA;;;;;;AA/EA;;;;;;AD5xBA;;;;;;;;;;;;;;;;;;AADA;;;;;;A4B3GA;;;;;;A5BqIA;;;;;;;;;;;;;;;;;;;;;;;;A2B/TA;;;;;;;;;;;;;;;;;;A1BkkCA;;;;;;A0BlkCA;;;;;;AAAA;;;;A1BipCA;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AD32BA;;;;AC4xBA;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AAAA;;;;;;;;;;;;AE99BA;;;;;;AF89BA;;;;;;;;;;;;AE99BA;;;;;;AoCzMA;;;;;;AtCuqCA;;;;;;AE99BA;;;;;;AF89BA;;;;;;AsCxqCA;;;;;;AtCuvCA;;;;;;AA/EA;;;;;;;;;;;;AE99BA;;;;;;AF89BA;;;;;;;;;;;;;;;;;;AI/+BA;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;ALo1CA;;;;;;;;;;;;;;;;;;;;AGn0CA;;;;;AYwEA;;;;;;;;;;;;;;;;;;;;;;;;;AdizCA;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AA3ZA;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;ADfA;;;;;;;;;;;;;;;AIyaA;;;;;;;;;;AJjYA;;;;;;;;;;;;;;;;;;;;;;;;;ACzBA;;;;;;;;;;ADvUA;;;;;;;;;;;;;;AMqfA;;;;;;;;;;;;;ACjvCA;;;;;;ANkpCA;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AG0WA;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AH1WA;;;;;;;;;;;;;;;AAVA;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;ADl2BA;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AM4nCA;;;;;;;;AL/VA;;;;;;;;;;;;;;AW8PA;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AZxgCA;;;;AkBlNA;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AhBhKA;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AI+8CA;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AP1kCA;;;;;;;;;;;;;;;;;;;;;;;;AwCjbA;;;;;AlCyLA;;;;;;;;;;;;;;;AJ0iCA;;;;;AAUA;;;;;AE3iCA;;;;;;;;;;;;;;;;;;;;AFggCA;;;;;AA8RA;;;;;AAFA;;;;;AI5xCA;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AoB0jBA;;;;;;;;;;AEtpBA;;;;;A1BipCA;;;;;;;;;;A0BvpCA;;;;;A1BwkCA;;;;;A0BlkCA;;;;;;;;;;;;;;;;;;;;AAAA;;;;;A1BipCA;;;;;A0BjpCA;;;;;;;;;;A1BkkCA;;;;;A0BlkCA;;;;;;;;;;A1BopCA;;;;;AAlFA;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AsCppCA;;;;;AAAA;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;ATyzBA;;;;;AS5zBA;;;;;AAAA;;;;;;;;;;AADA;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AfoTA;;;;;AexTA;;;;;;;;;;;;;;;AtC4pCA;;;;;;;;;;AE99BA;;;;;AF89BA;;;;;;;;;;;;;;;AAAA;;;;;;;;;;AwBv8BA;;;;;AAFA;;;;;AAjCA;;;;;;;;;;;;;;;;;;;;AA6jBA;;;;;AD/FA;;;;;;;;;;ACgGA;;;;;;;;;;;;;;;ADlGA;;;;;AC+FA;;;;;AD1bA;;;;;AerTA;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;ApCgMA;;;;;;;;;;;;;;;;;;;;;;;AoC9MA;;;;;AtC4qCA;;;;;AsC7qCA;;;;;;;;;;AAAA;;;;;;;;;;AADA;;;;;;;;;;AAAA;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AvCymBA;;;;;;;;;;;ACu0FA;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AAhuEA;;;;AD/zBA;;;;;;;;;;;;AA0BA;;;;;;;;;;;;;;;;;;;;;AC+0BA;;;;;;;;;;;;;;;ACxsCA;;;;;;;;;;;;AIw8CA;;;;;;;;;;;;AJx8CA;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AAAA;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AD4nCA;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AO3hBA;;;;;;;;;;ALncA;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AF89BA;;;;AGyWA;;;;AHzWA;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AAAA;;;;;;;;;;;;;;;;;;;;AC5nCA;;;;;;;;;;;;;;;;;;;;AF+VA;;;;;;;;;;;AC6xBA;;;;;;;;;;;;;;;;;;;;;;;;;AAAA;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AM6RA","file":"docs/charm.js","sourcesContent":["#include <fstream>\n#include <string>\n#include <vector>\n#include <iostream>\n#include <variant>\n#include <unordered_map>\n#include <functional>\n#include <utility>\n\n#include \"PredefinedFunctions.h\"\n#include \"ParserTypes.h\"\n#include \"Error.h\"\n#include \"Debug.h\"\n#include \"Runner.h\"\n#include \"FunctionAnalyzer.h\"\n#include \"FFI.h\"\n#include \"Parser.h\"\n\n#ifdef CHARM_GUI\n#include \"gui.h\"\n#else\nstatic void display_output(std::string output) {\n\tstd::cout << output;\n}\n\nstatic std::string get_input_line() {\n\tstd::string result;\n\tstd::getline(std::cin, result);\n\treturn result;\n}\n#endif\n\nvoid PredefinedFunctions::addBuiltinFunction(std::string n, std::function<void(Runner*)> f) {\n\tBuiltinFunction bf;\n\tbf.f = f; bf.takesContext = false;\n\tcppFunctionNames[n] = bf;\n}\nvoid PredefinedFunctions::addBuiltinFunction(std::string n, std::function<void(Runner*, RunnerContext*)> f) {\n\tBuiltinFunction bf;\n\tbf.f = f; bf.takesContext = true;\n\tcppFunctionNames[n] = bf;\n}\nvoid PredefinedFunctions::functionLookup(std::string functionName, Runner* r, RunnerContext* context) {\n\tauto f = cppFunctionNames.at(functionName);\n\tif (f.takesContext) {\n\t\tauto castF = std::get<std::function<void(Runner*, RunnerContext*)>>(f.f);\n\t\tcastF(r, context);\n\t} else {\n\t\tauto castF = std::get<std::function<void(Runner*)>>(f.f);\n\t\tcastF(r);\n\t}\n}\n\nPredefinedFunctions::PredefinedFunctions() {\n\t/*************************************\n\tINPUT / OUTPUT\n\t*************************************/\n\taddBuiltinFunction(\"p\", [](Runner* r) {\n\t\tdisplay_output(charmFunctionToString(r->getCurrentStack()->pop()));\n\t});\n\taddBuiltinFunction(\"pstring\", [](Runner* r) {\n\t\tCharmFunction f1 = r->getCurrentStack()->pop();\n\t\tif (f1.functionType == STRING_FUNCTION) {\n\t\t\tdisplay_output(f1.stringValue);\n\t\t} else {\n\t\t\truntime_die(\"Non string passed to `pstring`.\");\n\t\t}\n\t});\n\taddBuiltinFunction(\"newline\", [](Runner* r) {\n\t\tdisplay_output(\"\\n\");\n\t});\n\taddBuiltinFunction(\"getline\", [](Runner* r) {\n\t\tCharmFunction input;\n\t\tinput.functionType = STRING_FUNCTION;\n\t\tinput.stringValue = get_input_line();\n\t\tr->getCurrentStack()->push(input);\n\t});\n\t/*************************************\n\tDEBUGGING FUNCTIONS\n\t*************************************/\n\taddBuiltinFunction(\"type\", [](Runner* r) {\n\t\tCharmFunction f1 = r->getCurrentStack()->pop();\n\t\tCharmFunction out;\n\t\tout.functionType = STRING_FUNCTION;\n\t\tswitch (f1.functionType) {\n\t\t\tcase LIST_FUNCTION:\n\t\t\tout.stringValue = \"LIST_FUNCTION\";\n\t\t\tbreak;\n\n\t\t\tcase NUMBER_FUNCTION:\n\t\t\tout.stringValue = \"NUMBER_FUNCTION\";\n\t\t\tbreak;\n\n\t\t\tcase STRING_FUNCTION:\n\t\t\tout.stringValue = \"STRING_FUNCTION\";\n\t\t\tbreak;\n\n\t\t\tcase DEFINED_FUNCTION:\n\t\t\tout.stringValue = \"DEFINED_FUNCTION\";\n\t\t\tbreak;\n\n\t\t\tcase FUNCTION_DEFINITION:\n\t\t\tout.stringValue = \"FUNCTION_DEFINITION\";\n\t\t\tbreak;\n\t\t}\n\t\tr->getCurrentStack()->push(f1);\n\t\tr->getCurrentStack()->push(out);\n\t});\n\t/*************************************\n\tFUNCTION DEFINITION\n\t*************************************/\n\taddBuiltinFunction(\"def\", [](Runner* r, RunnerContext* context) {\n\t\t//function body\n\t\tCharmFunction f1 = r->getCurrentStack()->pop();\n\t\t//function name\n\t\tCharmFunction f2 = r->getCurrentStack()->pop();\n\t\tif (f2.functionType != STRING_FUNCTION) {\n\t\t\truntime_die(\"Non string passed to `def`.\");\n\t\t}\n\t\tif (f1.functionType != LIST_FUNCTION) {\n\t\t\truntime_die(\"Non list passed to `def`.\");\n\t\t}\n\t\t//a function with type FUNCTION_DEFINITION\n\t\tCharmFunction f;\n\t\tf.functionType = FUNCTION_DEFINITION;\n\t\tf.functionName = f2.stringValue;\n\t\tf.literalFunctions = f1.literalFunctions;\n\n\t\tFunctionDefinition fD;\n\t\tfD.functionName = f.functionName;\n\t\tfD.functionBody = f.literalFunctions;\n\n\t\tCharmFunctionDefinitionInfo defInfo;\n\t\tdefInfo.inlineable = context->fA->isInlinable(f);\n\t\tif (defInfo.inlineable) {\n\t\t\tcontext->fA->addToInlineDefinitions(f);\n\t\t}\n\t\tdefInfo.tailCallRecursive = context->fA->isInlinable(f);\n\n\t\tfD.definitionInfo = defInfo;\n\t\tr->addFunctionDefinition(fD);\n\t});\n\taddBuiltinFunction(\"ffi\", [](Runner* r) {\n\t\t//library symbol\n\t\tCharmFunction f1 = r->getCurrentStack()->pop();\n\t\t//library path\n\t\tCharmFunction f2 = r->getCurrentStack()->pop();\n\t\t//charm function name\n\t\tCharmFunction f3 = r->getCurrentStack()->pop();\n\t\tif (f1.functionType != STRING_FUNCTION || f2.functionType != STRING_FUNCTION || f3.functionType != STRING_FUNCTION) {\n\t\t\truntime_die(\"Non string passed to `ffi`.\");\n\t\t}\n\t\tr->ffi->loadMutateFFI(f3.stringValue, f2.stringValue, f1.stringValue);\n\t});\n\t/*************************************\n\tCOMPARISONS\n\t*************************************/\n\taddBuiltinFunction(\"eq\", [](Runner* r) {\n\t\tCharmFunction f1 = r->getCurrentStack()->pop();\n\t\tCharmFunction f2 = r->getCurrentStack()->pop();\n\t\tCharmFunction out;\n\t\tout.functionType = NUMBER_FUNCTION;\n\t\tout.numberValue.whichType = INTEGER_VALUE;\n\t\tout.numberValue.integerValue = f1 == f2 ? 1 : 0;\n\t\tr->getCurrentStack()->push(out);\n\t});\n\t/*************************************\n\tSTACK MANIPULATIONS\n\t*************************************/\n\taddBuiltinFunction(\"dup\", [](Runner* r) {\n\t\tCharmFunction f1 = r->getCurrentStack()->pop();\n\t\tr->getCurrentStack()->push(f1);\n\t\tr->getCurrentStack()->push(f1);\n\t});\n\taddBuiltinFunction(\"pop\", [](Runner* r) {\n\t\tr->getCurrentStack()->pop();\n\t});\n\taddBuiltinFunction(\"swap\", [](Runner* r) {\n\t\tCharmFunction f1 = r->getCurrentStack()->pop();\n\t\tCharmFunction f2 = r->getCurrentStack()->pop();\n\t\t//check to make sure we've got ints that are positive and below MAX_STACK\n\t\tif (Stack::isInt(f1) && Stack::isInt(f2)) {\n\t\t\tif ((f1.numberValue.integerValue < 0) || (f2.numberValue.integerValue < 0)) {\n\t\t\t\truntime_die(\"Negative int passed to `swap`.\");\n\t\t\t}\n\t\t\tif ((f1.numberValue.integerValue >= r->MAX_STACK) || (f2.numberValue.integerValue >= r->MAX_STACK)) {\n\t\t\t\truntime_die(\"Overflowing pointers passed to `swap`.\");\n\t\t\t}\n\t\t\tr->getCurrentStack()->swap((unsigned long long)f1.numberValue.integerValue, (unsigned long long)f2.numberValue.integerValue);\n\t\t} else {\n\t\t\truntime_die(\"Non integer passed to `swap`.\");\n\t\t}\n\t});\n\t/*************************************\n\tTRAVERSABLE (STRING / LIST) MANIPULATIONS\n\t*************************************/\n\taddBuiltinFunction(\"len\", [](Runner* r) {\n\t\t//list to check length of\n\t\tCharmFunction f1 = r->getCurrentStack()->pop();\n\t\t//push list back on because we dont need to get rid of it\n\t\tr->getCurrentStack()->push(f1);\n\t\tCharmFunction out;\n\t\tout.functionType = NUMBER_FUNCTION;\n\t\tCharmNumber num;\n\t\tnum.whichType = INTEGER_VALUE;\n\t\t//make sure f1 is a list or string\n\t\tif (f1.functionType == LIST_FUNCTION) {\n\t\t\tnum.integerValue = f1.literalFunctions.size();\n\t\t} else if (f1.functionType == STRING_FUNCTION) {\n\t\t\tnum.integerValue = f1.stringValue.size();\n\t\t} else {\n\t\t\t//so if it's a bad type, i was going to just report a len of 0 or 1\n\t\t\t//but i feel like that would be really misleading. eh, i'll just do 1\n\t\t\tnum.integerValue = 1;\n\t\t}\n\t\tout.numberValue = num;\n\t\tr->getCurrentStack()->push(out);\n\t});\n\taddBuiltinFunction(\"at\", [](Runner* r) {\n\t\t//index number\n\t\tCharmFunction f1 = r->getCurrentStack()->pop();\n\t\t//list / string\n\t\tCharmFunction f2 = r->getCurrentStack()->pop();\n\t\tr->getCurrentStack()->push(f2);\n\t\tif (Stack::isInt(f1)) {\n\t\t\tCharmFunction out;\n\t\t\tif (f2.functionType == LIST_FUNCTION) {\n\t\t\t\tif (f2.literalFunctions.size() < 1) {\n\t\t\t\t\truntime_die(\"Empty list passed to `at`.\");\n\t\t\t\t}\n\t\t\t\tout.functionType = LIST_FUNCTION;\n\t\t\t\tout.literalFunctions = { f2.literalFunctions.at(f1.numberValue.integerValue % f2.literalFunctions.size()) };\n\t\t\t} else if (f2.functionType == STRING_FUNCTION) {\n\t\t\t\tif (f2.stringValue.size() < 1) {\n\t\t\t\t\truntime_die(\"Empty string passed to `at`.\");\n\t\t\t\t}\n\t\t\t\tout.functionType = STRING_FUNCTION;\n\t\t\t\tout.stringValue = f2.stringValue[f1.numberValue.integerValue % f2.stringValue.size()];\n\t\t\t} else {\n\t\t\t\truntime_die(\"Neither a list nor a string was passed to `at`\");\n\t\t\t}\n\t\t\tr->getCurrentStack()->push(out);\n\t\t} else {\n\t\t\truntime_die(\"Non integer index passed to `at`\");\n\t\t}\n\t});\n\taddBuiltinFunction(\"insert\", [](Runner* r) {\n\t\t//get index to insert in\n\t\tCharmFunction f1 = r->getCurrentStack()->pop();\n\t\t//get element to insert\n\t\tCharmFunction f2 = r->getCurrentStack()->pop();\n\t\t//get list or string\n\t\tCharmFunction f3 = r->getCurrentStack()->pop();\n\t\t//make sure f1 is an int\n\t\tif (!Stack::isInt(f1))\n\t\t\truntime_die(\"Non integer index passed to `insert`.\");\n\t\tif (f3.functionType == LIST_FUNCTION) {\n\t\t\t//only allow a list to be inserted into a list\n\t\t\tif (f2.functionType == LIST_FUNCTION) {\n\t\t\t\tf3.literalFunctions.insert(\n\t\t\t\t\tf3.literalFunctions.begin() + (f1.numberValue.integerValue % f3.literalFunctions.size()),\n\t\t\t\t\tf2.literalFunctions.begin(),\n\t\t\t\t\tf2.literalFunctions.end()\n\t\t\t\t);\n\t\t\t} else {\n\t\t\t\truntime_die(\"Attempted to `insert` a non list into a list.\");\n\t\t\t}\n\t\t} else if (f3.functionType == STRING_FUNCTION) {\n\t\t\t//only allow a string to be inserted into another string\n\t\t\tif (f2.functionType == STRING_FUNCTION) {\n\t\t\t\tf3.stringValue.insert(\n\t\t\t\t\tf1.numberValue.integerValue % f3.stringValue.size(),\n\t\t\t\t\tf2.stringValue\n\t\t\t\t);\n\t\t\t} else {\n\t\t\t\truntime_die(\"Attempted to `insert` a non string into a string.\");\n\t\t\t}\n\t\t}\n\t\tr->getCurrentStack()->push(f3);\n\t});\n\taddBuiltinFunction(\"concat\", [](Runner* r) {\n\t\t//get first list\n\t\tCharmFunction f1 = r->getCurrentStack()->pop();\n\t\t//get second list (first in order of concatination)\n\t\tCharmFunction f2 = r->getCurrentStack()->pop();\n\t\t//make sure they're both lists or strings\n\t\tif ((f1.functionType == LIST_FUNCTION) && (f2.functionType == LIST_FUNCTION)) {\n\t\t\tf2.literalFunctions.insert(f2.literalFunctions.end(), f1.literalFunctions.begin(), f1.literalFunctions.end());\n\t\t} else if ((f1.functionType == STRING_FUNCTION) && (f2.functionType == STRING_FUNCTION)) {\n\t\t\tf2.stringValue = f2.stringValue + f1.stringValue;\n\t\t} else {\n\t\t\truntime_die(\"Unmatching types passed to `concat`.\");\n\t\t}\n\t\tr->getCurrentStack()->push(f2);\n\t});\n\taddBuiltinFunction(\"split\", [](Runner* r) {\n\t\t//get split index\n\t\tCharmFunction f1 = r->getCurrentStack()->pop();\n\t\t//get list/string to split\n\t\tCharmFunction f2 = r->getCurrentStack()->pop();\n\t\tCharmFunction lowOut;\n\t\tCharmFunction highOut;\n\t\tif (f1.functionType == NUMBER_FUNCTION && f1.numberValue.whichType == INTEGER_VALUE) {\n\t\t\t//bounds checking\n\t\t\tif (f1.numberValue.integerValue < 0 || (unsigned long long)f1.numberValue.integerValue > f2.literalFunctions.size()) {\n\t\t\t\truntime_die(\"Out of bounds error on the number passed to `split`.\");\n\t\t\t}\n\t\t\tif (f2.functionType == LIST_FUNCTION) {\n\t\t\t\tlowOut.functionType = LIST_FUNCTION;\n\t\t\t\tlowOut.literalFunctions.assign(f2.literalFunctions.begin(), f2.literalFunctions.begin() + f1.numberValue.integerValue);\n\t\t\t\thighOut.functionType = LIST_FUNCTION;\n\t\t\t\thighOut.literalFunctions.assign(f2.literalFunctions.begin() + f1.numberValue.integerValue, f2.literalFunctions.end());\n\t\t\t} else if (f2.functionType == STRING_FUNCTION) {\n\t\t\t\tlowOut.functionType = STRING_FUNCTION;\n\t\t\t\tlowOut.stringValue.assign(f2.stringValue.begin(), f2.stringValue.begin() + f1.numberValue.integerValue);\n\t\t\t\thighOut.functionType = STRING_FUNCTION;\n\t\t\t\thighOut.stringValue.assign(f2.stringValue.begin() + f1.numberValue.integerValue, f2.stringValue.end());\n\t\t\t} else {\n\t\t\t\truntime_die(\"Non list/string passed to `split`.\");\n\t\t\t}\n\t\t} else {\n\t\t\truntime_die(\"Non integer passed to `split`.\");\n\t\t}\n\t\tr->getCurrentStack()->push(lowOut);\n\t\tr->getCurrentStack()->push(highOut);\n\t});\n\t/*************************************\n\tSTRING MANIPULATION\n\t*************************************/\n\taddBuiltinFunction(\"tostring\", [](Runner* r) {\n\t\tCharmFunction f1 = r->getCurrentStack()->pop();\n\t\tCharmFunction out;\n\t\tout.functionType = STRING_FUNCTION;\n\t\tout.stringValue = charmFunctionToString(f1);\n\t\tr->getCurrentStack()->push(out);\n\t});\n\taddBuiltinFunction(\"char\", [](Runner* r) {\n\t\tCharmFunction f1 = r->getCurrentStack()->pop();\n\t\tif (f1.functionType == NUMBER_FUNCTION) {\n\t\t\tif (f1.numberValue.whichType == INTEGER_VALUE) {\n\t\t\t\tif (f1.numberValue.integerValue < 0) {\n\t\t\t\t\truntime_die(\"Negative integer passed to `char`.\");\n\t\t\t\t} else {\n\t\t\t\t\tCharmFunction out;\n\t\t\t\t\tout.functionType = STRING_FUNCTION;\n\t\t\t\t\tout.stringValue = std::string(1, static_cast<char>(f1.numberValue.integerValue));\n\t\t\t\t\tr->getCurrentStack()->push(out);\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\truntime_die(\"Non integer passed to `char`.\");\n\t\t\t}\n\t\t} else {\n\t\t\truntime_die(\"Non number passed to `char`.\");\n\t\t}\n\t});\n\taddBuiltinFunction(\"ord\", [](Runner* r) {\n\t\tCharmFunction f1 = r->getCurrentStack()->pop();\n\t\tif (f1.functionType == STRING_FUNCTION) {\n\t\t\tif (f1.stringValue.size() > 0) {\n\t\t\t\tCharmFunction out;\n\t\t\t\tCharmNumber n;\n\t\t\t\tn.whichType = INTEGER_VALUE;\n\t\t\t\tn.integerValue = static_cast<long long>(f1.stringValue[0]);\n\t\t\t\tout.functionType = NUMBER_FUNCTION;\n\t\t\t\tout.numberValue = n;\n\t\t\t\tr->getCurrentStack()->push(out);\n\t\t\t} else {\n\t\t\t\truntime_die(\"Empty string passed to `ord`.\");\n\t\t\t}\n\t\t} else {\n\t\t\truntime_die(\"Non string passed to `ord`.\");\n\t\t}\n\t});\n\t/*************************************\n\tCONTROL FLOW\n\t*************************************/\n\taddBuiltinFunction(\"i\", [](Runner* r, RunnerContext* context) {\n\t\t//pop the top of the stack and run it\n\t\tCharmFunction f1 = r->getCurrentStack()->pop();\n\t\tif (f1.functionType == LIST_FUNCTION) {\n\t\t\t//when we run with `i`, remove the context (we can't tail call from an `i`)\n\t\t\tr->run(std::pair<CHARM_LIST_TYPE, FunctionAnalyzer*>(f1.literalFunctions, context->fA));\n\t\t} else {\n\t\t\truntime_die(\"Non list passed to `i`.\");\n\t\t}\n\t});\n\taddBuiltinFunction(\"q\", [](Runner* r) {\n\t\tCharmFunction f1 = r->getCurrentStack()->pop();\n\t\tCharmFunction list;\n\t\tlist.functionType = LIST_FUNCTION;\n\t\tlist.literalFunctions.push_back(f1);\n\t\tr->getCurrentStack()->push(list);\n\t});\n\taddBuiltinFunction(\"ifthen\", [](Runner* r, RunnerContext* context) {\n\t\t//the arguments to this function are a little different...\n\t\t//ifthen performs very basic tail-call optimization on its two sections (truthy/falsy)\n\t\t//if truthy (or falsy) end with the function itself (found through fD.functionName), then\n\t\t//the tail-call optimizer kicks in and the function simply loops instead of\n\t\t//creating a new stack frame by calling r->run()\n\n\t\t//this one is gonna take 3 arguments:\n\t\t//stack[2] = condition to run truthy section\n\t\t//stack[1] = truthy section (if...)\n\t\t//stack[0] = falsy section (else...)\n\t\t//have to reverse it because popping is weird\n\t\tCharmFunction falsy = r->getCurrentStack()->pop();\n\t\tbool falsyTailCall = false;\n\t\tCharmFunction truthy = r->getCurrentStack()->pop();\n\t\tbool truthyTailCall = false;\n\t\tCharmFunction condFunction = r->getCurrentStack()->pop();\n\t\tif ((condFunction.functionType == LIST_FUNCTION) &&\n\t\t\t(truthy.functionType == LIST_FUNCTION) &&\n\t\t\t(falsy.functionType == LIST_FUNCTION)) {\n\t\t\t\t//first, we run checks to set the tail call bools\n\t\t\t\tif (context->fD != nullptr) {\n\t\t\t\t\tstd::string defName = context->fD->functionName;\n\t\t\t\t\tif (truthy.literalFunctions.size() > 0 && truthy.literalFunctions.back().functionName == defName) {\n\t\t\t\t\t\ttruthyTailCall = true;\n\t\t\t\t\t}\n\t\t\t\t\tif (falsy.literalFunctions.size() > 0 && falsy.literalFunctions.back().functionName == defName) {\n\t\t\t\t\t\tfalsyTailCall = true;\n\t\t\t\t\t}\n\t\t\t\t\t//now, if we _DO_ have a tail call, modify truthy/falsy and enter a loop instead\n\t\t\t\t\t//there are 3 seperate cases here: truthy tail call, falsy tail call, or both\n\t\t\t\t\tif (truthyTailCall) {\n\t\t\t\t\t\tONLYDEBUG printf(\"ENGAGING TRUTHY IF/THEN TAIL CALL OPTIMIZATION\\n\");\n\t\t\t\t\t\t//remove the tail call\n\t\t\t\t\t\ttruthy.literalFunctions.pop_back();\n\t\t\t\t\t\twhile (1) {\n\t\t\t\t\t\t\tr->runWithContext(condFunction.literalFunctions, context);\n\t\t\t\t\t\t\tCharmFunction cond = r->getCurrentStack()->pop();\n\t\t\t\t\t\t\tif (Stack::isInt(cond)) {\n\t\t\t\t\t\t\t\tif (cond.numberValue.integerValue > 0) {\n\t\t\t\t\t\t\t\t\tr->runWithContext(truthy.literalFunctions, context);\n\t\t\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t\t\tr->runWithContext(falsy.literalFunctions, context);\n\t\t\t\t\t\t\t\t\t//end this function immediately once the tail call loop ends\n\t\t\t\t\t\t\t\t\tONLYDEBUG printf(\"DISENGAGING TRUTHY IF/THEN TAIL CALL OPTIMIZATION\\n\");\n\t\t\t\t\t\t\t\t\treturn;\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t\truntime_die(\"`ifthen` condition returned non integer.\");\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tif (falsyTailCall) {\n\t\t\t\t\t\tONLYDEBUG printf(\"ENGAGING FALSY IF/THEN TAIL CALL OPTIMIZATION\\n\");\n\t\t\t\t\t\t//remove the tail call\n\t\t\t\t\t\tfalsy.literalFunctions.pop_back();\n\t\t\t\t\t\twhile (1) {\n\t\t\t\t\t\t\tr->runWithContext(condFunction.literalFunctions, context);\n\t\t\t\t\t\t\tCharmFunction cond = r->getCurrentStack()->pop();\n\t\t\t\t\t\t\tif (Stack::isInt(cond)) {\n\t\t\t\t\t\t\t\tif (cond.numberValue.integerValue > 0) {\n\t\t\t\t\t\t\t\t\tr->runWithContext(truthy.literalFunctions, context);\n\t\t\t\t\t\t\t\t\t//end this function immediately once the tail call loop ends\n\t\t\t\t\t\t\t\t\tONLYDEBUG printf(\"DISENGAGING FALSY IF/THEN TAIL CALL OPTIMIZATION\\n\");\n\t\t\t\t\t\t\t\t\treturn;\n\t\t\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t\t\tr->runWithContext(falsy.literalFunctions, context);\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t\truntime_die(\"`ifthen` condition returned non integer.\");\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\t//here's an extra special case: if both truthy and falsy have a tail call\n\t\t\t\t\t//th(at) is: `f := [ <cond> ] [ <code> f ] [ <code> f ] ifthen`\n\t\t\t\t\t//this is equivalent to `f := [ <cond> ] [ <code> ] [ <code> ] ifthen f`\n\t\t\t\t\t//so we run it as an infinite loop\n\t\t\t\t\tif (truthyTailCall && falsyTailCall) {\n\t\t\t\t\t\tONLYDEBUG printf(\"ENGAGING TRUTHY/FALSY IF/THEN TAIL CALL OPTIMIZATION\\n\");\n\t\t\t\t\t\t//remove the tail calls\n\t\t\t\t\t\ttruthy.literalFunctions.pop_back();\n\t\t\t\t\t\tfalsy.literalFunctions.pop_back();\n\t\t\t\t\t\twhile (1) {\n\t\t\t\t\t\t\tCharmFunction cond = r->getCurrentStack()->pop();\n\t\t\t\t\t\t\tif (Stack::isInt(cond)) {\n\t\t\t\t\t\t\t\tif (cond.numberValue.integerValue > 0) {\n\t\t\t\t\t\t\t\t\tr->runWithContext(truthy.literalFunctions, context);\n\t\t\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t\t\tr->runWithContext(falsy.literalFunctions, context);\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t\truntime_die(\"`ifthen` condition returned non integer.\");\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\t//good joke\n\t\t\t\t\tONLYDEBUG printf(\"DISENGAGING TRUTHY/FALSY IF/THEN TAIL CALL OPTIMIZATION\\n\");\n\t\t\t\t}\n\t\t\t\t//but if not (or context was nullptr), continue execution as normal\n\t\t\t\tr->runWithContext(condFunction.literalFunctions, context);\n\t\t\t\t//now we check the top of the stack to see if it's truthy or falsy\n\t\t\t\tCharmFunction cond = r->getCurrentStack()->pop();\n\t\t\t\tif (Stack::isInt(cond)) {\n\t\t\t\t\tif (cond.numberValue.integerValue > 0) {\n\t\t\t\t\t\tr->runWithContext(truthy.literalFunctions, context);\n\t\t\t\t\t} else {\n\t\t\t\t\t\tr->runWithContext(falsy.literalFunctions, context);\n\t\t\t\t\t}\n\t\t\t\t} else {\n\t\t\t\t\truntime_die(\"`ifthen` condition returned non integer.\");\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\truntime_die(\"Non list passed to `ifthen`.\");\n\t\t\t}\n\t});\n\taddBuiltinFunction(\"inline\", [](Runner* r, RunnerContext* context) {\n\t\t//the boxed function to take in\n\t\tCharmFunction f1 = r->getCurrentStack()->pop();\n\t\tif (f1.functionType == LIST_FUNCTION) {\n\t\t\tCharmFunction out;\n\t\t\tout.functionType = LIST_FUNCTION;\n\t\t\tfor (CharmFunction f : f1.literalFunctions) {\n\t\t\t\tif (f.functionType == DEFINED_FUNCTION) {\n\t\t\t\t\tif (!context->fA->doInline(out.literalFunctions, f)) {\n\t\t\t\t\t\tout.literalFunctions.push_back(f);\n\t\t\t\t\t}\n\t\t\t\t} else {\n\t\t\t\t\tout.literalFunctions.push_back(f);\n\t\t\t\t}\n\t\t\t}\n\t\t\tr->getCurrentStack()->push(out);\n\t\t} else {\n\t\t\truntime_die(\"Non list passed to `inline`.\");\n\t\t}\n\t});\n\t/*************************************\n\tBOOLEAN OPS\n\t*************************************/\n\taddBuiltinFunction(\"xor\", [](Runner* r) {\n\t\tCharmFunction f1 = r->getCurrentStack()->pop();\n\t\tCharmFunction f2 = r->getCurrentStack()->pop();\n\t\tif (Stack::isInt(f1) && Stack::isInt(f2)) {\n\t\t\tCharmFunction out;\n\t\t\tout.functionType = NUMBER_FUNCTION;\n\t\t\tCharmNumber outNum;\n\t\t\toutNum.whichType = INTEGER_VALUE;\n\t\t\t//cancer incoming\n\t\t\toutNum.integerValue = ((f1.numberValue.integerValue > 0) ^ (f2.numberValue.integerValue > 0));\n\t\t\t//no more cancer\n\t\t\tout.numberValue = outNum;\n\t\t\tr->getCurrentStack()->push(out);\n\t\t} else {\n\t\t\truntime_die(\"Non integer passed to logic function.\");\n\t\t}\n\t});\n\t/*************************************\n\tTYPE INSPECIFIC MATH\n\t*************************************/\n\taddBuiltinFunction(\"abs\", [](Runner* r) {\n\t\tCharmFunction f1 = r->getCurrentStack()->pop();\n\t\tif (Stack::isInt(f1)) {\n\t\t\tstd::abs(f1.numberValue.integerValue);\n\t\t} else if (Stack::isFloat(f1)) {\n\t\t\tif (f1.numberValue.floatValue < 0) {\n\t\t\t\tf1.numberValue.floatValue = -f1.numberValue.floatValue;\n\t\t\t}\n\t\t} else {\n\t\t\truntime_die(\"Non number passed to `abs`.\");\n\t\t}\n\t});\n\t/*************************************\n\tINTEGER OPS\n\t*************************************/\n\taddBuiltinFunction(\"+\", [](Runner* r) {\n\t\tCharmFunction f1 = r->getCurrentStack()->pop();\n\t\tCharmFunction f2 = r->getCurrentStack()->pop();\n\t\tif (Stack::isInt(f1) && Stack::isInt(f2)) {\n\t\t\tf1.numberValue.integerValue = f1.numberValue.integerValue + f2.numberValue.integerValue;\n\t\t} else {\n\t\t\truntime_die(\"Non integer passed to `+`.\");\n\t\t}\n\t\tr->getCurrentStack()->push(f1);\n\t});\n\taddBuiltinFunction(\"-\", [](Runner* r) {\n\t\tCharmFunction f1 = r->getCurrentStack()->pop();\n\t\tCharmFunction f2 = r->getCurrentStack()->pop();\n\t\tif (Stack::isInt(f1) && Stack::isInt(f2)) {\n\t\t\tf1.numberValue.integerValue = f2.numberValue.integerValue - f1.numberValue.integerValue;\n\t\t} else {\n\t\t\truntime_die(\"Non integer passed to `-`.\");\n\t\t}\n\t\tr->getCurrentStack()->push(f1);\n\t});\n\taddBuiltinFunction(\"/\", [](Runner* r) {\n\t\tCharmFunction f1 = r->getCurrentStack()->pop();\n\t\tCharmFunction f2 = r->getCurrentStack()->pop();\n\t\tif (Stack::isInt(f1) && Stack::isInt(f2)) {\n\t\t\t//f1 used as answer\n\t\t\tf1.numberValue.integerValue = f2.numberValue.integerValue / f1.numberValue.integerValue;\n\t\t\t//f2 used as modulus\n\t\t\tf2.numberValue.integerValue = f2.numberValue.integerValue % f1.numberValue.integerValue;\n\t\t} else {\n\t\t\truntime_die(\"Non integer passed to `+`.\");\n\t\t}\n\t\tr->getCurrentStack()->push(f2);\n\t\tr->getCurrentStack()->push(f1);\n\t});\n\taddBuiltinFunction(\"*\", [](Runner* r) {\n\t\tCharmFunction f1 = r->getCurrentStack()->pop();\n\t\tCharmFunction f2 = r->getCurrentStack()->pop();\n\t\tif (Stack::isInt(f1) && Stack::isInt(f2)) {\n\t\t\tf1.numberValue.integerValue = f1.numberValue.integerValue * f2.numberValue.integerValue;\n\t\t} else {\n\t\t\truntime_die(\"Non integer passed to `*`.\");\n\t\t}\n\t\tr->getCurrentStack()->push(f1);\n\t});\n\taddBuiltinFunction(\"toint\", [](Runner* r) {\n\t\tCharmFunction f1 = r->getCurrentStack()->pop();\n\t\tif (Stack::isFloat(f1)) {\n\t\t\tf1.numberValue.whichType = INTEGER_VALUE;\n\t\t\tf1.numberValue.integerValue = (long long)f1.numberValue.floatValue;\n\t\t} else if (Stack::isInt(f1)) {\n\t\t\t//do nothing, it's already an int\n\t\t} else {\n\t\t\truntime_die(\"Non number passed to `toInt`.\");\n\t\t}\n\t});\n\t/*************************************\n\tSTACK CREATION/DESTRUCTION\n\t*************************************/\n\taddBuiltinFunction(\"createstack\", [](Runner* r) {\n\t\t//name of the stack\n\t\tCharmFunction f1 = r->getCurrentStack()->pop();\n\t\t//length of the stack\n\t\tCharmFunction f2 = r->getCurrentStack()->pop();\n\t\tif (Stack::isInt(f2)) {\n\t\t\tif (f2.numberValue.integerValue > 0) {\n\t\t\t\tr->createStack(f2.numberValue.integerValue, f1);\n\t\t\t} else {\n\t\t\t\truntime_die(\"Negative integer or zero passed to `createStack`.\");\n\t\t\t}\n\t\t} else {\n\t\t\truntime_die(\"Non integer passed to `createStack`.\");\n\t\t}\n\t});\n\taddBuiltinFunction(\"getstack\", [](Runner* r) {\n\t\t//name of the stack\n\t\tr->getCurrentStack()->push(r->getCurrentStack()->name);\n\t});\n\taddBuiltinFunction(\"switchstack\", [](Runner* r) {\n\t\tCharmFunction f1 = r->getCurrentStack()->pop();\n\t\tr->switchCurrentStack(f1);\n\t});\n\t/*************************************\n\tREF GETTING/SETTING\n\t*************************************/\n\taddBuiltinFunction(\"getref\", [](Runner* r) {\n\t\tCharmFunction f1 = r->getCurrentStack()->pop();\n\t\tr->getCurrentStack()->push(r->getReference(f1));\n\t});\n\taddBuiltinFunction(\"setref\", [](Runner* r) {\n\t\t//the value of the reference\n\t\tCharmFunction f1 = r->getCurrentStack()->pop();\n\t\t//the name of the reference\n\t\tCharmFunction f2 = r->getCurrentStack()->pop();\n\t\tr->setReference(f2, f1);\n\t});\n\t/*************************************\n\tLIBRARY INTERACTION\n\t*************************************/\n\taddBuiltinFunction(\"include\", [](Runner* r) {\n\t\t//NOTE: no inlining is done for included files\n\t\t//this is because all inlining is done at compile time,\n\t\t//and this inclusion happens at runtime\n\n\t\t//the namespace to place functions in\n\t\tCharmFunction f1 = r->getCurrentStack()->pop();\n\t\t//the path of the file to import\n\t\tCharmFunction f2 = r->getCurrentStack()->pop();\n\t\tif ((f1.functionType != STRING_FUNCTION) || (f2.functionType != STRING_FUNCTION)) {\n\t\t\truntime_die(\"Non string passed to `include`.\");\n\t\t}\n\t\tstd::string line;\n\t\tstd::ifstream importFile(f2.stringValue);\n\t\tParser parser = Parser();\n\t\twhile (std::getline(importFile, line)) {\n\t\t\tr->run(parser.lex(line), f1.stringValue);\n\t\t}\n\t});\n}\n","// -*- C++ -*-\n//===------------------------------ vector --------------------------------===//\n//\n//                     The LLVM Compiler Infrastructure\n//\n// This file is dual licensed under the MIT and the University of Illinois Open\n// Source Licenses. See LICENSE.TXT for details.\n//\n//===----------------------------------------------------------------------===//\n\n#ifndef _LIBCPP_VECTOR\n#define _LIBCPP_VECTOR\n\n/*\n    vector synopsis\n\nnamespace std\n{\n\ntemplate <class T, class Allocator = allocator<T> >\nclass vector\n{\npublic:\n    typedef T                                        value_type;\n    typedef Allocator                                allocator_type;\n    typedef typename allocator_type::reference       reference;\n    typedef typename allocator_type::const_reference const_reference;\n    typedef implementation-defined                   iterator;\n    typedef implementation-defined                   const_iterator;\n    typedef typename allocator_type::size_type       size_type;\n    typedef typename allocator_type::difference_type difference_type;\n    typedef typename allocator_type::pointer         pointer;\n    typedef typename allocator_type::const_pointer   const_pointer;\n    typedef std::reverse_iterator<iterator>          reverse_iterator;\n    typedef std::reverse_iterator<const_iterator>    const_reverse_iterator;\n\n    vector()\n        noexcept(is_nothrow_default_constructible<allocator_type>::value);\n    explicit vector(const allocator_type&);\n    explicit vector(size_type n);\n    explicit vector(size_type n, const allocator_type&); // C++14\n    vector(size_type n, const value_type& value, const allocator_type& = allocator_type());\n    template <class InputIterator>\n        vector(InputIterator first, InputIterator last, const allocator_type& = allocator_type());\n    vector(const vector& x);\n    vector(vector&& x)\n        noexcept(is_nothrow_move_constructible<allocator_type>::value);\n    vector(initializer_list<value_type> il);\n    vector(initializer_list<value_type> il, const allocator_type& a);\n    ~vector();\n    vector& operator=(const vector& x);\n    vector& operator=(vector&& x)\n        noexcept(\n             allocator_type::propagate_on_container_move_assignment::value ||\n             allocator_type::is_always_equal::value); // C++17\n    vector& operator=(initializer_list<value_type> il);\n    template <class InputIterator>\n        void assign(InputIterator first, InputIterator last);\n    void assign(size_type n, const value_type& u);\n    void assign(initializer_list<value_type> il);\n\n    allocator_type get_allocator() const noexcept;\n\n    iterator               begin() noexcept;\n    const_iterator         begin()   const noexcept;\n    iterator               end() noexcept;\n    const_iterator         end()     const noexcept;\n\n    reverse_iterator       rbegin() noexcept;\n    const_reverse_iterator rbegin()  const noexcept;\n    reverse_iterator       rend() noexcept;\n    const_reverse_iterator rend()    const noexcept;\n\n    const_iterator         cbegin()  const noexcept;\n    const_iterator         cend()    const noexcept;\n    const_reverse_iterator crbegin() const noexcept;\n    const_reverse_iterator crend()   const noexcept;\n\n    size_type size() const noexcept;\n    size_type max_size() const noexcept;\n    size_type capacity() const noexcept;\n    bool empty() const noexcept;\n    void reserve(size_type n);\n    void shrink_to_fit() noexcept;\n\n    reference       operator[](size_type n);\n    const_reference operator[](size_type n) const;\n    reference       at(size_type n);\n    const_reference at(size_type n) const;\n\n    reference       front();\n    const_reference front() const;\n    reference       back();\n    const_reference back() const;\n\n    value_type*       data() noexcept;\n    const value_type* data() const noexcept;\n\n    void push_back(const value_type& x);\n    void push_back(value_type&& x);\n    template <class... Args>\n        reference emplace_back(Args&&... args); // reference in C++17\n    void pop_back();\n\n    template <class... Args> iterator emplace(const_iterator position, Args&&... args);\n    iterator insert(const_iterator position, const value_type& x);\n    iterator insert(const_iterator position, value_type&& x);\n    iterator insert(const_iterator position, size_type n, const value_type& x);\n    template <class InputIterator>\n        iterator insert(const_iterator position, InputIterator first, InputIterator last);\n    iterator insert(const_iterator position, initializer_list<value_type> il);\n\n    iterator erase(const_iterator position);\n    iterator erase(const_iterator first, const_iterator last);\n\n    void clear() noexcept;\n\n    void resize(size_type sz);\n    void resize(size_type sz, const value_type& c);\n\n    void swap(vector&)\n        noexcept(allocator_traits<allocator_type>::propagate_on_container_swap::value ||\n                 allocator_traits<allocator_type>::is_always_equal::value);  // C++17\n\n    bool __invariants() const;\n};\n\ntemplate <class Allocator = allocator<T> >\nclass vector<bool, Allocator>\n{\npublic:\n    typedef bool                                     value_type;\n    typedef Allocator                                allocator_type;\n    typedef implementation-defined                   iterator;\n    typedef implementation-defined                   const_iterator;\n    typedef typename allocator_type::size_type       size_type;\n    typedef typename allocator_type::difference_type difference_type;\n    typedef iterator                                 pointer;\n    typedef const_iterator                           const_pointer;\n    typedef std::reverse_iterator<iterator>          reverse_iterator;\n    typedef std::reverse_iterator<const_iterator>    const_reverse_iterator;\n\n    class reference\n    {\n    public:\n        reference(const reference&) noexcept;\n        operator bool() const noexcept;\n        reference& operator=(const bool x) noexcept;\n        reference& operator=(const reference& x) noexcept;\n        iterator operator&() const noexcept;\n        void flip() noexcept;\n    };\n\n    class const_reference\n    {\n    public:\n        const_reference(const reference&) noexcept;\n        operator bool() const noexcept;\n        const_iterator operator&() const noexcept;\n    };\n\n    vector()\n        noexcept(is_nothrow_default_constructible<allocator_type>::value);\n    explicit vector(const allocator_type&);\n    explicit vector(size_type n, const allocator_type& a = allocator_type()); // C++14\n    vector(size_type n, const value_type& value, const allocator_type& = allocator_type());\n    template <class InputIterator>\n        vector(InputIterator first, InputIterator last, const allocator_type& = allocator_type());\n    vector(const vector& x);\n    vector(vector&& x)\n        noexcept(is_nothrow_move_constructible<allocator_type>::value);\n    vector(initializer_list<value_type> il);\n    vector(initializer_list<value_type> il, const allocator_type& a);\n    ~vector();\n    vector& operator=(const vector& x);\n    vector& operator=(vector&& x)\n        noexcept(\n             allocator_type::propagate_on_container_move_assignment::value ||\n             allocator_type::is_always_equal::value); // C++17\n    vector& operator=(initializer_list<value_type> il);\n    template <class InputIterator>\n        void assign(InputIterator first, InputIterator last);\n    void assign(size_type n, const value_type& u);\n    void assign(initializer_list<value_type> il);\n\n    allocator_type get_allocator() const noexcept;\n\n    iterator               begin() noexcept;\n    const_iterator         begin()   const noexcept;\n    iterator               end() noexcept;\n    const_iterator         end()     const noexcept;\n\n    reverse_iterator       rbegin() noexcept;\n    const_reverse_iterator rbegin()  const noexcept;\n    reverse_iterator       rend() noexcept;\n    const_reverse_iterator rend()    const noexcept;\n\n    const_iterator         cbegin()  const noexcept;\n    const_iterator         cend()    const noexcept;\n    const_reverse_iterator crbegin() const noexcept;\n    const_reverse_iterator crend()   const noexcept;\n\n    size_type size() const noexcept;\n    size_type max_size() const noexcept;\n    size_type capacity() const noexcept;\n    bool empty() const noexcept;\n    void reserve(size_type n);\n    void shrink_to_fit() noexcept;\n\n    reference       operator[](size_type n);\n    const_reference operator[](size_type n) const;\n    reference       at(size_type n);\n    const_reference at(size_type n) const;\n\n    reference       front();\n    const_reference front() const;\n    reference       back();\n    const_reference back() const;\n\n    void push_back(const value_type& x);\n    template <class... Args> reference emplace_back(Args&&... args);  // C++14; reference in C++17\n    void pop_back();\n\n    template <class... Args> iterator emplace(const_iterator position, Args&&... args);  // C++14\n    iterator insert(const_iterator position, const value_type& x);\n    iterator insert(const_iterator position, size_type n, const value_type& x);\n    template <class InputIterator>\n        iterator insert(const_iterator position, InputIterator first, InputIterator last);\n    iterator insert(const_iterator position, initializer_list<value_type> il);\n\n    iterator erase(const_iterator position);\n    iterator erase(const_iterator first, const_iterator last);\n\n    void clear() noexcept;\n\n    void resize(size_type sz);\n    void resize(size_type sz, value_type x);\n\n    void swap(vector&)\n        noexcept(allocator_traits<allocator_type>::propagate_on_container_swap::value ||\n                 allocator_traits<allocator_type>::is_always_equal::value);  // C++17\n    void flip() noexcept;\n\n    bool __invariants() const;\n};\n\ntemplate <class Allocator> struct hash<std::vector<bool, Allocator>>;\n\ntemplate <class T, class Allocator> bool operator==(const vector<T,Allocator>& x, const vector<T,Allocator>& y);\ntemplate <class T, class Allocator> bool operator< (const vector<T,Allocator>& x, const vector<T,Allocator>& y);\ntemplate <class T, class Allocator> bool operator!=(const vector<T,Allocator>& x, const vector<T,Allocator>& y);\ntemplate <class T, class Allocator> bool operator> (const vector<T,Allocator>& x, const vector<T,Allocator>& y);\ntemplate <class T, class Allocator> bool operator>=(const vector<T,Allocator>& x, const vector<T,Allocator>& y);\ntemplate <class T, class Allocator> bool operator<=(const vector<T,Allocator>& x, const vector<T,Allocator>& y);\n\ntemplate <class T, class Allocator>\nvoid swap(vector<T,Allocator>& x, vector<T,Allocator>& y)\n    noexcept(noexcept(x.swap(y)));\n\n}  // std\n\n*/\n\n#include <__config>\n#include <iosfwd> // for forward declaration of vector\n#include <__bit_reference>\n#include <type_traits>\n#include <climits>\n#include <limits>\n#include <initializer_list>\n#include <memory>\n#include <stdexcept>\n#include <algorithm>\n#include <cstring>\n#include <__split_buffer>\n#include <__functional_base>\n\n#include <__undef_min_max>\n\n#include <__debug>\n\n#if !defined(_LIBCPP_HAS_NO_PRAGMA_SYSTEM_HEADER)\n#pragma GCC system_header\n#endif\n\n_LIBCPP_BEGIN_NAMESPACE_STD\n\ntemplate <bool>\nclass __vector_base_common\n{\nprotected:\n    _LIBCPP_ALWAYS_INLINE __vector_base_common() {}\n    _LIBCPP_NORETURN void __throw_length_error() const;\n    _LIBCPP_NORETURN void __throw_out_of_range() const;\n};\n\ntemplate <bool __b>\nvoid\n__vector_base_common<__b>::__throw_length_error() const\n{\n    _VSTD::__throw_length_error(\"vector\");\n}\n\ntemplate <bool __b>\nvoid\n__vector_base_common<__b>::__throw_out_of_range() const\n{\n    _VSTD::__throw_out_of_range(\"vector\");\n}\n\n#ifdef _LIBCPP_MSVC\n#pragma warning( push )\n#pragma warning( disable: 4231 )\n#endif // _LIBCPP_MSVC\n_LIBCPP_EXTERN_TEMPLATE(class _LIBCPP_EXTERN_TEMPLATE_TYPE_VIS __vector_base_common<true>)\n#ifdef _LIBCPP_MSVC\n#pragma warning( pop )\n#endif // _LIBCPP_MSVC\n\ntemplate <class _Tp, class _Allocator>\nclass __vector_base\n    : protected __vector_base_common<true>\n{\nprotected:\n    typedef _Tp                                      value_type;\n    typedef _Allocator                               allocator_type;\n    typedef allocator_traits<allocator_type>         __alloc_traits;\n    typedef value_type&                              reference;\n    typedef const value_type&                        const_reference;\n    typedef typename __alloc_traits::size_type       size_type;\n    typedef typename __alloc_traits::difference_type difference_type;\n    typedef typename __alloc_traits::pointer         pointer;\n    typedef typename __alloc_traits::const_pointer   const_pointer;\n    typedef pointer                                  iterator;\n    typedef const_pointer                            const_iterator;\n\n    pointer                                         __begin_;\n    pointer                                         __end_;\n    __compressed_pair<pointer, allocator_type> __end_cap_;\n\n    _LIBCPP_INLINE_VISIBILITY\n    allocator_type& __alloc() _NOEXCEPT\n        {return __end_cap_.second();}\n    _LIBCPP_INLINE_VISIBILITY\n    const allocator_type& __alloc() const _NOEXCEPT\n        {return __end_cap_.second();}\n    _LIBCPP_INLINE_VISIBILITY\n    pointer& __end_cap() _NOEXCEPT\n        {return __end_cap_.first();}\n    _LIBCPP_INLINE_VISIBILITY\n    const pointer& __end_cap() const _NOEXCEPT\n        {return __end_cap_.first();}\n\n    _LIBCPP_INLINE_VISIBILITY\n    __vector_base()\n        _NOEXCEPT_(is_nothrow_default_constructible<allocator_type>::value);\n    _LIBCPP_INLINE_VISIBILITY __vector_base(const allocator_type& __a);\n    ~__vector_base();\n\n    _LIBCPP_INLINE_VISIBILITY\n    void clear() _NOEXCEPT {__destruct_at_end(__begin_);}\n    _LIBCPP_INLINE_VISIBILITY\n    size_type capacity() const _NOEXCEPT\n        {return static_cast<size_type>(__end_cap() - __begin_);}\n\n    _LIBCPP_INLINE_VISIBILITY\n    void __destruct_at_end(pointer __new_last) _NOEXCEPT;\n\n    _LIBCPP_INLINE_VISIBILITY\n    void __copy_assign_alloc(const __vector_base& __c)\n        {__copy_assign_alloc(__c, integral_constant<bool,\n                      __alloc_traits::propagate_on_container_copy_assignment::value>());}\n\n    _LIBCPP_INLINE_VISIBILITY\n    void __move_assign_alloc(__vector_base& __c)\n        _NOEXCEPT_(\n            !__alloc_traits::propagate_on_container_move_assignment::value ||\n            is_nothrow_move_assignable<allocator_type>::value)\n        {__move_assign_alloc(__c, integral_constant<bool,\n                      __alloc_traits::propagate_on_container_move_assignment::value>());}\nprivate:\n    _LIBCPP_INLINE_VISIBILITY\n    void __copy_assign_alloc(const __vector_base& __c, true_type)\n        {\n            if (__alloc() != __c.__alloc())\n            {\n                clear();\n                __alloc_traits::deallocate(__alloc(), __begin_, capacity());\n                __begin_ = __end_ = __end_cap() = nullptr;\n            }\n            __alloc() = __c.__alloc();\n        }\n\n    _LIBCPP_INLINE_VISIBILITY\n    void __copy_assign_alloc(const __vector_base&, false_type)\n        {}\n\n    _LIBCPP_INLINE_VISIBILITY\n    void __move_assign_alloc(__vector_base& __c, true_type)\n        _NOEXCEPT_(is_nothrow_move_assignable<allocator_type>::value)\n        {\n            __alloc() = _VSTD::move(__c.__alloc());\n        }\n\n    _LIBCPP_INLINE_VISIBILITY\n    void __move_assign_alloc(__vector_base&, false_type)\n        _NOEXCEPT\n        {}\n};\n\ntemplate <class _Tp, class _Allocator>\ninline _LIBCPP_INLINE_VISIBILITY\nvoid\n__vector_base<_Tp, _Allocator>::__destruct_at_end(pointer __new_last) _NOEXCEPT\n{\n    while (__new_last != __end_)\n        __alloc_traits::destroy(__alloc(), _VSTD::__to_raw_pointer(--__end_));\n}\n\ntemplate <class _Tp, class _Allocator>\ninline _LIBCPP_INLINE_VISIBILITY\n__vector_base<_Tp, _Allocator>::__vector_base()\n        _NOEXCEPT_(is_nothrow_default_constructible<allocator_type>::value)\n    : __begin_(nullptr),\n      __end_(nullptr),\n      __end_cap_(nullptr)\n{\n}\n\ntemplate <class _Tp, class _Allocator>\ninline _LIBCPP_INLINE_VISIBILITY\n__vector_base<_Tp, _Allocator>::__vector_base(const allocator_type& __a)\n    : __begin_(nullptr),\n      __end_(nullptr),\n      __end_cap_(nullptr, __a)\n{\n}\n\ntemplate <class _Tp, class _Allocator>\n__vector_base<_Tp, _Allocator>::~__vector_base()\n{\n    if (__begin_ != nullptr)\n    {\n        clear();\n        __alloc_traits::deallocate(__alloc(), __begin_, capacity());\n    }\n}\n\ntemplate <class _Tp, class _Allocator /* = allocator<_Tp> */>\nclass _LIBCPP_TEMPLATE_VIS vector\n    : private __vector_base<_Tp, _Allocator>\n{\nprivate:\n    typedef __vector_base<_Tp, _Allocator>           __base;\n    typedef allocator<_Tp>                           __default_allocator_type;\npublic:\n    typedef vector                                   __self;\n    typedef _Tp                                      value_type;\n    typedef _Allocator                               allocator_type;\n    typedef typename __base::__alloc_traits          __alloc_traits;\n    typedef typename __base::reference               reference;\n    typedef typename __base::const_reference         const_reference;\n    typedef typename __base::size_type               size_type;\n    typedef typename __base::difference_type         difference_type;\n    typedef typename __base::pointer                 pointer;\n    typedef typename __base::const_pointer           const_pointer;\n    typedef __wrap_iter<pointer>                     iterator;\n    typedef __wrap_iter<const_pointer>               const_iterator;\n    typedef _VSTD::reverse_iterator<iterator>         reverse_iterator;\n    typedef _VSTD::reverse_iterator<const_iterator>   const_reverse_iterator;\n\n    static_assert((is_same<typename allocator_type::value_type, value_type>::value),\n                  \"Allocator::value_type must be same type as value_type\");\n\n    _LIBCPP_INLINE_VISIBILITY\n    vector() _NOEXCEPT_(is_nothrow_default_constructible<allocator_type>::value)\n        {\n#if _LIBCPP_DEBUG_LEVEL >= 2\n            __get_db()->__insert_c(this);\n#endif\n        }\n    _LIBCPP_INLINE_VISIBILITY explicit vector(const allocator_type& __a)\n#if _LIBCPP_STD_VER <= 14\n        _NOEXCEPT_(is_nothrow_copy_constructible<allocator_type>::value)\n#else\n        _NOEXCEPT\n#endif\n        : __base(__a)\n    {\n#if _LIBCPP_DEBUG_LEVEL >= 2\n        __get_db()->__insert_c(this);\n#endif\n    }\n    explicit vector(size_type __n);\n#if _LIBCPP_STD_VER > 11\n    explicit vector(size_type __n, const allocator_type& __a);\n#endif\n    vector(size_type __n, const_reference __x);\n    vector(size_type __n, const_reference __x, const allocator_type& __a);\n    template <class _InputIterator>\n        vector(_InputIterator __first,\n               typename enable_if<__is_input_iterator  <_InputIterator>::value &&\n                                 !__is_forward_iterator<_InputIterator>::value &&\n                                 is_constructible<\n                                    value_type,\n                                    typename iterator_traits<_InputIterator>::reference>::value,\n                                 _InputIterator>::type __last);\n    template <class _InputIterator>\n        vector(_InputIterator __first, _InputIterator __last, const allocator_type& __a,\n               typename enable_if<__is_input_iterator  <_InputIterator>::value &&\n                                 !__is_forward_iterator<_InputIterator>::value &&\n                                 is_constructible<\n                                    value_type,\n                                    typename iterator_traits<_InputIterator>::reference>::value>::type* = 0);\n    template <class _ForwardIterator>\n        vector(_ForwardIterator __first,\n               typename enable_if<__is_forward_iterator<_ForwardIterator>::value &&\n                                 is_constructible<\n                                    value_type,\n                                    typename iterator_traits<_ForwardIterator>::reference>::value,\n                                 _ForwardIterator>::type __last);\n    template <class _ForwardIterator>\n        vector(_ForwardIterator __first, _ForwardIterator __last, const allocator_type& __a,\n               typename enable_if<__is_forward_iterator<_ForwardIterator>::value &&\n                                 is_constructible<\n                                    value_type,\n                                    typename iterator_traits<_ForwardIterator>::reference>::value>::type* = 0);\n#ifndef _LIBCPP_HAS_NO_GENERALIZED_INITIALIZERS\n    _LIBCPP_INLINE_VISIBILITY\n    vector(initializer_list<value_type> __il);\n    _LIBCPP_INLINE_VISIBILITY\n    vector(initializer_list<value_type> __il, const allocator_type& __a);\n#endif  // _LIBCPP_HAS_NO_GENERALIZED_INITIALIZERS\n#if _LIBCPP_DEBUG_LEVEL >= 2\n    _LIBCPP_INLINE_VISIBILITY\n    ~vector()\n    {\n        __get_db()->__erase_c(this);\n    }\n#endif\n\n    vector(const vector& __x);\n    vector(const vector& __x, const allocator_type& __a);\n    _LIBCPP_INLINE_VISIBILITY\n    vector& operator=(const vector& __x);\n#ifndef _LIBCPP_HAS_NO_RVALUE_REFERENCES\n    _LIBCPP_INLINE_VISIBILITY\n    vector(vector&& __x)\n#if _LIBCPP_STD_VER > 14\n        _NOEXCEPT;\n#else\n        _NOEXCEPT_(is_nothrow_move_constructible<allocator_type>::value);\n#endif\n    _LIBCPP_INLINE_VISIBILITY\n    vector(vector&& __x, const allocator_type& __a);\n    _LIBCPP_INLINE_VISIBILITY\n    vector& operator=(vector&& __x)\n        _NOEXCEPT_((__noexcept_move_assign_container<_Allocator, __alloc_traits>::value));\n#endif  // _LIBCPP_HAS_NO_RVALUE_REFERENCES\n#ifndef _LIBCPP_HAS_NO_GENERALIZED_INITIALIZERS\n    _LIBCPP_INLINE_VISIBILITY\n    vector& operator=(initializer_list<value_type> __il)\n        {assign(__il.begin(), __il.end()); return *this;}\n#endif  // _LIBCPP_HAS_NO_GENERALIZED_INITIALIZERS\n\n    template <class _InputIterator>\n        typename enable_if\n        <\n             __is_input_iterator  <_InputIterator>::value &&\n            !__is_forward_iterator<_InputIterator>::value &&\n            is_constructible<\n                 value_type,\n                 typename iterator_traits<_InputIterator>::reference>::value,\n            void\n        >::type\n        assign(_InputIterator __first, _InputIterator __last);\n    template <class _ForwardIterator>\n        typename enable_if\n        <\n            __is_forward_iterator<_ForwardIterator>::value &&\n            is_constructible<\n                 value_type,\n                 typename iterator_traits<_ForwardIterator>::reference>::value,\n            void\n        >::type\n        assign(_ForwardIterator __first, _ForwardIterator __last);\n\n    void assign(size_type __n, const_reference __u);\n#ifndef _LIBCPP_HAS_NO_GENERALIZED_INITIALIZERS\n    _LIBCPP_INLINE_VISIBILITY\n    void assign(initializer_list<value_type> __il)\n        {assign(__il.begin(), __il.end());}\n#endif  // _LIBCPP_HAS_NO_GENERALIZED_INITIALIZERS\n\n    _LIBCPP_INLINE_VISIBILITY\n    allocator_type get_allocator() const _NOEXCEPT\n        {return this->__alloc();}\n\n    _LIBCPP_INLINE_VISIBILITY iterator               begin() _NOEXCEPT;\n    _LIBCPP_INLINE_VISIBILITY const_iterator         begin()   const _NOEXCEPT;\n    _LIBCPP_INLINE_VISIBILITY iterator               end() _NOEXCEPT;\n    _LIBCPP_INLINE_VISIBILITY const_iterator         end()     const _NOEXCEPT;\n\n    _LIBCPP_INLINE_VISIBILITY\n    reverse_iterator       rbegin() _NOEXCEPT\n        {return       reverse_iterator(end());}\n    _LIBCPP_INLINE_VISIBILITY\n    const_reverse_iterator rbegin()  const _NOEXCEPT\n        {return const_reverse_iterator(end());}\n    _LIBCPP_INLINE_VISIBILITY\n    reverse_iterator       rend() _NOEXCEPT\n        {return       reverse_iterator(begin());}\n    _LIBCPP_INLINE_VISIBILITY\n    const_reverse_iterator rend()    const _NOEXCEPT\n        {return const_reverse_iterator(begin());}\n\n    _LIBCPP_INLINE_VISIBILITY\n    const_iterator         cbegin()  const _NOEXCEPT\n        {return begin();}\n    _LIBCPP_INLINE_VISIBILITY\n    const_iterator         cend()    const _NOEXCEPT\n        {return end();}\n    _LIBCPP_INLINE_VISIBILITY\n    const_reverse_iterator crbegin() const _NOEXCEPT\n        {return rbegin();}\n    _LIBCPP_INLINE_VISIBILITY\n    const_reverse_iterator crend()   const _NOEXCEPT\n        {return rend();}\n\n    _LIBCPP_INLINE_VISIBILITY\n    size_type size() const _NOEXCEPT\n        {return static_cast<size_type>(this->__end_ - this->__begin_);}\n    _LIBCPP_INLINE_VISIBILITY\n    size_type capacity() const _NOEXCEPT\n        {return __base::capacity();}\n    _LIBCPP_INLINE_VISIBILITY\n    bool empty() const _NOEXCEPT\n        {return this->__begin_ == this->__end_;}\n    size_type max_size() const _NOEXCEPT;\n    void reserve(size_type __n);\n    void shrink_to_fit() _NOEXCEPT;\n\n    _LIBCPP_INLINE_VISIBILITY reference       operator[](size_type __n);\n    _LIBCPP_INLINE_VISIBILITY const_reference operator[](size_type __n) const;\n    reference       at(size_type __n);\n    const_reference at(size_type __n) const;\n\n    _LIBCPP_INLINE_VISIBILITY reference       front()\n    {\n        _LIBCPP_ASSERT(!empty(), \"front() called for empty vector\");\n        return *this->__begin_;\n    }\n    _LIBCPP_INLINE_VISIBILITY const_reference front() const\n    {\n        _LIBCPP_ASSERT(!empty(), \"front() called for empty vector\");\n        return *this->__begin_;\n    }\n    _LIBCPP_INLINE_VISIBILITY reference       back()\n    {\n        _LIBCPP_ASSERT(!empty(), \"back() called for empty vector\");\n        return *(this->__end_ - 1);\n    }\n    _LIBCPP_INLINE_VISIBILITY const_reference back()  const\n    {\n        _LIBCPP_ASSERT(!empty(), \"back() called for empty vector\");\n        return *(this->__end_ - 1);\n    }\n\n    _LIBCPP_INLINE_VISIBILITY\n    value_type*       data() _NOEXCEPT\n        {return _VSTD::__to_raw_pointer(this->__begin_);}\n    _LIBCPP_INLINE_VISIBILITY\n    const value_type* data() const _NOEXCEPT\n        {return _VSTD::__to_raw_pointer(this->__begin_);}\n\n    _LIBCPP_INLINE_VISIBILITY void push_back(const_reference __x);\n#ifndef _LIBCPP_HAS_NO_RVALUE_REFERENCES\n    _LIBCPP_INLINE_VISIBILITY void push_back(value_type&& __x);\n#ifndef _LIBCPP_HAS_NO_VARIADICS\n    template <class... _Args>\n        _LIBCPP_INLINE_VISIBILITY\n#if _LIBCPP_STD_VER > 14\n        reference emplace_back(_Args&&... __args);\n#else\n        void      emplace_back(_Args&&... __args);\n#endif\n#endif  // _LIBCPP_HAS_NO_VARIADICS\n#endif  // _LIBCPP_HAS_NO_RVALUE_REFERENCES\n    _LIBCPP_INLINE_VISIBILITY\n    void pop_back();\n\n    iterator insert(const_iterator __position, const_reference __x);\n#ifndef _LIBCPP_HAS_NO_RVALUE_REFERENCES\n    iterator insert(const_iterator __position, value_type&& __x);\n#ifndef _LIBCPP_HAS_NO_VARIADICS\n    template <class... _Args>\n        iterator emplace(const_iterator __position, _Args&&... __args);\n#endif  // _LIBCPP_HAS_NO_VARIADICS\n#endif  // _LIBCPP_HAS_NO_RVALUE_REFERENCES\n    iterator insert(const_iterator __position, size_type __n, const_reference __x);\n    template <class _InputIterator>\n        typename enable_if\n        <\n             __is_input_iterator  <_InputIterator>::value &&\n            !__is_forward_iterator<_InputIterator>::value &&\n            is_constructible<\n                 value_type,\n                 typename iterator_traits<_InputIterator>::reference>::value,\n            iterator\n        >::type\n        insert(const_iterator __position, _InputIterator __first, _InputIterator __last);\n    template <class _ForwardIterator>\n        typename enable_if\n        <\n            __is_forward_iterator<_ForwardIterator>::value &&\n            is_constructible<\n                 value_type,\n                 typename iterator_traits<_ForwardIterator>::reference>::value,\n            iterator\n        >::type\n        insert(const_iterator __position, _ForwardIterator __first, _ForwardIterator __last);\n#ifndef _LIBCPP_HAS_NO_GENERALIZED_INITIALIZERS\n    _LIBCPP_INLINE_VISIBILITY\n    iterator insert(const_iterator __position, initializer_list<value_type> __il)\n        {return insert(__position, __il.begin(), __il.end());}\n#endif  // _LIBCPP_HAS_NO_GENERALIZED_INITIALIZERS\n\n    _LIBCPP_INLINE_VISIBILITY iterator erase(const_iterator __position);\n    iterator erase(const_iterator __first, const_iterator __last);\n\n    _LIBCPP_INLINE_VISIBILITY\n    void clear() _NOEXCEPT\n    {\n        size_type __old_size = size();\n        __base::clear();\n        __annotate_shrink(__old_size);\n        __invalidate_all_iterators();\n    }\n\n    void resize(size_type __sz);\n    void resize(size_type __sz, const_reference __x);\n\n    void swap(vector&)\n#if _LIBCPP_STD_VER >= 14\n        _NOEXCEPT_DEBUG;\n#else\n        _NOEXCEPT_DEBUG_(!__alloc_traits::propagate_on_container_swap::value ||\n                    __is_nothrow_swappable<allocator_type>::value);\n#endif\n\n    bool __invariants() const;\n\n#if _LIBCPP_DEBUG_LEVEL >= 2\n\n    bool __dereferenceable(const const_iterator* __i) const;\n    bool __decrementable(const const_iterator* __i) const;\n    bool __addable(const const_iterator* __i, ptrdiff_t __n) const;\n    bool __subscriptable(const const_iterator* __i, ptrdiff_t __n) const;\n\n#endif  // _LIBCPP_DEBUG_LEVEL >= 2\n\nprivate:\n    _LIBCPP_INLINE_VISIBILITY void __invalidate_all_iterators();\n    _LIBCPP_INLINE_VISIBILITY void __invalidate_iterators_past(pointer __new_last);\n    void allocate(size_type __n);\n    void deallocate() _NOEXCEPT;\n    _LIBCPP_INLINE_VISIBILITY size_type __recommend(size_type __new_size) const;\n    void __construct_at_end(size_type __n);\n    _LIBCPP_INLINE_VISIBILITY\n    void __construct_at_end(size_type __n, const_reference __x);\n    template <class _ForwardIterator>\n        typename enable_if\n        <\n            __is_forward_iterator<_ForwardIterator>::value,\n            void\n        >::type\n        __construct_at_end(_ForwardIterator __first, _ForwardIterator __last, size_type __n);\n    void __append(size_type __n);\n    void __append(size_type __n, const_reference __x);\n    _LIBCPP_INLINE_VISIBILITY\n    iterator       __make_iter(pointer __p) _NOEXCEPT;\n    _LIBCPP_INLINE_VISIBILITY\n    const_iterator __make_iter(const_pointer __p) const _NOEXCEPT;\n    void __swap_out_circular_buffer(__split_buffer<value_type, allocator_type&>& __v);\n    pointer __swap_out_circular_buffer(__split_buffer<value_type, allocator_type&>& __v, pointer __p);\n    void __move_range(pointer __from_s, pointer __from_e, pointer __to);\n    void __move_assign(vector& __c, true_type)\n        _NOEXCEPT_(is_nothrow_move_assignable<allocator_type>::value);\n    void __move_assign(vector& __c, false_type)\n        _NOEXCEPT_(__alloc_traits::is_always_equal::value);\n    _LIBCPP_INLINE_VISIBILITY\n    void __destruct_at_end(pointer __new_last) _NOEXCEPT\n    {\n        __invalidate_iterators_past(__new_last);\n        size_type __old_size = size();\n        __base::__destruct_at_end(__new_last);\n        __annotate_shrink(__old_size);\n    }\n    template <class _Up>\n        void\n#ifndef _LIBCPP_HAS_NO_RVALUE_REFERENCES\n        __push_back_slow_path(_Up&& __x);\n#else\n        __push_back_slow_path(_Up& __x);\n#endif\n#if !defined(_LIBCPP_HAS_NO_VARIADICS) && !defined(_LIBCPP_HAS_NO_RVALUE_REFERENCES)\n    template <class... _Args>\n        void\n        __emplace_back_slow_path(_Args&&... __args);\n#endif\n    // The following functions are no-ops outside of AddressSanitizer mode.\n    // We call annotatations only for the default Allocator because other allocators\n    // may not meet the AddressSanitizer alignment constraints.\n    // See the documentation for __sanitizer_annotate_contiguous_container for more details.\n#ifndef _LIBCPP_HAS_NO_ASAN\n    void __annotate_contiguous_container(const void *__beg, const void *__end,\n                                         const void *__old_mid,\n                                         const void *__new_mid) const\n    {\n\n      if (__beg && is_same<allocator_type, __default_allocator_type>::value)\n        __sanitizer_annotate_contiguous_container(__beg, __end, __old_mid, __new_mid);\n    }\n#else\n    _LIBCPP_INLINE_VISIBILITY\n    void __annotate_contiguous_container(const void*, const void*, const void*,\n                                         const void*) const {}\n#endif\n    _LIBCPP_INLINE_VISIBILITY\n    void __annotate_new(size_type __current_size) const {\n      __annotate_contiguous_container(data(), data() + capacity(),\n                                      data() + capacity(), data() + __current_size);\n    }\n\n    _LIBCPP_INLINE_VISIBILITY\n    void __annotate_delete() const {\n      __annotate_contiguous_container(data(), data() + capacity(),\n                                      data() + size(), data() + capacity());\n    }\n\n    _LIBCPP_INLINE_VISIBILITY\n    void __annotate_increase(size_type __n) const\n    {\n      __annotate_contiguous_container(data(), data() + capacity(),\n                                      data() + size(), data() + size() + __n);\n    }\n\n    _LIBCPP_INLINE_VISIBILITY\n    void __annotate_shrink(size_type __old_size) const\n    {\n      __annotate_contiguous_container(data(), data() + capacity(),\n                                      data() + __old_size, data() + size());\n    }\n#ifndef _LIBCPP_HAS_NO_ASAN\n    // The annotation for size increase should happen before the actual increase,\n    // but if an exception is thrown after that the annotation has to be undone.\n    struct __RAII_IncreaseAnnotator {\n      __RAII_IncreaseAnnotator(const vector &__v, size_type __n = 1)\n        : __commit(false), __v(__v), __old_size(__v.size() + __n) {\n        __v.__annotate_increase(__n);\n      }\n      void __done() { __commit = true; }\n      ~__RAII_IncreaseAnnotator() {\n        if (__commit) return;\n        __v.__annotate_shrink(__old_size);\n      }\n      bool __commit;\n      const vector &__v;\n      size_type __old_size;\n    };\n#else\n    struct __RAII_IncreaseAnnotator {\n      _LIBCPP_INLINE_VISIBILITY\n      __RAII_IncreaseAnnotator(const vector &, size_type = 1) {}\n      _LIBCPP_INLINE_VISIBILITY void __done() {}\n    };\n#endif\n\n};\n\ntemplate <class _Tp, class _Allocator>\nvoid\nvector<_Tp, _Allocator>::__swap_out_circular_buffer(__split_buffer<value_type, allocator_type&>& __v)\n{\n    __annotate_delete();\n    __alloc_traits::__construct_backward(this->__alloc(), this->__begin_, this->__end_, __v.__begin_);\n    _VSTD::swap(this->__begin_, __v.__begin_);\n    _VSTD::swap(this->__end_, __v.__end_);\n    _VSTD::swap(this->__end_cap(), __v.__end_cap());\n    __v.__first_ = __v.__begin_;\n    __annotate_new(size());\n    __invalidate_all_iterators();\n}\n\ntemplate <class _Tp, class _Allocator>\ntypename vector<_Tp, _Allocator>::pointer\nvector<_Tp, _Allocator>::__swap_out_circular_buffer(__split_buffer<value_type, allocator_type&>& __v, pointer __p)\n{\n    __annotate_delete();\n    pointer __r = __v.__begin_;\n    __alloc_traits::__construct_backward(this->__alloc(), this->__begin_, __p, __v.__begin_);\n    __alloc_traits::__construct_forward(this->__alloc(), __p, this->__end_, __v.__end_);\n    _VSTD::swap(this->__begin_, __v.__begin_);\n    _VSTD::swap(this->__end_, __v.__end_);\n    _VSTD::swap(this->__end_cap(), __v.__end_cap());\n    __v.__first_ = __v.__begin_;\n    __annotate_new(size());\n    __invalidate_all_iterators();\n    return __r;\n}\n\n//  Allocate space for __n objects\n//  throws length_error if __n > max_size()\n//  throws (probably bad_alloc) if memory run out\n//  Precondition:  __begin_ == __end_ == __end_cap() == 0\n//  Precondition:  __n > 0\n//  Postcondition:  capacity() == __n\n//  Postcondition:  size() == 0\ntemplate <class _Tp, class _Allocator>\nvoid\nvector<_Tp, _Allocator>::allocate(size_type __n)\n{\n    if (__n > max_size())\n        this->__throw_length_error();\n    this->__begin_ = this->__end_ = __alloc_traits::allocate(this->__alloc(), __n);\n    this->__end_cap() = this->__begin_ + __n;\n    __annotate_new(0);\n}\n\ntemplate <class _Tp, class _Allocator>\nvoid\nvector<_Tp, _Allocator>::deallocate() _NOEXCEPT\n{\n    if (this->__begin_ != nullptr)\n    {\n        clear();\n        __alloc_traits::deallocate(this->__alloc(), this->__begin_, capacity());\n        this->__begin_ = this->__end_ = this->__end_cap() = nullptr;\n    }\n}\n\ntemplate <class _Tp, class _Allocator>\ntypename vector<_Tp, _Allocator>::size_type\nvector<_Tp, _Allocator>::max_size() const _NOEXCEPT\n{\n    return _VSTD::min<size_type>(__alloc_traits::max_size(this->__alloc()),\n                                 numeric_limits<difference_type>::max());\n}\n\n//  Precondition:  __new_size > capacity()\ntemplate <class _Tp, class _Allocator>\ninline _LIBCPP_INLINE_VISIBILITY\ntypename vector<_Tp, _Allocator>::size_type\nvector<_Tp, _Allocator>::__recommend(size_type __new_size) const\n{\n    const size_type __ms = max_size();\n    if (__new_size > __ms)\n        this->__throw_length_error();\n    const size_type __cap = capacity();\n    if (__cap >= __ms / 2)\n        return __ms;\n    return _VSTD::max<size_type>(2*__cap, __new_size);\n}\n\n//  Default constructs __n objects starting at __end_\n//  throws if construction throws\n//  Precondition:  __n > 0\n//  Precondition:  size() + __n <= capacity()\n//  Postcondition:  size() == size() + __n\ntemplate <class _Tp, class _Allocator>\nvoid\nvector<_Tp, _Allocator>::__construct_at_end(size_type __n)\n{\n    allocator_type& __a = this->__alloc();\n    do\n    {\n        __RAII_IncreaseAnnotator __annotator(*this);\n        __alloc_traits::construct(__a, _VSTD::__to_raw_pointer(this->__end_));\n        ++this->__end_;\n        --__n;\n        __annotator.__done();\n    } while (__n > 0);\n}\n\n//  Copy constructs __n objects starting at __end_ from __x\n//  throws if construction throws\n//  Precondition:  __n > 0\n//  Precondition:  size() + __n <= capacity()\n//  Postcondition:  size() == old size() + __n\n//  Postcondition:  [i] == __x for all i in [size() - __n, __n)\ntemplate <class _Tp, class _Allocator>\ninline\nvoid\nvector<_Tp, _Allocator>::__construct_at_end(size_type __n, const_reference __x)\n{\n    allocator_type& __a = this->__alloc();\n    do\n    {\n        __RAII_IncreaseAnnotator __annotator(*this);\n        __alloc_traits::construct(__a, _VSTD::__to_raw_pointer(this->__end_), __x);\n        ++this->__end_;\n        --__n;\n        __annotator.__done();\n    } while (__n > 0);\n}\n\ntemplate <class _Tp, class _Allocator>\ntemplate <class _ForwardIterator>\ntypename enable_if\n<\n    __is_forward_iterator<_ForwardIterator>::value,\n    void\n>::type\nvector<_Tp, _Allocator>::__construct_at_end(_ForwardIterator __first, _ForwardIterator __last, size_type __n)\n{\n    allocator_type& __a = this->__alloc();\n    __RAII_IncreaseAnnotator __annotator(*this, __n);\n    __alloc_traits::__construct_range_forward(__a, __first, __last, this->__end_);\n    __annotator.__done();\n}\n\n//  Default constructs __n objects starting at __end_\n//  throws if construction throws\n//  Postcondition:  size() == size() + __n\n//  Exception safety: strong.\ntemplate <class _Tp, class _Allocator>\nvoid\nvector<_Tp, _Allocator>::__append(size_type __n)\n{\n    if (static_cast<size_type>(this->__end_cap() - this->__end_) >= __n)\n        this->__construct_at_end(__n);\n    else\n    {\n        allocator_type& __a = this->__alloc();\n        __split_buffer<value_type, allocator_type&> __v(__recommend(size() + __n), size(), __a);\n        __v.__construct_at_end(__n);\n        __swap_out_circular_buffer(__v);\n    }\n}\n\n//  Default constructs __n objects starting at __end_\n//  throws if construction throws\n//  Postcondition:  size() == size() + __n\n//  Exception safety: strong.\ntemplate <class _Tp, class _Allocator>\nvoid\nvector<_Tp, _Allocator>::__append(size_type __n, const_reference __x)\n{\n    if (static_cast<size_type>(this->__end_cap() - this->__end_) >= __n)\n        this->__construct_at_end(__n, __x);\n    else\n    {\n        allocator_type& __a = this->__alloc();\n        __split_buffer<value_type, allocator_type&> __v(__recommend(size() + __n), size(), __a);\n        __v.__construct_at_end(__n, __x);\n        __swap_out_circular_buffer(__v);\n    }\n}\n\ntemplate <class _Tp, class _Allocator>\nvector<_Tp, _Allocator>::vector(size_type __n)\n{\n#if _LIBCPP_DEBUG_LEVEL >= 2\n    __get_db()->__insert_c(this);\n#endif\n    if (__n > 0)\n    {\n        allocate(__n);\n        __construct_at_end(__n);\n    }\n}\n\n#if _LIBCPP_STD_VER > 11\ntemplate <class _Tp, class _Allocator>\nvector<_Tp, _Allocator>::vector(size_type __n, const allocator_type& __a)\n    : __base(__a)\n{\n#if _LIBCPP_DEBUG_LEVEL >= 2\n    __get_db()->__insert_c(this);\n#endif\n    if (__n > 0)\n    {\n        allocate(__n);\n        __construct_at_end(__n);\n    }\n}\n#endif\n\ntemplate <class _Tp, class _Allocator>\nvector<_Tp, _Allocator>::vector(size_type __n, const_reference __x)\n{\n#if _LIBCPP_DEBUG_LEVEL >= 2\n    __get_db()->__insert_c(this);\n#endif\n    if (__n > 0)\n    {\n        allocate(__n);\n        __construct_at_end(__n, __x);\n    }\n}\n\ntemplate <class _Tp, class _Allocator>\nvector<_Tp, _Allocator>::vector(size_type __n, const_reference __x, const allocator_type& __a)\n    : __base(__a)\n{\n#if _LIBCPP_DEBUG_LEVEL >= 2\n    __get_db()->__insert_c(this);\n#endif\n    if (__n > 0)\n    {\n        allocate(__n);\n        __construct_at_end(__n, __x);\n    }\n}\n\ntemplate <class _Tp, class _Allocator>\ntemplate <class _InputIterator>\nvector<_Tp, _Allocator>::vector(_InputIterator __first,\n       typename enable_if<__is_input_iterator  <_InputIterator>::value &&\n                         !__is_forward_iterator<_InputIterator>::value &&\n                         is_constructible<\n                            value_type,\n                            typename iterator_traits<_InputIterator>::reference>::value,\n                          _InputIterator>::type __last)\n{\n#if _LIBCPP_DEBUG_LEVEL >= 2\n    __get_db()->__insert_c(this);\n#endif\n    for (; __first != __last; ++__first)\n        push_back(*__first);\n}\n\ntemplate <class _Tp, class _Allocator>\ntemplate <class _InputIterator>\nvector<_Tp, _Allocator>::vector(_InputIterator __first, _InputIterator __last, const allocator_type& __a,\n       typename enable_if<__is_input_iterator  <_InputIterator>::value &&\n                         !__is_forward_iterator<_InputIterator>::value &&\n                         is_constructible<\n                            value_type,\n                            typename iterator_traits<_InputIterator>::reference>::value>::type*)\n    : __base(__a)\n{\n#if _LIBCPP_DEBUG_LEVEL >= 2\n    __get_db()->__insert_c(this);\n#endif\n    for (; __first != __last; ++__first)\n        push_back(*__first);\n}\n\ntemplate <class _Tp, class _Allocator>\ntemplate <class _ForwardIterator>\nvector<_Tp, _Allocator>::vector(_ForwardIterator __first,\n                                typename enable_if<__is_forward_iterator<_ForwardIterator>::value &&\n                                is_constructible<\n                                   value_type,\n                                   typename iterator_traits<_ForwardIterator>::reference>::value,\n                                                   _ForwardIterator>::type __last)\n{\n#if _LIBCPP_DEBUG_LEVEL >= 2\n    __get_db()->__insert_c(this);\n#endif\n    size_type __n = static_cast<size_type>(_VSTD::distance(__first, __last));\n    if (__n > 0)\n    {\n        allocate(__n);\n        __construct_at_end(__first, __last, __n);\n    }\n}\n\ntemplate <class _Tp, class _Allocator>\ntemplate <class _ForwardIterator>\nvector<_Tp, _Allocator>::vector(_ForwardIterator __first, _ForwardIterator __last, const allocator_type& __a,\n                                typename enable_if<__is_forward_iterator<_ForwardIterator>::value &&\n                                is_constructible<\n                                   value_type,\n                                   typename iterator_traits<_ForwardIterator>::reference>::value>::type*)\n    : __base(__a)\n{\n#if _LIBCPP_DEBUG_LEVEL >= 2\n    __get_db()->__insert_c(this);\n#endif\n    size_type __n = static_cast<size_type>(_VSTD::distance(__first, __last));\n    if (__n > 0)\n    {\n        allocate(__n);\n        __construct_at_end(__first, __last, __n);\n    }\n}\n\ntemplate <class _Tp, class _Allocator>\nvector<_Tp, _Allocator>::vector(const vector& __x)\n    : __base(__alloc_traits::select_on_container_copy_construction(__x.__alloc()))\n{\n#if _LIBCPP_DEBUG_LEVEL >= 2\n    __get_db()->__insert_c(this);\n#endif\n    size_type __n = __x.size();\n    if (__n > 0)\n    {\n        allocate(__n);\n        __construct_at_end(__x.__begin_, __x.__end_, __n);\n    }\n}\n\ntemplate <class _Tp, class _Allocator>\nvector<_Tp, _Allocator>::vector(const vector& __x, const allocator_type& __a)\n    : __base(__a)\n{\n#if _LIBCPP_DEBUG_LEVEL >= 2\n    __get_db()->__insert_c(this);\n#endif\n    size_type __n = __x.size();\n    if (__n > 0)\n    {\n        allocate(__n);\n        __construct_at_end(__x.__begin_, __x.__end_, __n);\n    }\n}\n\n#ifndef _LIBCPP_HAS_NO_RVALUE_REFERENCES\n\ntemplate <class _Tp, class _Allocator>\ninline _LIBCPP_INLINE_VISIBILITY\nvector<_Tp, _Allocator>::vector(vector&& __x)\n#if _LIBCPP_STD_VER > 14\n        _NOEXCEPT\n#else\n        _NOEXCEPT_(is_nothrow_move_constructible<allocator_type>::value)\n#endif\n    : __base(_VSTD::move(__x.__alloc()))\n{\n#if _LIBCPP_DEBUG_LEVEL >= 2\n    __get_db()->__insert_c(this);\n    __get_db()->swap(this, &__x);\n#endif\n    this->__begin_ = __x.__begin_;\n    this->__end_ = __x.__end_;\n    this->__end_cap() = __x.__end_cap();\n    __x.__begin_ = __x.__end_ = __x.__end_cap() = nullptr;\n}\n\ntemplate <class _Tp, class _Allocator>\ninline _LIBCPP_INLINE_VISIBILITY\nvector<_Tp, _Allocator>::vector(vector&& __x, const allocator_type& __a)\n    : __base(__a)\n{\n#if _LIBCPP_DEBUG_LEVEL >= 2\n    __get_db()->__insert_c(this);\n#endif\n    if (__a == __x.__alloc())\n    {\n        this->__begin_ = __x.__begin_;\n        this->__end_ = __x.__end_;\n        this->__end_cap() = __x.__end_cap();\n        __x.__begin_ = __x.__end_ = __x.__end_cap() = nullptr;\n#if _LIBCPP_DEBUG_LEVEL >= 2\n        __get_db()->swap(this, &__x);\n#endif\n    }\n    else\n    {\n        typedef move_iterator<iterator> _Ip;\n        assign(_Ip(__x.begin()), _Ip(__x.end()));\n    }\n}\n\n#ifndef _LIBCPP_HAS_NO_GENERALIZED_INITIALIZERS\n\ntemplate <class _Tp, class _Allocator>\ninline _LIBCPP_INLINE_VISIBILITY\nvector<_Tp, _Allocator>::vector(initializer_list<value_type> __il)\n{\n#if _LIBCPP_DEBUG_LEVEL >= 2\n    __get_db()->__insert_c(this);\n#endif\n    if (__il.size() > 0)\n    {\n        allocate(__il.size());\n        __construct_at_end(__il.begin(), __il.end(), __il.size());\n    }\n}\n\ntemplate <class _Tp, class _Allocator>\ninline _LIBCPP_INLINE_VISIBILITY\nvector<_Tp, _Allocator>::vector(initializer_list<value_type> __il, const allocator_type& __a)\n    : __base(__a)\n{\n#if _LIBCPP_DEBUG_LEVEL >= 2\n    __get_db()->__insert_c(this);\n#endif\n    if (__il.size() > 0)\n    {\n        allocate(__il.size());\n        __construct_at_end(__il.begin(), __il.end(), __il.size());\n    }\n}\n\n#endif  // _LIBCPP_HAS_NO_GENERALIZED_INITIALIZERS\n\ntemplate <class _Tp, class _Allocator>\ninline _LIBCPP_INLINE_VISIBILITY\nvector<_Tp, _Allocator>&\nvector<_Tp, _Allocator>::operator=(vector&& __x)\n    _NOEXCEPT_((__noexcept_move_assign_container<_Allocator, __alloc_traits>::value))\n{\n    __move_assign(__x, integral_constant<bool,\n          __alloc_traits::propagate_on_container_move_assignment::value>());\n    return *this;\n}\n\ntemplate <class _Tp, class _Allocator>\nvoid\nvector<_Tp, _Allocator>::__move_assign(vector& __c, false_type)\n    _NOEXCEPT_(__alloc_traits::is_always_equal::value)\n{\n    if (__base::__alloc() != __c.__alloc())\n    {\n        typedef move_iterator<iterator> _Ip;\n        assign(_Ip(__c.begin()), _Ip(__c.end()));\n    }\n    else\n        __move_assign(__c, true_type());\n}\n\ntemplate <class _Tp, class _Allocator>\nvoid\nvector<_Tp, _Allocator>::__move_assign(vector& __c, true_type)\n    _NOEXCEPT_(is_nothrow_move_assignable<allocator_type>::value)\n{\n    deallocate();\n    __base::__move_assign_alloc(__c); // this can throw\n    this->__begin_ = __c.__begin_;\n    this->__end_ = __c.__end_;\n    this->__end_cap() = __c.__end_cap();\n    __c.__begin_ = __c.__end_ = __c.__end_cap() = nullptr;\n#if _LIBCPP_DEBUG_LEVEL >= 2\n    __get_db()->swap(this, &__c);\n#endif\n}\n\n#endif  // _LIBCPP_HAS_NO_RVALUE_REFERENCES\n\ntemplate <class _Tp, class _Allocator>\ninline _LIBCPP_INLINE_VISIBILITY\nvector<_Tp, _Allocator>&\nvector<_Tp, _Allocator>::operator=(const vector& __x)\n{\n    if (this != &__x)\n    {\n        __base::__copy_assign_alloc(__x);\n        assign(__x.__begin_, __x.__end_);\n    }\n    return *this;\n}\n\ntemplate <class _Tp, class _Allocator>\ntemplate <class _InputIterator>\ntypename enable_if\n<\n     __is_input_iterator  <_InputIterator>::value &&\n    !__is_forward_iterator<_InputIterator>::value &&\n    is_constructible<\n       _Tp,\n       typename iterator_traits<_InputIterator>::reference>::value,\n    void\n>::type\nvector<_Tp, _Allocator>::assign(_InputIterator __first, _InputIterator __last)\n{\n    clear();\n    for (; __first != __last; ++__first)\n        push_back(*__first);\n}\n\ntemplate <class _Tp, class _Allocator>\ntemplate <class _ForwardIterator>\ntypename enable_if\n<\n    __is_forward_iterator<_ForwardIterator>::value &&\n    is_constructible<\n       _Tp,\n       typename iterator_traits<_ForwardIterator>::reference>::value,\n    void\n>::type\nvector<_Tp, _Allocator>::assign(_ForwardIterator __first, _ForwardIterator __last)\n{\n    size_type __new_size = static_cast<size_type>(_VSTD::distance(__first, __last));\n    if (__new_size <= capacity())\n    {\n        _ForwardIterator __mid = __last;\n        bool __growing = false;\n        if (__new_size > size())\n        {\n            __growing = true;\n            __mid =  __first;\n            _VSTD::advance(__mid, size());\n        }\n        pointer __m = _VSTD::copy(__first, __mid, this->__begin_);\n        if (__growing)\n            __construct_at_end(__mid, __last, __new_size - size());\n        else\n            this->__destruct_at_end(__m);\n    }\n    else\n    {\n        deallocate();\n        allocate(__recommend(__new_size));\n        __construct_at_end(__first, __last, __new_size);\n    }\n    __invalidate_all_iterators();\n}\n\ntemplate <class _Tp, class _Allocator>\nvoid\nvector<_Tp, _Allocator>::assign(size_type __n, const_reference __u)\n{\n    if (__n <= capacity())\n    {\n        size_type __s = size();\n        _VSTD::fill_n(this->__begin_, _VSTD::min(__n, __s), __u);\n        if (__n > __s)\n            __construct_at_end(__n - __s, __u);\n        else\n            this->__destruct_at_end(this->__begin_ + __n);\n    }\n    else\n    {\n        deallocate();\n        allocate(__recommend(static_cast<size_type>(__n)));\n        __construct_at_end(__n, __u);\n    }\n    __invalidate_all_iterators();\n}\n\ntemplate <class _Tp, class _Allocator>\ninline _LIBCPP_INLINE_VISIBILITY\ntypename vector<_Tp, _Allocator>::iterator\nvector<_Tp, _Allocator>::__make_iter(pointer __p) _NOEXCEPT\n{\n#if _LIBCPP_DEBUG_LEVEL >= 2\n    return iterator(this, __p);\n#else\n    return iterator(__p);\n#endif\n}\n\ntemplate <class _Tp, class _Allocator>\ninline _LIBCPP_INLINE_VISIBILITY\ntypename vector<_Tp, _Allocator>::const_iterator\nvector<_Tp, _Allocator>::__make_iter(const_pointer __p) const _NOEXCEPT\n{\n#if _LIBCPP_DEBUG_LEVEL >= 2\n    return const_iterator(this, __p);\n#else\n    return const_iterator(__p);\n#endif\n}\n\ntemplate <class _Tp, class _Allocator>\ninline _LIBCPP_INLINE_VISIBILITY\ntypename vector<_Tp, _Allocator>::iterator\nvector<_Tp, _Allocator>::begin() _NOEXCEPT\n{\n    return __make_iter(this->__begin_);\n}\n\ntemplate <class _Tp, class _Allocator>\ninline _LIBCPP_INLINE_VISIBILITY\ntypename vector<_Tp, _Allocator>::const_iterator\nvector<_Tp, _Allocator>::begin() const _NOEXCEPT\n{\n    return __make_iter(this->__begin_);\n}\n\ntemplate <class _Tp, class _Allocator>\ninline _LIBCPP_INLINE_VISIBILITY\ntypename vector<_Tp, _Allocator>::iterator\nvector<_Tp, _Allocator>::end() _NOEXCEPT\n{\n    return __make_iter(this->__end_);\n}\n\ntemplate <class _Tp, class _Allocator>\ninline _LIBCPP_INLINE_VISIBILITY\ntypename vector<_Tp, _Allocator>::const_iterator\nvector<_Tp, _Allocator>::end() const _NOEXCEPT\n{\n    return __make_iter(this->__end_);\n}\n\ntemplate <class _Tp, class _Allocator>\ninline _LIBCPP_INLINE_VISIBILITY\ntypename vector<_Tp, _Allocator>::reference\nvector<_Tp, _Allocator>::operator[](size_type __n)\n{\n    _LIBCPP_ASSERT(__n < size(), \"vector[] index out of bounds\");\n    return this->__begin_[__n];\n}\n\ntemplate <class _Tp, class _Allocator>\ninline _LIBCPP_INLINE_VISIBILITY\ntypename vector<_Tp, _Allocator>::const_reference\nvector<_Tp, _Allocator>::operator[](size_type __n) const\n{\n    _LIBCPP_ASSERT(__n < size(), \"vector[] index out of bounds\");\n    return this->__begin_[__n];\n}\n\ntemplate <class _Tp, class _Allocator>\ntypename vector<_Tp, _Allocator>::reference\nvector<_Tp, _Allocator>::at(size_type __n)\n{\n    if (__n >= size())\n        this->__throw_out_of_range();\n    return this->__begin_[__n];\n}\n\ntemplate <class _Tp, class _Allocator>\ntypename vector<_Tp, _Allocator>::const_reference\nvector<_Tp, _Allocator>::at(size_type __n) const\n{\n    if (__n >= size())\n        this->__throw_out_of_range();\n    return this->__begin_[__n];\n}\n\ntemplate <class _Tp, class _Allocator>\nvoid\nvector<_Tp, _Allocator>::reserve(size_type __n)\n{\n    if (__n > capacity())\n    {\n        allocator_type& __a = this->__alloc();\n        __split_buffer<value_type, allocator_type&> __v(__n, size(), __a);\n        __swap_out_circular_buffer(__v);\n    }\n}\n\ntemplate <class _Tp, class _Allocator>\nvoid\nvector<_Tp, _Allocator>::shrink_to_fit() _NOEXCEPT\n{\n    if (capacity() > size())\n    {\n#ifndef _LIBCPP_NO_EXCEPTIONS\n        try\n        {\n#endif  // _LIBCPP_NO_EXCEPTIONS\n            allocator_type& __a = this->__alloc();\n            __split_buffer<value_type, allocator_type&> __v(size(), size(), __a);\n            __swap_out_circular_buffer(__v);\n#ifndef _LIBCPP_NO_EXCEPTIONS\n        }\n        catch (...)\n        {\n        }\n#endif  // _LIBCPP_NO_EXCEPTIONS\n    }\n}\n\ntemplate <class _Tp, class _Allocator>\ntemplate <class _Up>\nvoid\n#ifndef _LIBCPP_HAS_NO_RVALUE_REFERENCES\nvector<_Tp, _Allocator>::__push_back_slow_path(_Up&& __x)\n#else\nvector<_Tp, _Allocator>::__push_back_slow_path(_Up& __x)\n#endif\n{\n    allocator_type& __a = this->__alloc();\n    __split_buffer<value_type, allocator_type&> __v(__recommend(size() + 1), size(), __a);\n    // __v.push_back(_VSTD::forward<_Up>(__x));\n    __alloc_traits::construct(__a, _VSTD::__to_raw_pointer(__v.__end_), _VSTD::forward<_Up>(__x));\n    __v.__end_++;\n    __swap_out_circular_buffer(__v);\n}\n\ntemplate <class _Tp, class _Allocator>\ninline _LIBCPP_INLINE_VISIBILITY\nvoid\nvector<_Tp, _Allocator>::push_back(const_reference __x)\n{\n    if (this->__end_ != this->__end_cap())\n    {\n        __RAII_IncreaseAnnotator __annotator(*this);\n        __alloc_traits::construct(this->__alloc(),\n                                  _VSTD::__to_raw_pointer(this->__end_), __x);\n        __annotator.__done();\n        ++this->__end_;\n    }\n    else\n        __push_back_slow_path(__x);\n}\n\n#ifndef _LIBCPP_HAS_NO_RVALUE_REFERENCES\n\ntemplate <class _Tp, class _Allocator>\ninline _LIBCPP_INLINE_VISIBILITY\nvoid\nvector<_Tp, _Allocator>::push_back(value_type&& __x)\n{\n    if (this->__end_ < this->__end_cap())\n    {\n        __RAII_IncreaseAnnotator __annotator(*this);\n        __alloc_traits::construct(this->__alloc(),\n                                  _VSTD::__to_raw_pointer(this->__end_),\n                                  _VSTD::move(__x));\n        __annotator.__done();\n        ++this->__end_;\n    }\n    else\n        __push_back_slow_path(_VSTD::move(__x));\n}\n\n#ifndef _LIBCPP_HAS_NO_VARIADICS\n\ntemplate <class _Tp, class _Allocator>\ntemplate <class... _Args>\nvoid\nvector<_Tp, _Allocator>::__emplace_back_slow_path(_Args&&... __args)\n{\n    allocator_type& __a = this->__alloc();\n    __split_buffer<value_type, allocator_type&> __v(__recommend(size() + 1), size(), __a);\n//    __v.emplace_back(_VSTD::forward<_Args>(__args)...);\n    __alloc_traits::construct(__a, _VSTD::__to_raw_pointer(__v.__end_), _VSTD::forward<_Args>(__args)...);\n    __v.__end_++;\n    __swap_out_circular_buffer(__v);\n}\n\ntemplate <class _Tp, class _Allocator>\ntemplate <class... _Args>\ninline\n#if _LIBCPP_STD_VER > 14\ntypename vector<_Tp, _Allocator>::reference\n#else\nvoid\n#endif\nvector<_Tp, _Allocator>::emplace_back(_Args&&... __args)\n{\n    if (this->__end_ < this->__end_cap())\n    {\n        __RAII_IncreaseAnnotator __annotator(*this);\n        __alloc_traits::construct(this->__alloc(),\n                                  _VSTD::__to_raw_pointer(this->__end_),\n                                  _VSTD::forward<_Args>(__args)...);\n        __annotator.__done();\n        ++this->__end_;\n    }\n    else\n        __emplace_back_slow_path(_VSTD::forward<_Args>(__args)...);\n#if _LIBCPP_STD_VER > 14\n    return this->back();\n#endif\n}\n\n#endif  // _LIBCPP_HAS_NO_VARIADICS\n#endif  // _LIBCPP_HAS_NO_RVALUE_REFERENCES\n\ntemplate <class _Tp, class _Allocator>\ninline\nvoid\nvector<_Tp, _Allocator>::pop_back()\n{\n    _LIBCPP_ASSERT(!empty(), \"vector::pop_back called for empty vector\");\n    this->__destruct_at_end(this->__end_ - 1);\n}\n\ntemplate <class _Tp, class _Allocator>\ninline _LIBCPP_INLINE_VISIBILITY\ntypename vector<_Tp, _Allocator>::iterator\nvector<_Tp, _Allocator>::erase(const_iterator __position)\n{\n#if _LIBCPP_DEBUG_LEVEL >= 2\n    _LIBCPP_ASSERT(__get_const_db()->__find_c_from_i(&__position) == this,\n        \"vector::erase(iterator) called with an iterator not\"\n        \" referring to this vector\");\n#endif\n    _LIBCPP_ASSERT(__position != end(),\n        \"vector::erase(iterator) called with a non-dereferenceable iterator\");\n    difference_type __ps = __position - cbegin();\n    pointer __p = this->__begin_ + __ps;\n    this->__destruct_at_end(_VSTD::move(__p + 1, this->__end_, __p));\n    this->__invalidate_iterators_past(__p-1);\n    iterator __r = __make_iter(__p);\n    return __r;\n}\n\ntemplate <class _Tp, class _Allocator>\ntypename vector<_Tp, _Allocator>::iterator\nvector<_Tp, _Allocator>::erase(const_iterator __first, const_iterator __last)\n{\n#if _LIBCPP_DEBUG_LEVEL >= 2\n    _LIBCPP_ASSERT(__get_const_db()->__find_c_from_i(&__first) == this,\n        \"vector::erase(iterator,  iterator) called with an iterator not\"\n        \" referring to this vector\");\n    _LIBCPP_ASSERT(__get_const_db()->__find_c_from_i(&__last) == this,\n        \"vector::erase(iterator,  iterator) called with an iterator not\"\n        \" referring to this vector\");\n#endif\n    _LIBCPP_ASSERT(__first <= __last, \"vector::erase(first, last) called with invalid range\");\n    pointer __p = this->__begin_ + (__first - begin());\n    if (__first != __last) {\n        this->__destruct_at_end(_VSTD::move(__p + (__last - __first), this->__end_, __p));\n        this->__invalidate_iterators_past(__p - 1);\n    }\n    iterator __r = __make_iter(__p);\n    return __r;\n}\n\ntemplate <class _Tp, class _Allocator>\nvoid\nvector<_Tp, _Allocator>::__move_range(pointer __from_s, pointer __from_e, pointer __to)\n{\n    pointer __old_last = this->__end_;\n    difference_type __n = __old_last - __to;\n    for (pointer __i = __from_s + __n; __i < __from_e; ++__i, ++this->__end_)\n        __alloc_traits::construct(this->__alloc(),\n                                  _VSTD::__to_raw_pointer(this->__end_),\n                                  _VSTD::move(*__i));\n    _VSTD::move_backward(__from_s, __from_s + __n, __old_last);\n}\n\ntemplate <class _Tp, class _Allocator>\ntypename vector<_Tp, _Allocator>::iterator\nvector<_Tp, _Allocator>::insert(const_iterator __position, const_reference __x)\n{\n#if _LIBCPP_DEBUG_LEVEL >= 2\n    _LIBCPP_ASSERT(__get_const_db()->__find_c_from_i(&__position) == this,\n        \"vector::insert(iterator, x) called with an iterator not\"\n        \" referring to this vector\");\n#endif\n    pointer __p = this->__begin_ + (__position - begin());\n    if (this->__end_ < this->__end_cap())\n    {\n        __RAII_IncreaseAnnotator __annotator(*this);\n        if (__p == this->__end_)\n        {\n            __alloc_traits::construct(this->__alloc(),\n                                      _VSTD::__to_raw_pointer(this->__end_), __x);\n            ++this->__end_;\n        }\n        else\n        {\n            __move_range(__p, this->__end_, __p + 1);\n            const_pointer __xr = pointer_traits<const_pointer>::pointer_to(__x);\n            if (__p <= __xr && __xr < this->__end_)\n                ++__xr;\n            *__p = *__xr;\n        }\n        __annotator.__done();\n    }\n    else\n    {\n        allocator_type& __a = this->__alloc();\n        __split_buffer<value_type, allocator_type&> __v(__recommend(size() + 1), __p - this->__begin_, __a);\n        __v.push_back(__x);\n        __p = __swap_out_circular_buffer(__v, __p);\n    }\n    return __make_iter(__p);\n}\n\n#ifndef _LIBCPP_HAS_NO_RVALUE_REFERENCES\n\ntemplate <class _Tp, class _Allocator>\ntypename vector<_Tp, _Allocator>::iterator\nvector<_Tp, _Allocator>::insert(const_iterator __position, value_type&& __x)\n{\n#if _LIBCPP_DEBUG_LEVEL >= 2\n    _LIBCPP_ASSERT(__get_const_db()->__find_c_from_i(&__position) == this,\n        \"vector::insert(iterator, x) called with an iterator not\"\n        \" referring to this vector\");\n#endif\n    pointer __p = this->__begin_ + (__position - begin());\n    if (this->__end_ < this->__end_cap())\n    {\n        __RAII_IncreaseAnnotator __annotator(*this);\n        if (__p == this->__end_)\n        {\n            __alloc_traits::construct(this->__alloc(),\n                                      _VSTD::__to_raw_pointer(this->__end_),\n                                      _VSTD::move(__x));\n            ++this->__end_;\n        }\n        else\n        {\n            __move_range(__p, this->__end_, __p + 1);\n            *__p = _VSTD::move(__x);\n        }\n        __annotator.__done();\n    }\n    else\n    {\n        allocator_type& __a = this->__alloc();\n        __split_buffer<value_type, allocator_type&> __v(__recommend(size() + 1), __p - this->__begin_, __a);\n        __v.push_back(_VSTD::move(__x));\n        __p = __swap_out_circular_buffer(__v, __p);\n    }\n    return __make_iter(__p);\n}\n\n#ifndef _LIBCPP_HAS_NO_VARIADICS\n\ntemplate <class _Tp, class _Allocator>\ntemplate <class... _Args>\ntypename vector<_Tp, _Allocator>::iterator\nvector<_Tp, _Allocator>::emplace(const_iterator __position, _Args&&... __args)\n{\n#if _LIBCPP_DEBUG_LEVEL >= 2\n    _LIBCPP_ASSERT(__get_const_db()->__find_c_from_i(&__position) == this,\n        \"vector::emplace(iterator, x) called with an iterator not\"\n        \" referring to this vector\");\n#endif\n    pointer __p = this->__begin_ + (__position - begin());\n    if (this->__end_ < this->__end_cap())\n    {\n        __RAII_IncreaseAnnotator __annotator(*this);\n        if (__p == this->__end_)\n        {\n            __alloc_traits::construct(this->__alloc(),\n                                      _VSTD::__to_raw_pointer(this->__end_),\n                                      _VSTD::forward<_Args>(__args)...);\n            ++this->__end_;\n        }\n        else\n        {\n            __temp_value<value_type, _Allocator> __tmp(this->__alloc(), _VSTD::forward<_Args>(__args)...);\n            __move_range(__p, this->__end_, __p + 1);\n            *__p = _VSTD::move(__tmp.get());\n        }\n        __annotator.__done();\n    }\n    else\n    {\n        allocator_type& __a = this->__alloc();\n        __split_buffer<value_type, allocator_type&> __v(__recommend(size() + 1), __p - this->__begin_, __a);\n        __v.emplace_back(_VSTD::forward<_Args>(__args)...);\n        __p = __swap_out_circular_buffer(__v, __p);\n    }\n    return __make_iter(__p);\n}\n\n#endif  // _LIBCPP_HAS_NO_VARIADICS\n#endif  // _LIBCPP_HAS_NO_RVALUE_REFERENCES\n\ntemplate <class _Tp, class _Allocator>\ntypename vector<_Tp, _Allocator>::iterator\nvector<_Tp, _Allocator>::insert(const_iterator __position, size_type __n, const_reference __x)\n{\n#if _LIBCPP_DEBUG_LEVEL >= 2\n    _LIBCPP_ASSERT(__get_const_db()->__find_c_from_i(&__position) == this,\n        \"vector::insert(iterator, n, x) called with an iterator not\"\n        \" referring to this vector\");\n#endif\n    pointer __p = this->__begin_ + (__position - begin());\n    if (__n > 0)\n    {\n        if (__n <= static_cast<size_type>(this->__end_cap() - this->__end_))\n        {\n            size_type __old_n = __n;\n            pointer __old_last = this->__end_;\n            if (__n > static_cast<size_type>(this->__end_ - __p))\n            {\n                size_type __cx = __n - (this->__end_ - __p);\n                __construct_at_end(__cx, __x);\n                __n -= __cx;\n            }\n            if (__n > 0)\n            {\n                __RAII_IncreaseAnnotator __annotator(*this, __n);\n                __move_range(__p, __old_last, __p + __old_n);\n                __annotator.__done();\n                const_pointer __xr = pointer_traits<const_pointer>::pointer_to(__x);\n                if (__p <= __xr && __xr < this->__end_)\n                    __xr += __old_n;\n                _VSTD::fill_n(__p, __n, *__xr);\n            }\n        }\n        else\n        {\n            allocator_type& __a = this->__alloc();\n            __split_buffer<value_type, allocator_type&> __v(__recommend(size() + __n), __p - this->__begin_, __a);\n            __v.__construct_at_end(__n, __x);\n            __p = __swap_out_circular_buffer(__v, __p);\n        }\n    }\n    return __make_iter(__p);\n}\n\ntemplate <class _Tp, class _Allocator>\ntemplate <class _InputIterator>\ntypename enable_if\n<\n     __is_input_iterator  <_InputIterator>::value &&\n    !__is_forward_iterator<_InputIterator>::value &&\n    is_constructible<\n       _Tp,\n       typename iterator_traits<_InputIterator>::reference>::value,\n    typename vector<_Tp, _Allocator>::iterator\n>::type\nvector<_Tp, _Allocator>::insert(const_iterator __position, _InputIterator __first, _InputIterator __last)\n{\n#if _LIBCPP_DEBUG_LEVEL >= 2\n    _LIBCPP_ASSERT(__get_const_db()->__find_c_from_i(&__position) == this,\n        \"vector::insert(iterator, range) called with an iterator not\"\n        \" referring to this vector\");\n#endif\n    difference_type __off = __position - begin();\n    pointer __p = this->__begin_ + __off;\n    allocator_type& __a = this->__alloc();\n    pointer __old_last = this->__end_;\n    for (; this->__end_ != this->__end_cap() && __first != __last; ++__first)\n    {\n        __RAII_IncreaseAnnotator __annotator(*this);\n        __alloc_traits::construct(__a, _VSTD::__to_raw_pointer(this->__end_),\n                                  *__first);\n        ++this->__end_;\n        __annotator.__done();\n    }\n    __split_buffer<value_type, allocator_type&> __v(__a);\n    if (__first != __last)\n    {\n#ifndef _LIBCPP_NO_EXCEPTIONS\n        try\n        {\n#endif  // _LIBCPP_NO_EXCEPTIONS\n            __v.__construct_at_end(__first, __last);\n            difference_type __old_size = __old_last - this->__begin_;\n            difference_type __old_p = __p - this->__begin_;\n            reserve(__recommend(size() + __v.size()));\n            __p = this->__begin_ + __old_p;\n            __old_last = this->__begin_ + __old_size;\n#ifndef _LIBCPP_NO_EXCEPTIONS\n        }\n        catch (...)\n        {\n            erase(__make_iter(__old_last), end());\n            throw;\n        }\n#endif  // _LIBCPP_NO_EXCEPTIONS\n    }\n    __p = _VSTD::rotate(__p, __old_last, this->__end_);\n    insert(__make_iter(__p), make_move_iterator(__v.begin()),\n                                    make_move_iterator(__v.end()));\n    return begin() + __off;\n}\n\ntemplate <class _Tp, class _Allocator>\ntemplate <class _ForwardIterator>\ntypename enable_if\n<\n    __is_forward_iterator<_ForwardIterator>::value &&\n    is_constructible<\n       _Tp,\n       typename iterator_traits<_ForwardIterator>::reference>::value,\n    typename vector<_Tp, _Allocator>::iterator\n>::type\nvector<_Tp, _Allocator>::insert(const_iterator __position, _ForwardIterator __first, _ForwardIterator __last)\n{\n#if _LIBCPP_DEBUG_LEVEL >= 2\n    _LIBCPP_ASSERT(__get_const_db()->__find_c_from_i(&__position) == this,\n        \"vector::insert(iterator, range) called with an iterator not\"\n        \" referring to this vector\");\n#endif\n    pointer __p = this->__begin_ + (__position - begin());\n    difference_type __n = _VSTD::distance(__first, __last);\n    if (__n > 0)\n    {\n        if (__n <= this->__end_cap() - this->__end_)\n        {\n            size_type __old_n = __n;\n            pointer __old_last = this->__end_;\n            _ForwardIterator __m = __last;\n            difference_type __dx = this->__end_ - __p;\n            if (__n > __dx)\n            {\n                __m = __first;\n                difference_type __diff = this->__end_ - __p;\n                _VSTD::advance(__m, __diff);\n                __construct_at_end(__m, __last, __n - __diff);\n                __n = __dx;\n            }\n            if (__n > 0)\n            {\n                __RAII_IncreaseAnnotator __annotator(*this, __n);\n                __move_range(__p, __old_last, __p + __old_n);\n                __annotator.__done();\n                _VSTD::copy(__first, __m, __p);\n            }\n        }\n        else\n        {\n            allocator_type& __a = this->__alloc();\n            __split_buffer<value_type, allocator_type&> __v(__recommend(size() + __n), __p - this->__begin_, __a);\n            __v.__construct_at_end(__first, __last);\n            __p = __swap_out_circular_buffer(__v, __p);\n        }\n    }\n    return __make_iter(__p);\n}\n\ntemplate <class _Tp, class _Allocator>\nvoid\nvector<_Tp, _Allocator>::resize(size_type __sz)\n{\n    size_type __cs = size();\n    if (__cs < __sz)\n        this->__append(__sz - __cs);\n    else if (__cs > __sz)\n        this->__destruct_at_end(this->__begin_ + __sz);\n}\n\ntemplate <class _Tp, class _Allocator>\nvoid\nvector<_Tp, _Allocator>::resize(size_type __sz, const_reference __x)\n{\n    size_type __cs = size();\n    if (__cs < __sz)\n        this->__append(__sz - __cs, __x);\n    else if (__cs > __sz)\n        this->__destruct_at_end(this->__begin_ + __sz);\n}\n\ntemplate <class _Tp, class _Allocator>\nvoid\nvector<_Tp, _Allocator>::swap(vector& __x)\n#if _LIBCPP_STD_VER >= 14\n    _NOEXCEPT_DEBUG\n#else\n    _NOEXCEPT_DEBUG_(!__alloc_traits::propagate_on_container_swap::value ||\n                __is_nothrow_swappable<allocator_type>::value)\n#endif\n{\n    _LIBCPP_ASSERT(__alloc_traits::propagate_on_container_swap::value ||\n                   this->__alloc() == __x.__alloc(),\n                   \"vector::swap: Either propagate_on_container_swap must be true\"\n                   \" or the allocators must compare equal\");\n    _VSTD::swap(this->__begin_, __x.__begin_);\n    _VSTD::swap(this->__end_, __x.__end_);\n    _VSTD::swap(this->__end_cap(), __x.__end_cap());\n    __swap_allocator(this->__alloc(), __x.__alloc(), \n        integral_constant<bool,__alloc_traits::propagate_on_container_swap::value>());\n#if _LIBCPP_DEBUG_LEVEL >= 2\n    __get_db()->swap(this, &__x);\n#endif  // _LIBCPP_DEBUG_LEVEL >= 2\n}\n\ntemplate <class _Tp, class _Allocator>\nbool\nvector<_Tp, _Allocator>::__invariants() const\n{\n    if (this->__begin_ == nullptr)\n    {\n        if (this->__end_ != nullptr || this->__end_cap() != nullptr)\n            return false;\n    }\n    else\n    {\n        if (this->__begin_ > this->__end_)\n            return false;\n        if (this->__begin_ == this->__end_cap())\n            return false;\n        if (this->__end_ > this->__end_cap())\n            return false;\n    }\n    return true;\n}\n\n#if _LIBCPP_DEBUG_LEVEL >= 2\n\ntemplate <class _Tp, class _Allocator>\nbool\nvector<_Tp, _Allocator>::__dereferenceable(const const_iterator* __i) const\n{\n    return this->__begin_ <= __i->base() && __i->base() < this->__end_;\n}\n\ntemplate <class _Tp, class _Allocator>\nbool\nvector<_Tp, _Allocator>::__decrementable(const const_iterator* __i) const\n{\n    return this->__begin_ < __i->base() && __i->base() <= this->__end_;\n}\n\ntemplate <class _Tp, class _Allocator>\nbool\nvector<_Tp, _Allocator>::__addable(const const_iterator* __i, ptrdiff_t __n) const\n{\n    const_pointer __p = __i->base() + __n;\n    return this->__begin_ <= __p && __p <= this->__end_;\n}\n\ntemplate <class _Tp, class _Allocator>\nbool\nvector<_Tp, _Allocator>::__subscriptable(const const_iterator* __i, ptrdiff_t __n) const\n{\n    const_pointer __p = __i->base() + __n;\n    return this->__begin_ <= __p && __p < this->__end_;\n}\n\n#endif  // _LIBCPP_DEBUG_LEVEL >= 2\n\ntemplate <class _Tp, class _Allocator>\ninline _LIBCPP_INLINE_VISIBILITY\nvoid\nvector<_Tp, _Allocator>::__invalidate_all_iterators()\n{\n#if _LIBCPP_DEBUG_LEVEL >= 2\n    __get_db()->__invalidate_all(this);\n#endif  // _LIBCPP_DEBUG_LEVEL >= 2\n}\n\n\ntemplate <class _Tp, class _Allocator>\ninline _LIBCPP_INLINE_VISIBILITY\nvoid\nvector<_Tp, _Allocator>::__invalidate_iterators_past(pointer __new_last) {\n#if _LIBCPP_DEBUG_LEVEL >= 2\n  __c_node* __c = __get_db()->__find_c_and_lock(this);\n  for (__i_node** __p = __c->end_; __p != __c->beg_; ) {\n    --__p;\n    const_iterator* __i = static_cast<const_iterator*>((*__p)->__i_);\n    if (__i->base() > __new_last) {\n      (*__p)->__c_ = nullptr;\n      if (--__c->end_ != __p)\n        memmove(__p, __p+1, (__c->end_ - __p)*sizeof(__i_node*));\n    }\n  }\n  __get_db()->unlock();\n#else\n  ((void)__new_last);\n#endif\n}\n\n// vector<bool>\n\ntemplate <class _Allocator> class vector<bool, _Allocator>;\n\ntemplate <class _Allocator> struct hash<vector<bool, _Allocator> >;\n\ntemplate <class _Allocator>\nstruct __has_storage_type<vector<bool, _Allocator> >\n{\n    static const bool value = true;\n};\n\ntemplate <class _Allocator>\nclass _LIBCPP_TEMPLATE_VIS vector<bool, _Allocator>\n    : private __vector_base_common<true>\n{\npublic:\n    typedef vector                                   __self;\n    typedef bool                                     value_type;\n    typedef _Allocator                               allocator_type;\n    typedef allocator_traits<allocator_type>         __alloc_traits;\n    typedef typename __alloc_traits::size_type       size_type;\n    typedef typename __alloc_traits::difference_type difference_type;\n    typedef size_type __storage_type;\n    typedef __bit_iterator<vector, false>            pointer;\n    typedef __bit_iterator<vector, true>             const_pointer;\n    typedef pointer                                  iterator;\n    typedef const_pointer                            const_iterator;\n    typedef _VSTD::reverse_iterator<iterator>         reverse_iterator;\n    typedef _VSTD::reverse_iterator<const_iterator>   const_reverse_iterator;\n\nprivate:\n    typedef typename __rebind_alloc_helper<__alloc_traits, __storage_type>::type __storage_allocator;\n    typedef allocator_traits<__storage_allocator>    __storage_traits;\n    typedef typename __storage_traits::pointer       __storage_pointer;\n    typedef typename __storage_traits::const_pointer __const_storage_pointer;\n\n    __storage_pointer                                      __begin_;\n    size_type                                              __size_;\n    __compressed_pair<size_type, __storage_allocator> __cap_alloc_;\npublic:\n    typedef __bit_reference<vector>                  reference;\n    typedef __bit_const_reference<vector>            const_reference;\nprivate:\n    _LIBCPP_INLINE_VISIBILITY\n    size_type& __cap() _NOEXCEPT\n        {return __cap_alloc_.first();}\n    _LIBCPP_INLINE_VISIBILITY\n    const size_type& __cap() const _NOEXCEPT\n        {return __cap_alloc_.first();}\n    _LIBCPP_INLINE_VISIBILITY\n    __storage_allocator& __alloc() _NOEXCEPT\n        {return __cap_alloc_.second();}\n    _LIBCPP_INLINE_VISIBILITY\n    const __storage_allocator& __alloc() const _NOEXCEPT\n        {return __cap_alloc_.second();}\n\n    static const unsigned __bits_per_word = static_cast<unsigned>(sizeof(__storage_type) * CHAR_BIT);\n\n    _LIBCPP_INLINE_VISIBILITY\n    static size_type __internal_cap_to_external(size_type __n) _NOEXCEPT\n        {return __n * __bits_per_word;}\n    _LIBCPP_INLINE_VISIBILITY\n    static size_type __external_cap_to_internal(size_type __n) _NOEXCEPT\n        {return (__n - 1) / __bits_per_word + 1;}\n\npublic:\n    _LIBCPP_INLINE_VISIBILITY\n    vector() _NOEXCEPT_(is_nothrow_default_constructible<allocator_type>::value);\n\n    _LIBCPP_INLINE_VISIBILITY explicit vector(const allocator_type& __a)\n#if _LIBCPP_STD_VER <= 14\n        _NOEXCEPT_(is_nothrow_copy_constructible<allocator_type>::value);\n#else\n        _NOEXCEPT;\n#endif\n    ~vector();\n    explicit vector(size_type __n);\n#if _LIBCPP_STD_VER > 11\n    explicit vector(size_type __n, const allocator_type& __a);\n#endif\n    vector(size_type __n, const value_type& __v);\n    vector(size_type __n, const value_type& __v, const allocator_type& __a);\n    template <class _InputIterator>\n        vector(_InputIterator __first, _InputIterator __last,\n               typename enable_if<__is_input_iterator  <_InputIterator>::value &&\n                                 !__is_forward_iterator<_InputIterator>::value>::type* = 0);\n    template <class _InputIterator>\n        vector(_InputIterator __first, _InputIterator __last, const allocator_type& __a,\n               typename enable_if<__is_input_iterator  <_InputIterator>::value &&\n                                 !__is_forward_iterator<_InputIterator>::value>::type* = 0);\n    template <class _ForwardIterator>\n        vector(_ForwardIterator __first, _ForwardIterator __last,\n               typename enable_if<__is_forward_iterator<_ForwardIterator>::value>::type* = 0);\n    template <class _ForwardIterator>\n        vector(_ForwardIterator __first, _ForwardIterator __last, const allocator_type& __a,\n               typename enable_if<__is_forward_iterator<_ForwardIterator>::value>::type* = 0);\n\n    vector(const vector& __v);\n    vector(const vector& __v, const allocator_type& __a);\n    vector& operator=(const vector& __v);\n#ifndef _LIBCPP_HAS_NO_GENERALIZED_INITIALIZERS\n    vector(initializer_list<value_type> __il);\n    vector(initializer_list<value_type> __il, const allocator_type& __a);\n#endif  // _LIBCPP_HAS_NO_GENERALIZED_INITIALIZERS\n\n#ifndef _LIBCPP_HAS_NO_RVALUE_REFERENCES\n    _LIBCPP_INLINE_VISIBILITY\n    vector(vector&& __v)\n#if _LIBCPP_STD_VER > 14\n        _NOEXCEPT;\n#else\n        _NOEXCEPT_(is_nothrow_move_constructible<allocator_type>::value);\n#endif\n    vector(vector&& __v, const allocator_type& __a);\n    _LIBCPP_INLINE_VISIBILITY\n    vector& operator=(vector&& __v)\n        _NOEXCEPT_((__noexcept_move_assign_container<_Allocator, __alloc_traits>::value));\n#endif  // _LIBCPP_HAS_NO_RVALUE_REFERENCES\n#ifndef _LIBCPP_HAS_NO_GENERALIZED_INITIALIZERS\n    _LIBCPP_INLINE_VISIBILITY\n    vector& operator=(initializer_list<value_type> __il)\n        {assign(__il.begin(), __il.end()); return *this;}\n#endif  // _LIBCPP_HAS_NO_GENERALIZED_INITIALIZERS\n\n    template <class _InputIterator>\n        typename enable_if\n        <\n            __is_input_iterator<_InputIterator>::value &&\n           !__is_forward_iterator<_InputIterator>::value,\n           void\n        >::type\n        assign(_InputIterator __first, _InputIterator __last);\n    template <class _ForwardIterator>\n        typename enable_if\n        <\n            __is_forward_iterator<_ForwardIterator>::value,\n           void\n        >::type\n        assign(_ForwardIterator __first, _ForwardIterator __last);\n\n    void assign(size_type __n, const value_type& __x);\n#ifndef _LIBCPP_HAS_NO_GENERALIZED_INITIALIZERS\n    _LIBCPP_INLINE_VISIBILITY\n    void assign(initializer_list<value_type> __il)\n        {assign(__il.begin(), __il.end());}\n#endif  // _LIBCPP_HAS_NO_GENERALIZED_INITIALIZERS\n\n    _LIBCPP_INLINE_VISIBILITY allocator_type get_allocator() const _NOEXCEPT\n        {return allocator_type(this->__alloc());}\n\n    size_type max_size() const _NOEXCEPT;\n    _LIBCPP_INLINE_VISIBILITY\n    size_type capacity() const _NOEXCEPT\n        {return __internal_cap_to_external(__cap());}\n    _LIBCPP_INLINE_VISIBILITY\n    size_type size() const _NOEXCEPT\n        {return __size_;}\n    _LIBCPP_INLINE_VISIBILITY\n    bool empty() const _NOEXCEPT\n        {return __size_ == 0;}\n    void reserve(size_type __n);\n    void shrink_to_fit() _NOEXCEPT;\n\n    _LIBCPP_INLINE_VISIBILITY\n    iterator begin() _NOEXCEPT\n        {return __make_iter(0);}\n    _LIBCPP_INLINE_VISIBILITY\n    const_iterator begin() const _NOEXCEPT\n        {return __make_iter(0);}\n    _LIBCPP_INLINE_VISIBILITY\n    iterator end() _NOEXCEPT\n        {return __make_iter(__size_);}\n    _LIBCPP_INLINE_VISIBILITY\n    const_iterator end()   const _NOEXCEPT\n        {return __make_iter(__size_);}\n\n    _LIBCPP_INLINE_VISIBILITY\n    reverse_iterator rbegin() _NOEXCEPT\n        {return       reverse_iterator(end());}\n    _LIBCPP_INLINE_VISIBILITY\n    const_reverse_iterator rbegin() const _NOEXCEPT\n        {return const_reverse_iterator(end());}\n    _LIBCPP_INLINE_VISIBILITY\n    reverse_iterator rend() _NOEXCEPT\n        {return       reverse_iterator(begin());}\n    _LIBCPP_INLINE_VISIBILITY\n    const_reverse_iterator rend()   const _NOEXCEPT\n        {return const_reverse_iterator(begin());}\n\n    _LIBCPP_INLINE_VISIBILITY\n    const_iterator         cbegin()  const _NOEXCEPT\n        {return __make_iter(0);}\n    _LIBCPP_INLINE_VISIBILITY\n    const_iterator         cend()    const _NOEXCEPT\n        {return __make_iter(__size_);}\n    _LIBCPP_INLINE_VISIBILITY\n    const_reverse_iterator crbegin() const _NOEXCEPT\n        {return rbegin();}\n    _LIBCPP_INLINE_VISIBILITY\n    const_reverse_iterator crend()   const _NOEXCEPT\n        {return rend();}\n\n    _LIBCPP_INLINE_VISIBILITY reference       operator[](size_type __n)       {return __make_ref(__n);}\n    _LIBCPP_INLINE_VISIBILITY const_reference operator[](size_type __n) const {return __make_ref(__n);}\n    reference       at(size_type __n);\n    const_reference at(size_type __n) const;\n\n    _LIBCPP_INLINE_VISIBILITY reference       front()       {return __make_ref(0);}\n    _LIBCPP_INLINE_VISIBILITY const_reference front() const {return __make_ref(0);}\n    _LIBCPP_INLINE_VISIBILITY reference       back()        {return __make_ref(__size_ - 1);}\n    _LIBCPP_INLINE_VISIBILITY const_reference back()  const {return __make_ref(__size_ - 1);}\n\n    void push_back(const value_type& __x);\n#if _LIBCPP_STD_VER > 11\n    template <class... _Args>\n#if _LIBCPP_STD_VER > 14\n    _LIBCPP_INLINE_VISIBILITY reference emplace_back(_Args&&... __args)\n#else\n    _LIBCPP_INLINE_VISIBILITY void      emplace_back(_Args&&... __args)\n#endif\n    {\n        push_back ( value_type ( _VSTD::forward<_Args>(__args)... ));\n#if _LIBCPP_STD_VER > 14\n        return this->back();\n#endif\n    }\n#endif\n\n    _LIBCPP_INLINE_VISIBILITY void pop_back() {--__size_;}\n\n#if _LIBCPP_STD_VER > 11\n    template <class... _Args>\n   _LIBCPP_INLINE_VISIBILITY iterator emplace(const_iterator position, _Args&&... __args)\n        { return insert ( position, value_type ( _VSTD::forward<_Args>(__args)... )); }\n#endif\n\n    iterator insert(const_iterator __position, const value_type& __x);\n    iterator insert(const_iterator __position, size_type __n, const value_type& __x);\n    iterator insert(const_iterator __position, size_type __n, const_reference __x);\n    template <class _InputIterator>\n        typename enable_if\n        <\n             __is_input_iterator  <_InputIterator>::value &&\n            !__is_forward_iterator<_InputIterator>::value,\n            iterator\n        >::type\n        insert(const_iterator __position, _InputIterator __first, _InputIterator __last);\n    template <class _ForwardIterator>\n        typename enable_if\n        <\n            __is_forward_iterator<_ForwardIterator>::value,\n            iterator\n        >::type\n        insert(const_iterator __position, _ForwardIterator __first, _ForwardIterator __last);\n#ifndef _LIBCPP_HAS_NO_GENERALIZED_INITIALIZERS\n    _LIBCPP_INLINE_VISIBILITY\n    iterator insert(const_iterator __position, initializer_list<value_type> __il)\n        {return insert(__position, __il.begin(), __il.end());}\n#endif  // _LIBCPP_HAS_NO_GENERALIZED_INITIALIZERS\n\n    _LIBCPP_INLINE_VISIBILITY iterator erase(const_iterator __position);\n    iterator erase(const_iterator __first, const_iterator __last);\n\n    _LIBCPP_INLINE_VISIBILITY\n    void clear() _NOEXCEPT {__size_ = 0;}\n\n    void swap(vector&)\n#if _LIBCPP_STD_VER >= 14\n        _NOEXCEPT;\n#else\n        _NOEXCEPT_(!__alloc_traits::propagate_on_container_swap::value ||\n                    __is_nothrow_swappable<allocator_type>::value);\n#endif\n    static void swap(reference __x, reference __y) _NOEXCEPT { _VSTD::swap(__x, __y); }\n\n    void resize(size_type __sz, value_type __x = false);\n    void flip() _NOEXCEPT;\n\n    bool __invariants() const;\n\nprivate:\n    _LIBCPP_INLINE_VISIBILITY void __invalidate_all_iterators();\n    void allocate(size_type __n);\n    void deallocate() _NOEXCEPT;\n    _LIBCPP_INLINE_VISIBILITY\n    static size_type __align_it(size_type __new_size) _NOEXCEPT\n        {return __new_size + (__bits_per_word-1) & ~((size_type)__bits_per_word-1);};\n    _LIBCPP_INLINE_VISIBILITY  size_type __recommend(size_type __new_size) const;\n    _LIBCPP_INLINE_VISIBILITY void __construct_at_end(size_type __n, bool __x);\n    template <class _ForwardIterator>\n        typename enable_if\n        <\n            __is_forward_iterator<_ForwardIterator>::value,\n            void\n        >::type\n        __construct_at_end(_ForwardIterator __first, _ForwardIterator __last);\n    void __append(size_type __n, const_reference __x);\n    _LIBCPP_INLINE_VISIBILITY\n    reference __make_ref(size_type __pos) _NOEXCEPT\n        {return reference(__begin_ + __pos / __bits_per_word, __storage_type(1) << __pos % __bits_per_word);}\n    _LIBCPP_INLINE_VISIBILITY\n    const_reference __make_ref(size_type __pos) const _NOEXCEPT\n        {return const_reference(__begin_ + __pos / __bits_per_word, __storage_type(1) << __pos % __bits_per_word);}\n    _LIBCPP_INLINE_VISIBILITY\n    iterator __make_iter(size_type __pos) _NOEXCEPT\n        {return iterator(__begin_ + __pos / __bits_per_word, static_cast<unsigned>(__pos % __bits_per_word));}\n    _LIBCPP_INLINE_VISIBILITY\n    const_iterator __make_iter(size_type __pos) const _NOEXCEPT\n        {return const_iterator(__begin_ + __pos / __bits_per_word, static_cast<unsigned>(__pos % __bits_per_word));}\n    _LIBCPP_INLINE_VISIBILITY\n    iterator __const_iterator_cast(const_iterator __p) _NOEXCEPT\n        {return begin() + (__p - cbegin());}\n\n    _LIBCPP_INLINE_VISIBILITY\n    void __copy_assign_alloc(const vector& __v)\n        {__copy_assign_alloc(__v, integral_constant<bool,\n                      __storage_traits::propagate_on_container_copy_assignment::value>());}\n    _LIBCPP_INLINE_VISIBILITY\n    void __copy_assign_alloc(const vector& __c, true_type)\n        {\n            if (__alloc() != __c.__alloc())\n                deallocate();\n            __alloc() = __c.__alloc();\n        }\n\n    _LIBCPP_INLINE_VISIBILITY\n    void __copy_assign_alloc(const vector&, false_type)\n        {}\n\n    void __move_assign(vector& __c, false_type);\n    void __move_assign(vector& __c, true_type)\n        _NOEXCEPT_(is_nothrow_move_assignable<allocator_type>::value);\n    _LIBCPP_INLINE_VISIBILITY\n    void __move_assign_alloc(vector& __c)\n        _NOEXCEPT_(\n            !__storage_traits::propagate_on_container_move_assignment::value ||\n            is_nothrow_move_assignable<allocator_type>::value)\n        {__move_assign_alloc(__c, integral_constant<bool,\n                      __storage_traits::propagate_on_container_move_assignment::value>());}\n    _LIBCPP_INLINE_VISIBILITY\n    void __move_assign_alloc(vector& __c, true_type)\n        _NOEXCEPT_(is_nothrow_move_assignable<allocator_type>::value)\n        {\n            __alloc() = _VSTD::move(__c.__alloc());\n        }\n\n    _LIBCPP_INLINE_VISIBILITY\n    void __move_assign_alloc(vector&, false_type)\n        _NOEXCEPT\n        {}\n\n    size_t __hash_code() const _NOEXCEPT;\n\n    friend class __bit_reference<vector>;\n    friend class __bit_const_reference<vector>;\n    friend class __bit_iterator<vector, false>;\n    friend class __bit_iterator<vector, true>;\n    friend struct __bit_array<vector>;\n    friend struct _LIBCPP_TEMPLATE_VIS hash<vector>;\n};\n\ntemplate <class _Allocator>\ninline _LIBCPP_INLINE_VISIBILITY\nvoid\nvector<bool, _Allocator>::__invalidate_all_iterators()\n{\n}\n\n//  Allocate space for __n objects\n//  throws length_error if __n > max_size()\n//  throws (probably bad_alloc) if memory run out\n//  Precondition:  __begin_ == __end_ == __cap() == 0\n//  Precondition:  __n > 0\n//  Postcondition:  capacity() == __n\n//  Postcondition:  size() == 0\ntemplate <class _Allocator>\nvoid\nvector<bool, _Allocator>::allocate(size_type __n)\n{\n    if (__n > max_size())\n        this->__throw_length_error();\n    __n = __external_cap_to_internal(__n);\n    this->__begin_ = __storage_traits::allocate(this->__alloc(), __n);\n    this->__size_ = 0;\n    this->__cap() = __n;\n}\n\ntemplate <class _Allocator>\nvoid\nvector<bool, _Allocator>::deallocate() _NOEXCEPT\n{\n    if (this->__begin_ != nullptr)\n    {\n        __storage_traits::deallocate(this->__alloc(), this->__begin_, __cap());\n        __invalidate_all_iterators();\n        this->__begin_ = nullptr;\n        this->__size_ = this->__cap() = 0;\n    }\n}\n\ntemplate <class _Allocator>\ntypename vector<bool, _Allocator>::size_type\nvector<bool, _Allocator>::max_size() const _NOEXCEPT\n{\n    size_type __amax = __storage_traits::max_size(__alloc());\n    size_type __nmax = numeric_limits<size_type>::max() / 2;  // end() >= begin(), always\n    if (__nmax / __bits_per_word <= __amax)\n        return __nmax;\n    return __internal_cap_to_external(__amax);\n}\n\n//  Precondition:  __new_size > capacity()\ntemplate <class _Allocator>\ninline _LIBCPP_INLINE_VISIBILITY\ntypename vector<bool, _Allocator>::size_type\nvector<bool, _Allocator>::__recommend(size_type __new_size) const\n{\n    const size_type __ms = max_size();\n    if (__new_size > __ms)\n        this->__throw_length_error();\n    const size_type __cap = capacity();\n    if (__cap >= __ms / 2)\n        return __ms;\n    return _VSTD::max(2*__cap, __align_it(__new_size));\n}\n\n//  Default constructs __n objects starting at __end_\n//  Precondition:  __n > 0\n//  Precondition:  size() + __n <= capacity()\n//  Postcondition:  size() == size() + __n\ntemplate <class _Allocator>\ninline _LIBCPP_INLINE_VISIBILITY\nvoid\nvector<bool, _Allocator>::__construct_at_end(size_type __n, bool __x)\n{\n    size_type __old_size = this->__size_;\n    this->__size_ += __n;\n    _VSTD::fill_n(__make_iter(__old_size), __n, __x);\n}\n\ntemplate <class _Allocator>\ntemplate <class _ForwardIterator>\ntypename enable_if\n<\n    __is_forward_iterator<_ForwardIterator>::value,\n    void\n>::type\nvector<bool, _Allocator>::__construct_at_end(_ForwardIterator __first, _ForwardIterator __last)\n{\n    size_type __old_size = this->__size_;\n    this->__size_ += _VSTD::distance(__first, __last);\n    _VSTD::copy(__first, __last, __make_iter(__old_size));\n}\n\ntemplate <class _Allocator>\ninline _LIBCPP_INLINE_VISIBILITY\nvector<bool, _Allocator>::vector()\n    _NOEXCEPT_(is_nothrow_default_constructible<allocator_type>::value)\n    : __begin_(nullptr),\n      __size_(0),\n      __cap_alloc_(0)\n{\n}\n\ntemplate <class _Allocator>\ninline _LIBCPP_INLINE_VISIBILITY\nvector<bool, _Allocator>::vector(const allocator_type& __a)\n#if _LIBCPP_STD_VER <= 14\n        _NOEXCEPT_(is_nothrow_copy_constructible<allocator_type>::value)\n#else\n        _NOEXCEPT\n#endif\n    : __begin_(nullptr),\n      __size_(0),\n      __cap_alloc_(0, static_cast<__storage_allocator>(__a))\n{\n}\n\ntemplate <class _Allocator>\nvector<bool, _Allocator>::vector(size_type __n)\n    : __begin_(nullptr),\n      __size_(0),\n      __cap_alloc_(0)\n{\n    if (__n > 0)\n    {\n        allocate(__n);\n        __construct_at_end(__n, false);\n    }\n}\n\n#if _LIBCPP_STD_VER > 11\ntemplate <class _Allocator>\nvector<bool, _Allocator>::vector(size_type __n, const allocator_type& __a)\n    : __begin_(nullptr),\n      __size_(0),\n      __cap_alloc_(0, static_cast<__storage_allocator>(__a))\n{\n    if (__n > 0)\n    {\n        allocate(__n);\n        __construct_at_end(__n, false);\n    }\n}\n#endif\n\ntemplate <class _Allocator>\nvector<bool, _Allocator>::vector(size_type __n, const value_type& __x)\n    : __begin_(nullptr),\n      __size_(0),\n      __cap_alloc_(0)\n{\n    if (__n > 0)\n    {\n        allocate(__n);\n        __construct_at_end(__n, __x);\n    }\n}\n\ntemplate <class _Allocator>\nvector<bool, _Allocator>::vector(size_type __n, const value_type& __x, const allocator_type& __a)\n    : __begin_(nullptr),\n      __size_(0),\n      __cap_alloc_(0, static_cast<__storage_allocator>(__a))\n{\n    if (__n > 0)\n    {\n        allocate(__n);\n        __construct_at_end(__n, __x);\n    }\n}\n\ntemplate <class _Allocator>\ntemplate <class _InputIterator>\nvector<bool, _Allocator>::vector(_InputIterator __first, _InputIterator __last,\n       typename enable_if<__is_input_iterator  <_InputIterator>::value &&\n                         !__is_forward_iterator<_InputIterator>::value>::type*)\n    : __begin_(nullptr),\n      __size_(0),\n      __cap_alloc_(0)\n{\n#ifndef _LIBCPP_NO_EXCEPTIONS\n    try\n    {\n#endif  // _LIBCPP_NO_EXCEPTIONS\n        for (; __first != __last; ++__first)\n            push_back(*__first);\n#ifndef _LIBCPP_NO_EXCEPTIONS\n    }\n    catch (...)\n    {\n        if (__begin_ != nullptr)\n            __storage_traits::deallocate(__alloc(), __begin_, __cap());\n        __invalidate_all_iterators();\n        throw;\n    }\n#endif  // _LIBCPP_NO_EXCEPTIONS\n}\n\ntemplate <class _Allocator>\ntemplate <class _InputIterator>\nvector<bool, _Allocator>::vector(_InputIterator __first, _InputIterator __last, const allocator_type& __a,\n       typename enable_if<__is_input_iterator  <_InputIterator>::value &&\n                         !__is_forward_iterator<_InputIterator>::value>::type*)\n    : __begin_(nullptr),\n      __size_(0),\n      __cap_alloc_(0, static_cast<__storage_allocator>(__a))\n{\n#ifndef _LIBCPP_NO_EXCEPTIONS\n    try\n    {\n#endif  // _LIBCPP_NO_EXCEPTIONS\n        for (; __first != __last; ++__first)\n            push_back(*__first);\n#ifndef _LIBCPP_NO_EXCEPTIONS\n    }\n    catch (...)\n    {\n        if (__begin_ != nullptr)\n            __storage_traits::deallocate(__alloc(), __begin_, __cap());\n        __invalidate_all_iterators();\n        throw;\n    }\n#endif  // _LIBCPP_NO_EXCEPTIONS\n}\n\ntemplate <class _Allocator>\ntemplate <class _ForwardIterator>\nvector<bool, _Allocator>::vector(_ForwardIterator __first, _ForwardIterator __last,\n                                typename enable_if<__is_forward_iterator<_ForwardIterator>::value>::type*)\n    : __begin_(nullptr),\n      __size_(0),\n      __cap_alloc_(0)\n{\n    size_type __n = static_cast<size_type>(_VSTD::distance(__first, __last));\n    if (__n > 0)\n    {\n        allocate(__n);\n        __construct_at_end(__first, __last);\n    }\n}\n\ntemplate <class _Allocator>\ntemplate <class _ForwardIterator>\nvector<bool, _Allocator>::vector(_ForwardIterator __first, _ForwardIterator __last, const allocator_type& __a,\n                                typename enable_if<__is_forward_iterator<_ForwardIterator>::value>::type*)\n    : __begin_(nullptr),\n      __size_(0),\n      __cap_alloc_(0, static_cast<__storage_allocator>(__a))\n{\n    size_type __n = static_cast<size_type>(_VSTD::distance(__first, __last));\n    if (__n > 0)\n    {\n        allocate(__n);\n        __construct_at_end(__first, __last);\n    }\n}\n\n#ifndef _LIBCPP_HAS_NO_GENERALIZED_INITIALIZERS\n\ntemplate <class _Allocator>\nvector<bool, _Allocator>::vector(initializer_list<value_type> __il)\n    : __begin_(nullptr),\n      __size_(0),\n      __cap_alloc_(0)\n{\n    size_type __n = static_cast<size_type>(__il.size());\n    if (__n > 0)\n    {\n        allocate(__n);\n        __construct_at_end(__il.begin(), __il.end());\n    }\n}\n\ntemplate <class _Allocator>\nvector<bool, _Allocator>::vector(initializer_list<value_type> __il, const allocator_type& __a)\n    : __begin_(nullptr),\n      __size_(0),\n      __cap_alloc_(0, static_cast<__storage_allocator>(__a))\n{\n    size_type __n = static_cast<size_type>(__il.size());\n    if (__n > 0)\n    {\n        allocate(__n);\n        __construct_at_end(__il.begin(), __il.end());\n    }\n}\n\n#endif  // _LIBCPP_HAS_NO_GENERALIZED_INITIALIZERS\n\ntemplate <class _Allocator>\nvector<bool, _Allocator>::~vector()\n{\n    if (__begin_ != nullptr)\n        __storage_traits::deallocate(__alloc(), __begin_, __cap());\n    __invalidate_all_iterators();\n}\n\ntemplate <class _Allocator>\nvector<bool, _Allocator>::vector(const vector& __v)\n    : __begin_(nullptr),\n      __size_(0),\n      __cap_alloc_(0, __storage_traits::select_on_container_copy_construction(__v.__alloc()))\n{\n    if (__v.size() > 0)\n    {\n        allocate(__v.size());\n        __construct_at_end(__v.begin(), __v.end());\n    }\n}\n\ntemplate <class _Allocator>\nvector<bool, _Allocator>::vector(const vector& __v, const allocator_type& __a)\n    : __begin_(nullptr),\n      __size_(0),\n      __cap_alloc_(0, __a)\n{\n    if (__v.size() > 0)\n    {\n        allocate(__v.size());\n        __construct_at_end(__v.begin(), __v.end());\n    }\n}\n\ntemplate <class _Allocator>\nvector<bool, _Allocator>&\nvector<bool, _Allocator>::operator=(const vector& __v)\n{\n    if (this != &__v)\n    {\n        __copy_assign_alloc(__v);\n        if (__v.__size_)\n        {\n            if (__v.__size_ > capacity())\n            {\n                deallocate();\n                allocate(__v.__size_);\n            }\n            _VSTD::copy(__v.__begin_, __v.__begin_ + __external_cap_to_internal(__v.__size_), __begin_);\n        }\n        __size_ = __v.__size_;\n    }\n    return *this;\n}\n\n#ifndef _LIBCPP_HAS_NO_RVALUE_REFERENCES\n\ntemplate <class _Allocator>\ninline _LIBCPP_INLINE_VISIBILITY\nvector<bool, _Allocator>::vector(vector&& __v)\n#if _LIBCPP_STD_VER > 14\n        _NOEXCEPT\n#else\n        _NOEXCEPT_(is_nothrow_move_constructible<allocator_type>::value)\n#endif\n    : __begin_(__v.__begin_),\n      __size_(__v.__size_),\n      __cap_alloc_(__v.__cap_alloc_)\n{\n    __v.__begin_ = nullptr;\n    __v.__size_ = 0;\n    __v.__cap() = 0;\n}\n\ntemplate <class _Allocator>\nvector<bool, _Allocator>::vector(vector&& __v, const allocator_type& __a)\n    : __begin_(nullptr),\n      __size_(0),\n      __cap_alloc_(0, __a)\n{\n    if (__a == allocator_type(__v.__alloc()))\n    {\n        this->__begin_ = __v.__begin_;\n        this->__size_ = __v.__size_;\n        this->__cap() = __v.__cap();\n        __v.__begin_ = nullptr;\n        __v.__cap() = __v.__size_ = 0;\n    }\n    else if (__v.size() > 0)\n    {\n        allocate(__v.size());\n        __construct_at_end(__v.begin(), __v.end());\n    }\n}\n\ntemplate <class _Allocator>\ninline _LIBCPP_INLINE_VISIBILITY\nvector<bool, _Allocator>&\nvector<bool, _Allocator>::operator=(vector&& __v)\n    _NOEXCEPT_((__noexcept_move_assign_container<_Allocator, __alloc_traits>::value))\n{\n    __move_assign(__v, integral_constant<bool,\n          __storage_traits::propagate_on_container_move_assignment::value>());\n    return *this;\n}\n\ntemplate <class _Allocator>\nvoid\nvector<bool, _Allocator>::__move_assign(vector& __c, false_type)\n{\n    if (__alloc() != __c.__alloc())\n        assign(__c.begin(), __c.end());\n    else\n        __move_assign(__c, true_type());\n}\n\ntemplate <class _Allocator>\nvoid\nvector<bool, _Allocator>::__move_assign(vector& __c, true_type)\n    _NOEXCEPT_(is_nothrow_move_assignable<allocator_type>::value)\n{\n    deallocate();\n    __move_assign_alloc(__c);\n    this->__begin_ = __c.__begin_;\n    this->__size_ = __c.__size_;\n    this->__cap() = __c.__cap();\n    __c.__begin_ = nullptr;\n    __c.__cap() = __c.__size_ = 0;\n}\n\n#endif  // _LIBCPP_HAS_NO_RVALUE_REFERENCES\n\ntemplate <class _Allocator>\nvoid\nvector<bool, _Allocator>::assign(size_type __n, const value_type& __x)\n{\n    __size_ = 0;\n    if (__n > 0)\n    {\n        size_type __c = capacity();\n        if (__n <= __c)\n            __size_ = __n;\n        else\n        {\n            vector __v(__alloc());\n            __v.reserve(__recommend(__n));\n            __v.__size_ = __n;\n            swap(__v);\n        }\n        _VSTD::fill_n(begin(), __n, __x);\n    }\n  __invalidate_all_iterators();\n}\n\ntemplate <class _Allocator>\ntemplate <class _InputIterator>\ntypename enable_if\n<\n    __is_input_iterator<_InputIterator>::value &&\n   !__is_forward_iterator<_InputIterator>::value,\n   void\n>::type\nvector<bool, _Allocator>::assign(_InputIterator __first, _InputIterator __last)\n{\n    clear();\n    for (; __first != __last; ++__first)\n        push_back(*__first);\n}\n\ntemplate <class _Allocator>\ntemplate <class _ForwardIterator>\ntypename enable_if\n<\n    __is_forward_iterator<_ForwardIterator>::value,\n   void\n>::type\nvector<bool, _Allocator>::assign(_ForwardIterator __first, _ForwardIterator __last)\n{\n    clear();\n    difference_type __ns = _VSTD::distance(__first, __last);\n    _LIBCPP_ASSERT(__ns >= 0, \"invalid range specified\");\n    const size_t __n = static_cast<size_type>(__ns);\n    if (__n)\n    {\n        if (__n > capacity())\n        {\n            deallocate();\n            allocate(__n);\n        }\n        __construct_at_end(__first, __last);\n    }\n}\n\ntemplate <class _Allocator>\nvoid\nvector<bool, _Allocator>::reserve(size_type __n)\n{\n    if (__n > capacity())\n    {\n        vector __v(this->__alloc());\n        __v.allocate(__n);\n        __v.__construct_at_end(this->begin(), this->end());\n        swap(__v);\n        __invalidate_all_iterators();\n    }\n}\n\ntemplate <class _Allocator>\nvoid\nvector<bool, _Allocator>::shrink_to_fit() _NOEXCEPT\n{\n    if (__external_cap_to_internal(size()) > __cap())\n    {\n#ifndef _LIBCPP_NO_EXCEPTIONS\n        try\n        {\n#endif  // _LIBCPP_NO_EXCEPTIONS\n            vector(*this, allocator_type(__alloc())).swap(*this);\n#ifndef _LIBCPP_NO_EXCEPTIONS\n        }\n        catch (...)\n        {\n        }\n#endif  // _LIBCPP_NO_EXCEPTIONS\n    }\n}\n\ntemplate <class _Allocator>\ntypename vector<bool, _Allocator>::reference\nvector<bool, _Allocator>::at(size_type __n)\n{\n    if (__n >= size())\n        this->__throw_out_of_range();\n    return (*this)[__n];\n}\n\ntemplate <class _Allocator>\ntypename vector<bool, _Allocator>::const_reference\nvector<bool, _Allocator>::at(size_type __n) const\n{\n    if (__n >= size())\n        this->__throw_out_of_range();\n    return (*this)[__n];\n}\n\ntemplate <class _Allocator>\nvoid\nvector<bool, _Allocator>::push_back(const value_type& __x)\n{\n    if (this->__size_ == this->capacity())\n        reserve(__recommend(this->__size_ + 1));\n    ++this->__size_;\n    back() = __x;\n}\n\ntemplate <class _Allocator>\ntypename vector<bool, _Allocator>::iterator\nvector<bool, _Allocator>::insert(const_iterator __position, const value_type& __x)\n{\n    iterator __r;\n    if (size() < capacity())\n    {\n        const_iterator __old_end = end();\n        ++__size_;\n        _VSTD::copy_backward(__position, __old_end, end());\n        __r = __const_iterator_cast(__position);\n    }\n    else\n    {\n        vector __v(__alloc());\n        __v.reserve(__recommend(__size_ + 1));\n        __v.__size_ = __size_ + 1;\n        __r = _VSTD::copy(cbegin(), __position, __v.begin());\n        _VSTD::copy_backward(__position, cend(), __v.end());\n        swap(__v);\n    }\n    *__r = __x;\n    return __r;\n}\n\ntemplate <class _Allocator>\ntypename vector<bool, _Allocator>::iterator\nvector<bool, _Allocator>::insert(const_iterator __position, size_type __n, const value_type& __x)\n{\n    iterator __r;\n    size_type __c = capacity();\n    if (__n <= __c && size() <= __c - __n)\n    {\n        const_iterator __old_end = end();\n        __size_ += __n;\n        _VSTD::copy_backward(__position, __old_end, end());\n        __r = __const_iterator_cast(__position);\n    }\n    else\n    {\n        vector __v(__alloc());\n        __v.reserve(__recommend(__size_ + __n));\n        __v.__size_ = __size_ + __n;\n        __r = _VSTD::copy(cbegin(), __position, __v.begin());\n        _VSTD::copy_backward(__position, cend(), __v.end());\n        swap(__v);\n    }\n    _VSTD::fill_n(__r, __n, __x);\n    return __r;\n}\n\ntemplate <class _Allocator>\ntemplate <class _InputIterator>\ntypename enable_if\n<\n     __is_input_iterator  <_InputIterator>::value &&\n    !__is_forward_iterator<_InputIterator>::value,\n    typename vector<bool, _Allocator>::iterator\n>::type\nvector<bool, _Allocator>::insert(const_iterator __position, _InputIterator __first, _InputIterator __last)\n{\n    difference_type __off = __position - begin();\n    iterator __p = __const_iterator_cast(__position);\n    iterator __old_end = end();\n    for (; size() != capacity() && __first != __last; ++__first)\n    {\n        ++this->__size_;\n        back() = *__first;\n    }\n    vector __v(__alloc());\n    if (__first != __last)\n    {\n#ifndef _LIBCPP_NO_EXCEPTIONS\n        try\n        {\n#endif  // _LIBCPP_NO_EXCEPTIONS\n            __v.assign(__first, __last);\n            difference_type __old_size = static_cast<difference_type>(__old_end - begin());\n            difference_type __old_p = __p - begin();\n            reserve(__recommend(size() + __v.size()));\n            __p = begin() + __old_p;\n            __old_end = begin() + __old_size;\n#ifndef _LIBCPP_NO_EXCEPTIONS\n        }\n        catch (...)\n        {\n            erase(__old_end, end());\n            throw;\n        }\n#endif  // _LIBCPP_NO_EXCEPTIONS\n    }\n    __p = _VSTD::rotate(__p, __old_end, end());\n    insert(__p, __v.begin(), __v.end());\n    return begin() + __off;\n}\n\ntemplate <class _Allocator>\ntemplate <class _ForwardIterator>\ntypename enable_if\n<\n    __is_forward_iterator<_ForwardIterator>::value,\n    typename vector<bool, _Allocator>::iterator\n>::type\nvector<bool, _Allocator>::insert(const_iterator __position, _ForwardIterator __first, _ForwardIterator __last)\n{\n    const difference_type __n_signed = _VSTD::distance(__first, __last);\n    _LIBCPP_ASSERT(__n_signed >= 0, \"invalid range specified\");\n    const size_type __n = static_cast<size_type>(__n_signed);\n    iterator __r;\n    size_type __c = capacity();\n    if (__n <= __c && size() <= __c - __n)\n    {\n        const_iterator __old_end = end();\n        __size_ += __n;\n        _VSTD::copy_backward(__position, __old_end, end());\n        __r = __const_iterator_cast(__position);\n    }\n    else\n    {\n        vector __v(__alloc());\n        __v.reserve(__recommend(__size_ + __n));\n        __v.__size_ = __size_ + __n;\n        __r = _VSTD::copy(cbegin(), __position, __v.begin());\n        _VSTD::copy_backward(__position, cend(), __v.end());\n        swap(__v);\n    }\n    _VSTD::copy(__first, __last, __r);\n    return __r;\n}\n\ntemplate <class _Allocator>\ninline _LIBCPP_INLINE_VISIBILITY\ntypename vector<bool, _Allocator>::iterator\nvector<bool, _Allocator>::erase(const_iterator __position)\n{\n    iterator __r = __const_iterator_cast(__position);\n    _VSTD::copy(__position + 1, this->cend(), __r);\n    --__size_;\n    return __r;\n}\n\ntemplate <class _Allocator>\ntypename vector<bool, _Allocator>::iterator\nvector<bool, _Allocator>::erase(const_iterator __first, const_iterator __last)\n{\n    iterator __r = __const_iterator_cast(__first);\n    difference_type __d = __last - __first;\n    _VSTD::copy(__last, this->cend(), __r);\n    __size_ -= __d;\n    return __r;\n}\n\ntemplate <class _Allocator>\nvoid\nvector<bool, _Allocator>::swap(vector& __x)\n#if _LIBCPP_STD_VER >= 14\n    _NOEXCEPT\n#else\n    _NOEXCEPT_(!__alloc_traits::propagate_on_container_swap::value ||\n                __is_nothrow_swappable<allocator_type>::value)\n#endif\n{\n    _VSTD::swap(this->__begin_, __x.__begin_);\n    _VSTD::swap(this->__size_, __x.__size_);\n    _VSTD::swap(this->__cap(), __x.__cap());\n    __swap_allocator(this->__alloc(), __x.__alloc(), \n        integral_constant<bool, __alloc_traits::propagate_on_container_swap::value>());\n}\n\ntemplate <class _Allocator>\nvoid\nvector<bool, _Allocator>::resize(size_type __sz, value_type __x)\n{\n    size_type __cs = size();\n    if (__cs < __sz)\n    {\n        iterator __r;\n        size_type __c = capacity();\n        size_type __n = __sz - __cs;\n        if (__n <= __c && __cs <= __c - __n)\n        {\n            __r = end();\n            __size_ += __n;\n        }\n        else\n        {\n            vector __v(__alloc());\n            __v.reserve(__recommend(__size_ + __n));\n            __v.__size_ = __size_ + __n;\n            __r = _VSTD::copy(cbegin(), cend(), __v.begin());\n            swap(__v);\n        }\n        _VSTD::fill_n(__r, __n, __x);\n    }\n    else\n        __size_ = __sz;\n}\n\ntemplate <class _Allocator>\nvoid\nvector<bool, _Allocator>::flip() _NOEXCEPT\n{\n    // do middle whole words\n    size_type __n = __size_;\n    __storage_pointer __p = __begin_;\n    for (; __n >= __bits_per_word; ++__p, __n -= __bits_per_word)\n        *__p = ~*__p;\n    // do last partial word\n    if (__n > 0)\n    {\n        __storage_type __m = ~__storage_type(0) >> (__bits_per_word - __n);\n        __storage_type __b = *__p & __m;\n        *__p &= ~__m;\n        *__p |= ~__b & __m;\n    }\n}\n\ntemplate <class _Allocator>\nbool\nvector<bool, _Allocator>::__invariants() const\n{\n    if (this->__begin_ == nullptr)\n    {\n        if (this->__size_ != 0 || this->__cap() != 0)\n            return false;\n    }\n    else\n    {\n        if (this->__cap() == 0)\n            return false;\n        if (this->__size_ > this->capacity())\n            return false;\n    }\n    return true;\n}\n\ntemplate <class _Allocator>\nsize_t\nvector<bool, _Allocator>::__hash_code() const _NOEXCEPT\n{\n    size_t __h = 0;\n    // do middle whole words\n    size_type __n = __size_;\n    __storage_pointer __p = __begin_;\n    for (; __n >= __bits_per_word; ++__p, __n -= __bits_per_word)\n        __h ^= *__p;\n    // do last partial word\n    if (__n > 0)\n    {\n        const __storage_type __m = ~__storage_type(0) >> (__bits_per_word - __n);\n        __h ^= *__p & __m;\n    }\n    return __h;\n}\n\ntemplate <class _Allocator>\nstruct _LIBCPP_TEMPLATE_VIS hash<vector<bool, _Allocator> >\n    : public unary_function<vector<bool, _Allocator>, size_t>\n{\n    _LIBCPP_INLINE_VISIBILITY\n    size_t operator()(const vector<bool, _Allocator>& __vec) const _NOEXCEPT\n        {return __vec.__hash_code();}\n};\n\ntemplate <class _Tp, class _Allocator>\ninline _LIBCPP_INLINE_VISIBILITY\nbool\noperator==(const vector<_Tp, _Allocator>& __x, const vector<_Tp, _Allocator>& __y)\n{\n    const typename vector<_Tp, _Allocator>::size_type __sz = __x.size();\n    return __sz == __y.size() && _VSTD::equal(__x.begin(), __x.end(), __y.begin());\n}\n\ntemplate <class _Tp, class _Allocator>\ninline _LIBCPP_INLINE_VISIBILITY\nbool\noperator!=(const vector<_Tp, _Allocator>& __x, const vector<_Tp, _Allocator>& __y)\n{\n    return !(__x == __y);\n}\n\ntemplate <class _Tp, class _Allocator>\ninline _LIBCPP_INLINE_VISIBILITY\nbool\noperator< (const vector<_Tp, _Allocator>& __x, const vector<_Tp, _Allocator>& __y)\n{\n    return _VSTD::lexicographical_compare(__x.begin(), __x.end(), __y.begin(), __y.end());\n}\n\ntemplate <class _Tp, class _Allocator>\ninline _LIBCPP_INLINE_VISIBILITY\nbool\noperator> (const vector<_Tp, _Allocator>& __x, const vector<_Tp, _Allocator>& __y)\n{\n    return __y < __x;\n}\n\ntemplate <class _Tp, class _Allocator>\ninline _LIBCPP_INLINE_VISIBILITY\nbool\noperator>=(const vector<_Tp, _Allocator>& __x, const vector<_Tp, _Allocator>& __y)\n{\n    return !(__x < __y);\n}\n\ntemplate <class _Tp, class _Allocator>\ninline _LIBCPP_INLINE_VISIBILITY\nbool\noperator<=(const vector<_Tp, _Allocator>& __x, const vector<_Tp, _Allocator>& __y)\n{\n    return !(__y < __x);\n}\n\ntemplate <class _Tp, class _Allocator>\ninline _LIBCPP_INLINE_VISIBILITY\nvoid\nswap(vector<_Tp, _Allocator>& __x, vector<_Tp, _Allocator>& __y)\n    _NOEXCEPT_(_NOEXCEPT_(__x.swap(__y)))\n{\n    __x.swap(__y);\n}\n\n_LIBCPP_END_NAMESPACE_STD\n\n#endif  // _LIBCPP_VECTOR\n","// -*- C++ -*-\n//===--------------------------- string -----------------------------------===//\n//\n//                     The LLVM Compiler Infrastructure\n//\n// This file is distributed under the University of Illinois Open Source\n// License. See LICENSE.TXT for details.\n//\n//===----------------------------------------------------------------------===//\n\n#ifndef _LIBCPP_STRING\n#define _LIBCPP_STRING\n\n/*\n    string synopsis\n\nnamespace std\n{\n\ntemplate <class stateT>\nclass fpos\n{\nprivate:\n    stateT st;\npublic:\n    fpos(streamoff = streamoff());\n\n    operator streamoff() const;\n\n    stateT state() const;\n    void state(stateT);\n\n    fpos& operator+=(streamoff);\n    fpos  operator+ (streamoff) const;\n    fpos& operator-=(streamoff);\n    fpos  operator- (streamoff) const;\n};\n\ntemplate <class stateT> streamoff operator-(const fpos<stateT>& x, const fpos<stateT>& y);\n\ntemplate <class stateT> bool operator==(const fpos<stateT>& x, const fpos<stateT>& y);\ntemplate <class stateT> bool operator!=(const fpos<stateT>& x, const fpos<stateT>& y);\n\ntemplate <class charT>\nstruct char_traits\n{\n    typedef charT     char_type;\n    typedef ...       int_type;\n    typedef streamoff off_type;\n    typedef streampos pos_type;\n    typedef mbstate_t state_type;\n\n    static void assign(char_type& c1, const char_type& c2) noexcept;\n    static constexpr bool eq(char_type c1, char_type c2) noexcept;\n    static constexpr bool lt(char_type c1, char_type c2) noexcept;\n\n    static int              compare(const char_type* s1, const char_type* s2, size_t n);\n    static size_t           length(const char_type* s);\n    static const char_type* find(const char_type* s, size_t n, const char_type& a);\n    static char_type*       move(char_type* s1, const char_type* s2, size_t n);\n    static char_type*       copy(char_type* s1, const char_type* s2, size_t n);\n    static char_type*       assign(char_type* s, size_t n, char_type a);\n\n    static constexpr int_type  not_eof(int_type c) noexcept;\n    static constexpr char_type to_char_type(int_type c) noexcept;\n    static constexpr int_type  to_int_type(char_type c) noexcept;\n    static constexpr bool      eq_int_type(int_type c1, int_type c2) noexcept;\n    static constexpr int_type  eof() noexcept;\n};\n\ntemplate <> struct char_traits<char>;\ntemplate <> struct char_traits<wchar_t>;\n\ntemplate<class charT, class traits = char_traits<charT>, class Allocator = allocator<charT> >\nclass basic_string\n{\npublic:\n// types:\n    typedef traits traits_type;\n    typedef typename traits_type::char_type value_type;\n    typedef Allocator allocator_type;\n    typedef typename allocator_type::size_type size_type;\n    typedef typename allocator_type::difference_type difference_type;\n    typedef typename allocator_type::reference reference;\n    typedef typename allocator_type::const_reference const_reference;\n    typedef typename allocator_type::pointer pointer;\n    typedef typename allocator_type::const_pointer const_pointer;\n    typedef implementation-defined iterator;\n    typedef implementation-defined const_iterator;\n    typedef std::reverse_iterator<iterator> reverse_iterator;\n    typedef std::reverse_iterator<const_iterator> const_reverse_iterator;\n\n    static const size_type npos = -1;\n\n    basic_string()\n        noexcept(is_nothrow_default_constructible<allocator_type>::value);\n    explicit basic_string(const allocator_type& a);\n    basic_string(const basic_string& str);\n    basic_string(basic_string&& str)\n        noexcept(is_nothrow_move_constructible<allocator_type>::value);\n    basic_string(const basic_string& str, size_type pos,\n                 const allocator_type& a = allocator_type());\n    basic_string(const basic_string& str, size_type pos, size_type n,\n                 const Allocator& a = Allocator());\n    template<class T>\n        basic_string(const T& t, size_type pos, size_type n, const Allocator& a = Allocator()); // C++17\n    explicit basic_string(const basic_string_view<charT, traits> sv, const Allocator& a = Allocator());\n    basic_string(const value_type* s, const allocator_type& a = allocator_type());\n    basic_string(const value_type* s, size_type n, const allocator_type& a = allocator_type());\n    basic_string(size_type n, value_type c, const allocator_type& a = allocator_type());\n    template<class InputIterator>\n        basic_string(InputIterator begin, InputIterator end,\n                     const allocator_type& a = allocator_type());\n    basic_string(initializer_list<value_type>, const Allocator& = Allocator());\n    basic_string(const basic_string&, const Allocator&);\n    basic_string(basic_string&&, const Allocator&);\n\n    ~basic_string();\n\n    operator basic_string_view<charT, traits>() const noexcept;\n\n    basic_string& operator=(const basic_string& str);\n    basic_string& operator=(basic_string_view<charT, traits> sv);\n    basic_string& operator=(basic_string&& str)\n        noexcept(\n             allocator_type::propagate_on_container_move_assignment::value ||\n             allocator_type::is_always_equal::value ); // C++17\n    basic_string& operator=(const value_type* s);\n    basic_string& operator=(value_type c);\n    basic_string& operator=(initializer_list<value_type>);\n\n    iterator       begin() noexcept;\n    const_iterator begin() const noexcept;\n    iterator       end() noexcept;\n    const_iterator end() const noexcept;\n\n    reverse_iterator       rbegin() noexcept;\n    const_reverse_iterator rbegin() const noexcept;\n    reverse_iterator       rend() noexcept;\n    const_reverse_iterator rend() const noexcept;\n\n    const_iterator         cbegin() const noexcept;\n    const_iterator         cend() const noexcept;\n    const_reverse_iterator crbegin() const noexcept;\n    const_reverse_iterator crend() const noexcept;\n\n    size_type size() const noexcept;\n    size_type length() const noexcept;\n    size_type max_size() const noexcept;\n    size_type capacity() const noexcept;\n\n    void resize(size_type n, value_type c);\n    void resize(size_type n);\n\n    void reserve(size_type res_arg = 0);\n    void shrink_to_fit();\n    void clear() noexcept;\n    bool empty() const noexcept;\n\n    const_reference operator[](size_type pos) const;\n    reference       operator[](size_type pos);\n\n    const_reference at(size_type n) const;\n    reference       at(size_type n);\n\n    basic_string& operator+=(const basic_string& str);\n    basic_string& operator+=(basic_string_view<charT, traits> sv);\n    basic_string& operator+=(const value_type* s);\n    basic_string& operator+=(value_type c);\n    basic_string& operator+=(initializer_list<value_type>);\n\n    basic_string& append(const basic_string& str);\n    basic_string& append(basic_string_view<charT, traits> sv);\n    basic_string& append(const basic_string& str, size_type pos, size_type n=npos); //C++14\n    template <class T>\n        basic_string& append(const T& t, size_type pos, size_type n=npos); // C++17\n    basic_string& append(const value_type* s, size_type n);\n    basic_string& append(const value_type* s);\n    basic_string& append(size_type n, value_type c);\n    template<class InputIterator>\n        basic_string& append(InputIterator first, InputIterator last);\n    basic_string& append(initializer_list<value_type>);\n\n    void push_back(value_type c);\n    void pop_back();\n    reference       front();\n    const_reference front() const;\n    reference       back();\n    const_reference back() const;\n\n    basic_string& assign(const basic_string& str);\n    basic_string& assign(basic_string_view<charT, traits> sv);\n    basic_string& assign(basic_string&& str);\n    basic_string& assign(const basic_string& str, size_type pos, size_type n=npos); // C++14\n    template <class T>\n        basic_string& assign(const T& t, size_type pos, size_type n=npos); // C++17\n    basic_string& assign(const value_type* s, size_type n);\n    basic_string& assign(const value_type* s);\n    basic_string& assign(size_type n, value_type c);\n    template<class InputIterator>\n        basic_string& assign(InputIterator first, InputIterator last);\n    basic_string& assign(initializer_list<value_type>);\n\n    basic_string& insert(size_type pos1, const basic_string& str);\n    basic_string& insert(size_type pos1, basic_string_view<charT, traits> sv);\n    basic_string& insert(size_type pos1, const basic_string& str,\n                         size_type pos2, size_type n);\n    template <class T>\n        basic_string& insert(size_type pos1, const T& t, size_type pos2, size_type n); // C++17\n    basic_string& insert(size_type pos, const value_type* s, size_type n=npos); //C++14\n    basic_string& insert(size_type pos, const value_type* s);\n    basic_string& insert(size_type pos, size_type n, value_type c);\n    iterator      insert(const_iterator p, value_type c);\n    iterator      insert(const_iterator p, size_type n, value_type c);\n    template<class InputIterator>\n        iterator insert(const_iterator p, InputIterator first, InputIterator last);\n    iterator      insert(const_iterator p, initializer_list<value_type>);\n\n    basic_string& erase(size_type pos = 0, size_type n = npos);\n    iterator      erase(const_iterator position);\n    iterator      erase(const_iterator first, const_iterator last);\n\n    basic_string& replace(size_type pos1, size_type n1, const basic_string& str);\n    basic_string& replace(size_type pos1, size_type n1, basic_string_view<charT, traits> sv);\n    basic_string& replace(size_type pos1, size_type n1, const basic_string& str,\n                          size_type pos2, size_type n2=npos); // C++14\n    template <class T>\n        basic_string& replace(size_type pos1, size_type n1, const T& t,\n                              size_type pos2, size_type n); // C++17\n    basic_string& replace(size_type pos, size_type n1, const value_type* s, size_type n2);\n    basic_string& replace(size_type pos, size_type n1, const value_type* s);\n    basic_string& replace(size_type pos, size_type n1, size_type n2, value_type c);\n    basic_string& replace(const_iterator i1, const_iterator i2, const basic_string& str);\n    basic_string& replace(const_iterator i1, const_iterator i2, basic_string_view<charT, traits> sv);\n    basic_string& replace(const_iterator i1, const_iterator i2, const value_type* s, size_type n);\n    basic_string& replace(const_iterator i1, const_iterator i2, const value_type* s);\n    basic_string& replace(const_iterator i1, const_iterator i2, size_type n, value_type c);\n    template<class InputIterator>\n        basic_string& replace(const_iterator i1, const_iterator i2, InputIterator j1, InputIterator j2);\n    basic_string& replace(const_iterator i1, const_iterator i2, initializer_list<value_type>);\n\n    size_type copy(value_type* s, size_type n, size_type pos = 0) const;\n    basic_string substr(size_type pos = 0, size_type n = npos) const;\n\n    void swap(basic_string& str)\n        noexcept(allocator_traits<allocator_type>::propagate_on_container_swap::value ||\n                 allocator_traits<allocator_type>::is_always_equal::value);  // C++17\n\n    const value_type* c_str() const noexcept;\n    const value_type* data() const noexcept;\n          value_type* data()       noexcept;   // C++17\n\n    allocator_type get_allocator() const noexcept;\n\n    size_type find(const basic_string& str, size_type pos = 0) const noexcept;\n    size_type find(basic_string_view<charT, traits> sv, size_type pos = 0) const noexcept;\n    size_type find(const value_type* s, size_type pos, size_type n) const noexcept;\n    size_type find(const value_type* s, size_type pos = 0) const noexcept;\n    size_type find(value_type c, size_type pos = 0) const noexcept;\n\n    size_type rfind(const basic_string& str, size_type pos = npos) const noexcept;\n    size_type ffind(basic_string_view<charT, traits> sv, size_type pos = 0) const noexcept;\n    size_type rfind(const value_type* s, size_type pos, size_type n) const noexcept;\n    size_type rfind(const value_type* s, size_type pos = npos) const noexcept;\n    size_type rfind(value_type c, size_type pos = npos) const noexcept;\n\n    size_type find_first_of(const basic_string& str, size_type pos = 0) const noexcept;\n    size_type find_first_of(basic_string_view<charT, traits> sv, size_type pos = 0) const noexcept;\n    size_type find_first_of(const value_type* s, size_type pos, size_type n) const noexcept;\n    size_type find_first_of(const value_type* s, size_type pos = 0) const noexcept;\n    size_type find_first_of(value_type c, size_type pos = 0) const noexcept;\n\n    size_type find_last_of(const basic_string& str, size_type pos = npos) const noexcept;\n    size_type find_last_of(basic_string_view<charT, traits> sv, size_type pos = 0) const noexcept;\n    size_type find_last_of(const value_type* s, size_type pos, size_type n) const noexcept;\n    size_type find_last_of(const value_type* s, size_type pos = npos) const noexcept;\n    size_type find_last_of(value_type c, size_type pos = npos) const noexcept;\n\n    size_type find_first_not_of(const basic_string& str, size_type pos = 0) const noexcept;\n    size_type find_first_not_of(basic_string_view<charT, traits> sv, size_type pos = 0) const noexcept;\n    size_type find_first_not_of(const value_type* s, size_type pos, size_type n) const noexcept;\n    size_type find_first_not_of(const value_type* s, size_type pos = 0) const noexcept;\n    size_type find_first_not_of(value_type c, size_type pos = 0) const noexcept;\n\n    size_type find_last_not_of(const basic_string& str, size_type pos = npos) const noexcept;\n    size_type find_last_not_of(basic_string_view<charT, traits> sv, size_type pos = 0) const noexcept;\n    size_type find_last_not_of(const value_type* s, size_type pos, size_type n) const noexcept;\n    size_type find_last_not_of(const value_type* s, size_type pos = npos) const noexcept;\n    size_type find_last_not_of(value_type c, size_type pos = npos) const noexcept;\n\n    int compare(const basic_string& str) const noexcept;\n    int compare(basic_string_view<charT, traits> sv) const noexcept;\n    int compare(size_type pos1, size_type n1, const basic_string& str) const;\n    int compare(size_type pos1, size_type n1, basic_string_view<charT, traits> sv) const;\n    int compare(size_type pos1, size_type n1, const basic_string& str,\n                size_type pos2, size_type n2=npos) const; // C++14\n    template <class T>\n        int compare(size_type pos1, size_type n1, const T& t,\n                    size_type pos2, size_type n2=npos) const; // C++17\n    int compare(const value_type* s) const noexcept;\n    int compare(size_type pos1, size_type n1, const value_type* s) const;\n    int compare(size_type pos1, size_type n1, const value_type* s, size_type n2) const;\n\n    bool __invariants() const;\n};\n\ntemplate<class charT, class traits, class Allocator>\nbasic_string<charT, traits, Allocator>\noperator+(const basic_string<charT, traits, Allocator>& lhs,\n          const basic_string<charT, traits, Allocator>& rhs);\n\ntemplate<class charT, class traits, class Allocator>\nbasic_string<charT, traits, Allocator>\noperator+(const charT* lhs , const basic_string<charT,traits,Allocator>&rhs);\n\ntemplate<class charT, class traits, class Allocator>\nbasic_string<charT, traits, Allocator>\noperator+(charT lhs, const basic_string<charT,traits,Allocator>& rhs);\n\ntemplate<class charT, class traits, class Allocator>\nbasic_string<charT, traits, Allocator>\noperator+(const basic_string<charT, traits, Allocator>& lhs, const charT* rhs);\n\ntemplate<class charT, class traits, class Allocator>\nbasic_string<charT, traits, Allocator>\noperator+(const basic_string<charT, traits, Allocator>& lhs, charT rhs);\n\ntemplate<class charT, class traits, class Allocator>\nbool operator==(const basic_string<charT, traits, Allocator>& lhs,\n                const basic_string<charT, traits, Allocator>& rhs) noexcept;\n\ntemplate<class charT, class traits, class Allocator>\nbool operator==(const charT* lhs, const basic_string<charT, traits, Allocator>& rhs) noexcept;\n\ntemplate<class charT, class traits, class Allocator>\nbool operator==(const basic_string<charT,traits,Allocator>& lhs, const charT* rhs) noexcept;\n\ntemplate<class charT, class traits, class Allocator>\nbool operator!=(const basic_string<charT,traits,Allocator>& lhs,\n                const basic_string<charT, traits, Allocator>& rhs) noexcept;\n\ntemplate<class charT, class traits, class Allocator>\nbool operator!=(const charT* lhs, const basic_string<charT, traits, Allocator>& rhs) noexcept;\n\ntemplate<class charT, class traits, class Allocator>\nbool operator!=(const basic_string<charT, traits, Allocator>& lhs, const charT* rhs) noexcept;\n\ntemplate<class charT, class traits, class Allocator>\nbool operator< (const basic_string<charT, traits, Allocator>& lhs,\n                const basic_string<charT, traits, Allocator>& rhs) noexcept;\n\ntemplate<class charT, class traits, class Allocator>\nbool operator< (const basic_string<charT, traits, Allocator>& lhs, const charT* rhs) noexcept;\n\ntemplate<class charT, class traits, class Allocator>\nbool operator< (const charT* lhs, const basic_string<charT, traits, Allocator>& rhs) noexcept;\n\ntemplate<class charT, class traits, class Allocator>\nbool operator> (const basic_string<charT, traits, Allocator>& lhs,\n                const basic_string<charT, traits, Allocator>& rhs) noexcept;\n\ntemplate<class charT, class traits, class Allocator>\nbool operator> (const basic_string<charT, traits, Allocator>& lhs, const charT* rhs) noexcept;\n\ntemplate<class charT, class traits, class Allocator>\nbool operator> (const charT* lhs, const basic_string<charT, traits, Allocator>& rhs) noexcept;\n\ntemplate<class charT, class traits, class Allocator>\nbool operator<=(const basic_string<charT, traits, Allocator>& lhs,\n                const basic_string<charT, traits, Allocator>& rhs) noexcept;\n\ntemplate<class charT, class traits, class Allocator>\nbool operator<=(const basic_string<charT, traits, Allocator>& lhs, const charT* rhs) noexcept;\n\ntemplate<class charT, class traits, class Allocator>\nbool operator<=(const charT* lhs, const basic_string<charT, traits, Allocator>& rhs) noexcept;\n\ntemplate<class charT, class traits, class Allocator>\nbool operator>=(const basic_string<charT, traits, Allocator>& lhs,\n                const basic_string<charT, traits, Allocator>& rhs) noexcept;\n\ntemplate<class charT, class traits, class Allocator>\nbool operator>=(const basic_string<charT, traits, Allocator>& lhs, const charT* rhs) noexcept;\n\ntemplate<class charT, class traits, class Allocator>\nbool operator>=(const charT* lhs, const basic_string<charT, traits, Allocator>& rhs) noexcept;\n\ntemplate<class charT, class traits, class Allocator>\nvoid swap(basic_string<charT, traits, Allocator>& lhs,\n          basic_string<charT, traits, Allocator>& rhs)\n            noexcept(noexcept(lhs.swap(rhs)));\n\ntemplate<class charT, class traits, class Allocator>\nbasic_istream<charT, traits>&\noperator>>(basic_istream<charT, traits>& is, basic_string<charT, traits, Allocator>& str);\n\ntemplate<class charT, class traits, class Allocator>\nbasic_ostream<charT, traits>&\noperator<<(basic_ostream<charT, traits>& os, const basic_string<charT, traits, Allocator>& str);\n\ntemplate<class charT, class traits, class Allocator>\nbasic_istream<charT, traits>&\ngetline(basic_istream<charT, traits>& is, basic_string<charT, traits, Allocator>& str,\n        charT delim);\n\ntemplate<class charT, class traits, class Allocator>\nbasic_istream<charT, traits>&\ngetline(basic_istream<charT, traits>& is, basic_string<charT, traits, Allocator>& str);\n\ntypedef basic_string<char>    string;\ntypedef basic_string<wchar_t> wstring;\ntypedef basic_string<char16_t> u16string;\ntypedef basic_string<char32_t> u32string;\n\nint                stoi  (const string& str, size_t* idx = 0, int base = 10);\nlong               stol  (const string& str, size_t* idx = 0, int base = 10);\nunsigned long      stoul (const string& str, size_t* idx = 0, int base = 10);\nlong long          stoll (const string& str, size_t* idx = 0, int base = 10);\nunsigned long long stoull(const string& str, size_t* idx = 0, int base = 10);\n\nfloat       stof (const string& str, size_t* idx = 0);\ndouble      stod (const string& str, size_t* idx = 0);\nlong double stold(const string& str, size_t* idx = 0);\n\nstring to_string(int val);\nstring to_string(unsigned val);\nstring to_string(long val);\nstring to_string(unsigned long val);\nstring to_string(long long val);\nstring to_string(unsigned long long val);\nstring to_string(float val);\nstring to_string(double val);\nstring to_string(long double val);\n\nint                stoi  (const wstring& str, size_t* idx = 0, int base = 10);\nlong               stol  (const wstring& str, size_t* idx = 0, int base = 10);\nunsigned long      stoul (const wstring& str, size_t* idx = 0, int base = 10);\nlong long          stoll (const wstring& str, size_t* idx = 0, int base = 10);\nunsigned long long stoull(const wstring& str, size_t* idx = 0, int base = 10);\n\nfloat       stof (const wstring& str, size_t* idx = 0);\ndouble      stod (const wstring& str, size_t* idx = 0);\nlong double stold(const wstring& str, size_t* idx = 0);\n\nwstring to_wstring(int val);\nwstring to_wstring(unsigned val);\nwstring to_wstring(long val);\nwstring to_wstring(unsigned long val);\nwstring to_wstring(long long val);\nwstring to_wstring(unsigned long long val);\nwstring to_wstring(float val);\nwstring to_wstring(double val);\nwstring to_wstring(long double val);\n\ntemplate <> struct hash<string>;\ntemplate <> struct hash<u16string>;\ntemplate <> struct hash<u32string>;\ntemplate <> struct hash<wstring>;\n\nbasic_string<char>     operator \"\" s( const char *str,     size_t len ); // C++14\nbasic_string<wchar_t>  operator \"\" s( const wchar_t *str,  size_t len ); // C++14\nbasic_string<char16_t> operator \"\" s( const char16_t *str, size_t len ); // C++14\nbasic_string<char32_t> operator \"\" s( const char32_t *str, size_t len ); // C++14\n\n}  // std\n\n*/\n\n#include <__config>\n#include <string_view>\n#include <iosfwd>\n#include <cstring>\n#include <cstdio>  // For EOF.\n#include <cwchar>\n#include <algorithm>\n#include <iterator>\n#include <utility>\n#include <memory>\n#include <stdexcept>\n#include <type_traits>\n#include <initializer_list>\n#include <__functional_base>\n#ifndef _LIBCPP_HAS_NO_UNICODE_CHARS\n#include <cstdint>\n#endif\n\n#include <__undef_min_max>\n\n#include <__debug>\n\n#if !defined(_LIBCPP_HAS_NO_PRAGMA_SYSTEM_HEADER)\n#pragma GCC system_header\n#endif\n\n_LIBCPP_BEGIN_NAMESPACE_STD\n\n// fpos\n\ntemplate <class _StateT>\nclass _LIBCPP_TEMPLATE_VIS fpos\n{\nprivate:\n    _StateT __st_;\n    streamoff __off_;\npublic:\n    _LIBCPP_INLINE_VISIBILITY fpos(streamoff __off = streamoff()) : __st_(), __off_(__off) {}\n\n    _LIBCPP_INLINE_VISIBILITY operator streamoff() const {return __off_;}\n\n    _LIBCPP_INLINE_VISIBILITY _StateT state() const {return __st_;}\n    _LIBCPP_INLINE_VISIBILITY void state(_StateT __st) {__st_ = __st;}\n\n    _LIBCPP_INLINE_VISIBILITY fpos& operator+=(streamoff __off) {__off_ += __off; return *this;}\n    _LIBCPP_INLINE_VISIBILITY fpos  operator+ (streamoff __off) const {fpos __t(*this); __t += __off; return __t;}\n    _LIBCPP_INLINE_VISIBILITY fpos& operator-=(streamoff __off) {__off_ -= __off; return *this;}\n    _LIBCPP_INLINE_VISIBILITY fpos  operator- (streamoff __off) const {fpos __t(*this); __t -= __off; return __t;}\n};\n\ntemplate <class _StateT>\ninline _LIBCPP_INLINE_VISIBILITY\nstreamoff operator-(const fpos<_StateT>& __x, const fpos<_StateT>& __y)\n    {return streamoff(__x) - streamoff(__y);}\n\ntemplate <class _StateT>\ninline _LIBCPP_INLINE_VISIBILITY\nbool operator==(const fpos<_StateT>& __x, const fpos<_StateT>& __y)\n    {return streamoff(__x) == streamoff(__y);}\n\ntemplate <class _StateT>\ninline _LIBCPP_INLINE_VISIBILITY\nbool operator!=(const fpos<_StateT>& __x, const fpos<_StateT>& __y)\n    {return streamoff(__x) != streamoff(__y);}\n\n// basic_string\n\ntemplate<class _CharT, class _Traits, class _Allocator>\nbasic_string<_CharT, _Traits, _Allocator>\noperator+(const basic_string<_CharT, _Traits, _Allocator>& __x,\n          const basic_string<_CharT, _Traits, _Allocator>& __y);\n\ntemplate<class _CharT, class _Traits, class _Allocator>\nbasic_string<_CharT, _Traits, _Allocator>\noperator+(const _CharT* __x, const basic_string<_CharT,_Traits,_Allocator>& __y);\n\ntemplate<class _CharT, class _Traits, class _Allocator>\nbasic_string<_CharT, _Traits, _Allocator>\noperator+(_CharT __x, const basic_string<_CharT,_Traits,_Allocator>& __y);\n\ntemplate<class _CharT, class _Traits, class _Allocator>\nbasic_string<_CharT, _Traits, _Allocator>\noperator+(const basic_string<_CharT, _Traits, _Allocator>& __x, const _CharT* __y);\n\ntemplate<class _CharT, class _Traits, class _Allocator>\nbasic_string<_CharT, _Traits, _Allocator>\noperator+(const basic_string<_CharT, _Traits, _Allocator>& __x, _CharT __y);\n\ntemplate <bool>\nclass _LIBCPP_TEMPLATE_VIS __basic_string_common\n{\nprotected:\n    _LIBCPP_NORETURN void __throw_length_error() const;\n    _LIBCPP_NORETURN void __throw_out_of_range() const;\n};\n\ntemplate <bool __b>\nvoid\n__basic_string_common<__b>::__throw_length_error() const\n{\n    _VSTD::__throw_length_error(\"basic_string\");\n}\n\ntemplate <bool __b>\nvoid\n__basic_string_common<__b>::__throw_out_of_range() const\n{\n    _VSTD::__throw_out_of_range(\"basic_string\");\n}\n\n#ifdef _LIBCPP_MSVC\n#pragma warning( push )\n#pragma warning( disable: 4231 )\n#endif // _LIBCPP_MSVC\n_LIBCPP_EXTERN_TEMPLATE(class _LIBCPP_EXTERN_TEMPLATE_TYPE_VIS __basic_string_common<true>)\n#ifdef _LIBCPP_MSVC\n#pragma warning( pop )\n#endif // _LIBCPP_MSVC\n\n#ifdef _LIBCPP_NO_EXCEPTIONS\ntemplate <class _Iter>\nstruct __libcpp_string_gets_noexcept_iterator_impl : public true_type {};\n#elif defined(_LIBCPP_HAS_NO_NOEXCEPT)\ntemplate <class _Iter>\nstruct __libcpp_string_gets_noexcept_iterator_impl : public false_type {};\n#else\ntemplate <class _Iter, bool = __is_forward_iterator<_Iter>::value>\nstruct __libcpp_string_gets_noexcept_iterator_impl : public _LIBCPP_BOOL_CONSTANT((\n    noexcept(++(declval<_Iter&>())) && \n    is_nothrow_assignable<_Iter&, _Iter>::value && \n    noexcept(declval<_Iter>() == declval<_Iter>()) && \n    noexcept(*declval<_Iter>())\n)) {};\n\ntemplate <class _Iter> \nstruct __libcpp_string_gets_noexcept_iterator_impl<_Iter, false> : public false_type {};\n#endif\n\n\ntemplate <class _Iter>\nstruct __libcpp_string_gets_noexcept_iterator\n    : public _LIBCPP_BOOL_CONSTANT(__libcpp_is_trivial_iterator<_Iter>::value || __libcpp_string_gets_noexcept_iterator_impl<_Iter>::value) {};\n\ntemplate <class _CharT, class _Traits, class _Tp>\nstruct __can_be_converted_to_string_view : public _LIBCPP_BOOL_CONSTANT(\n\t( is_convertible<const _Tp&, basic_string_view<_CharT, _Traits> >::value &&\n     !is_convertible<const _Tp&, const _CharT*>::value)) {};\n\n#ifdef _LIBCPP_ABI_ALTERNATE_STRING_LAYOUT\n\ntemplate <class _CharT, size_t = sizeof(_CharT)>\nstruct __padding\n{\n    unsigned char __xx[sizeof(_CharT)-1];\n};\n\ntemplate <class _CharT>\nstruct __padding<_CharT, 1>\n{\n};\n\n#endif  // _LIBCPP_ABI_ALTERNATE_STRING_LAYOUT\n\ntemplate<class _CharT, class _Traits, class _Allocator>\nclass _LIBCPP_TEMPLATE_VIS basic_string\n    : private __basic_string_common<true>\n{\npublic:\n    typedef basic_string                                 __self;\n    typedef basic_string_view<_CharT, _Traits>           __self_view;\n    typedef _Traits                                      traits_type;\n    typedef typename traits_type::char_type              value_type;\n    typedef _Allocator                                   allocator_type;\n    typedef allocator_traits<allocator_type>             __alloc_traits;\n    typedef typename __alloc_traits::size_type           size_type;\n    typedef typename __alloc_traits::difference_type     difference_type;\n    typedef value_type&                                  reference;\n    typedef const value_type&                            const_reference;\n    typedef typename __alloc_traits::pointer             pointer;\n    typedef typename __alloc_traits::const_pointer       const_pointer;\n\n    static_assert(is_pod<value_type>::value, \"Character type of basic_string must be a POD\");\n    static_assert((is_same<_CharT, value_type>::value),\n                  \"traits_type::char_type must be the same type as CharT\");\n    static_assert((is_same<typename allocator_type::value_type, value_type>::value),\n                  \"Allocator::value_type must be same type as value_type\");\n#if defined(_LIBCPP_RAW_ITERATORS)\n    typedef pointer                                      iterator;\n    typedef const_pointer                                const_iterator;\n#else  // defined(_LIBCPP_RAW_ITERATORS)\n    typedef __wrap_iter<pointer>                         iterator;\n    typedef __wrap_iter<const_pointer>                   const_iterator;\n#endif  // defined(_LIBCPP_RAW_ITERATORS)\n    typedef _VSTD::reverse_iterator<iterator>             reverse_iterator;\n    typedef _VSTD::reverse_iterator<const_iterator>       const_reverse_iterator;\n\nprivate:\n\n#ifdef _LIBCPP_ABI_ALTERNATE_STRING_LAYOUT\n\n    struct __long\n    {\n        pointer   __data_;\n        size_type __size_;\n        size_type __cap_;\n    };\n\n#if _LIBCPP_BIG_ENDIAN\n    enum {__short_mask = 0x01};\n    enum {__long_mask  = 0x1ul};\n#else  // _LIBCPP_BIG_ENDIAN\n    enum {__short_mask = 0x80};\n    enum {__long_mask  = ~(size_type(~0) >> 1)};\n#endif  // _LIBCPP_BIG_ENDIAN\n\n    enum {__min_cap = (sizeof(__long) - 1)/sizeof(value_type) > 2 ?\n                      (sizeof(__long) - 1)/sizeof(value_type) : 2};\n\n    struct __short\n    {\n        value_type __data_[__min_cap];\n        struct\n            : __padding<value_type>\n        {\n            unsigned char __size_;\n        };\n    };\n\n#else\n\n    struct __long\n    {\n        size_type __cap_;\n        size_type __size_;\n        pointer   __data_;\n    };\n\n#if _LIBCPP_BIG_ENDIAN\n    enum {__short_mask = 0x80};\n    enum {__long_mask  = ~(size_type(~0) >> 1)};\n#else  // _LIBCPP_BIG_ENDIAN\n    enum {__short_mask = 0x01};\n    enum {__long_mask  = 0x1ul};\n#endif  // _LIBCPP_BIG_ENDIAN\n\n    enum {__min_cap = (sizeof(__long) - 1)/sizeof(value_type) > 2 ?\n                      (sizeof(__long) - 1)/sizeof(value_type) : 2};\n\n    struct __short\n    {\n        union\n        {\n            unsigned char __size_;\n            value_type __lx;\n        };\n        value_type __data_[__min_cap];\n    };\n\n#endif  // _LIBCPP_ABI_ALTERNATE_STRING_LAYOUT\n\n    union __ulx{__long __lx; __short __lxx;};\n\n    enum {__n_words = sizeof(__ulx) / sizeof(size_type)};\n\n    struct __raw\n    {\n        size_type __words[__n_words];\n    };\n\n    struct __rep\n    {\n        union\n        {\n            __long  __l;\n            __short __s;\n            __raw   __r;\n        };\n    };\n\n    __compressed_pair<__rep, allocator_type> __r_;\n\npublic:\n    static const size_type npos = -1;\n\n    _LIBCPP_INLINE_VISIBILITY basic_string()\n        _NOEXCEPT_(is_nothrow_default_constructible<allocator_type>::value);\n\n    _LIBCPP_INLINE_VISIBILITY explicit basic_string(const allocator_type& __a)\n#if _LIBCPP_STD_VER <= 14\n        _NOEXCEPT_(is_nothrow_copy_constructible<allocator_type>::value);\n#else\n        _NOEXCEPT;\n#endif\n\n    basic_string(const basic_string& __str);\n    basic_string(const basic_string& __str, const allocator_type& __a);\n\n#ifndef _LIBCPP_HAS_NO_RVALUE_REFERENCES\n    _LIBCPP_INLINE_VISIBILITY\n    basic_string(basic_string&& __str)\n#if _LIBCPP_STD_VER <= 14\n        _NOEXCEPT_(is_nothrow_move_constructible<allocator_type>::value);\n#else\n        _NOEXCEPT;\n#endif\n\n    _LIBCPP_INLINE_VISIBILITY\n    basic_string(basic_string&& __str, const allocator_type& __a);\n#endif  // _LIBCPP_HAS_NO_RVALUE_REFERENCES\n    _LIBCPP_INLINE_VISIBILITY basic_string(const value_type* __s);\n    _LIBCPP_INLINE_VISIBILITY\n    basic_string(const value_type* __s, const allocator_type& __a);\n    _LIBCPP_INLINE_VISIBILITY\n    basic_string(const value_type* __s, size_type __n);\n    _LIBCPP_INLINE_VISIBILITY\n    basic_string(const value_type* __s, size_type __n, const allocator_type& __a);\n    _LIBCPP_INLINE_VISIBILITY\n    basic_string(size_type __n, value_type __c);\n    _LIBCPP_INLINE_VISIBILITY\n    basic_string(size_type __n, value_type __c, const allocator_type& __a);\n    basic_string(const basic_string& __str, size_type __pos, size_type __n,\n                 const allocator_type& __a = allocator_type());\n    _LIBCPP_INLINE_VISIBILITY\n    basic_string(const basic_string& __str, size_type __pos,\n                 const allocator_type& __a = allocator_type());\n    template<class _Tp>\n        basic_string(const _Tp& __t, size_type __pos, size_type __n, \n                     const allocator_type& __a = allocator_type(),\n                     typename enable_if<__can_be_converted_to_string_view<_CharT, _Traits, _Tp>::value, void>::type* = 0);\n    _LIBCPP_INLINE_VISIBILITY explicit\n    basic_string(__self_view __sv);\n    _LIBCPP_INLINE_VISIBILITY\n    basic_string(__self_view __sv, const allocator_type& __a);\n    template<class _InputIterator>\n        _LIBCPP_INLINE_VISIBILITY\n        basic_string(_InputIterator __first, _InputIterator __last);\n    template<class _InputIterator>\n        _LIBCPP_INLINE_VISIBILITY\n        basic_string(_InputIterator __first, _InputIterator __last, const allocator_type& __a);\n#ifndef _LIBCPP_HAS_NO_GENERALIZED_INITIALIZERS\n    _LIBCPP_INLINE_VISIBILITY\n    basic_string(initializer_list<value_type> __il);\n    _LIBCPP_INLINE_VISIBILITY\n    basic_string(initializer_list<value_type> __il, const allocator_type& __a);\n#endif  // _LIBCPP_HAS_NO_GENERALIZED_INITIALIZERS\n\n    inline ~basic_string();\n\n    _LIBCPP_INLINE_VISIBILITY\n    operator __self_view() const _NOEXCEPT { return __self_view(data(), size()); }\n\n    basic_string& operator=(const basic_string& __str);\n\n#ifndef _LIBCPP_CXX03_LANG\n    template <class = void>\n#endif\n    _LIBCPP_INLINE_VISIBILITY\n    basic_string& operator=(__self_view __sv)  {return assign(__sv);}\n#ifndef _LIBCPP_HAS_NO_RVALUE_REFERENCES\n    _LIBCPP_INLINE_VISIBILITY\n    basic_string& operator=(basic_string&& __str)\n        _NOEXCEPT_((__noexcept_move_assign_container<_Allocator, __alloc_traits>::value));\n#endif\n    _LIBCPP_INLINE_VISIBILITY basic_string& operator=(const value_type* __s) {return assign(__s);}\n    basic_string& operator=(value_type __c);\n#ifndef _LIBCPP_HAS_NO_GENERALIZED_INITIALIZERS\n    _LIBCPP_INLINE_VISIBILITY\n    basic_string& operator=(initializer_list<value_type> __il) {return assign(__il.begin(), __il.size());}\n#endif  // _LIBCPP_HAS_NO_GENERALIZED_INITIALIZERS\n\n#if _LIBCPP_DEBUG_LEVEL >= 2\n    _LIBCPP_INLINE_VISIBILITY\n    iterator begin() _NOEXCEPT\n        {return iterator(this, __get_pointer());}\n    _LIBCPP_INLINE_VISIBILITY\n    const_iterator begin() const _NOEXCEPT\n        {return const_iterator(this, __get_pointer());}\n    _LIBCPP_INLINE_VISIBILITY\n    iterator end() _NOEXCEPT\n        {return iterator(this, __get_pointer() + size());}\n    _LIBCPP_INLINE_VISIBILITY\n    const_iterator end() const _NOEXCEPT\n        {return const_iterator(this, __get_pointer() + size());}\n#else\n    _LIBCPP_INLINE_VISIBILITY\n    iterator begin() _NOEXCEPT\n        {return iterator(__get_pointer());}\n    _LIBCPP_INLINE_VISIBILITY\n    const_iterator begin() const _NOEXCEPT\n        {return const_iterator(__get_pointer());}\n    _LIBCPP_INLINE_VISIBILITY\n    iterator end() _NOEXCEPT\n        {return iterator(__get_pointer() + size());}\n    _LIBCPP_INLINE_VISIBILITY\n    const_iterator end() const _NOEXCEPT\n        {return const_iterator(__get_pointer() + size());}\n#endif  // _LIBCPP_DEBUG_LEVEL >= 2\n    _LIBCPP_INLINE_VISIBILITY\n    reverse_iterator rbegin() _NOEXCEPT\n        {return reverse_iterator(end());}\n    _LIBCPP_INLINE_VISIBILITY\n    const_reverse_iterator rbegin() const _NOEXCEPT\n        {return const_reverse_iterator(end());}\n    _LIBCPP_INLINE_VISIBILITY\n    reverse_iterator rend() _NOEXCEPT\n        {return reverse_iterator(begin());}\n    _LIBCPP_INLINE_VISIBILITY\n    const_reverse_iterator rend() const _NOEXCEPT\n        {return const_reverse_iterator(begin());}\n\n    _LIBCPP_INLINE_VISIBILITY\n    const_iterator cbegin() const _NOEXCEPT\n        {return begin();}\n    _LIBCPP_INLINE_VISIBILITY\n    const_iterator cend() const _NOEXCEPT\n        {return end();}\n    _LIBCPP_INLINE_VISIBILITY\n    const_reverse_iterator crbegin() const _NOEXCEPT\n        {return rbegin();}\n    _LIBCPP_INLINE_VISIBILITY\n    const_reverse_iterator crend() const _NOEXCEPT\n        {return rend();}\n\n    _LIBCPP_INLINE_VISIBILITY size_type size() const _NOEXCEPT\n        {return __is_long() ? __get_long_size() : __get_short_size();}\n    _LIBCPP_INLINE_VISIBILITY size_type length() const _NOEXCEPT {return size();}\n    _LIBCPP_INLINE_VISIBILITY size_type max_size() const _NOEXCEPT;\n    _LIBCPP_INLINE_VISIBILITY size_type capacity() const _NOEXCEPT\n        {return (__is_long() ? __get_long_cap()\n                             : static_cast<size_type>(__min_cap)) - 1;}\n\n    void resize(size_type __n, value_type __c);\n    _LIBCPP_INLINE_VISIBILITY void resize(size_type __n) {resize(__n, value_type());}\n\n    void reserve(size_type res_arg = 0);\n    _LIBCPP_INLINE_VISIBILITY\n    void shrink_to_fit() _NOEXCEPT {reserve();}\n    _LIBCPP_INLINE_VISIBILITY\n    void clear() _NOEXCEPT;\n    _LIBCPP_INLINE_VISIBILITY bool empty() const _NOEXCEPT {return size() == 0;}\n\n    _LIBCPP_INLINE_VISIBILITY const_reference operator[](size_type __pos) const _NOEXCEPT;\n    _LIBCPP_INLINE_VISIBILITY reference       operator[](size_type __pos)       _NOEXCEPT;\n\n    const_reference at(size_type __n) const;\n    reference       at(size_type __n);\n\n    _LIBCPP_INLINE_VISIBILITY basic_string& operator+=(const basic_string& __str) {return append(__str);}\n    _LIBCPP_INLINE_VISIBILITY basic_string& operator+=(__self_view __sv)          {return append(__sv);}\n    _LIBCPP_INLINE_VISIBILITY basic_string& operator+=(const value_type* __s)     {return append(__s);}\n    _LIBCPP_INLINE_VISIBILITY basic_string& operator+=(value_type __c)            {push_back(__c); return *this;}\n#ifndef _LIBCPP_HAS_NO_GENERALIZED_INITIALIZERS\n    _LIBCPP_INLINE_VISIBILITY basic_string& operator+=(initializer_list<value_type> __il) {return append(__il);}\n#endif  // _LIBCPP_HAS_NO_GENERALIZED_INITIALIZERS\n\n    _LIBCPP_INLINE_VISIBILITY\n    basic_string& append(const basic_string& __str);\n    _LIBCPP_INLINE_VISIBILITY\n    basic_string& append(__self_view __sv) { return append(__sv.data(), __sv.size()); }\n    basic_string& append(const basic_string& __str, size_type __pos, size_type __n=npos);\n    template <class _Tp>\n        typename enable_if\n        <\n            __can_be_converted_to_string_view<_CharT, _Traits, _Tp>::value,\n            basic_string&\n        >::type\n                  append(const _Tp& __t, size_type __pos, size_type __n=npos);\n    basic_string& append(const value_type* __s, size_type __n);\n    basic_string& append(const value_type* __s);\n    basic_string& append(size_type __n, value_type __c);\n    template <class _ForwardIterator>\n    inline basic_string& __append_forward_unsafe(_ForwardIterator, _ForwardIterator);\n    template<class _InputIterator>\n        typename enable_if\n        <\n            __is_exactly_input_iterator<_InputIterator>::value\n                || !__libcpp_string_gets_noexcept_iterator<_InputIterator>::value,\n            basic_string&\n        >::type\n    _LIBCPP_INLINE_VISIBILITY\n    append(_InputIterator __first, _InputIterator __last) {\n      const basic_string __temp (__first, __last, __alloc());\n      append(__temp.data(), __temp.size());\n      return *this;\n    }\n    template<class _ForwardIterator>\n        typename enable_if\n        <\n            __is_forward_iterator<_ForwardIterator>::value\n                && __libcpp_string_gets_noexcept_iterator<_ForwardIterator>::value,\n            basic_string&\n        >::type\n    _LIBCPP_INLINE_VISIBILITY\n    append(_ForwardIterator __first, _ForwardIterator __last) {\n      return __append_forward_unsafe(__first, __last);\n    }\n\n#ifndef _LIBCPP_HAS_NO_GENERALIZED_INITIALIZERS\n    _LIBCPP_INLINE_VISIBILITY\n    basic_string& append(initializer_list<value_type> __il) {return append(__il.begin(), __il.size());}\n#endif  // _LIBCPP_HAS_NO_GENERALIZED_INITIALIZERS\n\n    void push_back(value_type __c);\n    _LIBCPP_INLINE_VISIBILITY\n    void pop_back();\n    _LIBCPP_INLINE_VISIBILITY reference       front();\n    _LIBCPP_INLINE_VISIBILITY const_reference front() const;\n    _LIBCPP_INLINE_VISIBILITY reference       back();\n    _LIBCPP_INLINE_VISIBILITY const_reference back() const;\n\n    _LIBCPP_INLINE_VISIBILITY\n    basic_string& assign(__self_view __sv) { return assign(__sv.data(), __sv.size()); }\n    _LIBCPP_INLINE_VISIBILITY\n    basic_string& assign(const basic_string& __str) { return *this = __str; }\n#ifndef _LIBCPP_HAS_NO_RVALUE_REFERENCES\n    _LIBCPP_INLINE_VISIBILITY\n    basic_string& assign(basic_string&& str)\n        _NOEXCEPT_((__noexcept_move_assign_container<_Allocator, __alloc_traits>::value))\n        {*this = _VSTD::move(str); return *this;}\n#endif\n    basic_string& assign(const basic_string& __str, size_type __pos, size_type __n=npos);\n    template <class _Tp>\n        typename enable_if\n        <\n            __can_be_converted_to_string_view<_CharT, _Traits, _Tp>::value,\n            basic_string&\n        >::type\n                  assign(const _Tp & __t, size_type pos, size_type n=npos);\n    basic_string& assign(const value_type* __s, size_type __n);\n    basic_string& assign(const value_type* __s);\n    basic_string& assign(size_type __n, value_type __c);\n    template<class _InputIterator>\n        typename enable_if\n        <\n           __is_exactly_input_iterator<_InputIterator>::value\n                || !__libcpp_string_gets_noexcept_iterator<_InputIterator>::value,\n            basic_string&\n        >::type\n        assign(_InputIterator __first, _InputIterator __last);\n    template<class _ForwardIterator>\n        typename enable_if\n        <\n            __is_forward_iterator<_ForwardIterator>::value\n                 && __libcpp_string_gets_noexcept_iterator<_ForwardIterator>::value,\n            basic_string&\n        >::type\n        assign(_ForwardIterator __first, _ForwardIterator __last);\n#ifndef _LIBCPP_HAS_NO_GENERALIZED_INITIALIZERS\n    _LIBCPP_INLINE_VISIBILITY\n    basic_string& assign(initializer_list<value_type> __il) {return assign(__il.begin(), __il.size());}\n#endif  // _LIBCPP_HAS_NO_GENERALIZED_INITIALIZERS\n\n    _LIBCPP_INLINE_VISIBILITY\n    basic_string& insert(size_type __pos1, const basic_string& __str);\n    _LIBCPP_INLINE_VISIBILITY\n    basic_string& insert(size_type __pos1, __self_view __sv) { return insert(__pos1, __sv.data(), __sv.size()); }\n    template <class _Tp>\n        typename enable_if\n        <\n            __can_be_converted_to_string_view<_CharT, _Traits, _Tp>::value,\n            basic_string&\n        >::type\n                  insert(size_type __pos1, const _Tp& __t, size_type __pos2, size_type __n=npos);\n    basic_string& insert(size_type __pos1, const basic_string& __str, size_type __pos2, size_type __n=npos);\n    basic_string& insert(size_type __pos, const value_type* __s, size_type __n);\n    basic_string& insert(size_type __pos, const value_type* __s);\n    basic_string& insert(size_type __pos, size_type __n, value_type __c);\n    iterator      insert(const_iterator __pos, value_type __c);\n    _LIBCPP_INLINE_VISIBILITY\n    iterator      insert(const_iterator __pos, size_type __n, value_type __c);\n    template<class _InputIterator>\n        typename enable_if\n        <\n           __is_exactly_input_iterator<_InputIterator>::value\n                || !__libcpp_string_gets_noexcept_iterator<_InputIterator>::value,\n            iterator\n        >::type\n        insert(const_iterator __pos, _InputIterator __first, _InputIterator __last);\n    template<class _ForwardIterator>\n        typename enable_if\n        <\n            __is_forward_iterator<_ForwardIterator>::value\n                 && __libcpp_string_gets_noexcept_iterator<_ForwardIterator>::value,\n            iterator\n        >::type\n        insert(const_iterator __pos, _ForwardIterator __first, _ForwardIterator __last);\n#ifndef _LIBCPP_HAS_NO_GENERALIZED_INITIALIZERS\n    _LIBCPP_INLINE_VISIBILITY\n    iterator insert(const_iterator __pos, initializer_list<value_type> __il)\n                    {return insert(__pos, __il.begin(), __il.end());}\n#endif  // _LIBCPP_HAS_NO_GENERALIZED_INITIALIZERS\n\n    basic_string& erase(size_type __pos = 0, size_type __n = npos);\n    _LIBCPP_INLINE_VISIBILITY\n    iterator      erase(const_iterator __pos);\n    _LIBCPP_INLINE_VISIBILITY\n    iterator      erase(const_iterator __first, const_iterator __last);\n\n    _LIBCPP_INLINE_VISIBILITY\n    basic_string& replace(size_type __pos1, size_type __n1, const basic_string& __str);\n    _LIBCPP_INLINE_VISIBILITY\n    basic_string& replace(size_type __pos1, size_type __n1, __self_view __sv) { return replace(__pos1, __n1, __sv.data(), __sv.size()); }\n    basic_string& replace(size_type __pos1, size_type __n1, const basic_string& __str, size_type __pos2, size_type __n2=npos);\n    template <class _Tp>\n        typename enable_if\n        <\n            __can_be_converted_to_string_view<_CharT, _Traits, _Tp>::value,\n            basic_string&\n        >::type\n                  replace(size_type __pos1, size_type __n1, const _Tp& __t, size_type __pos2, size_type __n2=npos);\n    basic_string& replace(size_type __pos, size_type __n1, const value_type* __s, size_type __n2);\n    basic_string& replace(size_type __pos, size_type __n1, const value_type* __s);\n    basic_string& replace(size_type __pos, size_type __n1, size_type __n2, value_type __c);\n    _LIBCPP_INLINE_VISIBILITY\n    basic_string& replace(const_iterator __i1, const_iterator __i2, const basic_string& __str);\n    _LIBCPP_INLINE_VISIBILITY\n    basic_string& replace(const_iterator __i1, const_iterator __i2, __self_view __sv) { return replace(__i1 - begin(), __i2 - __i1, __sv); }\n    _LIBCPP_INLINE_VISIBILITY\n    basic_string& replace(const_iterator __i1, const_iterator __i2, const value_type* __s, size_type __n);\n    _LIBCPP_INLINE_VISIBILITY\n    basic_string& replace(const_iterator __i1, const_iterator __i2, const value_type* __s);\n    _LIBCPP_INLINE_VISIBILITY\n    basic_string& replace(const_iterator __i1, const_iterator __i2, size_type __n, value_type __c);\n    template<class _InputIterator>\n        typename enable_if\n        <\n            __is_input_iterator<_InputIterator>::value,\n            basic_string&\n        >::type\n        replace(const_iterator __i1, const_iterator __i2, _InputIterator __j1, _InputIterator __j2);\n#ifndef _LIBCPP_HAS_NO_GENERALIZED_INITIALIZERS\n    _LIBCPP_INLINE_VISIBILITY\n    basic_string& replace(const_iterator __i1, const_iterator __i2, initializer_list<value_type> __il)\n        {return replace(__i1, __i2, __il.begin(), __il.end());}\n#endif  // _LIBCPP_HAS_NO_GENERALIZED_INITIALIZERS\n\n    size_type copy(value_type* __s, size_type __n, size_type __pos = 0) const;\n    _LIBCPP_INLINE_VISIBILITY\n    basic_string substr(size_type __pos = 0, size_type __n = npos) const;\n\n    _LIBCPP_INLINE_VISIBILITY\n    void swap(basic_string& __str)\n#if _LIBCPP_STD_VER >= 14\n        _NOEXCEPT_DEBUG;\n#else\n        _NOEXCEPT_DEBUG_(!__alloc_traits::propagate_on_container_swap::value ||\n                    __is_nothrow_swappable<allocator_type>::value);\n#endif\n\n    _LIBCPP_INLINE_VISIBILITY\n    const value_type* c_str() const _NOEXCEPT {return data();}\n    _LIBCPP_INLINE_VISIBILITY\n    const value_type* data() const _NOEXCEPT  {return _VSTD::__to_raw_pointer(__get_pointer());}\n#if _LIBCPP_STD_VER > 14\n    _LIBCPP_INLINE_VISIBILITY\n    value_type* data()             _NOEXCEPT  {return _VSTD::__to_raw_pointer(__get_pointer());}\n#endif\n\n    _LIBCPP_INLINE_VISIBILITY\n    allocator_type get_allocator() const _NOEXCEPT {return __alloc();}\n\n    _LIBCPP_INLINE_VISIBILITY\n    size_type find(const basic_string& __str, size_type __pos = 0) const _NOEXCEPT;\n    _LIBCPP_INLINE_VISIBILITY\n    size_type find(__self_view __sv, size_type __pos = 0) const _NOEXCEPT;\n    size_type find(const value_type* __s, size_type __pos, size_type __n) const _NOEXCEPT;\n    _LIBCPP_INLINE_VISIBILITY\n    size_type find(const value_type* __s, size_type __pos = 0) const _NOEXCEPT;\n    size_type find(value_type __c, size_type __pos = 0) const _NOEXCEPT;\n\n    _LIBCPP_INLINE_VISIBILITY\n    size_type rfind(const basic_string& __str, size_type __pos = npos) const _NOEXCEPT;\n    _LIBCPP_INLINE_VISIBILITY\n    size_type rfind(__self_view __sv, size_type __pos = 0) const _NOEXCEPT;\n    size_type rfind(const value_type* __s, size_type __pos, size_type __n) const _NOEXCEPT;\n    _LIBCPP_INLINE_VISIBILITY\n    size_type rfind(const value_type* __s, size_type __pos = npos) const _NOEXCEPT;\n    size_type rfind(value_type __c, size_type __pos = npos) const _NOEXCEPT;\n\n    _LIBCPP_INLINE_VISIBILITY\n    size_type find_first_of(const basic_string& __str, size_type __pos = 0) const _NOEXCEPT;\n    _LIBCPP_INLINE_VISIBILITY\n    size_type find_first_of(__self_view __sv, size_type __pos = 0) const _NOEXCEPT;\n    size_type find_first_of(const value_type* __s, size_type __pos, size_type __n) const _NOEXCEPT;\n    _LIBCPP_INLINE_VISIBILITY\n    size_type find_first_of(const value_type* __s, size_type __pos = 0) const _NOEXCEPT;\n    _LIBCPP_INLINE_VISIBILITY\n    size_type find_first_of(value_type __c, size_type __pos = 0) const _NOEXCEPT;\n\n    _LIBCPP_INLINE_VISIBILITY\n    size_type find_last_of(const basic_string& __str, size_type __pos = npos) const _NOEXCEPT;\n    _LIBCPP_INLINE_VISIBILITY\n    size_type find_last_of(__self_view __sv, size_type __pos = 0) const _NOEXCEPT;\n    size_type find_last_of(const value_type* __s, size_type __pos, size_type __n) const _NOEXCEPT;\n    _LIBCPP_INLINE_VISIBILITY\n    size_type find_last_of(const value_type* __s, size_type __pos = npos) const _NOEXCEPT;\n    _LIBCPP_INLINE_VISIBILITY\n    size_type find_last_of(value_type __c, size_type __pos = npos) const _NOEXCEPT;\n\n    _LIBCPP_INLINE_VISIBILITY\n    size_type find_first_not_of(const basic_string& __str, size_type __pos = 0) const _NOEXCEPT;\n    _LIBCPP_INLINE_VISIBILITY\n    size_type find_first_not_of(__self_view __sv, size_type __pos = 0) const _NOEXCEPT;\n    size_type find_first_not_of(const value_type* __s, size_type __pos, size_type __n) const _NOEXCEPT;\n    _LIBCPP_INLINE_VISIBILITY\n    size_type find_first_not_of(const value_type* __s, size_type __pos = 0) const _NOEXCEPT;\n    _LIBCPP_INLINE_VISIBILITY\n    size_type find_first_not_of(value_type __c, size_type __pos = 0) const _NOEXCEPT;\n\n    _LIBCPP_INLINE_VISIBILITY\n    size_type find_last_not_of(const basic_string& __str, size_type __pos = npos) const _NOEXCEPT;\n    _LIBCPP_INLINE_VISIBILITY\n    size_type find_last_not_of(__self_view __sv, size_type __pos = 0) const _NOEXCEPT;\n    size_type find_last_not_of(const value_type* __s, size_type __pos, size_type __n) const _NOEXCEPT;\n    _LIBCPP_INLINE_VISIBILITY\n    size_type find_last_not_of(const value_type* __s, size_type __pos = npos) const _NOEXCEPT;\n    _LIBCPP_INLINE_VISIBILITY\n    size_type find_last_not_of(value_type __c, size_type __pos = npos) const _NOEXCEPT;\n\n    _LIBCPP_INLINE_VISIBILITY\n    int compare(const basic_string& __str) const _NOEXCEPT;\n    _LIBCPP_INLINE_VISIBILITY\n    int compare(__self_view __sv) const _NOEXCEPT;\n    _LIBCPP_INLINE_VISIBILITY\n    int compare(size_type __pos1, size_type __n1, __self_view __sv) const;\n    _LIBCPP_INLINE_VISIBILITY\n    int compare(size_type __pos1, size_type __n1, const basic_string& __str) const;\n    int compare(size_type __pos1, size_type __n1, const basic_string& __str, size_type __pos2, size_type __n2=npos) const;\n    template <class _Tp>\n    inline _LIBCPP_INLINE_VISIBILITY\n        typename enable_if\n        <\n            __can_be_converted_to_string_view<_CharT, _Traits, _Tp>::value,\n            int\n        >::type\n        compare(size_type __pos1, size_type __n1, const _Tp& __t, size_type __pos2, size_type __n2=npos) const;\n    int compare(const value_type* __s) const _NOEXCEPT;\n    int compare(size_type __pos1, size_type __n1, const value_type* __s) const;\n    int compare(size_type __pos1, size_type __n1, const value_type* __s, size_type __n2) const;\n\n    _LIBCPP_INLINE_VISIBILITY bool __invariants() const;\n\n    _LIBCPP_INLINE_VISIBILITY\n    bool __is_long() const _NOEXCEPT\n        {return bool(__r_.first().__s.__size_ & __short_mask);}\n\n#if _LIBCPP_DEBUG_LEVEL >= 2\n\n    bool __dereferenceable(const const_iterator* __i) const;\n    bool __decrementable(const const_iterator* __i) const;\n    bool __addable(const const_iterator* __i, ptrdiff_t __n) const;\n    bool __subscriptable(const const_iterator* __i, ptrdiff_t __n) const;\n\n#endif  // _LIBCPP_DEBUG_LEVEL >= 2\n\nprivate:\n    _LIBCPP_INLINE_VISIBILITY\n    allocator_type& __alloc() _NOEXCEPT\n        {return __r_.second();}\n    _LIBCPP_INLINE_VISIBILITY\n    const allocator_type& __alloc() const _NOEXCEPT\n        {return __r_.second();}\n\n#ifdef _LIBCPP_ABI_ALTERNATE_STRING_LAYOUT\n\n    _LIBCPP_INLINE_VISIBILITY\n    void __set_short_size(size_type __s) _NOEXCEPT\n#   if _LIBCPP_BIG_ENDIAN\n        {__r_.first().__s.__size_ = (unsigned char)(__s << 1);}\n#   else\n        {__r_.first().__s.__size_ = (unsigned char)(__s);}\n#   endif\n\n    _LIBCPP_INLINE_VISIBILITY\n    size_type __get_short_size() const _NOEXCEPT\n#   if _LIBCPP_BIG_ENDIAN\n        {return __r_.first().__s.__size_ >> 1;}\n#   else\n        {return __r_.first().__s.__size_;}\n#   endif\n\n#else  // _LIBCPP_ABI_ALTERNATE_STRING_LAYOUT\n\n    _LIBCPP_INLINE_VISIBILITY\n    void __set_short_size(size_type __s) _NOEXCEPT\n#   if _LIBCPP_BIG_ENDIAN\n        {__r_.first().__s.__size_ = (unsigned char)(__s);}\n#   else\n        {__r_.first().__s.__size_ = (unsigned char)(__s << 1);}\n#   endif\n\n    _LIBCPP_INLINE_VISIBILITY\n    size_type __get_short_size() const _NOEXCEPT\n#   if _LIBCPP_BIG_ENDIAN\n        {return __r_.first().__s.__size_;}\n#   else\n        {return __r_.first().__s.__size_ >> 1;}\n#   endif\n\n#endif  // _LIBCPP_ABI_ALTERNATE_STRING_LAYOUT\n\n    _LIBCPP_INLINE_VISIBILITY\n    void __set_long_size(size_type __s) _NOEXCEPT\n        {__r_.first().__l.__size_ = __s;}\n    _LIBCPP_INLINE_VISIBILITY\n    size_type __get_long_size() const _NOEXCEPT\n        {return __r_.first().__l.__size_;}\n    _LIBCPP_INLINE_VISIBILITY\n    void __set_size(size_type __s) _NOEXCEPT\n        {if (__is_long()) __set_long_size(__s); else __set_short_size(__s);}\n\n    _LIBCPP_INLINE_VISIBILITY\n    void __set_long_cap(size_type __s) _NOEXCEPT\n        {__r_.first().__l.__cap_  = __long_mask | __s;}\n    _LIBCPP_INLINE_VISIBILITY\n    size_type __get_long_cap() const _NOEXCEPT\n        {return __r_.first().__l.__cap_ & size_type(~__long_mask);}\n\n    _LIBCPP_INLINE_VISIBILITY\n    void __set_long_pointer(pointer __p) _NOEXCEPT\n        {__r_.first().__l.__data_ = __p;}\n    _LIBCPP_INLINE_VISIBILITY\n    pointer __get_long_pointer() _NOEXCEPT\n        {return __r_.first().__l.__data_;}\n    _LIBCPP_INLINE_VISIBILITY\n    const_pointer __get_long_pointer() const _NOEXCEPT\n        {return __r_.first().__l.__data_;}\n    _LIBCPP_INLINE_VISIBILITY\n    pointer __get_short_pointer() _NOEXCEPT\n        {return pointer_traits<pointer>::pointer_to(__r_.first().__s.__data_[0]);}\n    _LIBCPP_INLINE_VISIBILITY\n    const_pointer __get_short_pointer() const _NOEXCEPT\n        {return pointer_traits<const_pointer>::pointer_to(__r_.first().__s.__data_[0]);}\n    _LIBCPP_INLINE_VISIBILITY\n    pointer __get_pointer() _NOEXCEPT\n        {return __is_long() ? __get_long_pointer() : __get_short_pointer();}\n    _LIBCPP_INLINE_VISIBILITY\n    const_pointer __get_pointer() const _NOEXCEPT\n        {return __is_long() ? __get_long_pointer() : __get_short_pointer();}\n\n    _LIBCPP_INLINE_VISIBILITY\n    void __zero() _NOEXCEPT\n        {\n            size_type (&__a)[__n_words] = __r_.first().__r.__words;\n            for (unsigned __i = 0; __i < __n_words; ++__i)\n                __a[__i] = 0;\n        }\n\n    template <size_type __a> static\n        _LIBCPP_INLINE_VISIBILITY\n        size_type __align_it(size_type __s) _NOEXCEPT\n            {return (__s + (__a-1)) & ~(__a-1);}\n    enum {__alignment = 16};\n    static _LIBCPP_INLINE_VISIBILITY\n    size_type __recommend(size_type __s) _NOEXCEPT\n        {return (__s < __min_cap ? static_cast<size_type>(__min_cap) :\n                 __align_it<sizeof(value_type) < __alignment ?\n                            __alignment/sizeof(value_type) : 1 > (__s+1)) - 1;}\n\n    inline _LIBCPP_EXTERN_TEMPLATE_INLINE_VISIBILITY\n    void __init(const value_type* __s, size_type __sz, size_type __reserve);\n    inline _LIBCPP_EXTERN_TEMPLATE_INLINE_VISIBILITY\n    void __init(const value_type* __s, size_type __sz);\n    inline _LIBCPP_EXTERN_TEMPLATE_INLINE_VISIBILITY\n    void __init(size_type __n, value_type __c);\n\n    template <class _InputIterator>\n    inline _LIBCPP_EXTERN_TEMPLATE_INLINE_VISIBILITY\n    typename enable_if\n    <\n        __is_exactly_input_iterator<_InputIterator>::value,\n        void\n    >::type\n    __init(_InputIterator __first, _InputIterator __last);\n\n    template <class _ForwardIterator>\n    inline _LIBCPP_EXTERN_TEMPLATE_INLINE_VISIBILITY\n    typename enable_if\n    <\n        __is_forward_iterator<_ForwardIterator>::value,\n        void\n    >::type\n    __init(_ForwardIterator __first, _ForwardIterator __last);\n\n    void __grow_by(size_type __old_cap, size_type __delta_cap, size_type __old_sz,\n                   size_type __n_copy,  size_type __n_del,     size_type __n_add = 0);\n    void __grow_by_and_replace(size_type __old_cap, size_type __delta_cap, size_type __old_sz,\n                               size_type __n_copy,  size_type __n_del,\n                               size_type __n_add, const value_type* __p_new_stuff);\n\n    _LIBCPP_INLINE_VISIBILITY\n    void __erase_to_end(size_type __pos);\n\n    _LIBCPP_INLINE_VISIBILITY\n    void __copy_assign_alloc(const basic_string& __str)\n        {__copy_assign_alloc(__str, integral_constant<bool,\n                      __alloc_traits::propagate_on_container_copy_assignment::value>());}\n\n    _LIBCPP_INLINE_VISIBILITY\n    void __copy_assign_alloc(const basic_string& __str, true_type)\n        {\n            if (__alloc() != __str.__alloc())\n            {\n                clear();\n                shrink_to_fit();\n            }\n            __alloc() = __str.__alloc();\n        }\n\n    _LIBCPP_INLINE_VISIBILITY\n    void __copy_assign_alloc(const basic_string&, false_type) _NOEXCEPT\n        {}\n\n#ifndef _LIBCPP_HAS_NO_RVALUE_REFERENCES\n    _LIBCPP_INLINE_VISIBILITY\n    void __move_assign(basic_string& __str, false_type)\n        _NOEXCEPT_(__alloc_traits::is_always_equal::value);\n    _LIBCPP_INLINE_VISIBILITY\n    void __move_assign(basic_string& __str, true_type)\n#if _LIBCPP_STD_VER > 14\n        _NOEXCEPT;\n#else\n        _NOEXCEPT_(is_nothrow_move_assignable<allocator_type>::value);\n#endif\n#endif\n\n    _LIBCPP_INLINE_VISIBILITY\n    void\n    __move_assign_alloc(basic_string& __str)\n        _NOEXCEPT_(\n            !__alloc_traits::propagate_on_container_move_assignment::value ||\n            is_nothrow_move_assignable<allocator_type>::value)\n    {__move_assign_alloc(__str, integral_constant<bool,\n                      __alloc_traits::propagate_on_container_move_assignment::value>());}\n\n    _LIBCPP_INLINE_VISIBILITY\n    void __move_assign_alloc(basic_string& __c, true_type)\n        _NOEXCEPT_(is_nothrow_move_assignable<allocator_type>::value)\n        {\n            __alloc() = _VSTD::move(__c.__alloc());\n        }\n\n    _LIBCPP_INLINE_VISIBILITY\n    void __move_assign_alloc(basic_string&, false_type)\n        _NOEXCEPT\n        {}\n\n    _LIBCPP_INLINE_VISIBILITY void __invalidate_all_iterators();\n    _LIBCPP_INLINE_VISIBILITY void __invalidate_iterators_past(size_type);\n\n    friend basic_string operator+<>(const basic_string&, const basic_string&);\n    friend basic_string operator+<>(const value_type*, const basic_string&);\n    friend basic_string operator+<>(value_type, const basic_string&);\n    friend basic_string operator+<>(const basic_string&, const value_type*);\n    friend basic_string operator+<>(const basic_string&, value_type);\n};\n\ntemplate <class _CharT, class _Traits, class _Allocator>\ninline _LIBCPP_INLINE_VISIBILITY\nvoid\nbasic_string<_CharT, _Traits, _Allocator>::__invalidate_all_iterators()\n{\n#if _LIBCPP_DEBUG_LEVEL >= 2\n    __get_db()->__invalidate_all(this);\n#endif  // _LIBCPP_DEBUG_LEVEL >= 2\n}\n\ntemplate <class _CharT, class _Traits, class _Allocator>\ninline _LIBCPP_INLINE_VISIBILITY\nvoid\nbasic_string<_CharT, _Traits, _Allocator>::__invalidate_iterators_past(size_type\n#if _LIBCPP_DEBUG_LEVEL >= 2\n                                                                        __pos\n#endif\n                                                                      )\n{\n#if _LIBCPP_DEBUG_LEVEL >= 2\n    __c_node* __c = __get_db()->__find_c_and_lock(this);\n    if (__c)\n    {\n        const_pointer __new_last = __get_pointer() + __pos;\n        for (__i_node** __p = __c->end_; __p != __c->beg_; )\n        {\n            --__p;\n            const_iterator* __i = static_cast<const_iterator*>((*__p)->__i_);\n            if (__i->base() > __new_last)\n            {\n                (*__p)->__c_ = nullptr;\n                if (--__c->end_ != __p)\n                    memmove(__p, __p+1, (__c->end_ - __p)*sizeof(__i_node*));\n            }\n        }\n        __get_db()->unlock();\n    }\n#endif  // _LIBCPP_DEBUG_LEVEL >= 2\n}\n\ntemplate <class _CharT, class _Traits, class _Allocator>\ninline _LIBCPP_INLINE_VISIBILITY\nbasic_string<_CharT, _Traits, _Allocator>::basic_string()\n    _NOEXCEPT_(is_nothrow_default_constructible<allocator_type>::value)\n{\n#if _LIBCPP_DEBUG_LEVEL >= 2\n    __get_db()->__insert_c(this);\n#endif\n    __zero();\n}\n\ntemplate <class _CharT, class _Traits, class _Allocator>\ninline _LIBCPP_INLINE_VISIBILITY\nbasic_string<_CharT, _Traits, _Allocator>::basic_string(const allocator_type& __a)\n#if _LIBCPP_STD_VER <= 14\n        _NOEXCEPT_(is_nothrow_copy_constructible<allocator_type>::value)\n#else\n        _NOEXCEPT\n#endif\n: __r_(__a)\n{\n#if _LIBCPP_DEBUG_LEVEL >= 2\n    __get_db()->__insert_c(this);\n#endif\n    __zero();\n}\n\ntemplate <class _CharT, class _Traits, class _Allocator>\nvoid basic_string<_CharT, _Traits, _Allocator>::__init(const value_type* __s,\n                                                       size_type __sz,\n                                                       size_type __reserve)\n{\n    if (__reserve > max_size())\n        this->__throw_length_error();\n    pointer __p;\n    if (__reserve < __min_cap)\n    {\n        __set_short_size(__sz);\n        __p = __get_short_pointer();\n    }\n    else\n    {\n        size_type __cap = __recommend(__reserve);\n        __p = __alloc_traits::allocate(__alloc(), __cap+1);\n        __set_long_pointer(__p);\n        __set_long_cap(__cap+1);\n        __set_long_size(__sz);\n    }\n    traits_type::copy(_VSTD::__to_raw_pointer(__p), __s, __sz);\n    traits_type::assign(__p[__sz], value_type());\n}\n\ntemplate <class _CharT, class _Traits, class _Allocator>\nvoid\nbasic_string<_CharT, _Traits, _Allocator>::__init(const value_type* __s, size_type __sz)\n{\n    if (__sz > max_size())\n        this->__throw_length_error();\n    pointer __p;\n    if (__sz < __min_cap)\n    {\n        __set_short_size(__sz);\n        __p = __get_short_pointer();\n    }\n    else\n    {\n        size_type __cap = __recommend(__sz);\n        __p = __alloc_traits::allocate(__alloc(), __cap+1);\n        __set_long_pointer(__p);\n        __set_long_cap(__cap+1);\n        __set_long_size(__sz);\n    }\n    traits_type::copy(_VSTD::__to_raw_pointer(__p), __s, __sz);\n    traits_type::assign(__p[__sz], value_type());\n}\n\ntemplate <class _CharT, class _Traits, class _Allocator>\ninline _LIBCPP_INLINE_VISIBILITY\nbasic_string<_CharT, _Traits, _Allocator>::basic_string(const value_type* __s)\n{\n    _LIBCPP_ASSERT(__s != nullptr, \"basic_string(const char*) detected nullptr\");\n    __init(__s, traits_type::length(__s));\n#if _LIBCPP_DEBUG_LEVEL >= 2\n    __get_db()->__insert_c(this);\n#endif\n}\n\ntemplate <class _CharT, class _Traits, class _Allocator>\ninline _LIBCPP_INLINE_VISIBILITY\nbasic_string<_CharT, _Traits, _Allocator>::basic_string(const value_type* __s, const allocator_type& __a)\n    : __r_(__a)\n{\n    _LIBCPP_ASSERT(__s != nullptr, \"basic_string(const char*, allocator) detected nullptr\");\n    __init(__s, traits_type::length(__s));\n#if _LIBCPP_DEBUG_LEVEL >= 2\n    __get_db()->__insert_c(this);\n#endif\n}\n\ntemplate <class _CharT, class _Traits, class _Allocator>\ninline _LIBCPP_INLINE_VISIBILITY\nbasic_string<_CharT, _Traits, _Allocator>::basic_string(const value_type* __s, size_type __n)\n{\n    _LIBCPP_ASSERT(__n == 0 || __s != nullptr, \"basic_string(const char*, n) detected nullptr\");\n    __init(__s, __n);\n#if _LIBCPP_DEBUG_LEVEL >= 2\n    __get_db()->__insert_c(this);\n#endif\n}\n\ntemplate <class _CharT, class _Traits, class _Allocator>\ninline _LIBCPP_INLINE_VISIBILITY\nbasic_string<_CharT, _Traits, _Allocator>::basic_string(const value_type* __s, size_type __n, const allocator_type& __a)\n    : __r_(__a)\n{\n    _LIBCPP_ASSERT(__n == 0 || __s != nullptr, \"basic_string(const char*, n, allocator) detected nullptr\");\n    __init(__s, __n);\n#if _LIBCPP_DEBUG_LEVEL >= 2\n    __get_db()->__insert_c(this);\n#endif\n}\n\ntemplate <class _CharT, class _Traits, class _Allocator>\nbasic_string<_CharT, _Traits, _Allocator>::basic_string(const basic_string& __str)\n    : __r_(__alloc_traits::select_on_container_copy_construction(__str.__alloc()))\n{\n    if (!__str.__is_long())\n        __r_.first().__r = __str.__r_.first().__r;\n    else\n        __init(_VSTD::__to_raw_pointer(__str.__get_long_pointer()), __str.__get_long_size());\n#if _LIBCPP_DEBUG_LEVEL >= 2\n    __get_db()->__insert_c(this);\n#endif\n}\n\ntemplate <class _CharT, class _Traits, class _Allocator>\nbasic_string<_CharT, _Traits, _Allocator>::basic_string(const basic_string& __str, const allocator_type& __a)\n    : __r_(__a)\n{\n    if (!__str.__is_long())\n        __r_.first().__r = __str.__r_.first().__r;\n    else\n        __init(_VSTD::__to_raw_pointer(__str.__get_long_pointer()), __str.__get_long_size());\n#if _LIBCPP_DEBUG_LEVEL >= 2\n    __get_db()->__insert_c(this);\n#endif\n}\n\n#ifndef _LIBCPP_HAS_NO_RVALUE_REFERENCES\n\ntemplate <class _CharT, class _Traits, class _Allocator>\ninline _LIBCPP_INLINE_VISIBILITY\nbasic_string<_CharT, _Traits, _Allocator>::basic_string(basic_string&& __str)\n#if _LIBCPP_STD_VER <= 14\n        _NOEXCEPT_(is_nothrow_move_constructible<allocator_type>::value)\n#else\n        _NOEXCEPT\n#endif\n    : __r_(_VSTD::move(__str.__r_))\n{\n    __str.__zero();\n#if _LIBCPP_DEBUG_LEVEL >= 2\n    __get_db()->__insert_c(this);\n    if (__is_long())\n        __get_db()->swap(this, &__str);\n#endif\n}\n\ntemplate <class _CharT, class _Traits, class _Allocator>\ninline _LIBCPP_INLINE_VISIBILITY\nbasic_string<_CharT, _Traits, _Allocator>::basic_string(basic_string&& __str, const allocator_type& __a)\n    : __r_(__a)\n{\n    if (__str.__is_long() && __a != __str.__alloc()) // copy, not move\n        __init(_VSTD::__to_raw_pointer(__str.__get_long_pointer()), __str.__get_long_size());\n    else\n    {\n        __r_.first().__r = __str.__r_.first().__r;\n        __str.__zero();\n    }\n#if _LIBCPP_DEBUG_LEVEL >= 2\n    __get_db()->__insert_c(this);\n    if (__is_long())\n        __get_db()->swap(this, &__str);\n#endif\n}\n\n#endif  // _LIBCPP_HAS_NO_RVALUE_REFERENCES\n\ntemplate <class _CharT, class _Traits, class _Allocator>\nvoid\nbasic_string<_CharT, _Traits, _Allocator>::__init(size_type __n, value_type __c)\n{\n    if (__n > max_size())\n        this->__throw_length_error();\n    pointer __p;\n    if (__n < __min_cap)\n    {\n        __set_short_size(__n);\n        __p = __get_short_pointer();\n    }\n    else\n    {\n        size_type __cap = __recommend(__n);\n        __p = __alloc_traits::allocate(__alloc(), __cap+1);\n        __set_long_pointer(__p);\n        __set_long_cap(__cap+1);\n        __set_long_size(__n);\n    }\n    traits_type::assign(_VSTD::__to_raw_pointer(__p), __n, __c);\n    traits_type::assign(__p[__n], value_type());\n}\n\ntemplate <class _CharT, class _Traits, class _Allocator>\ninline _LIBCPP_INLINE_VISIBILITY\nbasic_string<_CharT, _Traits, _Allocator>::basic_string(size_type __n, value_type __c)\n{\n    __init(__n, __c);\n#if _LIBCPP_DEBUG_LEVEL >= 2\n    __get_db()->__insert_c(this);\n#endif\n}\n\ntemplate <class _CharT, class _Traits, class _Allocator>\ninline _LIBCPP_INLINE_VISIBILITY\nbasic_string<_CharT, _Traits, _Allocator>::basic_string(size_type __n, value_type __c, const allocator_type& __a)\n    : __r_(__a)\n{\n    __init(__n, __c);\n#if _LIBCPP_DEBUG_LEVEL >= 2\n    __get_db()->__insert_c(this);\n#endif\n}\n\ntemplate <class _CharT, class _Traits, class _Allocator>\nbasic_string<_CharT, _Traits, _Allocator>::basic_string(const basic_string& __str, size_type __pos, size_type __n,\n                                                        const allocator_type& __a)\n    : __r_(__a)\n{\n    size_type __str_sz = __str.size();\n    if (__pos > __str_sz)\n        this->__throw_out_of_range();\n    __init(__str.data() + __pos, _VSTD::min(__n, __str_sz - __pos));\n#if _LIBCPP_DEBUG_LEVEL >= 2\n    __get_db()->__insert_c(this);\n#endif\n}\n\ntemplate <class _CharT, class _Traits, class _Allocator>\ninline _LIBCPP_INLINE_VISIBILITY\nbasic_string<_CharT, _Traits, _Allocator>::basic_string(const basic_string& __str, size_type __pos,\n                                                        const allocator_type& __a)\n    : __r_(__a)\n{\n    size_type __str_sz = __str.size();\n    if (__pos > __str_sz)\n        this->__throw_out_of_range();\n    __init(__str.data() + __pos, __str_sz - __pos);\n#if _LIBCPP_DEBUG_LEVEL >= 2\n    __get_db()->__insert_c(this);\n#endif\n}\n\ntemplate <class _CharT, class _Traits, class _Allocator>\ntemplate <class _Tp>\nbasic_string<_CharT, _Traits, _Allocator>::basic_string(\n             const _Tp& __t, size_type __pos, size_type __n, const allocator_type& __a,\n\t\t\t typename enable_if<__can_be_converted_to_string_view<_CharT, _Traits, _Tp>::value, void>::type *)\n    : __r_(__a)\n{\n\t__self_view __sv = __self_view(__t).substr(__pos, __n);\n    __init(__sv.data(), __sv.size());\n#if _LIBCPP_DEBUG_LEVEL >= 2\n    __get_db()->__insert_c(this);\n#endif\t\n}\n\ntemplate <class _CharT, class _Traits, class _Allocator>\ninline _LIBCPP_INLINE_VISIBILITY\nbasic_string<_CharT, _Traits, _Allocator>::basic_string(__self_view __sv)\n{\n    __init(__sv.data(), __sv.size());\n#if _LIBCPP_DEBUG_LEVEL >= 2\n    __get_db()->__insert_c(this);\n#endif\n}\n\ntemplate <class _CharT, class _Traits, class _Allocator>\ninline _LIBCPP_INLINE_VISIBILITY\nbasic_string<_CharT, _Traits, _Allocator>::basic_string(__self_view __sv, const allocator_type& __a)\n    : __r_(__a)\n{\n    __init(__sv.data(), __sv.size());\n#if _LIBCPP_DEBUG_LEVEL >= 2\n    __get_db()->__insert_c(this);\n#endif\n}\n\ntemplate <class _CharT, class _Traits, class _Allocator>\ntemplate <class _InputIterator>\ntypename enable_if\n<\n    __is_exactly_input_iterator<_InputIterator>::value,\n    void\n>::type\nbasic_string<_CharT, _Traits, _Allocator>::__init(_InputIterator __first, _InputIterator __last)\n{\n    __zero();\n#ifndef _LIBCPP_NO_EXCEPTIONS\n    try\n    {\n#endif  // _LIBCPP_NO_EXCEPTIONS\n    for (; __first != __last; ++__first)\n        push_back(*__first);\n#ifndef _LIBCPP_NO_EXCEPTIONS\n    }\n    catch (...)\n    {\n        if (__is_long())\n            __alloc_traits::deallocate(__alloc(), __get_long_pointer(), __get_long_cap());\n        throw;\n    }\n#endif  // _LIBCPP_NO_EXCEPTIONS\n}\n\ntemplate <class _CharT, class _Traits, class _Allocator>\ntemplate <class _ForwardIterator>\ntypename enable_if\n<\n    __is_forward_iterator<_ForwardIterator>::value,\n    void\n>::type\nbasic_string<_CharT, _Traits, _Allocator>::__init(_ForwardIterator __first, _ForwardIterator __last)\n{\n    size_type __sz = static_cast<size_type>(_VSTD::distance(__first, __last));\n    if (__sz > max_size())\n        this->__throw_length_error();\n    pointer __p;\n    if (__sz < __min_cap)\n    {\n        __set_short_size(__sz);\n        __p = __get_short_pointer();\n    }\n    else\n    {\n        size_type __cap = __recommend(__sz);\n        __p = __alloc_traits::allocate(__alloc(), __cap+1);\n        __set_long_pointer(__p);\n        __set_long_cap(__cap+1);\n        __set_long_size(__sz);\n    }\n    for (; __first != __last; ++__first, (void) ++__p)\n        traits_type::assign(*__p, *__first);\n    traits_type::assign(*__p, value_type());\n}\n\ntemplate <class _CharT, class _Traits, class _Allocator>\ntemplate<class _InputIterator>\ninline _LIBCPP_INLINE_VISIBILITY\nbasic_string<_CharT, _Traits, _Allocator>::basic_string(_InputIterator __first, _InputIterator __last)\n{\n    __init(__first, __last);\n#if _LIBCPP_DEBUG_LEVEL >= 2\n    __get_db()->__insert_c(this);\n#endif\n}\n\ntemplate <class _CharT, class _Traits, class _Allocator>\ntemplate<class _InputIterator>\ninline _LIBCPP_INLINE_VISIBILITY\nbasic_string<_CharT, _Traits, _Allocator>::basic_string(_InputIterator __first, _InputIterator __last,\n                                                        const allocator_type& __a)\n    : __r_(__a)\n{\n    __init(__first, __last);\n#if _LIBCPP_DEBUG_LEVEL >= 2\n    __get_db()->__insert_c(this);\n#endif\n}\n\n#ifndef _LIBCPP_HAS_NO_GENERALIZED_INITIALIZERS\n\ntemplate <class _CharT, class _Traits, class _Allocator>\ninline _LIBCPP_INLINE_VISIBILITY\nbasic_string<_CharT, _Traits, _Allocator>::basic_string(initializer_list<value_type> __il)\n{\n    __init(__il.begin(), __il.end());\n#if _LIBCPP_DEBUG_LEVEL >= 2\n    __get_db()->__insert_c(this);\n#endif\n}\n\ntemplate <class _CharT, class _Traits, class _Allocator>\ninline _LIBCPP_INLINE_VISIBILITY\nbasic_string<_CharT, _Traits, _Allocator>::basic_string(initializer_list<value_type> __il, const allocator_type& __a)\n    : __r_(__a)\n{\n    __init(__il.begin(), __il.end());\n#if _LIBCPP_DEBUG_LEVEL >= 2\n    __get_db()->__insert_c(this);\n#endif\n}\n\n#endif  // _LIBCPP_HAS_NO_GENERALIZED_INITIALIZERS\n\ntemplate <class _CharT, class _Traits, class _Allocator>\nbasic_string<_CharT, _Traits, _Allocator>::~basic_string()\n{\n#if _LIBCPP_DEBUG_LEVEL >= 2\n    __get_db()->__erase_c(this);\n#endif\n    if (__is_long())\n        __alloc_traits::deallocate(__alloc(), __get_long_pointer(), __get_long_cap());\n}\n\ntemplate <class _CharT, class _Traits, class _Allocator>\nvoid\nbasic_string<_CharT, _Traits, _Allocator>::__grow_by_and_replace\n    (size_type __old_cap, size_type __delta_cap, size_type __old_sz,\n     size_type __n_copy,  size_type __n_del,     size_type __n_add, const value_type* __p_new_stuff)\n{\n    size_type __ms = max_size();\n    if (__delta_cap > __ms - __old_cap - 1)\n        this->__throw_length_error();\n    pointer __old_p = __get_pointer();\n    size_type __cap = __old_cap < __ms / 2 - __alignment ?\n                          __recommend(_VSTD::max(__old_cap + __delta_cap, 2 * __old_cap)) :\n                          __ms - 1;\n    pointer __p = __alloc_traits::allocate(__alloc(), __cap+1);\n    __invalidate_all_iterators();\n    if (__n_copy != 0)\n        traits_type::copy(_VSTD::__to_raw_pointer(__p),\n                          _VSTD::__to_raw_pointer(__old_p), __n_copy);\n    if (__n_add != 0)\n        traits_type::copy(_VSTD::__to_raw_pointer(__p) + __n_copy, __p_new_stuff, __n_add);\n    size_type __sec_cp_sz = __old_sz - __n_del - __n_copy;\n    if (__sec_cp_sz != 0)\n        traits_type::copy(_VSTD::__to_raw_pointer(__p) + __n_copy + __n_add,\n                          _VSTD::__to_raw_pointer(__old_p) + __n_copy + __n_del, __sec_cp_sz);\n    if (__old_cap+1 != __min_cap)\n        __alloc_traits::deallocate(__alloc(), __old_p, __old_cap+1);\n    __set_long_pointer(__p);\n    __set_long_cap(__cap+1);\n    __old_sz = __n_copy + __n_add + __sec_cp_sz;\n    __set_long_size(__old_sz);\n    traits_type::assign(__p[__old_sz], value_type());\n}\n\ntemplate <class _CharT, class _Traits, class _Allocator>\nvoid\nbasic_string<_CharT, _Traits, _Allocator>::__grow_by(size_type __old_cap, size_type __delta_cap, size_type __old_sz,\n                                                     size_type __n_copy,  size_type __n_del,     size_type __n_add)\n{\n    size_type __ms = max_size();\n    if (__delta_cap > __ms - __old_cap)\n        this->__throw_length_error();\n    pointer __old_p = __get_pointer();\n    size_type __cap = __old_cap < __ms / 2 - __alignment ?\n                          __recommend(_VSTD::max(__old_cap + __delta_cap, 2 * __old_cap)) :\n                          __ms - 1;\n    pointer __p = __alloc_traits::allocate(__alloc(), __cap+1);\n    __invalidate_all_iterators();\n    if (__n_copy != 0)\n        traits_type::copy(_VSTD::__to_raw_pointer(__p),\n                          _VSTD::__to_raw_pointer(__old_p), __n_copy);\n    size_type __sec_cp_sz = __old_sz - __n_del - __n_copy;\n    if (__sec_cp_sz != 0)\n        traits_type::copy(_VSTD::__to_raw_pointer(__p) + __n_copy + __n_add,\n                          _VSTD::__to_raw_pointer(__old_p) + __n_copy + __n_del,\n                          __sec_cp_sz);\n    if (__old_cap+1 != __min_cap)\n        __alloc_traits::deallocate(__alloc(), __old_p, __old_cap+1);\n    __set_long_pointer(__p);\n    __set_long_cap(__cap+1);\n}\n\n// assign\n\ntemplate <class _CharT, class _Traits, class _Allocator>\nbasic_string<_CharT, _Traits, _Allocator>&\nbasic_string<_CharT, _Traits, _Allocator>::assign(const value_type* __s, size_type __n)\n{\n    _LIBCPP_ASSERT(__n == 0 || __s != nullptr, \"string::assign received nullptr\");\n    size_type __cap = capacity();\n    if (__cap >= __n)\n    {\n        value_type* __p = _VSTD::__to_raw_pointer(__get_pointer());\n        traits_type::move(__p, __s, __n);\n        traits_type::assign(__p[__n], value_type());\n        __set_size(__n);\n        __invalidate_iterators_past(__n);\n    }\n    else\n    {\n        size_type __sz = size();\n        __grow_by_and_replace(__cap, __n - __cap, __sz, 0, __sz, __n, __s);\n    }\n    return *this;\n}\n\ntemplate <class _CharT, class _Traits, class _Allocator>\nbasic_string<_CharT, _Traits, _Allocator>&\nbasic_string<_CharT, _Traits, _Allocator>::assign(size_type __n, value_type __c)\n{\n    size_type __cap = capacity();\n    if (__cap < __n)\n    {\n        size_type __sz = size();\n        __grow_by(__cap, __n - __cap, __sz, 0, __sz);\n    }\n    else\n        __invalidate_iterators_past(__n);\n    value_type* __p = _VSTD::__to_raw_pointer(__get_pointer());\n    traits_type::assign(__p, __n, __c);\n    traits_type::assign(__p[__n], value_type());\n    __set_size(__n);\n    return *this;\n}\n\ntemplate <class _CharT, class _Traits, class _Allocator>\nbasic_string<_CharT, _Traits, _Allocator>&\nbasic_string<_CharT, _Traits, _Allocator>::operator=(value_type __c)\n{\n    pointer __p;\n    if (__is_long())\n    {\n        __p = __get_long_pointer();\n        __set_long_size(1);\n    }\n    else\n    {\n        __p = __get_short_pointer();\n        __set_short_size(1);\n    }\n    traits_type::assign(*__p, __c);\n    traits_type::assign(*++__p, value_type());\n    __invalidate_iterators_past(1);\n    return *this;\n}\n\ntemplate <class _CharT, class _Traits, class _Allocator>\nbasic_string<_CharT, _Traits, _Allocator>&\nbasic_string<_CharT, _Traits, _Allocator>::operator=(const basic_string& __str)\n{\n    if (this != &__str)\n    {\n        __copy_assign_alloc(__str);\n        assign(__str.data(), __str.size());\n    }\n    return *this;\n}\n\n#ifndef _LIBCPP_HAS_NO_RVALUE_REFERENCES\n\ntemplate <class _CharT, class _Traits, class _Allocator>\ninline _LIBCPP_INLINE_VISIBILITY\nvoid\nbasic_string<_CharT, _Traits, _Allocator>::__move_assign(basic_string& __str, false_type)\n    _NOEXCEPT_(__alloc_traits::is_always_equal::value)\n{\n    if (__alloc() != __str.__alloc())\n        assign(__str);\n    else\n        __move_assign(__str, true_type());\n}\n\ntemplate <class _CharT, class _Traits, class _Allocator>\ninline _LIBCPP_INLINE_VISIBILITY\nvoid\nbasic_string<_CharT, _Traits, _Allocator>::__move_assign(basic_string& __str, true_type)\n#if _LIBCPP_STD_VER > 14\n    _NOEXCEPT\n#else\n    _NOEXCEPT_(is_nothrow_move_assignable<allocator_type>::value)\n#endif\n{\n    clear();\n    shrink_to_fit();\n    __r_.first() = __str.__r_.first();\n    __move_assign_alloc(__str);\n    __str.__zero();\n}\n\ntemplate <class _CharT, class _Traits, class _Allocator>\ninline _LIBCPP_INLINE_VISIBILITY\nbasic_string<_CharT, _Traits, _Allocator>&\nbasic_string<_CharT, _Traits, _Allocator>::operator=(basic_string&& __str)\n    _NOEXCEPT_((__noexcept_move_assign_container<_Allocator, __alloc_traits>::value))\n{\n    __move_assign(__str, integral_constant<bool,\n          __alloc_traits::propagate_on_container_move_assignment::value>());\n    return *this;\n}\n\n#endif\n\ntemplate <class _CharT, class _Traits, class _Allocator>\ntemplate<class _InputIterator>\ntypename enable_if\n<\n     __is_exactly_input_iterator <_InputIterator>::value\n          || !__libcpp_string_gets_noexcept_iterator<_InputIterator>::value,\n    basic_string<_CharT, _Traits, _Allocator>&\n>::type\nbasic_string<_CharT, _Traits, _Allocator>::assign(_InputIterator __first, _InputIterator __last)\n{\n    const basic_string __temp(__first, __last, __alloc());\n    assign(__temp.data(), __temp.size());\n    return *this;\n}\n\ntemplate <class _CharT, class _Traits, class _Allocator>\ntemplate<class _ForwardIterator>\ntypename enable_if\n<\n    __is_forward_iterator<_ForwardIterator>::value\n         && __libcpp_string_gets_noexcept_iterator<_ForwardIterator>::value,\n    basic_string<_CharT, _Traits, _Allocator>&\n>::type\nbasic_string<_CharT, _Traits, _Allocator>::assign(_ForwardIterator __first, _ForwardIterator __last)\n{\n    size_type __n = static_cast<size_type>(_VSTD::distance(__first, __last));\n    size_type __cap = capacity();\n    if (__cap < __n)\n    {\n        size_type __sz = size();\n        __grow_by(__cap, __n - __cap, __sz, 0, __sz);\n    }\n    else\n        __invalidate_iterators_past(__n);\n    pointer __p = __get_pointer();\n    for (; __first != __last; ++__first, ++__p)\n        traits_type::assign(*__p, *__first);\n    traits_type::assign(*__p, value_type());\n    __set_size(__n);\n    return *this;\n}\n\ntemplate <class _CharT, class _Traits, class _Allocator>\nbasic_string<_CharT, _Traits, _Allocator>&\nbasic_string<_CharT, _Traits, _Allocator>::assign(const basic_string& __str, size_type __pos, size_type __n)\n{\n    size_type __sz = __str.size();\n    if (__pos > __sz)\n        this->__throw_out_of_range();\n    return assign(__str.data() + __pos, _VSTD::min(__n, __sz - __pos));\n}\n\ntemplate <class _CharT, class _Traits, class _Allocator>\ntemplate <class _Tp>\ntypename enable_if\n<\n    __can_be_converted_to_string_view<_CharT, _Traits, _Tp>::value,\n\tbasic_string<_CharT, _Traits, _Allocator>&\n>::type\nbasic_string<_CharT, _Traits, _Allocator>::assign(const _Tp & __t, size_type __pos, size_type __n)\n{\n    __self_view __sv = __t;\n    size_type __sz = __sv.size();\n    if (__pos > __sz)\n        this->__throw_out_of_range();\n    return assign(__sv.data() + __pos, _VSTD::min(__n, __sz - __pos));\n}\n\n\ntemplate <class _CharT, class _Traits, class _Allocator>\nbasic_string<_CharT, _Traits, _Allocator>&\nbasic_string<_CharT, _Traits, _Allocator>::assign(const value_type* __s)\n{\n    _LIBCPP_ASSERT(__s != nullptr, \"string::assign received nullptr\");\n    return assign(__s, traits_type::length(__s));\n}\n\n// append\n\ntemplate <class _CharT, class _Traits, class _Allocator>\nbasic_string<_CharT, _Traits, _Allocator>&\nbasic_string<_CharT, _Traits, _Allocator>::append(const value_type* __s, size_type __n)\n{\n    _LIBCPP_ASSERT(__n == 0 || __s != nullptr, \"string::append received nullptr\");\n    size_type __cap = capacity();\n    size_type __sz = size();\n    if (__cap - __sz >= __n)\n    {\n        if (__n)\n        {\n            value_type* __p = _VSTD::__to_raw_pointer(__get_pointer());\n            traits_type::copy(__p + __sz, __s, __n);\n            __sz += __n;\n            __set_size(__sz);\n            traits_type::assign(__p[__sz], value_type());\n        }\n    }\n    else\n        __grow_by_and_replace(__cap, __sz + __n - __cap, __sz, __sz, 0, __n, __s);\n    return *this;\n}\n\ntemplate <class _CharT, class _Traits, class _Allocator>\nbasic_string<_CharT, _Traits, _Allocator>&\nbasic_string<_CharT, _Traits, _Allocator>::append(size_type __n, value_type __c)\n{\n    if (__n)\n    {\n        size_type __cap = capacity();\n        size_type __sz = size();\n        if (__cap - __sz < __n)\n            __grow_by(__cap, __sz + __n - __cap, __sz, __sz, 0);\n        pointer __p = __get_pointer();\n        traits_type::assign(_VSTD::__to_raw_pointer(__p) + __sz, __n, __c);\n        __sz += __n;\n        __set_size(__sz);\n        traits_type::assign(__p[__sz], value_type());\n    }\n    return *this;\n}\n\ntemplate <class _CharT, class _Traits, class _Allocator>\nvoid\nbasic_string<_CharT, _Traits, _Allocator>::push_back(value_type __c)\n{\n    bool __is_short = !__is_long();\n    size_type __cap;\n    size_type __sz;\n    if (__is_short)\n    {\n        __cap = __min_cap - 1;\n        __sz = __get_short_size();\n    }\n    else\n    {\n        __cap = __get_long_cap() - 1;\n        __sz = __get_long_size();\n    }\n    if (__sz == __cap)\n    {\n        __grow_by(__cap, 1, __sz, __sz, 0);\n        __is_short = !__is_long();\n    }\n    pointer __p;\n    if (__is_short)\n    {\n        __p = __get_short_pointer() + __sz;\n        __set_short_size(__sz+1);\n    }\n    else\n    {\n        __p = __get_long_pointer() + __sz;\n        __set_long_size(__sz+1);\n    }\n    traits_type::assign(*__p, __c);\n    traits_type::assign(*++__p, value_type());\n}\n\ntemplate <class _Tp>\nbool __ptr_in_range (const _Tp* __p, const _Tp* __first, const _Tp* __last)\n{\n    return __first <= __p && __p < __last;\n}\n\ntemplate <class _Tp1, class _Tp2>\nbool __ptr_in_range (const _Tp1*, const _Tp2*, const _Tp2*)\n{\n    return false;\n}\n\ntemplate <class _CharT, class _Traits, class _Allocator>\ntemplate<class _ForwardIterator>\nbasic_string<_CharT, _Traits, _Allocator>&\nbasic_string<_CharT, _Traits, _Allocator>::__append_forward_unsafe(\n    _ForwardIterator __first, _ForwardIterator __last)\n{\n    static_assert(__is_forward_iterator<_ForwardIterator>::value,\n                  \"function requires a ForwardIterator\");\n    size_type __sz = size();\n    size_type __cap = capacity();\n    size_type __n = static_cast<size_type>(_VSTD::distance(__first, __last));\n    if (__n)\n    {\n        typedef typename iterator_traits<_ForwardIterator>::reference _CharRef;\n        _CharRef __tmp_ref = *__first;\n        if (__ptr_in_range(_VSTD::addressof(__tmp_ref), data(), data() + size()))\n        {\n            const basic_string __temp (__first, __last, __alloc());\n            append(__temp.data(), __temp.size());\n        }\n        else \n        {\n            if (__cap - __sz < __n)\n                __grow_by(__cap, __sz + __n - __cap, __sz, __sz, 0);\n            pointer __p = __get_pointer() + __sz;\n            for (; __first != __last; ++__p, ++__first)\n                traits_type::assign(*__p, *__first);\n            traits_type::assign(*__p, value_type());\n            __set_size(__sz + __n);\n        }\n    }\n    return *this;\n}\n\ntemplate <class _CharT, class _Traits, class _Allocator>\ninline _LIBCPP_INLINE_VISIBILITY\nbasic_string<_CharT, _Traits, _Allocator>&\nbasic_string<_CharT, _Traits, _Allocator>::append(const basic_string& __str)\n{\n    return append(__str.data(), __str.size());\n}\n\ntemplate <class _CharT, class _Traits, class _Allocator>\nbasic_string<_CharT, _Traits, _Allocator>&\nbasic_string<_CharT, _Traits, _Allocator>::append(const basic_string& __str, size_type __pos, size_type __n)\n{\n    size_type __sz = __str.size();\n    if (__pos > __sz)\n        this->__throw_out_of_range();\n    return append(__str.data() + __pos, _VSTD::min(__n, __sz - __pos));\n}\n\ntemplate <class _CharT, class _Traits, class _Allocator>\ntemplate <class _Tp>\n    typename enable_if\n    <\n        __can_be_converted_to_string_view<_CharT, _Traits, _Tp>::value,\n        basic_string<_CharT, _Traits, _Allocator>&\n    >::type\nbasic_string<_CharT, _Traits, _Allocator>::append(const _Tp & __t, size_type __pos, size_type __n)\n{\n    __self_view __sv = __t;\n    size_type __sz = __sv.size();\n    if (__pos > __sz)\n        this->__throw_out_of_range();\n    return append(__sv.data() + __pos, _VSTD::min(__n, __sz - __pos));\n}\n\ntemplate <class _CharT, class _Traits, class _Allocator>\nbasic_string<_CharT, _Traits, _Allocator>&\nbasic_string<_CharT, _Traits, _Allocator>::append(const value_type* __s)\n{\n    _LIBCPP_ASSERT(__s != nullptr, \"string::append received nullptr\");\n    return append(__s, traits_type::length(__s));\n}\n\n// insert\n\ntemplate <class _CharT, class _Traits, class _Allocator>\nbasic_string<_CharT, _Traits, _Allocator>&\nbasic_string<_CharT, _Traits, _Allocator>::insert(size_type __pos, const value_type* __s, size_type __n)\n{\n    _LIBCPP_ASSERT(__n == 0 || __s != nullptr, \"string::insert received nullptr\");\n    size_type __sz = size();\n    if (__pos > __sz)\n        this->__throw_out_of_range();\n    size_type __cap = capacity();\n    if (__cap - __sz >= __n)\n    {\n        if (__n)\n        {\n            value_type* __p = _VSTD::__to_raw_pointer(__get_pointer());\n            size_type __n_move = __sz - __pos;\n            if (__n_move != 0)\n            {\n                if (__p + __pos <= __s && __s < __p + __sz)\n                    __s += __n;\n                traits_type::move(__p + __pos + __n, __p + __pos, __n_move);\n            }\n            traits_type::move(__p + __pos, __s, __n);\n            __sz += __n;\n            __set_size(__sz);\n            traits_type::assign(__p[__sz], value_type());\n        }\n    }\n    else\n        __grow_by_and_replace(__cap, __sz + __n - __cap, __sz, __pos, 0, __n, __s);\n    return *this;\n}\n\ntemplate <class _CharT, class _Traits, class _Allocator>\nbasic_string<_CharT, _Traits, _Allocator>&\nbasic_string<_CharT, _Traits, _Allocator>::insert(size_type __pos, size_type __n, value_type __c)\n{\n    size_type __sz = size();\n    if (__pos > __sz)\n        this->__throw_out_of_range();\n    if (__n)\n    {\n        size_type __cap = capacity();\n        value_type* __p;\n        if (__cap - __sz >= __n)\n        {\n            __p = _VSTD::__to_raw_pointer(__get_pointer());\n            size_type __n_move = __sz - __pos;\n            if (__n_move != 0)\n                traits_type::move(__p + __pos + __n, __p + __pos, __n_move);\n        }\n        else\n        {\n            __grow_by(__cap, __sz + __n - __cap, __sz, __pos, 0, __n);\n            __p = _VSTD::__to_raw_pointer(__get_long_pointer());\n        }\n        traits_type::assign(__p + __pos, __n, __c);\n        __sz += __n;\n        __set_size(__sz);\n        traits_type::assign(__p[__sz], value_type());\n    }\n    return *this;\n}\n\ntemplate <class _CharT, class _Traits, class _Allocator>\ntemplate<class _InputIterator>\ntypename enable_if\n<\n   __is_exactly_input_iterator<_InputIterator>::value\n        || !__libcpp_string_gets_noexcept_iterator<_InputIterator>::value,\n   typename basic_string<_CharT, _Traits, _Allocator>::iterator\n>::type\nbasic_string<_CharT, _Traits, _Allocator>::insert(const_iterator __pos, _InputIterator __first, _InputIterator __last)\n{\n#if _LIBCPP_DEBUG_LEVEL >= 2\n    _LIBCPP_ASSERT(__get_const_db()->__find_c_from_i(&__pos) == this,\n        \"string::insert(iterator, range) called with an iterator not\"\n        \" referring to this string\");\n#endif\n    const basic_string __temp(__first, __last, __alloc());\n    return insert(__pos, __temp.data(), __temp.data() + __temp.size());\n}\n\ntemplate <class _CharT, class _Traits, class _Allocator>\ntemplate<class _ForwardIterator>\ntypename enable_if\n<\n    __is_forward_iterator<_ForwardIterator>::value\n        && __libcpp_string_gets_noexcept_iterator<_ForwardIterator>::value,\n    typename basic_string<_CharT, _Traits, _Allocator>::iterator\n>::type\nbasic_string<_CharT, _Traits, _Allocator>::insert(const_iterator __pos, _ForwardIterator __first, _ForwardIterator __last)\n{\n#if _LIBCPP_DEBUG_LEVEL >= 2\n    _LIBCPP_ASSERT(__get_const_db()->__find_c_from_i(&__pos) == this,\n        \"string::insert(iterator, range) called with an iterator not\"\n        \" referring to this string\");\n#endif\n    size_type __ip = static_cast<size_type>(__pos - begin());\n    size_type __n = static_cast<size_type>(_VSTD::distance(__first, __last));\n    if (__n)\n    {\n        typedef typename iterator_traits<_ForwardIterator>::reference _CharRef;\n        _CharRef __tmp_char = *__first;\n        if (__ptr_in_range(_VSTD::addressof(__tmp_char), data(), data() + size()))\n        {\n            const basic_string __temp(__first, __last, __alloc());\n            return insert(__pos, __temp.data(), __temp.data() + __temp.size());\n        }\n\n        size_type __sz = size();\n        size_type __cap = capacity();\n        value_type* __p;\n        if (__cap - __sz >= __n)\n        {\n            __p = _VSTD::__to_raw_pointer(__get_pointer());\n            size_type __n_move = __sz - __ip;\n            if (__n_move != 0)\n                traits_type::move(__p + __ip + __n, __p + __ip, __n_move);\n        }\n        else\n        {\n            __grow_by(__cap, __sz + __n - __cap, __sz, __ip, 0, __n);\n            __p = _VSTD::__to_raw_pointer(__get_long_pointer());\n        }\n        __sz += __n;\n        __set_size(__sz);\n        traits_type::assign(__p[__sz], value_type());\n        for (__p += __ip; __first != __last; ++__p, ++__first)\n            traits_type::assign(*__p, *__first);\n    }\n    return begin() + __ip;\n}\n\ntemplate <class _CharT, class _Traits, class _Allocator>\ninline _LIBCPP_INLINE_VISIBILITY\nbasic_string<_CharT, _Traits, _Allocator>&\nbasic_string<_CharT, _Traits, _Allocator>::insert(size_type __pos1, const basic_string& __str)\n{\n    return insert(__pos1, __str.data(), __str.size());\n}\n\ntemplate <class _CharT, class _Traits, class _Allocator>\nbasic_string<_CharT, _Traits, _Allocator>&\nbasic_string<_CharT, _Traits, _Allocator>::insert(size_type __pos1, const basic_string& __str,\n                                                  size_type __pos2, size_type __n)\n{\n    size_type __str_sz = __str.size();\n    if (__pos2 > __str_sz)\n        this->__throw_out_of_range();\n    return insert(__pos1, __str.data() + __pos2, _VSTD::min(__n, __str_sz - __pos2));\n}\n\ntemplate <class _CharT, class _Traits, class _Allocator>\ntemplate <class _Tp>\ntypename enable_if\n<\n    __can_be_converted_to_string_view<_CharT, _Traits, _Tp>::value,\n\tbasic_string<_CharT, _Traits, _Allocator>&\n>::type\nbasic_string<_CharT, _Traits, _Allocator>::insert(size_type __pos1, const _Tp& __t,\n                                                  size_type __pos2, size_type __n)\n{\n    __self_view __sv = __t;\n    size_type __str_sz = __sv.size();\n    if (__pos2 > __str_sz)\n        this->__throw_out_of_range();\n    return insert(__pos1, __sv.data() + __pos2, _VSTD::min(__n, __str_sz - __pos2));\n}\n\ntemplate <class _CharT, class _Traits, class _Allocator>\nbasic_string<_CharT, _Traits, _Allocator>&\nbasic_string<_CharT, _Traits, _Allocator>::insert(size_type __pos, const value_type* __s)\n{\n    _LIBCPP_ASSERT(__s != nullptr, \"string::insert received nullptr\");\n    return insert(__pos, __s, traits_type::length(__s));\n}\n\ntemplate <class _CharT, class _Traits, class _Allocator>\ntypename basic_string<_CharT, _Traits, _Allocator>::iterator\nbasic_string<_CharT, _Traits, _Allocator>::insert(const_iterator __pos, value_type __c)\n{\n    size_type __ip = static_cast<size_type>(__pos - begin());\n    size_type __sz = size();\n    size_type __cap = capacity();\n    value_type* __p;\n    if (__cap == __sz)\n    {\n        __grow_by(__cap, 1, __sz, __ip, 0, 1);\n        __p = _VSTD::__to_raw_pointer(__get_long_pointer());\n    }\n    else\n    {\n        __p = _VSTD::__to_raw_pointer(__get_pointer());\n        size_type __n_move = __sz - __ip;\n        if (__n_move != 0)\n            traits_type::move(__p + __ip + 1, __p + __ip, __n_move);\n    }\n    traits_type::assign(__p[__ip], __c);\n    traits_type::assign(__p[++__sz], value_type());\n    __set_size(__sz);\n    return begin() + static_cast<difference_type>(__ip);\n}\n\ntemplate <class _CharT, class _Traits, class _Allocator>\ninline _LIBCPP_INLINE_VISIBILITY\ntypename basic_string<_CharT, _Traits, _Allocator>::iterator\nbasic_string<_CharT, _Traits, _Allocator>::insert(const_iterator __pos, size_type __n, value_type __c)\n{\n#if _LIBCPP_DEBUG_LEVEL >= 2\n    _LIBCPP_ASSERT(__get_const_db()->__find_c_from_i(&__pos) == this,\n        \"string::insert(iterator, n, value) called with an iterator not\"\n        \" referring to this string\");\n#endif\n    difference_type __p = __pos - begin();\n    insert(static_cast<size_type>(__p), __n, __c);\n    return begin() + __p;\n}\n\n// replace\n\ntemplate <class _CharT, class _Traits, class _Allocator>\nbasic_string<_CharT, _Traits, _Allocator>&\nbasic_string<_CharT, _Traits, _Allocator>::replace(size_type __pos, size_type __n1, const value_type* __s, size_type __n2)\n{\n    _LIBCPP_ASSERT(__n2 == 0 || __s != nullptr, \"string::replace received nullptr\");\n    size_type __sz = size();\n    if (__pos > __sz)\n        this->__throw_out_of_range();\n    __n1 = _VSTD::min(__n1, __sz - __pos);\n    size_type __cap = capacity();\n    if (__cap - __sz + __n1 >= __n2)\n    {\n        value_type* __p = _VSTD::__to_raw_pointer(__get_pointer());\n        if (__n1 != __n2)\n        {\n            size_type __n_move = __sz - __pos - __n1;\n            if (__n_move != 0)\n            {\n                if (__n1 > __n2)\n                {\n                    traits_type::move(__p + __pos, __s, __n2);\n                    traits_type::move(__p + __pos + __n2, __p + __pos + __n1, __n_move);\n                    goto __finish;\n                }\n                if (__p + __pos < __s && __s < __p + __sz)\n                {\n                    if (__p + __pos + __n1 <= __s)\n                        __s += __n2 - __n1;\n                    else // __p + __pos < __s < __p + __pos + __n1\n                    {\n                        traits_type::move(__p + __pos, __s, __n1);\n                        __pos += __n1;\n                        __s += __n2;\n                        __n2 -= __n1;\n                        __n1 = 0;\n                    }\n                }\n                traits_type::move(__p + __pos + __n2, __p + __pos + __n1, __n_move);\n            }\n        }\n        traits_type::move(__p + __pos, __s, __n2);\n__finish:\n        __sz += __n2 - __n1;\n        __set_size(__sz);\n        __invalidate_iterators_past(__sz);\n        traits_type::assign(__p[__sz], value_type());\n    }\n    else\n        __grow_by_and_replace(__cap, __sz - __n1 + __n2 - __cap, __sz, __pos, __n1, __n2, __s);\n    return *this;\n}\n\ntemplate <class _CharT, class _Traits, class _Allocator>\nbasic_string<_CharT, _Traits, _Allocator>&\nbasic_string<_CharT, _Traits, _Allocator>::replace(size_type __pos, size_type __n1, size_type __n2, value_type __c)\n{\n    size_type __sz = size();\n    if (__pos > __sz)\n        this->__throw_out_of_range();\n    __n1 = _VSTD::min(__n1, __sz - __pos);\n    size_type __cap = capacity();\n    value_type* __p;\n    if (__cap - __sz + __n1 >= __n2)\n    {\n        __p = _VSTD::__to_raw_pointer(__get_pointer());\n        if (__n1 != __n2)\n        {\n            size_type __n_move = __sz - __pos - __n1;\n            if (__n_move != 0)\n                traits_type::move(__p + __pos + __n2, __p + __pos + __n1, __n_move);\n        }\n    }\n    else\n    {\n        __grow_by(__cap, __sz - __n1 + __n2 - __cap, __sz, __pos, __n1, __n2);\n        __p = _VSTD::__to_raw_pointer(__get_long_pointer());\n    }\n    traits_type::assign(__p + __pos, __n2, __c);\n    __sz += __n2 - __n1;\n    __set_size(__sz);\n    __invalidate_iterators_past(__sz);\n    traits_type::assign(__p[__sz], value_type());\n    return *this;\n}\n\ntemplate <class _CharT, class _Traits, class _Allocator>\ntemplate<class _InputIterator>\ntypename enable_if\n<\n    __is_input_iterator<_InputIterator>::value,\n    basic_string<_CharT, _Traits, _Allocator>&\n>::type\nbasic_string<_CharT, _Traits, _Allocator>::replace(const_iterator __i1, const_iterator __i2,\n                                                   _InputIterator __j1, _InputIterator __j2)\n{\n    const basic_string __temp(__j1, __j2, __alloc());\n    return this->replace(__i1, __i2, __temp);\n}\n\ntemplate <class _CharT, class _Traits, class _Allocator>\ninline _LIBCPP_INLINE_VISIBILITY\nbasic_string<_CharT, _Traits, _Allocator>&\nbasic_string<_CharT, _Traits, _Allocator>::replace(size_type __pos1, size_type __n1, const basic_string& __str)\n{\n    return replace(__pos1, __n1, __str.data(), __str.size());\n}\n\ntemplate <class _CharT, class _Traits, class _Allocator>\nbasic_string<_CharT, _Traits, _Allocator>&\nbasic_string<_CharT, _Traits, _Allocator>::replace(size_type __pos1, size_type __n1, const basic_string& __str,\n                                                   size_type __pos2, size_type __n2)\n{\n    size_type __str_sz = __str.size();\n    if (__pos2 > __str_sz)\n        this->__throw_out_of_range();\n    return replace(__pos1, __n1, __str.data() + __pos2, _VSTD::min(__n2, __str_sz - __pos2));\n}\n\ntemplate <class _CharT, class _Traits, class _Allocator>\ntemplate <class _Tp>\ntypename enable_if\n<\n\t__can_be_converted_to_string_view<_CharT, _Traits, _Tp>::value,\n\tbasic_string<_CharT, _Traits, _Allocator>&\n>::type\nbasic_string<_CharT, _Traits, _Allocator>::replace(size_type __pos1, size_type __n1, const _Tp& __t,\n                                                   size_type __pos2, size_type __n2)\n{\n    __self_view __sv = __t;\n    size_type __str_sz = __sv.size();\n    if (__pos2 > __str_sz)\n        this->__throw_out_of_range();\n    return replace(__pos1, __n1, __sv.data() + __pos2, _VSTD::min(__n2, __str_sz - __pos2));\n}\n\ntemplate <class _CharT, class _Traits, class _Allocator>\nbasic_string<_CharT, _Traits, _Allocator>&\nbasic_string<_CharT, _Traits, _Allocator>::replace(size_type __pos, size_type __n1, const value_type* __s)\n{\n    _LIBCPP_ASSERT(__s != nullptr, \"string::replace received nullptr\");\n    return replace(__pos, __n1, __s, traits_type::length(__s));\n}\n\ntemplate <class _CharT, class _Traits, class _Allocator>\ninline _LIBCPP_INLINE_VISIBILITY\nbasic_string<_CharT, _Traits, _Allocator>&\nbasic_string<_CharT, _Traits, _Allocator>::replace(const_iterator __i1, const_iterator __i2, const basic_string& __str)\n{\n    return replace(static_cast<size_type>(__i1 - begin()), static_cast<size_type>(__i2 - __i1),\n                   __str.data(), __str.size());\n}\n\ntemplate <class _CharT, class _Traits, class _Allocator>\ninline _LIBCPP_INLINE_VISIBILITY\nbasic_string<_CharT, _Traits, _Allocator>&\nbasic_string<_CharT, _Traits, _Allocator>::replace(const_iterator __i1, const_iterator __i2, const value_type* __s, size_type __n)\n{\n    return replace(static_cast<size_type>(__i1 - begin()), static_cast<size_type>(__i2 - __i1), __s, __n);\n}\n\ntemplate <class _CharT, class _Traits, class _Allocator>\ninline _LIBCPP_INLINE_VISIBILITY\nbasic_string<_CharT, _Traits, _Allocator>&\nbasic_string<_CharT, _Traits, _Allocator>::replace(const_iterator __i1, const_iterator __i2, const value_type* __s)\n{\n    return replace(static_cast<size_type>(__i1 - begin()), static_cast<size_type>(__i2 - __i1), __s);\n}\n\ntemplate <class _CharT, class _Traits, class _Allocator>\ninline _LIBCPP_INLINE_VISIBILITY\nbasic_string<_CharT, _Traits, _Allocator>&\nbasic_string<_CharT, _Traits, _Allocator>::replace(const_iterator __i1, const_iterator __i2, size_type __n, value_type __c)\n{\n    return replace(static_cast<size_type>(__i1 - begin()), static_cast<size_type>(__i2 - __i1), __n, __c);\n}\n\n// erase\n\ntemplate <class _CharT, class _Traits, class _Allocator>\nbasic_string<_CharT, _Traits, _Allocator>&\nbasic_string<_CharT, _Traits, _Allocator>::erase(size_type __pos, size_type __n)\n{\n    size_type __sz = size();\n    if (__pos > __sz)\n        this->__throw_out_of_range();\n    if (__n)\n    {\n        value_type* __p = _VSTD::__to_raw_pointer(__get_pointer());\n        __n = _VSTD::min(__n, __sz - __pos);\n        size_type __n_move = __sz - __pos - __n;\n        if (__n_move != 0)\n            traits_type::move(__p + __pos, __p + __pos + __n, __n_move);\n        __sz -= __n;\n        __set_size(__sz);\n        __invalidate_iterators_past(__sz);\n        traits_type::assign(__p[__sz], value_type());\n    }\n    return *this;\n}\n\ntemplate <class _CharT, class _Traits, class _Allocator>\ninline _LIBCPP_INLINE_VISIBILITY\ntypename basic_string<_CharT, _Traits, _Allocator>::iterator\nbasic_string<_CharT, _Traits, _Allocator>::erase(const_iterator __pos)\n{\n#if _LIBCPP_DEBUG_LEVEL >= 2\n    _LIBCPP_ASSERT(__get_const_db()->__find_c_from_i(&__pos) == this,\n        \"string::erase(iterator) called with an iterator not\"\n        \" referring to this string\");\n#endif\n    _LIBCPP_ASSERT(__pos != end(),\n        \"string::erase(iterator) called with a non-dereferenceable iterator\");\n    iterator __b = begin();\n    size_type __r = static_cast<size_type>(__pos - __b);\n    erase(__r, 1);\n    return __b + static_cast<difference_type>(__r);\n}\n\ntemplate <class _CharT, class _Traits, class _Allocator>\ninline _LIBCPP_INLINE_VISIBILITY\ntypename basic_string<_CharT, _Traits, _Allocator>::iterator\nbasic_string<_CharT, _Traits, _Allocator>::erase(const_iterator __first, const_iterator __last)\n{\n#if _LIBCPP_DEBUG_LEVEL >= 2\n    _LIBCPP_ASSERT(__get_const_db()->__find_c_from_i(&__first) == this,\n        \"string::erase(iterator,  iterator) called with an iterator not\"\n        \" referring to this string\");\n#endif\n    _LIBCPP_ASSERT(__first <= __last, \"string::erase(first, last) called with invalid range\");\n    iterator __b = begin();\n    size_type __r = static_cast<size_type>(__first - __b);\n    erase(__r, static_cast<size_type>(__last - __first));\n    return __b + static_cast<difference_type>(__r);\n}\n\ntemplate <class _CharT, class _Traits, class _Allocator>\ninline _LIBCPP_INLINE_VISIBILITY\nvoid\nbasic_string<_CharT, _Traits, _Allocator>::pop_back()\n{\n    _LIBCPP_ASSERT(!empty(), \"string::pop_back(): string is already empty\");\n    size_type __sz;\n    if (__is_long())\n    {\n        __sz = __get_long_size() - 1;\n        __set_long_size(__sz);\n        traits_type::assign(*(__get_long_pointer() + __sz), value_type());\n    }\n    else\n    {\n        __sz = __get_short_size() - 1;\n        __set_short_size(__sz);\n        traits_type::assign(*(__get_short_pointer() + __sz), value_type());\n    }\n    __invalidate_iterators_past(__sz);\n}\n\ntemplate <class _CharT, class _Traits, class _Allocator>\ninline _LIBCPP_INLINE_VISIBILITY\nvoid\nbasic_string<_CharT, _Traits, _Allocator>::clear() _NOEXCEPT\n{\n    __invalidate_all_iterators();\n    if (__is_long())\n    {\n        traits_type::assign(*__get_long_pointer(), value_type());\n        __set_long_size(0);\n    }\n    else\n    {\n        traits_type::assign(*__get_short_pointer(), value_type());\n        __set_short_size(0);\n    }\n}\n\ntemplate <class _CharT, class _Traits, class _Allocator>\ninline _LIBCPP_INLINE_VISIBILITY\nvoid\nbasic_string<_CharT, _Traits, _Allocator>::__erase_to_end(size_type __pos)\n{\n    if (__is_long())\n    {\n        traits_type::assign(*(__get_long_pointer() + __pos), value_type());\n        __set_long_size(__pos);\n    }\n    else\n    {\n        traits_type::assign(*(__get_short_pointer() + __pos), value_type());\n        __set_short_size(__pos);\n    }\n    __invalidate_iterators_past(__pos);\n}\n\ntemplate <class _CharT, class _Traits, class _Allocator>\nvoid\nbasic_string<_CharT, _Traits, _Allocator>::resize(size_type __n, value_type __c)\n{\n    size_type __sz = size();\n    if (__n > __sz)\n        append(__n - __sz, __c);\n    else\n        __erase_to_end(__n);\n}\n\ntemplate <class _CharT, class _Traits, class _Allocator>\ninline _LIBCPP_INLINE_VISIBILITY\ntypename basic_string<_CharT, _Traits, _Allocator>::size_type\nbasic_string<_CharT, _Traits, _Allocator>::max_size() const _NOEXCEPT\n{\n    size_type __m = __alloc_traits::max_size(__alloc());\n#if _LIBCPP_BIG_ENDIAN\n    return (__m <= ~__long_mask ? __m : __m/2) - __alignment;\n#else\n    return __m - __alignment;\n#endif\n}\n\ntemplate <class _CharT, class _Traits, class _Allocator>\nvoid\nbasic_string<_CharT, _Traits, _Allocator>::reserve(size_type __res_arg)\n{\n    if (__res_arg > max_size())\n        this->__throw_length_error();\n    size_type __cap = capacity();\n    size_type __sz = size();\n    __res_arg = _VSTD::max(__res_arg, __sz);\n    __res_arg = __recommend(__res_arg);\n    if (__res_arg != __cap)\n    {\n        pointer __new_data, __p;\n        bool __was_long, __now_long;\n        if (__res_arg == __min_cap - 1)\n        {\n            __was_long = true;\n            __now_long = false;\n            __new_data = __get_short_pointer();\n            __p = __get_long_pointer();\n        }\n        else\n        {\n            if (__res_arg > __cap)\n                __new_data = __alloc_traits::allocate(__alloc(), __res_arg+1);\n            else\n            {\n            #ifndef _LIBCPP_NO_EXCEPTIONS\n                try\n                {\n            #endif  // _LIBCPP_NO_EXCEPTIONS\n                    __new_data = __alloc_traits::allocate(__alloc(), __res_arg+1);\n            #ifndef _LIBCPP_NO_EXCEPTIONS\n                }\n                catch (...)\n                {\n                    return;\n                }\n            #else  // _LIBCPP_NO_EXCEPTIONS\n                if (__new_data == nullptr)\n                    return;\n            #endif  // _LIBCPP_NO_EXCEPTIONS\n            }\n            __now_long = true;\n            __was_long = __is_long();\n            __p = __get_pointer();\n        }\n        traits_type::copy(_VSTD::__to_raw_pointer(__new_data),\n                          _VSTD::__to_raw_pointer(__p), size()+1);\n        if (__was_long)\n            __alloc_traits::deallocate(__alloc(), __p, __cap+1);\n        if (__now_long)\n        {\n            __set_long_cap(__res_arg+1);\n            __set_long_size(__sz);\n            __set_long_pointer(__new_data);\n        }\n        else\n            __set_short_size(__sz);\n        __invalidate_all_iterators();\n    }\n}\n\ntemplate <class _CharT, class _Traits, class _Allocator>\ninline _LIBCPP_INLINE_VISIBILITY\ntypename basic_string<_CharT, _Traits, _Allocator>::const_reference\nbasic_string<_CharT, _Traits, _Allocator>::operator[](size_type __pos) const _NOEXCEPT\n{\n    _LIBCPP_ASSERT(__pos <= size(), \"string index out of bounds\");\n    return *(data() + __pos);\n}\n\ntemplate <class _CharT, class _Traits, class _Allocator>\ninline _LIBCPP_INLINE_VISIBILITY\ntypename basic_string<_CharT, _Traits, _Allocator>::reference\nbasic_string<_CharT, _Traits, _Allocator>::operator[](size_type __pos) _NOEXCEPT\n{\n    _LIBCPP_ASSERT(__pos <= size(), \"string index out of bounds\");\n    return *(__get_pointer() + __pos);\n}\n\ntemplate <class _CharT, class _Traits, class _Allocator>\ntypename basic_string<_CharT, _Traits, _Allocator>::const_reference\nbasic_string<_CharT, _Traits, _Allocator>::at(size_type __n) const\n{\n    if (__n >= size())\n        this->__throw_out_of_range();\n    return (*this)[__n];\n}\n\ntemplate <class _CharT, class _Traits, class _Allocator>\ntypename basic_string<_CharT, _Traits, _Allocator>::reference\nbasic_string<_CharT, _Traits, _Allocator>::at(size_type __n)\n{\n    if (__n >= size())\n        this->__throw_out_of_range();\n    return (*this)[__n];\n}\n\ntemplate <class _CharT, class _Traits, class _Allocator>\ninline _LIBCPP_INLINE_VISIBILITY\ntypename basic_string<_CharT, _Traits, _Allocator>::reference\nbasic_string<_CharT, _Traits, _Allocator>::front()\n{\n    _LIBCPP_ASSERT(!empty(), \"string::front(): string is empty\");\n    return *__get_pointer();\n}\n\ntemplate <class _CharT, class _Traits, class _Allocator>\ninline _LIBCPP_INLINE_VISIBILITY\ntypename basic_string<_CharT, _Traits, _Allocator>::const_reference\nbasic_string<_CharT, _Traits, _Allocator>::front() const\n{\n    _LIBCPP_ASSERT(!empty(), \"string::front(): string is empty\");\n    return *data();\n}\n\ntemplate <class _CharT, class _Traits, class _Allocator>\ninline _LIBCPP_INLINE_VISIBILITY\ntypename basic_string<_CharT, _Traits, _Allocator>::reference\nbasic_string<_CharT, _Traits, _Allocator>::back()\n{\n    _LIBCPP_ASSERT(!empty(), \"string::back(): string is empty\");\n    return *(__get_pointer() + size() - 1);\n}\n\ntemplate <class _CharT, class _Traits, class _Allocator>\ninline _LIBCPP_INLINE_VISIBILITY\ntypename basic_string<_CharT, _Traits, _Allocator>::const_reference\nbasic_string<_CharT, _Traits, _Allocator>::back() const\n{\n    _LIBCPP_ASSERT(!empty(), \"string::back(): string is empty\");\n    return *(data() + size() - 1);\n}\n\ntemplate <class _CharT, class _Traits, class _Allocator>\ntypename basic_string<_CharT, _Traits, _Allocator>::size_type\nbasic_string<_CharT, _Traits, _Allocator>::copy(value_type* __s, size_type __n, size_type __pos) const\n{\n    size_type __sz = size();\n    if (__pos > __sz)\n        this->__throw_out_of_range();\n    size_type __rlen = _VSTD::min(__n, __sz - __pos);\n    traits_type::copy(__s, data() + __pos, __rlen);\n    return __rlen;\n}\n\ntemplate <class _CharT, class _Traits, class _Allocator>\ninline _LIBCPP_INLINE_VISIBILITY\nbasic_string<_CharT, _Traits, _Allocator>\nbasic_string<_CharT, _Traits, _Allocator>::substr(size_type __pos, size_type __n) const\n{\n    return basic_string(*this, __pos, __n, __alloc());\n}\n\ntemplate <class _CharT, class _Traits, class _Allocator>\ninline _LIBCPP_INLINE_VISIBILITY\nvoid\nbasic_string<_CharT, _Traits, _Allocator>::swap(basic_string& __str)\n#if _LIBCPP_STD_VER >= 14\n        _NOEXCEPT_DEBUG\n#else\n        _NOEXCEPT_DEBUG_(!__alloc_traits::propagate_on_container_swap::value ||\n                    __is_nothrow_swappable<allocator_type>::value)\n#endif\n{\n#if _LIBCPP_DEBUG_LEVEL >= 2\n    if (!__is_long())\n        __get_db()->__invalidate_all(this);\n    if (!__str.__is_long())\n        __get_db()->__invalidate_all(&__str);\n    __get_db()->swap(this, &__str);\n#endif\n    _LIBCPP_ASSERT(\n        __alloc_traits::propagate_on_container_swap::value ||\n        __alloc_traits::is_always_equal::value ||\n        __alloc() == __str.__alloc(), \"swapping non-equal allocators\");\n    _VSTD::swap(__r_.first(), __str.__r_.first());\n    __swap_allocator(__alloc(), __str.__alloc());\n}\n\n// find\n\ntemplate <class _Traits>\nstruct _LIBCPP_HIDDEN __traits_eq\n{\n    typedef typename _Traits::char_type char_type;\n    _LIBCPP_INLINE_VISIBILITY\n    bool operator()(const char_type& __x, const char_type& __y) _NOEXCEPT\n        {return _Traits::eq(__x, __y);}\n};\n\ntemplate<class _CharT, class _Traits, class _Allocator>\ntypename basic_string<_CharT, _Traits, _Allocator>::size_type\nbasic_string<_CharT, _Traits, _Allocator>::find(const value_type* __s,\n                                                size_type __pos,\n                                                size_type __n) const _NOEXCEPT\n{\n    _LIBCPP_ASSERT(__n == 0 || __s != nullptr, \"string::find(): received nullptr\");\n    return __str_find<value_type, size_type, traits_type, npos>\n        (data(), size(), __s, __pos, __n);\n}\n\ntemplate<class _CharT, class _Traits, class _Allocator>\ninline _LIBCPP_INLINE_VISIBILITY\ntypename basic_string<_CharT, _Traits, _Allocator>::size_type\nbasic_string<_CharT, _Traits, _Allocator>::find(const basic_string& __str,\n                                                size_type __pos) const _NOEXCEPT\n{\n    return __str_find<value_type, size_type, traits_type, npos>\n        (data(), size(), __str.data(), __pos, __str.size());\n}\n\ntemplate<class _CharT, class _Traits, class _Allocator>\ninline _LIBCPP_INLINE_VISIBILITY\ntypename basic_string<_CharT, _Traits, _Allocator>::size_type\nbasic_string<_CharT, _Traits, _Allocator>::find(__self_view __sv,\n                                                size_type __pos) const _NOEXCEPT\n{\n    return __str_find<value_type, size_type, traits_type, npos>\n        (data(), size(), __sv.data(), __pos, __sv.size());\n}\n\ntemplate<class _CharT, class _Traits, class _Allocator>\ninline _LIBCPP_INLINE_VISIBILITY\ntypename basic_string<_CharT, _Traits, _Allocator>::size_type\nbasic_string<_CharT, _Traits, _Allocator>::find(const value_type* __s,\n                                                size_type __pos) const _NOEXCEPT\n{\n    _LIBCPP_ASSERT(__s != nullptr, \"string::find(): received nullptr\");\n    return __str_find<value_type, size_type, traits_type, npos>\n        (data(), size(), __s, __pos, traits_type::length(__s));\n}\n\ntemplate<class _CharT, class _Traits, class _Allocator>\ntypename basic_string<_CharT, _Traits, _Allocator>::size_type\nbasic_string<_CharT, _Traits, _Allocator>::find(value_type __c,\n                                                size_type __pos) const _NOEXCEPT\n{\n    return __str_find<value_type, size_type, traits_type, npos>\n        (data(), size(), __c, __pos);\n}\n\n// rfind\n\ntemplate<class _CharT, class _Traits, class _Allocator>\ntypename basic_string<_CharT, _Traits, _Allocator>::size_type\nbasic_string<_CharT, _Traits, _Allocator>::rfind(const value_type* __s,\n                                                 size_type __pos,\n                                                 size_type __n) const _NOEXCEPT\n{\n    _LIBCPP_ASSERT(__n == 0 || __s != nullptr, \"string::rfind(): received nullptr\");\n    return __str_rfind<value_type, size_type, traits_type, npos>\n        (data(), size(), __s, __pos, __n);\n}\n\ntemplate<class _CharT, class _Traits, class _Allocator>\ninline _LIBCPP_INLINE_VISIBILITY\ntypename basic_string<_CharT, _Traits, _Allocator>::size_type\nbasic_string<_CharT, _Traits, _Allocator>::rfind(const basic_string& __str,\n                                                 size_type __pos) const _NOEXCEPT\n{\n    return __str_rfind<value_type, size_type, traits_type, npos>\n        (data(), size(), __str.data(), __pos, __str.size());\n}\n\ntemplate<class _CharT, class _Traits, class _Allocator>\ninline _LIBCPP_INLINE_VISIBILITY\ntypename basic_string<_CharT, _Traits, _Allocator>::size_type\nbasic_string<_CharT, _Traits, _Allocator>::rfind(__self_view __sv,\n                                                size_type __pos) const _NOEXCEPT\n{\n    return __str_rfind<value_type, size_type, traits_type, npos>\n        (data(), size(), __sv.data(), __pos, __sv.size());\n}\n\ntemplate<class _CharT, class _Traits, class _Allocator>\ninline _LIBCPP_INLINE_VISIBILITY\ntypename basic_string<_CharT, _Traits, _Allocator>::size_type\nbasic_string<_CharT, _Traits, _Allocator>::rfind(const value_type* __s,\n                                                 size_type __pos) const _NOEXCEPT\n{\n    _LIBCPP_ASSERT(__s != nullptr, \"string::rfind(): received nullptr\");\n    return __str_rfind<value_type, size_type, traits_type, npos>\n        (data(), size(), __s, __pos, traits_type::length(__s));\n}\n\ntemplate<class _CharT, class _Traits, class _Allocator>\ntypename basic_string<_CharT, _Traits, _Allocator>::size_type\nbasic_string<_CharT, _Traits, _Allocator>::rfind(value_type __c,\n                                                 size_type __pos) const _NOEXCEPT\n{\n    return __str_rfind<value_type, size_type, traits_type, npos>\n        (data(), size(), __c, __pos);\n}\n\n// find_first_of\n\ntemplate<class _CharT, class _Traits, class _Allocator>\ntypename basic_string<_CharT, _Traits, _Allocator>::size_type\nbasic_string<_CharT, _Traits, _Allocator>::find_first_of(const value_type* __s,\n                                                         size_type __pos,\n                                                         size_type __n) const _NOEXCEPT\n{\n    _LIBCPP_ASSERT(__n == 0 || __s != nullptr, \"string::find_first_of(): received nullptr\");\n    return __str_find_first_of<value_type, size_type, traits_type, npos>\n        (data(), size(), __s, __pos, __n);\n}\n\ntemplate<class _CharT, class _Traits, class _Allocator>\ninline _LIBCPP_INLINE_VISIBILITY\ntypename basic_string<_CharT, _Traits, _Allocator>::size_type\nbasic_string<_CharT, _Traits, _Allocator>::find_first_of(const basic_string& __str,\n                                                         size_type __pos) const _NOEXCEPT\n{\n    return __str_find_first_of<value_type, size_type, traits_type, npos>\n        (data(), size(), __str.data(), __pos, __str.size());\n}\n\ntemplate<class _CharT, class _Traits, class _Allocator>\ninline _LIBCPP_INLINE_VISIBILITY\ntypename basic_string<_CharT, _Traits, _Allocator>::size_type\nbasic_string<_CharT, _Traits, _Allocator>::find_first_of(__self_view __sv,\n                                                size_type __pos) const _NOEXCEPT\n{\n    return __str_find_first_of<value_type, size_type, traits_type, npos>\n        (data(), size(), __sv.data(), __pos, __sv.size());\n}\n\ntemplate<class _CharT, class _Traits, class _Allocator>\ninline _LIBCPP_INLINE_VISIBILITY\ntypename basic_string<_CharT, _Traits, _Allocator>::size_type\nbasic_string<_CharT, _Traits, _Allocator>::find_first_of(const value_type* __s,\n                                                         size_type __pos) const _NOEXCEPT\n{\n    _LIBCPP_ASSERT(__s != nullptr, \"string::find_first_of(): received nullptr\");\n    return __str_find_first_of<value_type, size_type, traits_type, npos>\n        (data(), size(), __s, __pos, traits_type::length(__s));\n}\n\ntemplate<class _CharT, class _Traits, class _Allocator>\ninline _LIBCPP_INLINE_VISIBILITY\ntypename basic_string<_CharT, _Traits, _Allocator>::size_type\nbasic_string<_CharT, _Traits, _Allocator>::find_first_of(value_type __c,\n                                                         size_type __pos) const _NOEXCEPT\n{\n    return find(__c, __pos);\n}\n\n// find_last_of\n\ntemplate<class _CharT, class _Traits, class _Allocator>\ntypename basic_string<_CharT, _Traits, _Allocator>::size_type\nbasic_string<_CharT, _Traits, _Allocator>::find_last_of(const value_type* __s,\n                                                        size_type __pos,\n                                                        size_type __n) const _NOEXCEPT\n{\n    _LIBCPP_ASSERT(__n == 0 || __s != nullptr, \"string::find_last_of(): received nullptr\");\n    return __str_find_last_of<value_type, size_type, traits_type, npos>\n        (data(), size(), __s, __pos, __n);\n}\n\ntemplate<class _CharT, class _Traits, class _Allocator>\ninline _LIBCPP_INLINE_VISIBILITY\ntypename basic_string<_CharT, _Traits, _Allocator>::size_type\nbasic_string<_CharT, _Traits, _Allocator>::find_last_of(const basic_string& __str,\n                                                        size_type __pos) const _NOEXCEPT\n{\n    return __str_find_last_of<value_type, size_type, traits_type, npos>\n        (data(), size(), __str.data(), __pos, __str.size());\n}\n\ntemplate<class _CharT, class _Traits, class _Allocator>\ninline _LIBCPP_INLINE_VISIBILITY\ntypename basic_string<_CharT, _Traits, _Allocator>::size_type\nbasic_string<_CharT, _Traits, _Allocator>::find_last_of(__self_view __sv,\n                                                size_type __pos) const _NOEXCEPT\n{\n    return __str_find_last_of<value_type, size_type, traits_type, npos>\n        (data(), size(), __sv.data(), __pos, __sv.size());\n}\n\ntemplate<class _CharT, class _Traits, class _Allocator>\ninline _LIBCPP_INLINE_VISIBILITY\ntypename basic_string<_CharT, _Traits, _Allocator>::size_type\nbasic_string<_CharT, _Traits, _Allocator>::find_last_of(const value_type* __s,\n                                                        size_type __pos) const _NOEXCEPT\n{\n    _LIBCPP_ASSERT(__s != nullptr, \"string::find_last_of(): received nullptr\");\n    return __str_find_last_of<value_type, size_type, traits_type, npos>\n        (data(), size(), __s, __pos, traits_type::length(__s));\n}\n\ntemplate<class _CharT, class _Traits, class _Allocator>\ninline _LIBCPP_INLINE_VISIBILITY\ntypename basic_string<_CharT, _Traits, _Allocator>::size_type\nbasic_string<_CharT, _Traits, _Allocator>::find_last_of(value_type __c,\n                                                        size_type __pos) const _NOEXCEPT\n{\n    return rfind(__c, __pos);\n}\n\n// find_first_not_of\n\ntemplate<class _CharT, class _Traits, class _Allocator>\ntypename basic_string<_CharT, _Traits, _Allocator>::size_type\nbasic_string<_CharT, _Traits, _Allocator>::find_first_not_of(const value_type* __s,\n                                                             size_type __pos,\n                                                             size_type __n) const _NOEXCEPT\n{\n    _LIBCPP_ASSERT(__n == 0 || __s != nullptr, \"string::find_first_not_of(): received nullptr\");\n    return __str_find_first_not_of<value_type, size_type, traits_type, npos>\n        (data(), size(), __s, __pos, __n);\n}\n\ntemplate<class _CharT, class _Traits, class _Allocator>\ninline _LIBCPP_INLINE_VISIBILITY\ntypename basic_string<_CharT, _Traits, _Allocator>::size_type\nbasic_string<_CharT, _Traits, _Allocator>::find_first_not_of(const basic_string& __str,\n                                                             size_type __pos) const _NOEXCEPT\n{\n    return __str_find_first_not_of<value_type, size_type, traits_type, npos>\n        (data(), size(), __str.data(), __pos, __str.size());\n}\n\ntemplate<class _CharT, class _Traits, class _Allocator>\ninline _LIBCPP_INLINE_VISIBILITY\ntypename basic_string<_CharT, _Traits, _Allocator>::size_type\nbasic_string<_CharT, _Traits, _Allocator>::find_first_not_of(__self_view __sv,\n                                                size_type __pos) const _NOEXCEPT\n{\n    return __str_find_first_not_of<value_type, size_type, traits_type, npos>\n        (data(), size(), __sv.data(), __pos, __sv.size());\n}\n\ntemplate<class _CharT, class _Traits, class _Allocator>\ninline _LIBCPP_INLINE_VISIBILITY\ntypename basic_string<_CharT, _Traits, _Allocator>::size_type\nbasic_string<_CharT, _Traits, _Allocator>::find_first_not_of(const value_type* __s,\n                                                             size_type __pos) const _NOEXCEPT\n{\n    _LIBCPP_ASSERT(__s != nullptr, \"string::find_first_not_of(): received nullptr\");\n    return __str_find_first_not_of<value_type, size_type, traits_type, npos>\n        (data(), size(), __s, __pos, traits_type::length(__s));\n}\n\ntemplate<class _CharT, class _Traits, class _Allocator>\ninline _LIBCPP_INLINE_VISIBILITY\ntypename basic_string<_CharT, _Traits, _Allocator>::size_type\nbasic_string<_CharT, _Traits, _Allocator>::find_first_not_of(value_type __c,\n                                                             size_type __pos) const _NOEXCEPT\n{\n    return __str_find_first_not_of<value_type, size_type, traits_type, npos>\n        (data(), size(), __c, __pos);\n}\n\n// find_last_not_of\n\ntemplate<class _CharT, class _Traits, class _Allocator>\ntypename basic_string<_CharT, _Traits, _Allocator>::size_type\nbasic_string<_CharT, _Traits, _Allocator>::find_last_not_of(const value_type* __s,\n                                                            size_type __pos,\n                                                            size_type __n) const _NOEXCEPT\n{\n    _LIBCPP_ASSERT(__n == 0 || __s != nullptr, \"string::find_last_not_of(): received nullptr\");\n    return __str_find_last_not_of<value_type, size_type, traits_type, npos>\n        (data(), size(), __s, __pos, __n);\n}\n\ntemplate<class _CharT, class _Traits, class _Allocator>\ninline _LIBCPP_INLINE_VISIBILITY\ntypename basic_string<_CharT, _Traits, _Allocator>::size_type\nbasic_string<_CharT, _Traits, _Allocator>::find_last_not_of(const basic_string& __str,\n                                                            size_type __pos) const _NOEXCEPT\n{\n    return __str_find_last_not_of<value_type, size_type, traits_type, npos>\n        (data(), size(), __str.data(), __pos, __str.size());\n}\n\ntemplate<class _CharT, class _Traits, class _Allocator>\ninline _LIBCPP_INLINE_VISIBILITY\ntypename basic_string<_CharT, _Traits, _Allocator>::size_type\nbasic_string<_CharT, _Traits, _Allocator>::find_last_not_of(__self_view __sv,\n                                                size_type __pos) const _NOEXCEPT\n{\n    return __str_find_last_not_of<value_type, size_type, traits_type, npos>\n        (data(), size(), __sv.data(), __pos, __sv.size());\n}\n\ntemplate<class _CharT, class _Traits, class _Allocator>\ninline _LIBCPP_INLINE_VISIBILITY\ntypename basic_string<_CharT, _Traits, _Allocator>::size_type\nbasic_string<_CharT, _Traits, _Allocator>::find_last_not_of(const value_type* __s,\n                                                            size_type __pos) const _NOEXCEPT\n{\n    _LIBCPP_ASSERT(__s != nullptr, \"string::find_last_not_of(): received nullptr\");\n    return __str_find_last_not_of<value_type, size_type, traits_type, npos>\n        (data(), size(), __s, __pos, traits_type::length(__s));\n}\n\ntemplate<class _CharT, class _Traits, class _Allocator>\ninline _LIBCPP_INLINE_VISIBILITY\ntypename basic_string<_CharT, _Traits, _Allocator>::size_type\nbasic_string<_CharT, _Traits, _Allocator>::find_last_not_of(value_type __c,\n                                                            size_type __pos) const _NOEXCEPT\n{\n    return __str_find_last_not_of<value_type, size_type, traits_type, npos>\n        (data(), size(), __c, __pos);\n}\n\n// compare\n\ntemplate <class _CharT, class _Traits, class _Allocator>\ninline _LIBCPP_INLINE_VISIBILITY\nint\nbasic_string<_CharT, _Traits, _Allocator>::compare(__self_view __sv) const _NOEXCEPT\n{\n    size_t __lhs_sz = size();\n    size_t __rhs_sz = __sv.size();\n    int __result = traits_type::compare(data(), __sv.data(),\n                                        _VSTD::min(__lhs_sz, __rhs_sz));\n    if (__result != 0)\n        return __result;\n    if (__lhs_sz < __rhs_sz)\n        return -1;\n    if (__lhs_sz > __rhs_sz)\n        return 1;\n    return 0;\n}\n\ntemplate <class _CharT, class _Traits, class _Allocator>\ninline _LIBCPP_INLINE_VISIBILITY\nint\nbasic_string<_CharT, _Traits, _Allocator>::compare(const basic_string& __str) const _NOEXCEPT\n{\n    return compare(__self_view(__str));\n}\n\ntemplate <class _CharT, class _Traits, class _Allocator>\nint\nbasic_string<_CharT, _Traits, _Allocator>::compare(size_type __pos1,\n                                                   size_type __n1,\n                                                   const value_type* __s,\n                                                   size_type __n2) const\n{\n    _LIBCPP_ASSERT(__n2 == 0 || __s != nullptr, \"string::compare(): received nullptr\");\n    size_type __sz = size();\n    if (__pos1 > __sz || __n2 == npos)\n        this->__throw_out_of_range();\n    size_type __rlen = _VSTD::min(__n1, __sz - __pos1);\n    int __r = traits_type::compare(data() + __pos1, __s, _VSTD::min(__rlen, __n2));\n    if (__r == 0)\n    {\n        if (__rlen < __n2)\n            __r = -1;\n        else if (__rlen > __n2)\n            __r = 1;\n    }\n    return __r;\n}\n\ntemplate <class _CharT, class _Traits, class _Allocator>\ninline _LIBCPP_INLINE_VISIBILITY\nint\nbasic_string<_CharT, _Traits, _Allocator>::compare(size_type __pos1,\n                                                   size_type __n1,\n                                                   __self_view __sv) const\n{\n    return compare(__pos1, __n1, __sv.data(), __sv.size());\n}\n\ntemplate <class _CharT, class _Traits, class _Allocator>\ninline _LIBCPP_INLINE_VISIBILITY\nint\nbasic_string<_CharT, _Traits, _Allocator>::compare(size_type __pos1,\n                                                   size_type __n1,\n                                                   const basic_string& __str) const\n{\n    return compare(__pos1, __n1, __str.data(), __str.size());\n}\n\ntemplate <class _CharT, class _Traits, class _Allocator>\ntemplate <class _Tp>\ntypename enable_if\n<\n\t__can_be_converted_to_string_view<_CharT, _Traits, _Tp>::value,\n\tint\n>::type\nbasic_string<_CharT, _Traits, _Allocator>::compare(size_type __pos1,\n                                                   size_type __n1,\n                                                   const _Tp& __t,\n                                                   size_type __pos2,\n                                                   size_type __n2) const\n{\n    __self_view __sv = __t;\n    return __self_view(*this).substr(__pos1, __n1).compare(__sv.substr(__pos2, __n2));\n}\n\ntemplate <class _CharT, class _Traits, class _Allocator>\nint\nbasic_string<_CharT, _Traits, _Allocator>::compare(size_type __pos1,\n                                                   size_type __n1,\n                                                   const basic_string& __str,\n                                                   size_type __pos2,\n                                                   size_type __n2) const\n{\n        return compare(__pos1, __n1, __self_view(__str), __pos2, __n2);\n}\n\ntemplate <class _CharT, class _Traits, class _Allocator>\nint\nbasic_string<_CharT, _Traits, _Allocator>::compare(const value_type* __s) const _NOEXCEPT\n{\n    _LIBCPP_ASSERT(__s != nullptr, \"string::compare(): received nullptr\");\n    return compare(0, npos, __s, traits_type::length(__s));\n}\n\ntemplate <class _CharT, class _Traits, class _Allocator>\nint\nbasic_string<_CharT, _Traits, _Allocator>::compare(size_type __pos1,\n                                                   size_type __n1,\n                                                   const value_type* __s) const\n{\n    _LIBCPP_ASSERT(__s != nullptr, \"string::compare(): received nullptr\");\n    return compare(__pos1, __n1, __s, traits_type::length(__s));\n}\n\n// __invariants\n\ntemplate<class _CharT, class _Traits, class _Allocator>\ninline _LIBCPP_INLINE_VISIBILITY\nbool\nbasic_string<_CharT, _Traits, _Allocator>::__invariants() const\n{\n    if (size() > capacity())\n        return false;\n    if (capacity() < __min_cap - 1)\n        return false;\n    if (data() == 0)\n        return false;\n    if (data()[size()] != value_type(0))\n        return false;\n    return true;\n}\n\n// operator==\n\ntemplate<class _CharT, class _Traits, class _Allocator>\ninline _LIBCPP_INLINE_VISIBILITY\nbool\noperator==(const basic_string<_CharT, _Traits, _Allocator>& __lhs,\n           const basic_string<_CharT, _Traits, _Allocator>& __rhs) _NOEXCEPT\n{\n    size_t __lhs_sz = __lhs.size();\n    return __lhs_sz == __rhs.size() && _Traits::compare(__lhs.data(),\n                                                        __rhs.data(),\n                                                        __lhs_sz) == 0;\n}\n\ntemplate<class _Allocator>\ninline _LIBCPP_INLINE_VISIBILITY\nbool\noperator==(const basic_string<char, char_traits<char>, _Allocator>& __lhs,\n           const basic_string<char, char_traits<char>, _Allocator>& __rhs) _NOEXCEPT\n{\n    size_t __lhs_sz = __lhs.size();\n    if (__lhs_sz != __rhs.size())\n        return false;\n    const char* __lp = __lhs.data();\n    const char* __rp = __rhs.data();\n    if (__lhs.__is_long())\n        return char_traits<char>::compare(__lp, __rp, __lhs_sz) == 0;\n    for (; __lhs_sz != 0; --__lhs_sz, ++__lp, ++__rp)\n        if (*__lp != *__rp)\n            return false;\n    return true;\n}\n\ntemplate<class _CharT, class _Traits, class _Allocator>\ninline _LIBCPP_INLINE_VISIBILITY\nbool\noperator==(const _CharT* __lhs,\n           const basic_string<_CharT, _Traits, _Allocator>& __rhs) _NOEXCEPT\n{\n    typedef basic_string<_CharT, _Traits, _Allocator> _String;\n    _LIBCPP_ASSERT(__lhs != nullptr, \"operator==(char*, basic_string): received nullptr\");\n    size_t __lhs_len = _Traits::length(__lhs);\n    if (__lhs_len != __rhs.size()) return false;\n    return __rhs.compare(0, _String::npos, __lhs, __lhs_len) == 0;\n}\n\ntemplate<class _CharT, class _Traits, class _Allocator>\ninline _LIBCPP_INLINE_VISIBILITY\nbool\noperator==(const basic_string<_CharT,_Traits,_Allocator>& __lhs,\n           const _CharT* __rhs) _NOEXCEPT\n{\n    typedef basic_string<_CharT, _Traits, _Allocator> _String;\n    _LIBCPP_ASSERT(__rhs != nullptr, \"operator==(basic_string, char*): received nullptr\");\n    size_t __rhs_len = _Traits::length(__rhs);\n    if (__rhs_len != __lhs.size()) return false;\n    return __lhs.compare(0, _String::npos, __rhs, __rhs_len) == 0;\n}\n\ntemplate<class _CharT, class _Traits, class _Allocator>\ninline _LIBCPP_INLINE_VISIBILITY\nbool\noperator!=(const basic_string<_CharT,_Traits,_Allocator>& __lhs,\n           const basic_string<_CharT, _Traits, _Allocator>& __rhs) _NOEXCEPT\n{\n    return !(__lhs == __rhs);\n}\n\ntemplate<class _CharT, class _Traits, class _Allocator>\ninline _LIBCPP_INLINE_VISIBILITY\nbool\noperator!=(const _CharT* __lhs,\n           const basic_string<_CharT, _Traits, _Allocator>& __rhs) _NOEXCEPT\n{\n    return !(__lhs == __rhs);\n}\n\ntemplate<class _CharT, class _Traits, class _Allocator>\ninline _LIBCPP_INLINE_VISIBILITY\nbool\noperator!=(const basic_string<_CharT, _Traits, _Allocator>& __lhs,\n           const _CharT* __rhs) _NOEXCEPT\n{\n    return !(__lhs == __rhs);\n}\n\n// operator<\n\ntemplate<class _CharT, class _Traits, class _Allocator>\ninline _LIBCPP_INLINE_VISIBILITY\nbool\noperator< (const basic_string<_CharT, _Traits, _Allocator>& __lhs,\n           const basic_string<_CharT, _Traits, _Allocator>& __rhs) _NOEXCEPT\n{\n    return __lhs.compare(__rhs) < 0;\n}\n\ntemplate<class _CharT, class _Traits, class _Allocator>\ninline _LIBCPP_INLINE_VISIBILITY\nbool\noperator< (const basic_string<_CharT, _Traits, _Allocator>& __lhs,\n           const _CharT* __rhs) _NOEXCEPT\n{\n    return __lhs.compare(__rhs) < 0;\n}\n\ntemplate<class _CharT, class _Traits, class _Allocator>\ninline _LIBCPP_INLINE_VISIBILITY\nbool\noperator< (const _CharT* __lhs,\n           const basic_string<_CharT, _Traits, _Allocator>& __rhs) _NOEXCEPT\n{\n    return __rhs.compare(__lhs) > 0;\n}\n\n// operator>\n\ntemplate<class _CharT, class _Traits, class _Allocator>\ninline _LIBCPP_INLINE_VISIBILITY\nbool\noperator> (const basic_string<_CharT, _Traits, _Allocator>& __lhs,\n           const basic_string<_CharT, _Traits, _Allocator>& __rhs) _NOEXCEPT\n{\n    return __rhs < __lhs;\n}\n\ntemplate<class _CharT, class _Traits, class _Allocator>\ninline _LIBCPP_INLINE_VISIBILITY\nbool\noperator> (const basic_string<_CharT, _Traits, _Allocator>& __lhs,\n           const _CharT* __rhs) _NOEXCEPT\n{\n    return __rhs < __lhs;\n}\n\ntemplate<class _CharT, class _Traits, class _Allocator>\ninline _LIBCPP_INLINE_VISIBILITY\nbool\noperator> (const _CharT* __lhs,\n           const basic_string<_CharT, _Traits, _Allocator>& __rhs) _NOEXCEPT\n{\n    return __rhs < __lhs;\n}\n\n// operator<=\n\ntemplate<class _CharT, class _Traits, class _Allocator>\ninline _LIBCPP_INLINE_VISIBILITY\nbool\noperator<=(const basic_string<_CharT, _Traits, _Allocator>& __lhs,\n           const basic_string<_CharT, _Traits, _Allocator>& __rhs) _NOEXCEPT\n{\n    return !(__rhs < __lhs);\n}\n\ntemplate<class _CharT, class _Traits, class _Allocator>\ninline _LIBCPP_INLINE_VISIBILITY\nbool\noperator<=(const basic_string<_CharT, _Traits, _Allocator>& __lhs,\n           const _CharT* __rhs) _NOEXCEPT\n{\n    return !(__rhs < __lhs);\n}\n\ntemplate<class _CharT, class _Traits, class _Allocator>\ninline _LIBCPP_INLINE_VISIBILITY\nbool\noperator<=(const _CharT* __lhs,\n           const basic_string<_CharT, _Traits, _Allocator>& __rhs) _NOEXCEPT\n{\n    return !(__rhs < __lhs);\n}\n\n// operator>=\n\ntemplate<class _CharT, class _Traits, class _Allocator>\ninline _LIBCPP_INLINE_VISIBILITY\nbool\noperator>=(const basic_string<_CharT, _Traits, _Allocator>& __lhs,\n           const basic_string<_CharT, _Traits, _Allocator>& __rhs) _NOEXCEPT\n{\n    return !(__lhs < __rhs);\n}\n\ntemplate<class _CharT, class _Traits, class _Allocator>\ninline _LIBCPP_INLINE_VISIBILITY\nbool\noperator>=(const basic_string<_CharT, _Traits, _Allocator>& __lhs,\n           const _CharT* __rhs) _NOEXCEPT\n{\n    return !(__lhs < __rhs);\n}\n\ntemplate<class _CharT, class _Traits, class _Allocator>\ninline _LIBCPP_INLINE_VISIBILITY\nbool\noperator>=(const _CharT* __lhs,\n           const basic_string<_CharT, _Traits, _Allocator>& __rhs) _NOEXCEPT\n{\n    return !(__lhs < __rhs);\n}\n\n// operator +\n\ntemplate<class _CharT, class _Traits, class _Allocator>\nbasic_string<_CharT, _Traits, _Allocator>\noperator+(const basic_string<_CharT, _Traits, _Allocator>& __lhs,\n          const basic_string<_CharT, _Traits, _Allocator>& __rhs)\n{\n    basic_string<_CharT, _Traits, _Allocator> __r(__lhs.get_allocator());\n    typename basic_string<_CharT, _Traits, _Allocator>::size_type __lhs_sz = __lhs.size();\n    typename basic_string<_CharT, _Traits, _Allocator>::size_type __rhs_sz = __rhs.size();\n    __r.__init(__lhs.data(), __lhs_sz, __lhs_sz + __rhs_sz);\n    __r.append(__rhs.data(), __rhs_sz);\n    return __r;\n}\n\ntemplate<class _CharT, class _Traits, class _Allocator>\nbasic_string<_CharT, _Traits, _Allocator>\noperator+(const _CharT* __lhs , const basic_string<_CharT,_Traits,_Allocator>& __rhs)\n{\n    basic_string<_CharT, _Traits, _Allocator> __r(__rhs.get_allocator());\n    typename basic_string<_CharT, _Traits, _Allocator>::size_type __lhs_sz = _Traits::length(__lhs);\n    typename basic_string<_CharT, _Traits, _Allocator>::size_type __rhs_sz = __rhs.size();\n    __r.__init(__lhs, __lhs_sz, __lhs_sz + __rhs_sz);\n    __r.append(__rhs.data(), __rhs_sz);\n    return __r;\n}\n\ntemplate<class _CharT, class _Traits, class _Allocator>\nbasic_string<_CharT, _Traits, _Allocator>\noperator+(_CharT __lhs, const basic_string<_CharT,_Traits,_Allocator>& __rhs)\n{\n    basic_string<_CharT, _Traits, _Allocator> __r(__rhs.get_allocator());\n    typename basic_string<_CharT, _Traits, _Allocator>::size_type __rhs_sz = __rhs.size();\n    __r.__init(&__lhs, 1, 1 + __rhs_sz);\n    __r.append(__rhs.data(), __rhs_sz);\n    return __r;\n}\n\ntemplate<class _CharT, class _Traits, class _Allocator>\nbasic_string<_CharT, _Traits, _Allocator>\noperator+(const basic_string<_CharT, _Traits, _Allocator>& __lhs, const _CharT* __rhs)\n{\n    basic_string<_CharT, _Traits, _Allocator> __r(__lhs.get_allocator());\n    typename basic_string<_CharT, _Traits, _Allocator>::size_type __lhs_sz = __lhs.size();\n    typename basic_string<_CharT, _Traits, _Allocator>::size_type __rhs_sz = _Traits::length(__rhs);\n    __r.__init(__lhs.data(), __lhs_sz, __lhs_sz + __rhs_sz);\n    __r.append(__rhs, __rhs_sz);\n    return __r;\n}\n\ntemplate<class _CharT, class _Traits, class _Allocator>\nbasic_string<_CharT, _Traits, _Allocator>\noperator+(const basic_string<_CharT, _Traits, _Allocator>& __lhs, _CharT __rhs)\n{\n    basic_string<_CharT, _Traits, _Allocator> __r(__lhs.get_allocator());\n    typename basic_string<_CharT, _Traits, _Allocator>::size_type __lhs_sz = __lhs.size();\n    __r.__init(__lhs.data(), __lhs_sz, __lhs_sz + 1);\n    __r.push_back(__rhs);\n    return __r;\n}\n\n#ifndef _LIBCPP_HAS_NO_RVALUE_REFERENCES\n\ntemplate<class _CharT, class _Traits, class _Allocator>\ninline _LIBCPP_INLINE_VISIBILITY\nbasic_string<_CharT, _Traits, _Allocator>\noperator+(basic_string<_CharT, _Traits, _Allocator>&& __lhs, const basic_string<_CharT, _Traits, _Allocator>& __rhs)\n{\n    return _VSTD::move(__lhs.append(__rhs));\n}\n\ntemplate<class _CharT, class _Traits, class _Allocator>\ninline _LIBCPP_INLINE_VISIBILITY\nbasic_string<_CharT, _Traits, _Allocator>\noperator+(const basic_string<_CharT, _Traits, _Allocator>& __lhs, basic_string<_CharT, _Traits, _Allocator>&& __rhs)\n{\n    return _VSTD::move(__rhs.insert(0, __lhs));\n}\n\ntemplate<class _CharT, class _Traits, class _Allocator>\ninline _LIBCPP_INLINE_VISIBILITY\nbasic_string<_CharT, _Traits, _Allocator>\noperator+(basic_string<_CharT, _Traits, _Allocator>&& __lhs, basic_string<_CharT, _Traits, _Allocator>&& __rhs)\n{\n    return _VSTD::move(__lhs.append(__rhs));\n}\n\ntemplate<class _CharT, class _Traits, class _Allocator>\ninline _LIBCPP_INLINE_VISIBILITY\nbasic_string<_CharT, _Traits, _Allocator>\noperator+(const _CharT* __lhs , basic_string<_CharT,_Traits,_Allocator>&& __rhs)\n{\n    return _VSTD::move(__rhs.insert(0, __lhs));\n}\n\ntemplate<class _CharT, class _Traits, class _Allocator>\ninline _LIBCPP_INLINE_VISIBILITY\nbasic_string<_CharT, _Traits, _Allocator>\noperator+(_CharT __lhs, basic_string<_CharT,_Traits,_Allocator>&& __rhs)\n{\n    __rhs.insert(__rhs.begin(), __lhs);\n    return _VSTD::move(__rhs);\n}\n\ntemplate<class _CharT, class _Traits, class _Allocator>\ninline _LIBCPP_INLINE_VISIBILITY\nbasic_string<_CharT, _Traits, _Allocator>\noperator+(basic_string<_CharT, _Traits, _Allocator>&& __lhs, const _CharT* __rhs)\n{\n    return _VSTD::move(__lhs.append(__rhs));\n}\n\ntemplate<class _CharT, class _Traits, class _Allocator>\ninline _LIBCPP_INLINE_VISIBILITY\nbasic_string<_CharT, _Traits, _Allocator>\noperator+(basic_string<_CharT, _Traits, _Allocator>&& __lhs, _CharT __rhs)\n{\n    __lhs.push_back(__rhs);\n    return _VSTD::move(__lhs);\n}\n\n#endif  // _LIBCPP_HAS_NO_RVALUE_REFERENCES\n\n// swap\n\ntemplate<class _CharT, class _Traits, class _Allocator>\ninline _LIBCPP_INLINE_VISIBILITY\nvoid\nswap(basic_string<_CharT, _Traits, _Allocator>& __lhs,\n     basic_string<_CharT, _Traits, _Allocator>& __rhs)\n     _NOEXCEPT_(_NOEXCEPT_(__lhs.swap(__rhs)))\n{\n    __lhs.swap(__rhs);\n}\n\n#ifndef _LIBCPP_HAS_NO_UNICODE_CHARS\n\ntypedef basic_string<char16_t> u16string;\ntypedef basic_string<char32_t> u32string;\n\n#endif  // _LIBCPP_HAS_NO_UNICODE_CHARS\n\n_LIBCPP_FUNC_VIS int                stoi  (const string& __str, size_t* __idx = 0, int __base = 10);\n_LIBCPP_FUNC_VIS long               stol  (const string& __str, size_t* __idx = 0, int __base = 10);\n_LIBCPP_FUNC_VIS unsigned long      stoul (const string& __str, size_t* __idx = 0, int __base = 10);\n_LIBCPP_FUNC_VIS long long          stoll (const string& __str, size_t* __idx = 0, int __base = 10);\n_LIBCPP_FUNC_VIS unsigned long long stoull(const string& __str, size_t* __idx = 0, int __base = 10);\n\n_LIBCPP_FUNC_VIS float       stof (const string& __str, size_t* __idx = 0);\n_LIBCPP_FUNC_VIS double      stod (const string& __str, size_t* __idx = 0);\n_LIBCPP_FUNC_VIS long double stold(const string& __str, size_t* __idx = 0);\n\n_LIBCPP_FUNC_VIS string to_string(int __val);\n_LIBCPP_FUNC_VIS string to_string(unsigned __val);\n_LIBCPP_FUNC_VIS string to_string(long __val);\n_LIBCPP_FUNC_VIS string to_string(unsigned long __val);\n_LIBCPP_FUNC_VIS string to_string(long long __val);\n_LIBCPP_FUNC_VIS string to_string(unsigned long long __val);\n_LIBCPP_FUNC_VIS string to_string(float __val);\n_LIBCPP_FUNC_VIS string to_string(double __val);\n_LIBCPP_FUNC_VIS string to_string(long double __val);\n\n_LIBCPP_FUNC_VIS int                stoi  (const wstring& __str, size_t* __idx = 0, int __base = 10);\n_LIBCPP_FUNC_VIS long               stol  (const wstring& __str, size_t* __idx = 0, int __base = 10);\n_LIBCPP_FUNC_VIS unsigned long      stoul (const wstring& __str, size_t* __idx = 0, int __base = 10);\n_LIBCPP_FUNC_VIS long long          stoll (const wstring& __str, size_t* __idx = 0, int __base = 10);\n_LIBCPP_FUNC_VIS unsigned long long stoull(const wstring& __str, size_t* __idx = 0, int __base = 10);\n\n_LIBCPP_FUNC_VIS float       stof (const wstring& __str, size_t* __idx = 0);\n_LIBCPP_FUNC_VIS double      stod (const wstring& __str, size_t* __idx = 0);\n_LIBCPP_FUNC_VIS long double stold(const wstring& __str, size_t* __idx = 0);\n\n_LIBCPP_FUNC_VIS wstring to_wstring(int __val);\n_LIBCPP_FUNC_VIS wstring to_wstring(unsigned __val);\n_LIBCPP_FUNC_VIS wstring to_wstring(long __val);\n_LIBCPP_FUNC_VIS wstring to_wstring(unsigned long __val);\n_LIBCPP_FUNC_VIS wstring to_wstring(long long __val);\n_LIBCPP_FUNC_VIS wstring to_wstring(unsigned long long __val);\n_LIBCPP_FUNC_VIS wstring to_wstring(float __val);\n_LIBCPP_FUNC_VIS wstring to_wstring(double __val);\n_LIBCPP_FUNC_VIS wstring to_wstring(long double __val);\n\ntemplate<class _CharT, class _Traits, class _Allocator>\n    const typename basic_string<_CharT, _Traits, _Allocator>::size_type\n                   basic_string<_CharT, _Traits, _Allocator>::npos;\n\ntemplate<class _CharT, class _Traits, class _Allocator>\nstruct _LIBCPP_TEMPLATE_VIS hash<basic_string<_CharT, _Traits, _Allocator> >\n    : public unary_function<basic_string<_CharT, _Traits, _Allocator>, size_t>\n{\n    size_t\n        operator()(const basic_string<_CharT, _Traits, _Allocator>& __val) const _NOEXCEPT;\n};\n\ntemplate<class _CharT, class _Traits, class _Allocator>\nsize_t\nhash<basic_string<_CharT, _Traits, _Allocator> >::operator()(\n        const basic_string<_CharT, _Traits, _Allocator>& __val) const _NOEXCEPT\n{\n    return __do_string_hash(__val.data(), __val.data() + __val.size());\n}\n\ntemplate<class _CharT, class _Traits, class _Allocator>\nbasic_ostream<_CharT, _Traits>&\noperator<<(basic_ostream<_CharT, _Traits>& __os,\n           const basic_string<_CharT, _Traits, _Allocator>& __str);\n\ntemplate<class _CharT, class _Traits, class _Allocator>\nbasic_istream<_CharT, _Traits>&\noperator>>(basic_istream<_CharT, _Traits>& __is,\n           basic_string<_CharT, _Traits, _Allocator>& __str);\n\ntemplate<class _CharT, class _Traits, class _Allocator>\nbasic_istream<_CharT, _Traits>&\ngetline(basic_istream<_CharT, _Traits>& __is,\n        basic_string<_CharT, _Traits, _Allocator>& __str, _CharT __dlm);\n\ntemplate<class _CharT, class _Traits, class _Allocator>\ninline _LIBCPP_INLINE_VISIBILITY\nbasic_istream<_CharT, _Traits>&\ngetline(basic_istream<_CharT, _Traits>& __is,\n        basic_string<_CharT, _Traits, _Allocator>& __str);\n\n#ifndef _LIBCPP_HAS_NO_RVALUE_REFERENCES\n\ntemplate<class _CharT, class _Traits, class _Allocator>\ninline _LIBCPP_INLINE_VISIBILITY\nbasic_istream<_CharT, _Traits>&\ngetline(basic_istream<_CharT, _Traits>&& __is,\n        basic_string<_CharT, _Traits, _Allocator>& __str, _CharT __dlm);\n\ntemplate<class _CharT, class _Traits, class _Allocator>\ninline _LIBCPP_INLINE_VISIBILITY\nbasic_istream<_CharT, _Traits>&\ngetline(basic_istream<_CharT, _Traits>&& __is,\n        basic_string<_CharT, _Traits, _Allocator>& __str);\n\n#endif  // _LIBCPP_HAS_NO_RVALUE_REFERENCES\n\n#if _LIBCPP_DEBUG_LEVEL >= 2\n\ntemplate<class _CharT, class _Traits, class _Allocator>\nbool\nbasic_string<_CharT, _Traits, _Allocator>::__dereferenceable(const const_iterator* __i) const\n{\n    return this->data() <= _VSTD::__to_raw_pointer(__i->base()) &&\n           _VSTD::__to_raw_pointer(__i->base()) < this->data() + this->size();\n}\n\ntemplate<class _CharT, class _Traits, class _Allocator>\nbool\nbasic_string<_CharT, _Traits, _Allocator>::__decrementable(const const_iterator* __i) const\n{\n    return this->data() < _VSTD::__to_raw_pointer(__i->base()) &&\n           _VSTD::__to_raw_pointer(__i->base()) <= this->data() + this->size();\n}\n\ntemplate<class _CharT, class _Traits, class _Allocator>\nbool\nbasic_string<_CharT, _Traits, _Allocator>::__addable(const const_iterator* __i, ptrdiff_t __n) const\n{\n    const value_type* __p = _VSTD::__to_raw_pointer(__i->base()) + __n;\n    return this->data() <= __p && __p <= this->data() + this->size();\n}\n\ntemplate<class _CharT, class _Traits, class _Allocator>\nbool\nbasic_string<_CharT, _Traits, _Allocator>::__subscriptable(const const_iterator* __i, ptrdiff_t __n) const\n{\n    const value_type* __p = _VSTD::__to_raw_pointer(__i->base()) + __n;\n    return this->data() <= __p && __p < this->data() + this->size();\n}\n\n#endif  // _LIBCPP_DEBUG_LEVEL >= 2\n\n#if _LIBCPP_STD_VER > 11 \n// Literal suffixes for basic_string [basic.string.literals]\ninline namespace literals\n{\n  inline namespace string_literals\n  {\n    inline _LIBCPP_INLINE_VISIBILITY\n    basic_string<char> operator \"\" s( const char *__str, size_t __len )\n    {\n        return basic_string<char> (__str, __len);\n    }\n\n    inline _LIBCPP_INLINE_VISIBILITY\n    basic_string<wchar_t> operator \"\" s( const wchar_t *__str, size_t __len )\n    {\n        return basic_string<wchar_t> (__str, __len);\n    }\n\n    inline _LIBCPP_INLINE_VISIBILITY\n    basic_string<char16_t> operator \"\" s( const char16_t *__str, size_t __len )\n    {\n        return basic_string<char16_t> (__str, __len);\n    }\n\n    inline _LIBCPP_INLINE_VISIBILITY\n    basic_string<char32_t> operator \"\" s( const char32_t *__str, size_t __len )\n    {\n        return basic_string<char32_t> (__str, __len);\n    }\n  }\n}\n#endif\n\n_LIBCPP_EXTERN_TEMPLATE(class _LIBCPP_EXTERN_TEMPLATE_TYPE_VIS basic_string<char>)\n_LIBCPP_EXTERN_TEMPLATE(class _LIBCPP_EXTERN_TEMPLATE_TYPE_VIS basic_string<wchar_t>)\n_LIBCPP_EXTERN_TEMPLATE(string operator+<char, char_traits<char>, allocator<char> >(char const*, string const&))\n\n_LIBCPP_END_NAMESPACE_STD\n\n#endif  // _LIBCPP_STRING\n","#pragma once\n#include <string>\n#include <sstream>\n#include <vector>\n#include <deque>\n#include <variant>\n\n#ifndef CHARM_STACK_TYPE\n\t#define CHARM_STACK_TYPE std::deque<CharmFunction>\n#endif\n\n#ifndef CHARM_LIST_TYPE\n\t#define CHARM_LIST_TYPE std::vector<CharmFunction>\n#endif\n\nenum CharmTypes {\n\tTYPESIG_ANY,\n\tTYPESIG_LIST,\n\tTYPESIG_LISTSTRING,\n\tTYPESIG_STRING,\n\tTYPESIG_INT,\n\tTYPESIG_FLOAT\n};\nstruct CharmTypeSignatureUnit {\n\tstd::vector<CharmTypes> pops;\n\tstd::vector<CharmTypes> pushes;\n};\nstruct CharmTypeSignature {\n\tstd::string functionName;\n\tstd::vector<CharmTypeSignatureUnit> units;\n};\n\nenum CharmFunctionType {\n\tFUNCTION_DEFINITION, //not a function, gets removed upon running\n\t\t\t\t\t\t //serves to create static function definitions\n\tLIST_FUNCTION,  //not really a function, but\n\t                //if the thing is in brackets,\n\t\t\t\t    //this makes it a lot easier\n\t\t\t\t    //to deal with\n\tNUMBER_FUNCTION, //pushes number on stack\n\tSTRING_FUNCTION, //pushes string on stack\n\tDEFINED_FUNCTION //built in function like\n\t                 //dup, pop, i\n\t\t\t\t\t //or for preprocessing the\n\t\t\t\t\t //definitions\n};\n\nenum CharmNumberType {\n\tINTEGER_VALUE,\n\tFLOAT_VALUE\n};\n\nstruct CharmNumber {\n\tCharmNumberType whichType;\n\tlong long integerValue;\n\tlong double floatValue;\n\t//to allow Charm to support both floats\n\t//and integers, we add both\n};\n\nstruct CharmFunctionDefinitionInfo {\n\tbool inlineable;\n\tbool tailCallRecursive;\n};\nstruct CharmFunction {\n\tCharmFunctionType functionType;\n\t//ONLY USED WITH STRING_FUNCTION\n\tstd::string stringValue;\n\t//ONLY USED WITH NUMBER_FUNCTION\n\tCharmNumber numberValue;\n\t//ONLY USED WITH LIST_FUNCTION AND FUNCTION_DEFINITION\n\tCHARM_LIST_TYPE literalFunctions;\n\t//ONLY USED WITH DEFINED_FUNCTION AND FUNCTION_DEFINITION\n\tstd::string functionName;\n\t//ONLY USED WITH FUNCTION_DEFINITION\n\tCharmFunctionDefinitionInfo definitionInfo;\n};\ninline std::string charmFunctionToString(CharmFunction f) {\n\tstd::stringstream out;\n\tswitch (f.functionType) {\n\t\tcase FUNCTION_DEFINITION:\n\t\tout << f.functionName << \":=\";\n\t\tfor (CharmFunction fs : f.literalFunctions) {\n\t\t\tout << charmFunctionToString(fs) << \" \";\n\t\t}\n\t\tbreak;\n\n\t\tcase LIST_FUNCTION:\n\t\tout << \"[ \";\n\t\tfor (CharmFunction fs : f.literalFunctions) {\n\t\t\tout << charmFunctionToString(fs) << \" \";\n\t\t}\n\t\tout << \"]\";\n\t\tbreak;\n\n\t\tcase NUMBER_FUNCTION:\n\t\tswitch (f.numberValue.whichType) {\n\t\t\tcase INTEGER_VALUE:\n\t\t\tout << f.numberValue.integerValue;\n\t\t\tbreak;\n\n\t\t\tcase FLOAT_VALUE:\n\t\t\tout << f.numberValue.floatValue;\n\t\t\tbreak;\n\t\t}\n\t\tbreak;\n\n\t\tcase STRING_FUNCTION:\n\t\tout << \"\\\" \" << f.stringValue << \" \\\"\";\n\t\tbreak;\n\n\t\tcase DEFINED_FUNCTION:\n\t\tout << f.functionName;\n\t\tbreak;\n\t}\n\treturn out.str();\n}\n\ninline bool operator==(const CharmFunction& lhs, const CharmFunction& rhs){\n\tif (lhs.functionType == rhs.functionType) {\n\t\tswitch (lhs.functionType) {\n\t\t\tcase LIST_FUNCTION:\n\t\t\tif (lhs.literalFunctions.size() != rhs.literalFunctions.size()) {\n\t\t\t\treturn false;\n\t\t\t} else {\n\t\t\t\tfor (unsigned long long n = 0; n < lhs.literalFunctions.size(); n++) {\n\t\t\t\t\tif (!(lhs.literalFunctions[n] == rhs.literalFunctions[n])) {\n\t\t\t\t\t\treturn false;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\treturn true;\n\t\t\t}\n\t\t\tbreak;\n\n\t\t\tcase NUMBER_FUNCTION:\n\t\t\tif (rhs.numberValue.whichType == lhs.numberValue.whichType) {\n\t\t\t\tif (lhs.numberValue.whichType == INTEGER_VALUE) {\n\t\t\t\t\treturn (lhs.numberValue.integerValue == rhs.numberValue.integerValue);\n\t\t\t\t} else {\n\t\t\t\t\treturn (lhs.numberValue.floatValue == rhs.numberValue.floatValue);\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\treturn false;\n\t\t\t}\n\t\t\tbreak;\n\n\t\t\tcase STRING_FUNCTION:\n\t\t\treturn (lhs.stringValue == rhs.stringValue);\n\t\t\tbreak;\n\n\t\t\tcase DEFINED_FUNCTION:\n\t\t\treturn (lhs.functionName == rhs.functionName);\n\t\t\tbreak;\n\n\t\t\tcase FUNCTION_DEFINITION:\n\t\t\treturn (lhs.functionName == rhs.functionName);\n\t\t\tbreak;\n\t\t}\n\t} else {\n\t\treturn false;\n\t}\n\t//somehow, you skirted around the entire if/else. impressive?\n\treturn false;\n}\n\n\n//ALL DEFINITIONS ARE CONSTANTS\nstruct CharmDefinition {\n\tstd::string constantName;\n\tCHARM_LIST_TYPE definition;\n};\n\nclass FunctionDefinition;\nclass FunctionAnalyzer;\n//USED IN RUNNER.CPP AND PREDEFINEDFUNCTIONS.CPP\nstruct RunnerContext {\n\tFunctionDefinition* fD;\n\tFunctionAnalyzer* fA;\n};\n","// -*- C++ -*-\n//===----------------------------- new ------------------------------------===//\n//\n//                     The LLVM Compiler Infrastructure\n//\n// This file is dual licensed under the MIT and the University of Illinois Open\n// Source Licenses. See LICENSE.TXT for details.\n//\n//===----------------------------------------------------------------------===//\n\n#ifndef _LIBCPP_NEW\n#define _LIBCPP_NEW\n\n/*\n    new synopsis\n\nnamespace std\n{\n\nclass bad_alloc\n    : public exception\n{\npublic:\n    bad_alloc() noexcept;\n    bad_alloc(const bad_alloc&) noexcept;\n    bad_alloc& operator=(const bad_alloc&) noexcept;\n    virtual const char* what() const noexcept;\n};\n\nclass bad_array_length : public bad_alloc // FIXME: Not part of C++\n{\npublic:\n    bad_array_length() noexcept;\n};\n\nclass bad_array_new_length : public bad_alloc // C++14\n{\npublic:\n    bad_array_new_length() noexcept;\n};\n\nenum class align_val_t : size_t {}; // C++17\nstruct nothrow_t {};\nextern const nothrow_t nothrow;\ntypedef void (*new_handler)();\nnew_handler set_new_handler(new_handler new_p) noexcept;\nnew_handler get_new_handler() noexcept;\n\n}  // std\n\nvoid* operator new(std::size_t size);                                   // replaceable\nvoid* operator new(std::size_t size, std::align_val_t alignment);       // replaceable, C++17\nvoid* operator new(std::size_t size, const std::nothrow_t&) noexcept;   // replaceable\nvoid* operator new(std::size_t size, std::align_val_t alignment,\n                   const std::nothrow_t&) noexcept;                     // replaceable, C++17\nvoid  operator delete(void* ptr) noexcept;                              // replaceable\nvoid  operator delete(void* ptr, std::size_t size) noexcept;            // replaceable, C++14\nvoid  operator delete(void* ptr, std::align_val_t alignment) noexcept;  // replaceable, C++17\nvoid  operator delete(void* ptr, std::size_t size,\n                      std::align_val_t alignment) noexcept;             // replaceable, C++17\nvoid  operator delete(void* ptr, const std::nothrow_t&) noexcept;       // replaceable\nvoid  operator delete(void* ptr, std:align_val_t alignment,\n                      const std::nothrow_t&) noexcept;                  // replaceable, C++17\n\nvoid* operator new[](std::size_t size);                                 // replaceable\nvoid* operator new[](std::size_t size,\n                     std::align_val_t alignment) noexcept;              // replaceable, C++17\nvoid* operator new[](std::size_t size, const std::nothrow_t&) noexcept; // replaceable\nvoid* operator new[](std::size_t size, std::align_val_t alignment,\n                     const std::nothrow_t&) noexcept;                   // replaceable, C++17\nvoid  operator delete[](void* ptr) noexcept;                            // replaceable\nvoid  operator delete[](void* ptr, std::size_t size) noexcept;          // replaceable, C++14\nvoid  operator delete[](void* ptr,\n                        std::align_val_t alignment) noexcept;           // replaceable, C++17\nvoid  operator delete[](void* ptr, std::size_t size,\n                        std::align_val_t alignment) noexcept;           // replaceable, C++17\nvoid  operator delete[](void* ptr, const std::nothrow_t&) noexcept;     // replaceable\nvoid  operator delete[](void* ptr, std::align_val_t alignment,\n                        const std::nothrow_t&) noexcept;                // replaceable, C++17\n\nvoid* operator new  (std::size_t size, void* ptr) noexcept;\nvoid* operator new[](std::size_t size, void* ptr) noexcept;\nvoid  operator delete  (void* ptr, void*) noexcept;\nvoid  operator delete[](void* ptr, void*) noexcept;\n\n*/\n\n#include <__config>\n#include <exception>\n#include <cstddef>\n#ifdef _LIBCPP_NO_EXCEPTIONS\n#include <cstdlib>\n#endif\n\n#if !defined(_LIBCPP_HAS_NO_PRAGMA_SYSTEM_HEADER)\n#pragma GCC system_header\n#endif\n\n#if !(defined(_LIBCPP_BUILDING_NEW) || _LIBCPP_STD_VER >= 14 || \\\n    (defined(__cpp_sized_deallocation) && __cpp_sized_deallocation >= 201309))\n# define _LIBCPP_HAS_NO_SIZED_DEALLOCATION\n#endif\n\n#if !defined(_LIBCPP_HAS_NO_ALIGNED_ALLOCATION) && \\\n    (!(defined(_LIBCPP_BUILDING_NEW) || _LIBCPP_STD_VER > 14 || \\\n    (defined(__cpp_aligned_new) && __cpp_aligned_new >= 201606)))\n# define _LIBCPP_HAS_NO_ALIGNED_ALLOCATION\n#endif\n\nnamespace std  // purposefully not using versioning namespace\n{\n\nclass _LIBCPP_EXCEPTION_ABI bad_alloc\n    : public exception\n{\npublic:\n    bad_alloc() _NOEXCEPT;\n    virtual ~bad_alloc() _NOEXCEPT;\n    virtual const char* what() const _NOEXCEPT;\n};\n\nclass _LIBCPP_EXCEPTION_ABI bad_array_new_length\n    : public bad_alloc\n{\npublic:\n    bad_array_new_length() _NOEXCEPT;\n    virtual ~bad_array_new_length() _NOEXCEPT;\n    virtual const char* what() const _NOEXCEPT;\n};\n\n_LIBCPP_NORETURN _LIBCPP_FUNC_VIS void __throw_bad_alloc();  // not in C++ spec\n\n#if defined(_LIBCPP_BUILDING_NEW) || (_LIBCPP_STD_VER > 11)\n\nclass _LIBCPP_EXCEPTION_ABI bad_array_length\n    : public bad_alloc\n{\npublic:\n    bad_array_length() _NOEXCEPT;\n    virtual ~bad_array_length() _NOEXCEPT;\n    virtual const char* what() const _NOEXCEPT;\n};\n\n#define _LIBCPP_BAD_ARRAY_LENGTH_DEFINED\n\n#endif  // defined(_LIBCPP_BUILDING_NEW) || (_LIBCPP_STD_VER > 11)\n\n#if !defined(_LIBCPP_HAS_NO_ALIGNED_ALLOCATION) || _LIBCPP_STD_VER > 14\n#ifndef _LIBCPP_CXX03_LANG\nenum class _LIBCPP_ENUM_VIS align_val_t : size_t { };\n#else\nenum align_val_t { __zero = 0, __max = (size_t)-1 };\n#endif\n#endif\n\nstruct _LIBCPP_TYPE_VIS nothrow_t {};\nextern _LIBCPP_FUNC_VIS const nothrow_t nothrow;\ntypedef void (*new_handler)();\n_LIBCPP_FUNC_VIS new_handler set_new_handler(new_handler) _NOEXCEPT;\n_LIBCPP_FUNC_VIS new_handler get_new_handler() _NOEXCEPT;\n\n}  // std\n\n#if defined(_LIBCPP_CXX03_LANG)\n#define _THROW_BAD_ALLOC throw(std::bad_alloc)\n#else\n#define _THROW_BAD_ALLOC\n#endif\n\n_LIBCPP_OVERRIDABLE_FUNC_VIS void* operator new(std::size_t __sz) _THROW_BAD_ALLOC;\n_LIBCPP_OVERRIDABLE_FUNC_VIS void* operator new(std::size_t __sz, const std::nothrow_t&) _NOEXCEPT _NOALIAS;\n_LIBCPP_OVERRIDABLE_FUNC_VIS void  operator delete(void* __p) _NOEXCEPT;\n_LIBCPP_OVERRIDABLE_FUNC_VIS void  operator delete(void* __p, const std::nothrow_t&) _NOEXCEPT;\n#ifndef _LIBCPP_HAS_NO_SIZED_DEALLOCATION\n_LIBCPP_OVERRIDABLE_FUNC_VIS void  operator delete(void* __p, std::size_t __sz) _NOEXCEPT;\n#endif\n\n_LIBCPP_OVERRIDABLE_FUNC_VIS void* operator new[](std::size_t __sz) _THROW_BAD_ALLOC;\n_LIBCPP_OVERRIDABLE_FUNC_VIS void* operator new[](std::size_t __sz, const std::nothrow_t&) _NOEXCEPT _NOALIAS;\n_LIBCPP_OVERRIDABLE_FUNC_VIS void  operator delete[](void* __p) _NOEXCEPT;\n_LIBCPP_OVERRIDABLE_FUNC_VIS void  operator delete[](void* __p, const std::nothrow_t&) _NOEXCEPT;\n#ifndef _LIBCPP_HAS_NO_SIZED_DEALLOCATION\n_LIBCPP_OVERRIDABLE_FUNC_VIS void  operator delete[](void* __p, std::size_t __sz) _NOEXCEPT;\n#endif\n\n#ifndef _LIBCPP_HAS_NO_ALIGNED_ALLOCATION\n_LIBCPP_OVERRIDABLE_FUNC_VIS void* operator new(std::size_t __sz, std::align_val_t) _THROW_BAD_ALLOC;\n_LIBCPP_OVERRIDABLE_FUNC_VIS void* operator new(std::size_t __sz, std::align_val_t, const std::nothrow_t&) _NOEXCEPT _NOALIAS;\n_LIBCPP_OVERRIDABLE_FUNC_VIS void  operator delete(void* __p, std::align_val_t) _NOEXCEPT;\n_LIBCPP_OVERRIDABLE_FUNC_VIS void  operator delete(void* __p, std::align_val_t, const std::nothrow_t&) _NOEXCEPT;\n#ifndef _LIBCPP_HAS_NO_SIZED_DEALLOCATION\n_LIBCPP_OVERRIDABLE_FUNC_VIS void  operator delete(void* __p, std::size_t __sz, std::align_val_t) _NOEXCEPT;\n#endif\n\n_LIBCPP_OVERRIDABLE_FUNC_VIS void* operator new[](std::size_t __sz, std::align_val_t) _THROW_BAD_ALLOC;\n_LIBCPP_OVERRIDABLE_FUNC_VIS void* operator new[](std::size_t __sz, std::align_val_t, const std::nothrow_t&) _NOEXCEPT _NOALIAS;\n_LIBCPP_OVERRIDABLE_FUNC_VIS void  operator delete[](void* __p, std::align_val_t) _NOEXCEPT;\n_LIBCPP_OVERRIDABLE_FUNC_VIS void  operator delete[](void* __p, std::align_val_t, const std::nothrow_t&) _NOEXCEPT;\n#ifndef _LIBCPP_HAS_NO_SIZED_DEALLOCATION\n_LIBCPP_OVERRIDABLE_FUNC_VIS void  operator delete[](void* __p, std::size_t __sz, std::align_val_t) _NOEXCEPT;\n#endif\n#endif\n\ninline _LIBCPP_INLINE_VISIBILITY void* operator new  (std::size_t, void* __p) _NOEXCEPT {return __p;}\ninline _LIBCPP_INLINE_VISIBILITY void* operator new[](std::size_t, void* __p) _NOEXCEPT {return __p;}\ninline _LIBCPP_INLINE_VISIBILITY void  operator delete  (void*, void*) _NOEXCEPT {}\ninline _LIBCPP_INLINE_VISIBILITY void  operator delete[](void*, void*) _NOEXCEPT {}\n\n_LIBCPP_BEGIN_NAMESPACE_STD\n\ninline _LIBCPP_INLINE_VISIBILITY void *__allocate(size_t __size) {\n#ifdef _LIBCPP_HAS_NO_BUILTIN_OPERATOR_NEW_DELETE\n  return ::operator new(__size);\n#else\n  return __builtin_operator_new(__size);\n#endif\n}\n\ninline _LIBCPP_INLINE_VISIBILITY void __libcpp_deallocate(void *__ptr) {\n#ifdef _LIBCPP_HAS_NO_BUILTIN_OPERATOR_NEW_DELETE\n  ::operator delete(__ptr);\n#else\n  __builtin_operator_delete(__ptr);\n#endif\n}\n\n#ifdef _LIBCPP_BAD_ARRAY_LENGTH_DEFINED\n_LIBCPP_NORETURN inline _LIBCPP_ALWAYS_INLINE\nvoid __throw_bad_array_length()\n{\n#ifndef _LIBCPP_NO_EXCEPTIONS\n    throw bad_array_length();\n#else\n\t_VSTD::abort();\n#endif\n}\n#endif\n\n_LIBCPP_END_NAMESPACE_STD\n\n#endif  // _LIBCPP_NEW\n","// -*- C++ -*-\n//===-------------------------- memory ------------------------------------===//\n//\n//                     The LLVM Compiler Infrastructure\n//\n// This file is dual licensed under the MIT and the University of Illinois Open\n// Source Licenses. See LICENSE.TXT for details.\n//\n//===----------------------------------------------------------------------===//\n\n#ifndef _LIBCPP_MEMORY\n#define _LIBCPP_MEMORY\n\n/*\n    memory synopsis\n\nnamespace std\n{\n\nstruct allocator_arg_t { };\nconstexpr allocator_arg_t allocator_arg = allocator_arg_t();\n\ntemplate <class T, class Alloc> struct uses_allocator;\n\ntemplate <class Ptr>\nstruct pointer_traits\n{\n    typedef Ptr pointer;\n    typedef <details> element_type;\n    typedef <details> difference_type;\n\n    template <class U> using rebind = <details>;\n\n    static pointer pointer_to(<details>);\n};\n\ntemplate <class T>\nstruct pointer_traits<T*>\n{\n    typedef T* pointer;\n    typedef T element_type;\n    typedef ptrdiff_t difference_type;\n\n    template <class U> using rebind = U*;\n\n    static pointer pointer_to(<details>) noexcept;\n};\n\ntemplate <class Alloc>\nstruct allocator_traits\n{\n    typedef Alloc                        allocator_type;\n    typedef typename allocator_type::value_type\n                                         value_type;\n\n    typedef Alloc::pointer | value_type* pointer;\n    typedef Alloc::const_pointer\n          | pointer_traits<pointer>::rebind<const value_type>\n                                         const_pointer;\n    typedef Alloc::void_pointer\n          | pointer_traits<pointer>::rebind<void>\n                                         void_pointer;\n    typedef Alloc::const_void_pointer\n          | pointer_traits<pointer>::rebind<const void>\n                                         const_void_pointer;\n    typedef Alloc::difference_type\n          | pointer_traits<pointer>::difference_type\n                                         difference_type;\n    typedef Alloc::size_type\n          | make_unsigned<difference_type>::type\n                                         size_type;\n    typedef Alloc::propagate_on_container_copy_assignment\n          | false_type                   propagate_on_container_copy_assignment;\n    typedef Alloc::propagate_on_container_move_assignment\n          | false_type                   propagate_on_container_move_assignment;\n    typedef Alloc::propagate_on_container_swap\n          | false_type                   propagate_on_container_swap;\n    typedef Alloc::is_always_equal\n          | is_empty                     is_always_equal;\n\n    template <class T> using rebind_alloc  = Alloc::rebind<U>::other | Alloc<T, Args...>;\n    template <class T> using rebind_traits = allocator_traits<rebind_alloc<T>>;\n\n    static pointer allocate(allocator_type& a, size_type n);\n    static pointer allocate(allocator_type& a, size_type n, const_void_pointer hint);\n\n    static void deallocate(allocator_type& a, pointer p, size_type n) noexcept;\n\n    template <class T, class... Args>\n        static void construct(allocator_type& a, T* p, Args&&... args);\n\n    template <class T>\n        static void destroy(allocator_type& a, T* p);\n\n    static size_type max_size(const allocator_type& a); // noexcept in C++14\n\n    static allocator_type\n        select_on_container_copy_construction(const allocator_type& a);\n};\n\ntemplate <>\nclass allocator<void>\n{\npublic:\n    typedef void*                                 pointer;\n    typedef const void*                           const_pointer;\n    typedef void                                  value_type;\n\n    template <class _Up> struct rebind {typedef allocator<_Up> other;};\n};\n\ntemplate <class T>\nclass allocator\n{\npublic:\n    typedef size_t                                size_type;\n    typedef ptrdiff_t                             difference_type;\n    typedef T*                                    pointer;\n    typedef const T*                              const_pointer;\n    typedef typename add_lvalue_reference<T>::type       reference;\n    typedef typename add_lvalue_reference<const T>::type const_reference;\n    typedef T                                     value_type;\n\n    template <class U> struct rebind {typedef allocator<U> other;};\n\n    allocator() noexcept;\n    allocator(const allocator&) noexcept;\n    template <class U> allocator(const allocator<U>&) noexcept;\n    ~allocator();\n    pointer address(reference x) const noexcept;\n    const_pointer address(const_reference x) const noexcept;\n    pointer allocate(size_type, allocator<void>::const_pointer hint = 0);\n    void deallocate(pointer p, size_type n) noexcept;\n    size_type max_size() const noexcept;\n    template<class U, class... Args>\n        void construct(U* p, Args&&... args);\n    template <class U>\n        void destroy(U* p);\n};\n\ntemplate <class T, class U>\nbool operator==(const allocator<T>&, const allocator<U>&) noexcept;\n\ntemplate <class T, class U>\nbool operator!=(const allocator<T>&, const allocator<U>&) noexcept;\n\ntemplate <class OutputIterator, class T>\nclass raw_storage_iterator\n    : public iterator<output_iterator_tag,\n                      T,                               // purposefully not C++03\n                      ptrdiff_t,                       // purposefully not C++03\n                      T*,                              // purposefully not C++03\n                      raw_storage_iterator&>           // purposefully not C++03\n{\npublic:\n    explicit raw_storage_iterator(OutputIterator x);\n    raw_storage_iterator& operator*();\n    raw_storage_iterator& operator=(const T& element);\n    raw_storage_iterator& operator++();\n    raw_storage_iterator  operator++(int);\n};\n\ntemplate <class T> pair<T*,ptrdiff_t> get_temporary_buffer(ptrdiff_t n) noexcept;\ntemplate <class T> void               return_temporary_buffer(T* p) noexcept;\n\ntemplate <class T> T* addressof(T& r) noexcept;\ntemplate <class T> T* addressof(const T&& r) noexcept = delete;\n\ntemplate <class InputIterator, class ForwardIterator>\nForwardIterator\nuninitialized_copy(InputIterator first, InputIterator last, ForwardIterator result);\n\ntemplate <class InputIterator, class Size, class ForwardIterator>\nForwardIterator\nuninitialized_copy_n(InputIterator first, Size n, ForwardIterator result);\n\ntemplate <class ForwardIterator, class T>\nvoid uninitialized_fill(ForwardIterator first, ForwardIterator last, const T& x);\n\ntemplate <class ForwardIterator, class Size, class T>\nForwardIterator\nuninitialized_fill_n(ForwardIterator first, Size n, const T& x);\n\ntemplate <class T>\nvoid destroy_at(T* location);\n\ntemplate <class ForwardIterator>\n void destroy(ForwardIterator first, ForwardIterator last);\n\ntemplate <class ForwardIterator, class Size>\n ForwardIterator destroy_n(ForwardIterator first, Size n);\n\ntemplate <class InputIterator, class ForwardIterator>\n ForwardIterator uninitialized_move(InputIterator first, InputIterator last, ForwardIterator result);\n\ntemplate <class InputIterator, class Size, class ForwardIterator>\n pair<InputIterator,ForwardIterator> uninitialized_move_n(InputIterator first, Size n, ForwardIterator result);\n\ntemplate <class ForwardIterator>\n void uninitialized_value_construct(ForwardIterator first, ForwardIterator last);\n\ntemplate <class ForwardIterator, class Size>\n ForwardIterator uninitialized_value_construct_n(ForwardIterator first, Size n);\n\ntemplate <class ForwardIterator>\n void uninitialized_default_construct(ForwardIterator first, ForwardIterator last);\n\ntemplate <class ForwardIterator, class Size>\n ForwardIterator uninitialized_default_construct_n(ForwardIterator first, Size n);\n\ntemplate <class Y> struct auto_ptr_ref {};\n\ntemplate<class X>\nclass auto_ptr\n{\npublic:\n    typedef X element_type;\n\n    explicit auto_ptr(X* p =0) throw();\n    auto_ptr(auto_ptr&) throw();\n    template<class Y> auto_ptr(auto_ptr<Y>&) throw();\n    auto_ptr& operator=(auto_ptr&) throw();\n    template<class Y> auto_ptr& operator=(auto_ptr<Y>&) throw();\n    auto_ptr& operator=(auto_ptr_ref<X> r) throw();\n    ~auto_ptr() throw();\n\n    typename add_lvalue_reference<X>::type operator*() const throw();\n    X* operator->() const throw();\n    X* get() const throw();\n    X* release() throw();\n    void reset(X* p =0) throw();\n\n    auto_ptr(auto_ptr_ref<X>) throw();\n    template<class Y> operator auto_ptr_ref<Y>() throw();\n    template<class Y> operator auto_ptr<Y>() throw();\n};\n\ntemplate <class T>\nstruct default_delete\n{\n    constexpr default_delete() noexcept = default;\n    template <class U> default_delete(const default_delete<U>&) noexcept;\n\n    void operator()(T*) const noexcept;\n};\n\ntemplate <class T>\nstruct default_delete<T[]>\n{\n    constexpr default_delete() noexcept = default;\n    void operator()(T*) const noexcept;\n    template <class U> void operator()(U*) const = delete;\n};\n\ntemplate <class T, class D = default_delete<T>>\nclass unique_ptr\n{\npublic:\n    typedef see below pointer;\n    typedef T element_type;\n    typedef D deleter_type;\n\n    // constructors\n    constexpr unique_ptr() noexcept;\n    explicit unique_ptr(pointer p) noexcept;\n    unique_ptr(pointer p, see below d1) noexcept;\n    unique_ptr(pointer p, see below d2) noexcept;\n    unique_ptr(unique_ptr&& u) noexcept;\n    unique_ptr(nullptr_t) noexcept : unique_ptr() { }\n    template <class U, class E>\n        unique_ptr(unique_ptr<U, E>&& u) noexcept;\n    template <class U>\n        unique_ptr(auto_ptr<U>&& u) noexcept;\n\n    // destructor\n    ~unique_ptr();\n\n    // assignment\n    unique_ptr& operator=(unique_ptr&& u) noexcept;\n    template <class U, class E> unique_ptr& operator=(unique_ptr<U, E>&& u) noexcept;\n    unique_ptr& operator=(nullptr_t) noexcept;\n\n    // observers\n    typename add_lvalue_reference<T>::type operator*() const;\n    pointer operator->() const noexcept;\n    pointer get() const noexcept;\n    deleter_type& get_deleter() noexcept;\n    const deleter_type& get_deleter() const noexcept;\n    explicit operator bool() const noexcept;\n\n    // modifiers\n    pointer release() noexcept;\n    void reset(pointer p = pointer()) noexcept;\n    void swap(unique_ptr& u) noexcept;\n};\n\ntemplate <class T, class D>\nclass unique_ptr<T[], D>\n{\npublic:\n    typedef implementation-defined pointer;\n    typedef T element_type;\n    typedef D deleter_type;\n\n    // constructors\n    constexpr unique_ptr() noexcept;\n    explicit unique_ptr(pointer p) noexcept;\n    unique_ptr(pointer p, see below d) noexcept;\n    unique_ptr(pointer p, see below d) noexcept;\n    unique_ptr(unique_ptr&& u) noexcept;\n    unique_ptr(nullptr_t) noexcept : unique_ptr() { }\n\n    // destructor\n    ~unique_ptr();\n\n    // assignment\n    unique_ptr& operator=(unique_ptr&& u) noexcept;\n    unique_ptr& operator=(nullptr_t) noexcept;\n\n    // observers\n    T& operator[](size_t i) const;\n    pointer get() const noexcept;\n    deleter_type& get_deleter() noexcept;\n    const deleter_type& get_deleter() const noexcept;\n    explicit operator bool() const noexcept;\n\n    // modifiers\n    pointer release() noexcept;\n    void reset(pointer p = pointer()) noexcept;\n    void reset(nullptr_t) noexcept;\n    template <class U> void reset(U) = delete;\n    void swap(unique_ptr& u) noexcept;\n};\n\ntemplate <class T, class D>\n    void swap(unique_ptr<T, D>& x, unique_ptr<T, D>& y) noexcept;\n\ntemplate <class T1, class D1, class T2, class D2>\n    bool operator==(const unique_ptr<T1, D1>& x, const unique_ptr<T2, D2>& y);\ntemplate <class T1, class D1, class T2, class D2>\n    bool operator!=(const unique_ptr<T1, D1>& x, const unique_ptr<T2, D2>& y);\ntemplate <class T1, class D1, class T2, class D2>\n    bool operator<(const unique_ptr<T1, D1>& x, const unique_ptr<T2, D2>& y);\ntemplate <class T1, class D1, class T2, class D2>\n    bool operator<=(const unique_ptr<T1, D1>& x, const unique_ptr<T2, D2>& y);\ntemplate <class T1, class D1, class T2, class D2>\n    bool operator>(const unique_ptr<T1, D1>& x, const unique_ptr<T2, D2>& y);\ntemplate <class T1, class D1, class T2, class D2>\n    bool operator>=(const unique_ptr<T1, D1>& x, const unique_ptr<T2, D2>& y);\n\ntemplate <class T, class D>\n    bool operator==(const unique_ptr<T, D>& x, nullptr_t) noexcept;\ntemplate <class T, class D>\n    bool operator==(nullptr_t, const unique_ptr<T, D>& y) noexcept;\ntemplate <class T, class D>\n    bool operator!=(const unique_ptr<T, D>& x, nullptr_t) noexcept;\ntemplate <class T, class D>\n    bool operator!=(nullptr_t, const unique_ptr<T, D>& y) noexcept;\n\ntemplate <class T, class D>\n    bool operator<(const unique_ptr<T, D>& x, nullptr_t);\ntemplate <class T, class D>\n    bool operator<(nullptr_t, const unique_ptr<T, D>& y);\ntemplate <class T, class D>\n    bool operator<=(const unique_ptr<T, D>& x, nullptr_t);\ntemplate <class T, class D>\n    bool operator<=(nullptr_t, const unique_ptr<T, D>& y);\ntemplate <class T, class D>\n    bool operator>(const unique_ptr<T, D>& x, nullptr_t);\ntemplate <class T, class D>\n    bool operator>(nullptr_t, const unique_ptr<T, D>& y);\ntemplate <class T, class D>\n    bool operator>=(const unique_ptr<T, D>& x, nullptr_t);\ntemplate <class T, class D>\n    bool operator>=(nullptr_t, const unique_ptr<T, D>& y);\n\nclass bad_weak_ptr\n    : public std::exception\n{\n    bad_weak_ptr() noexcept;\n};\n\ntemplate<class T, class... Args> unique_ptr<T> make_unique(Args&&... args);     // C++14\ntemplate<class T>                unique_ptr<T> make_unique(size_t n);           // C++14\ntemplate<class T, class... Args> unspecified   make_unique(Args&&...) = delete; // C++14, T == U[N]\n\ntemplate<class T>\nclass shared_ptr\n{\npublic:\n    typedef T element_type;\n    typedef weak_ptr<T> weak_type; // C++17\n\n    // constructors:\n    constexpr shared_ptr() noexcept;\n    template<class Y> explicit shared_ptr(Y* p);\n    template<class Y, class D> shared_ptr(Y* p, D d);\n    template<class Y, class D, class A> shared_ptr(Y* p, D d, A a);\n    template <class D> shared_ptr(nullptr_t p, D d);\n    template <class D, class A> shared_ptr(nullptr_t p, D d, A a);\n    template<class Y> shared_ptr(const shared_ptr<Y>& r, T *p) noexcept;\n    shared_ptr(const shared_ptr& r) noexcept;\n    template<class Y> shared_ptr(const shared_ptr<Y>& r) noexcept;\n    shared_ptr(shared_ptr&& r) noexcept;\n    template<class Y> shared_ptr(shared_ptr<Y>&& r) noexcept;\n    template<class Y> explicit shared_ptr(const weak_ptr<Y>& r);\n    template<class Y> shared_ptr(auto_ptr<Y>&& r);\n    template <class Y, class D> shared_ptr(unique_ptr<Y, D>&& r);\n    shared_ptr(nullptr_t) : shared_ptr() { }\n\n    // destructor:\n    ~shared_ptr();\n\n    // assignment:\n    shared_ptr& operator=(const shared_ptr& r) noexcept;\n    template<class Y> shared_ptr& operator=(const shared_ptr<Y>& r) noexcept;\n    shared_ptr& operator=(shared_ptr&& r) noexcept;\n    template<class Y> shared_ptr& operator=(shared_ptr<Y>&& r);\n    template<class Y> shared_ptr& operator=(auto_ptr<Y>&& r);\n    template <class Y, class D> shared_ptr& operator=(unique_ptr<Y, D>&& r);\n\n    // modifiers:\n    void swap(shared_ptr& r) noexcept;\n    void reset() noexcept;\n    template<class Y> void reset(Y* p);\n    template<class Y, class D> void reset(Y* p, D d);\n    template<class Y, class D, class A> void reset(Y* p, D d, A a);\n\n    // observers:\n    T* get() const noexcept;\n    T& operator*() const noexcept;\n    T* operator->() const noexcept;\n    long use_count() const noexcept;\n    bool unique() const noexcept;\n    explicit operator bool() const noexcept;\n    template<class U> bool owner_before(shared_ptr<U> const& b) const;\n    template<class U> bool owner_before(weak_ptr<U> const& b) const;\n};\n\n// shared_ptr comparisons:\ntemplate<class T, class U>\n    bool operator==(shared_ptr<T> const& a, shared_ptr<U> const& b) noexcept;\ntemplate<class T, class U>\n    bool operator!=(shared_ptr<T> const& a, shared_ptr<U> const& b) noexcept;\ntemplate<class T, class U>\n    bool operator<(shared_ptr<T> const& a, shared_ptr<U> const& b) noexcept;\ntemplate<class T, class U>\n    bool operator>(shared_ptr<T> const& a, shared_ptr<U> const& b) noexcept;\ntemplate<class T, class U>\n    bool operator<=(shared_ptr<T> const& a, shared_ptr<U> const& b) noexcept;\ntemplate<class T, class U>\n    bool operator>=(shared_ptr<T> const& a, shared_ptr<U> const& b) noexcept;\n\ntemplate <class T>\n    bool operator==(const shared_ptr<T>& x, nullptr_t) noexcept;\ntemplate <class T>\n    bool operator==(nullptr_t, const shared_ptr<T>& y) noexcept;\ntemplate <class T>\n    bool operator!=(const shared_ptr<T>& x, nullptr_t) noexcept;\ntemplate <class T>\n    bool operator!=(nullptr_t, const shared_ptr<T>& y) noexcept;\ntemplate <class T>\n    bool operator<(const shared_ptr<T>& x, nullptr_t) noexcept;\ntemplate <class T>\nbool operator<(nullptr_t, const shared_ptr<T>& y) noexcept;\ntemplate <class T>\n    bool operator<=(const shared_ptr<T>& x, nullptr_t) noexcept;\ntemplate <class T>\n    bool operator<=(nullptr_t, const shared_ptr<T>& y) noexcept;\ntemplate <class T>\n    bool operator>(const shared_ptr<T>& x, nullptr_t) noexcept;\ntemplate <class T>\n    bool operator>(nullptr_t, const shared_ptr<T>& y) noexcept;\ntemplate <class T>\n    bool operator>=(const shared_ptr<T>& x, nullptr_t) noexcept;\ntemplate <class T>\n    bool operator>=(nullptr_t, const shared_ptr<T>& y) noexcept;\n\n// shared_ptr specialized algorithms:\ntemplate<class T> void swap(shared_ptr<T>& a, shared_ptr<T>& b) noexcept;\n\n// shared_ptr casts:\ntemplate<class T, class U>\n    shared_ptr<T> static_pointer_cast(shared_ptr<U> const& r) noexcept;\ntemplate<class T, class U>\n    shared_ptr<T> dynamic_pointer_cast(shared_ptr<U> const& r) noexcept;\ntemplate<class T, class U>\n    shared_ptr<T> const_pointer_cast(shared_ptr<U> const& r) noexcept;\n\n// shared_ptr I/O:\ntemplate<class E, class T, class Y>\n    basic_ostream<E, T>& operator<< (basic_ostream<E, T>& os, shared_ptr<Y> const& p);\n\n// shared_ptr get_deleter:\ntemplate<class D, class T> D* get_deleter(shared_ptr<T> const& p) noexcept;\n\ntemplate<class T, class... Args>\n    shared_ptr<T> make_shared(Args&&... args);\ntemplate<class T, class A, class... Args>\n    shared_ptr<T> allocate_shared(const A& a, Args&&... args);\n\ntemplate<class T>\nclass weak_ptr\n{\npublic:\n    typedef T element_type;\n\n    // constructors\n    constexpr weak_ptr() noexcept;\n    template<class Y> weak_ptr(shared_ptr<Y> const& r) noexcept;\n    weak_ptr(weak_ptr const& r) noexcept;\n    template<class Y> weak_ptr(weak_ptr<Y> const& r) noexcept;\n    weak_ptr(weak_ptr&& r) noexcept;                      // C++14\n    template<class Y> weak_ptr(weak_ptr<Y>&& r) noexcept; // C++14\n\n    // destructor\n    ~weak_ptr();\n\n    // assignment\n    weak_ptr& operator=(weak_ptr const& r) noexcept;\n    template<class Y> weak_ptr& operator=(weak_ptr<Y> const& r) noexcept;\n    template<class Y> weak_ptr& operator=(shared_ptr<Y> const& r) noexcept;\n    weak_ptr& operator=(weak_ptr&& r) noexcept;                      // C++14\n    template<class Y> weak_ptr& operator=(weak_ptr<Y>&& r) noexcept; // C++14\n\n    // modifiers\n    void swap(weak_ptr& r) noexcept;\n    void reset() noexcept;\n\n    // observers\n    long use_count() const noexcept;\n    bool expired() const noexcept;\n    shared_ptr<T> lock() const noexcept;\n    template<class U> bool owner_before(shared_ptr<U> const& b) const;\n    template<class U> bool owner_before(weak_ptr<U> const& b) const;\n};\n\n// weak_ptr specialized algorithms:\ntemplate<class T> void swap(weak_ptr<T>& a, weak_ptr<T>& b) noexcept;\n\n// class owner_less:\ntemplate<class T> struct owner_less;\n\ntemplate<class T>\nstruct owner_less<shared_ptr<T>>\n    : binary_function<shared_ptr<T>, shared_ptr<T>, bool>\n{\n    typedef bool result_type;\n    bool operator()(shared_ptr<T> const&, shared_ptr<T> const&) const;\n    bool operator()(shared_ptr<T> const&, weak_ptr<T> const&) const;\n    bool operator()(weak_ptr<T> const&, shared_ptr<T> const&) const;\n};\n\ntemplate<class T>\nstruct owner_less<weak_ptr<T>>\n    : binary_function<weak_ptr<T>, weak_ptr<T>, bool>\n{\n    typedef bool result_type;\n    bool operator()(weak_ptr<T> const&, weak_ptr<T> const&) const;\n    bool operator()(shared_ptr<T> const&, weak_ptr<T> const&) const;\n    bool operator()(weak_ptr<T> const&, shared_ptr<T> const&) const;\n};\n\ntemplate<class T>\nclass enable_shared_from_this\n{\nprotected:\n    constexpr enable_shared_from_this() noexcept;\n    enable_shared_from_this(enable_shared_from_this const&) noexcept;\n    enable_shared_from_this& operator=(enable_shared_from_this const&) noexcept;\n    ~enable_shared_from_this();\npublic:\n    shared_ptr<T> shared_from_this();\n    shared_ptr<T const> shared_from_this() const;\n};\n\ntemplate<class T>\n    bool atomic_is_lock_free(const shared_ptr<T>* p);\ntemplate<class T>\n    shared_ptr<T> atomic_load(const shared_ptr<T>* p);\ntemplate<class T>\n    shared_ptr<T> atomic_load_explicit(const shared_ptr<T>* p, memory_order mo);\ntemplate<class T>\n    void atomic_store(shared_ptr<T>* p, shared_ptr<T> r);\ntemplate<class T>\n    void atomic_store_explicit(shared_ptr<T>* p, shared_ptr<T> r, memory_order mo);\ntemplate<class T>\n    shared_ptr<T> atomic_exchange(shared_ptr<T>* p, shared_ptr<T> r);\ntemplate<class T>\n    shared_ptr<T>\n    atomic_exchange_explicit(shared_ptr<T>* p, shared_ptr<T> r, memory_order mo);\ntemplate<class T>\n    bool\n    atomic_compare_exchange_weak(shared_ptr<T>* p, shared_ptr<T>* v, shared_ptr<T> w);\ntemplate<class T>\n    bool\n    atomic_compare_exchange_strong( shared_ptr<T>* p, shared_ptr<T>* v, shared_ptr<T> w);\ntemplate<class T>\n    bool\n    atomic_compare_exchange_weak_explicit(shared_ptr<T>* p, shared_ptr<T>* v,\n                                          shared_ptr<T> w, memory_order success,\n                                          memory_order failure);\ntemplate<class T>\n    bool\n    atomic_compare_exchange_strong_explicit(shared_ptr<T>* p, shared_ptr<T>* v,\n                                            shared_ptr<T> w, memory_order success,\n                                            memory_order failure);\n// Hash support\ntemplate <class T> struct hash;\ntemplate <class T, class D> struct hash<unique_ptr<T, D> >;\ntemplate <class T> struct hash<shared_ptr<T> >;\n\n// Pointer safety\nenum class pointer_safety { relaxed, preferred, strict };\nvoid declare_reachable(void *p);\ntemplate <class T> T *undeclare_reachable(T *p);\nvoid declare_no_pointers(char *p, size_t n);\nvoid undeclare_no_pointers(char *p, size_t n);\npointer_safety get_pointer_safety() noexcept;\n\nvoid* align(size_t alignment, size_t size, void*& ptr, size_t& space);\n\n}  // std\n\n*/\n\n#include <__config>\n#include <type_traits>\n#include <typeinfo>\n#include <cstddef>\n#include <cstdint>\n#include <new>\n#include <utility>\n#include <limits>\n#include <iterator>\n#include <__functional_base>\n#include <iosfwd>\n#include <tuple>\n#include <stdexcept>\n#include <cstring>\n\n#if !defined(_LIBCPP_HAS_NO_ATOMIC_HEADER)\n#  include <atomic>\n#endif\n\n#include <__undef_min_max>\n\n#if !defined(_LIBCPP_HAS_NO_PRAGMA_SYSTEM_HEADER)\n#pragma GCC system_header\n#endif\n\n_LIBCPP_BEGIN_NAMESPACE_STD\n\ntemplate <class _ValueType>\ninline _LIBCPP_ALWAYS_INLINE\n_ValueType __libcpp_relaxed_load(_ValueType const* __value) {\n#if !defined(_LIBCPP_HAS_NO_THREADS) && \\\n    defined(__ATOMIC_RELAXED) &&        \\\n    (__has_builtin(__atomic_load_n) || _GNUC_VER >= 407)\n    return __atomic_load_n(__value, __ATOMIC_RELAXED);\n#else\n    return *__value;\n#endif\n}\n\ntemplate <class _ValueType>\ninline _LIBCPP_ALWAYS_INLINE\n_ValueType __libcpp_acquire_load(_ValueType const* __value) {\n#if !defined(_LIBCPP_HAS_NO_THREADS) && \\\n    defined(__ATOMIC_ACQUIRE) &&        \\\n    (__has_builtin(__atomic_load_n) || _GNUC_VER >= 407)\n    return __atomic_load_n(__value, __ATOMIC_ACQUIRE);\n#else\n    return *__value;\n#endif\n}\n\n// addressof moved to <type_traits>\n\ntemplate <class _Tp> class allocator;\n\ntemplate <>\nclass _LIBCPP_TEMPLATE_VIS allocator<void>\n{\npublic:\n    typedef void*             pointer;\n    typedef const void*       const_pointer;\n    typedef void              value_type;\n\n    template <class _Up> struct rebind {typedef allocator<_Up> other;};\n};\n\ntemplate <>\nclass _LIBCPP_TEMPLATE_VIS allocator<const void>\n{\npublic:\n    typedef const void*       pointer;\n    typedef const void*       const_pointer;\n    typedef const void        value_type;\n\n    template <class _Up> struct rebind {typedef allocator<_Up> other;};\n};\n\n// pointer_traits\n\ntemplate <class _Tp>\nstruct __has_element_type\n{\nprivate:\n    struct __two {char __lx; char __lxx;};\n    template <class _Up> static __two __test(...);\n    template <class _Up> static char __test(typename _Up::element_type* = 0);\npublic:\n    static const bool value = sizeof(__test<_Tp>(0)) == 1;\n};\n\ntemplate <class _Ptr, bool = __has_element_type<_Ptr>::value>\nstruct __pointer_traits_element_type;\n\ntemplate <class _Ptr>\nstruct __pointer_traits_element_type<_Ptr, true>\n{\n    typedef typename _Ptr::element_type type;\n};\n\n#ifndef _LIBCPP_HAS_NO_VARIADICS\n\ntemplate <template <class, class...> class _Sp, class _Tp, class ..._Args>\nstruct __pointer_traits_element_type<_Sp<_Tp, _Args...>, true>\n{\n    typedef typename _Sp<_Tp, _Args...>::element_type type;\n};\n\ntemplate <template <class, class...> class _Sp, class _Tp, class ..._Args>\nstruct __pointer_traits_element_type<_Sp<_Tp, _Args...>, false>\n{\n    typedef _Tp type;\n};\n\n#else  // _LIBCPP_HAS_NO_VARIADICS\n\ntemplate <template <class> class _Sp, class _Tp>\nstruct __pointer_traits_element_type<_Sp<_Tp>, true>\n{\n    typedef typename _Sp<_Tp>::element_type type;\n};\n\ntemplate <template <class> class _Sp, class _Tp>\nstruct __pointer_traits_element_type<_Sp<_Tp>, false>\n{\n    typedef _Tp type;\n};\n\ntemplate <template <class, class> class _Sp, class _Tp, class _A0>\nstruct __pointer_traits_element_type<_Sp<_Tp, _A0>, true>\n{\n    typedef typename _Sp<_Tp, _A0>::element_type type;\n};\n\ntemplate <template <class, class> class _Sp, class _Tp, class _A0>\nstruct __pointer_traits_element_type<_Sp<_Tp, _A0>, false>\n{\n    typedef _Tp type;\n};\n\ntemplate <template <class, class, class> class _Sp, class _Tp, class _A0, class _A1>\nstruct __pointer_traits_element_type<_Sp<_Tp, _A0, _A1>, true>\n{\n    typedef typename _Sp<_Tp, _A0, _A1>::element_type type;\n};\n\ntemplate <template <class, class, class> class _Sp, class _Tp, class _A0, class _A1>\nstruct __pointer_traits_element_type<_Sp<_Tp, _A0, _A1>, false>\n{\n    typedef _Tp type;\n};\n\ntemplate <template <class, class, class, class> class _Sp, class _Tp, class _A0,\n                                                           class _A1, class _A2>\nstruct __pointer_traits_element_type<_Sp<_Tp, _A0, _A1, _A2>, true>\n{\n    typedef typename _Sp<_Tp, _A0, _A1, _A2>::element_type type;\n};\n\ntemplate <template <class, class, class, class> class _Sp, class _Tp, class _A0,\n                                                           class _A1, class _A2>\nstruct __pointer_traits_element_type<_Sp<_Tp, _A0, _A1, _A2>, false>\n{\n    typedef _Tp type;\n};\n\n#endif  // _LIBCPP_HAS_NO_VARIADICS\n\ntemplate <class _Tp>\nstruct __has_difference_type\n{\nprivate:\n    struct __two {char __lx; char __lxx;};\n    template <class _Up> static __two __test(...);\n    template <class _Up> static char __test(typename _Up::difference_type* = 0);\npublic:\n    static const bool value = sizeof(__test<_Tp>(0)) == 1;\n};\n\ntemplate <class _Ptr, bool = __has_difference_type<_Ptr>::value>\nstruct __pointer_traits_difference_type\n{\n    typedef ptrdiff_t type;\n};\n\ntemplate <class _Ptr>\nstruct __pointer_traits_difference_type<_Ptr, true>\n{\n    typedef typename _Ptr::difference_type type;\n};\n\ntemplate <class _Tp, class _Up>\nstruct __has_rebind\n{\nprivate:\n    struct __two {char __lx; char __lxx;};\n    template <class _Xp> static __two __test(...);\n    template <class _Xp> static char __test(typename _Xp::template rebind<_Up>* = 0);\npublic:\n    static const bool value = sizeof(__test<_Tp>(0)) == 1;\n};\n\ntemplate <class _Tp, class _Up, bool = __has_rebind<_Tp, _Up>::value>\nstruct __pointer_traits_rebind\n{\n#ifndef _LIBCPP_CXX03_LANG\n    typedef typename _Tp::template rebind<_Up> type;\n#else\n    typedef typename _Tp::template rebind<_Up>::other type;\n#endif\n};\n\n#ifndef _LIBCPP_HAS_NO_VARIADICS\n\ntemplate <template <class, class...> class _Sp, class _Tp, class ..._Args, class _Up>\nstruct __pointer_traits_rebind<_Sp<_Tp, _Args...>, _Up, true>\n{\n#ifndef _LIBCPP_CXX03_LANG\n    typedef typename _Sp<_Tp, _Args...>::template rebind<_Up> type;\n#else\n    typedef typename _Sp<_Tp, _Args...>::template rebind<_Up>::other type;\n#endif\n};\n\ntemplate <template <class, class...> class _Sp, class _Tp, class ..._Args, class _Up>\nstruct __pointer_traits_rebind<_Sp<_Tp, _Args...>, _Up, false>\n{\n    typedef _Sp<_Up, _Args...> type;\n};\n\n#else  // _LIBCPP_HAS_NO_VARIADICS\n\ntemplate <template <class> class _Sp, class _Tp, class _Up>\nstruct __pointer_traits_rebind<_Sp<_Tp>, _Up, true>\n{\n#ifndef _LIBCPP_CXX03_LANG\n    typedef typename _Sp<_Tp>::template rebind<_Up> type;\n#else\n    typedef typename _Sp<_Tp>::template rebind<_Up>::other type;\n#endif\n};\n\ntemplate <template <class> class _Sp, class _Tp, class _Up>\nstruct __pointer_traits_rebind<_Sp<_Tp>, _Up, false>\n{\n    typedef _Sp<_Up> type;\n};\n\ntemplate <template <class, class> class _Sp, class _Tp, class _A0, class _Up>\nstruct __pointer_traits_rebind<_Sp<_Tp, _A0>, _Up, true>\n{\n#ifndef _LIBCPP_CXX03_LANG\n    typedef typename _Sp<_Tp, _A0>::template rebind<_Up> type;\n#else\n    typedef typename _Sp<_Tp, _A0>::template rebind<_Up>::other type;\n#endif\n};\n\ntemplate <template <class, class> class _Sp, class _Tp, class _A0, class _Up>\nstruct __pointer_traits_rebind<_Sp<_Tp, _A0>, _Up, false>\n{\n    typedef _Sp<_Up, _A0> type;\n};\n\ntemplate <template <class, class, class> class _Sp, class _Tp, class _A0,\n                                         class _A1, class _Up>\nstruct __pointer_traits_rebind<_Sp<_Tp, _A0, _A1>, _Up, true>\n{\n#ifndef _LIBCPP_CXX03_LANG\n    typedef typename _Sp<_Tp, _A0, _A1>::template rebind<_Up> type;\n#else\n    typedef typename _Sp<_Tp, _A0, _A1>::template rebind<_Up>::other type;\n#endif\n};\n\ntemplate <template <class, class, class> class _Sp, class _Tp, class _A0,\n                                         class _A1, class _Up>\nstruct __pointer_traits_rebind<_Sp<_Tp, _A0, _A1>, _Up, false>\n{\n    typedef _Sp<_Up, _A0, _A1> type;\n};\n\ntemplate <template <class, class, class, class> class _Sp, class _Tp, class _A0,\n                                                class _A1, class _A2, class _Up>\nstruct __pointer_traits_rebind<_Sp<_Tp, _A0, _A1, _A2>, _Up, true>\n{\n#ifndef _LIBCPP_CXX03_LANG\n    typedef typename _Sp<_Tp, _A0, _A1, _A2>::template rebind<_Up> type;\n#else\n    typedef typename _Sp<_Tp, _A0, _A1, _A2>::template rebind<_Up>::other type;\n#endif\n};\n\ntemplate <template <class, class, class, class> class _Sp, class _Tp, class _A0,\n                                                class _A1, class _A2, class _Up>\nstruct __pointer_traits_rebind<_Sp<_Tp, _A0, _A1, _A2>, _Up, false>\n{\n    typedef _Sp<_Up, _A0, _A1, _A2> type;\n};\n\n#endif  // _LIBCPP_HAS_NO_VARIADICS\n\ntemplate <class _Ptr>\nstruct _LIBCPP_TEMPLATE_VIS pointer_traits\n{\n    typedef _Ptr                                                     pointer;\n    typedef typename __pointer_traits_element_type<pointer>::type    element_type;\n    typedef typename __pointer_traits_difference_type<pointer>::type difference_type;\n\n#ifndef _LIBCPP_CXX03_LANG\n    template <class _Up> using rebind = typename __pointer_traits_rebind<pointer, _Up>::type;\n#else\n    template <class _Up> struct rebind\n        {typedef typename __pointer_traits_rebind<pointer, _Up>::type other;};\n#endif  // _LIBCPP_CXX03_LANG\n\nprivate:\n    struct __nat {};\npublic:\n    _LIBCPP_INLINE_VISIBILITY\n    static pointer pointer_to(typename conditional<is_void<element_type>::value,\n                                           __nat, element_type>::type& __r)\n        {return pointer::pointer_to(__r);}\n};\n\ntemplate <class _Tp>\nstruct _LIBCPP_TEMPLATE_VIS pointer_traits<_Tp*>\n{\n    typedef _Tp*      pointer;\n    typedef _Tp       element_type;\n    typedef ptrdiff_t difference_type;\n\n#ifndef _LIBCPP_CXX03_LANG\n    template <class _Up> using rebind = _Up*;\n#else\n    template <class _Up> struct rebind {typedef _Up* other;};\n#endif\n\nprivate:\n    struct __nat {};\npublic:\n    _LIBCPP_INLINE_VISIBILITY\n    static pointer pointer_to(typename conditional<is_void<element_type>::value,\n                                      __nat, element_type>::type& __r) _NOEXCEPT\n        {return _VSTD::addressof(__r);}\n};\n\ntemplate <class _From, class _To>\nstruct __rebind_pointer {\n#ifndef _LIBCPP_CXX03_LANG\n    typedef typename pointer_traits<_From>::template rebind<_To>        type;\n#else\n    typedef typename pointer_traits<_From>::template rebind<_To>::other type;\n#endif\n};\n\n// allocator_traits\n\nnamespace __has_pointer_type_imp\n{\n    template <class _Up> static __two __test(...);\n    template <class _Up> static char __test(typename _Up::pointer* = 0);\n}\n\ntemplate <class _Tp>\nstruct __has_pointer_type\n    : public integral_constant<bool, sizeof(__has_pointer_type_imp::__test<_Tp>(0)) == 1>\n{\n};\n\nnamespace __pointer_type_imp\n{\n\ntemplate <class _Tp, class _Dp, bool = __has_pointer_type<_Dp>::value>\nstruct __pointer_type\n{\n    typedef typename _Dp::pointer type;\n};\n\ntemplate <class _Tp, class _Dp>\nstruct __pointer_type<_Tp, _Dp, false>\n{\n    typedef _Tp* type;\n};\n\n}  // __pointer_type_imp\n\ntemplate <class _Tp, class _Dp>\nstruct __pointer_type\n{\n    typedef typename __pointer_type_imp::__pointer_type<_Tp, typename remove_reference<_Dp>::type>::type type;\n};\n\ntemplate <class _Tp>\nstruct __has_const_pointer\n{\nprivate:\n    struct __two {char __lx; char __lxx;};\n    template <class _Up> static __two __test(...);\n    template <class _Up> static char __test(typename _Up::const_pointer* = 0);\npublic:\n    static const bool value = sizeof(__test<_Tp>(0)) == 1;\n};\n\ntemplate <class _Tp, class _Ptr, class _Alloc, bool = __has_const_pointer<_Alloc>::value>\nstruct __const_pointer\n{\n    typedef typename _Alloc::const_pointer type;\n};\n\ntemplate <class _Tp, class _Ptr, class _Alloc>\nstruct __const_pointer<_Tp, _Ptr, _Alloc, false>\n{\n#ifndef _LIBCPP_CXX03_LANG\n    typedef typename pointer_traits<_Ptr>::template rebind<const _Tp> type;\n#else\n    typedef typename pointer_traits<_Ptr>::template rebind<const _Tp>::other type;\n#endif\n};\n\ntemplate <class _Tp>\nstruct __has_void_pointer\n{\nprivate:\n    struct __two {char __lx; char __lxx;};\n    template <class _Up> static __two __test(...);\n    template <class _Up> static char __test(typename _Up::void_pointer* = 0);\npublic:\n    static const bool value = sizeof(__test<_Tp>(0)) == 1;\n};\n\ntemplate <class _Ptr, class _Alloc, bool = __has_void_pointer<_Alloc>::value>\nstruct __void_pointer\n{\n    typedef typename _Alloc::void_pointer type;\n};\n\ntemplate <class _Ptr, class _Alloc>\nstruct __void_pointer<_Ptr, _Alloc, false>\n{\n#ifndef _LIBCPP_CXX03_LANG\n    typedef typename pointer_traits<_Ptr>::template rebind<void> type;\n#else\n    typedef typename pointer_traits<_Ptr>::template rebind<void>::other type;\n#endif\n};\n\ntemplate <class _Tp>\nstruct __has_const_void_pointer\n{\nprivate:\n    struct __two {char __lx; char __lxx;};\n    template <class _Up> static __two __test(...);\n    template <class _Up> static char __test(typename _Up::const_void_pointer* = 0);\npublic:\n    static const bool value = sizeof(__test<_Tp>(0)) == 1;\n};\n\ntemplate <class _Ptr, class _Alloc, bool = __has_const_void_pointer<_Alloc>::value>\nstruct __const_void_pointer\n{\n    typedef typename _Alloc::const_void_pointer type;\n};\n\ntemplate <class _Ptr, class _Alloc>\nstruct __const_void_pointer<_Ptr, _Alloc, false>\n{\n#ifndef _LIBCPP_CXX03_LANG\n    typedef typename pointer_traits<_Ptr>::template rebind<const void> type;\n#else\n    typedef typename pointer_traits<_Ptr>::template rebind<const void>::other type;\n#endif\n};\n\ntemplate <class _Tp>\ninline _LIBCPP_INLINE_VISIBILITY\n_Tp*\n__to_raw_pointer(_Tp* __p) _NOEXCEPT\n{\n    return __p;\n}\n\ntemplate <class _Pointer>\ninline _LIBCPP_INLINE_VISIBILITY\ntypename pointer_traits<_Pointer>::element_type*\n__to_raw_pointer(_Pointer __p) _NOEXCEPT\n{\n    return _VSTD::__to_raw_pointer(__p.operator->());\n}\n\ntemplate <class _Tp>\nstruct __has_size_type\n{\nprivate:\n    struct __two {char __lx; char __lxx;};\n    template <class _Up> static __two __test(...);\n    template <class _Up> static char __test(typename _Up::size_type* = 0);\npublic:\n    static const bool value = sizeof(__test<_Tp>(0)) == 1;\n};\n\ntemplate <class _Alloc, class _DiffType, bool = __has_size_type<_Alloc>::value>\nstruct __size_type\n{\n    typedef typename make_unsigned<_DiffType>::type type;\n};\n\ntemplate <class _Alloc, class _DiffType>\nstruct __size_type<_Alloc, _DiffType, true>\n{\n    typedef typename _Alloc::size_type type;\n};\n\ntemplate <class _Tp>\nstruct __has_propagate_on_container_copy_assignment\n{\nprivate:\n    struct __two {char __lx; char __lxx;};\n    template <class _Up> static __two __test(...);\n    template <class _Up> static char __test(typename _Up::propagate_on_container_copy_assignment* = 0);\npublic:\n    static const bool value = sizeof(__test<_Tp>(0)) == 1;\n};\n\ntemplate <class _Alloc, bool = __has_propagate_on_container_copy_assignment<_Alloc>::value>\nstruct __propagate_on_container_copy_assignment\n{\n    typedef false_type type;\n};\n\ntemplate <class _Alloc>\nstruct __propagate_on_container_copy_assignment<_Alloc, true>\n{\n    typedef typename _Alloc::propagate_on_container_copy_assignment type;\n};\n\ntemplate <class _Tp>\nstruct __has_propagate_on_container_move_assignment\n{\nprivate:\n    struct __two {char __lx; char __lxx;};\n    template <class _Up> static __two __test(...);\n    template <class _Up> static char __test(typename _Up::propagate_on_container_move_assignment* = 0);\npublic:\n    static const bool value = sizeof(__test<_Tp>(0)) == 1;\n};\n\ntemplate <class _Alloc, bool = __has_propagate_on_container_move_assignment<_Alloc>::value>\nstruct __propagate_on_container_move_assignment\n{\n    typedef false_type type;\n};\n\ntemplate <class _Alloc>\nstruct __propagate_on_container_move_assignment<_Alloc, true>\n{\n    typedef typename _Alloc::propagate_on_container_move_assignment type;\n};\n\ntemplate <class _Tp>\nstruct __has_propagate_on_container_swap\n{\nprivate:\n    struct __two {char __lx; char __lxx;};\n    template <class _Up> static __two __test(...);\n    template <class _Up> static char __test(typename _Up::propagate_on_container_swap* = 0);\npublic:\n    static const bool value = sizeof(__test<_Tp>(0)) == 1;\n};\n\ntemplate <class _Alloc, bool = __has_propagate_on_container_swap<_Alloc>::value>\nstruct __propagate_on_container_swap\n{\n    typedef false_type type;\n};\n\ntemplate <class _Alloc>\nstruct __propagate_on_container_swap<_Alloc, true>\n{\n    typedef typename _Alloc::propagate_on_container_swap type;\n};\n\ntemplate <class _Tp>\nstruct __has_is_always_equal\n{\nprivate:\n    struct __two {char __lx; char __lxx;};\n    template <class _Up> static __two __test(...);\n    template <class _Up> static char __test(typename _Up::is_always_equal* = 0);\npublic:\n    static const bool value = sizeof(__test<_Tp>(0)) == 1;\n};\n\ntemplate <class _Alloc, bool = __has_is_always_equal<_Alloc>::value>\nstruct __is_always_equal\n{\n    typedef typename _VSTD::is_empty<_Alloc>::type type;\n};\n\ntemplate <class _Alloc>\nstruct __is_always_equal<_Alloc, true>\n{\n    typedef typename _Alloc::is_always_equal type;\n};\n\ntemplate <class _Tp, class _Up, bool = __has_rebind<_Tp, _Up>::value>\nstruct __has_rebind_other\n{\nprivate:\n    struct __two {char __lx; char __lxx;};\n    template <class _Xp> static __two __test(...);\n    template <class _Xp> static char __test(typename _Xp::template rebind<_Up>::other* = 0);\npublic:\n    static const bool value = sizeof(__test<_Tp>(0)) == 1;\n};\n\ntemplate <class _Tp, class _Up>\nstruct __has_rebind_other<_Tp, _Up, false>\n{\n    static const bool value = false;\n};\n\ntemplate <class _Tp, class _Up, bool = __has_rebind_other<_Tp, _Up>::value>\nstruct __allocator_traits_rebind\n{\n    typedef typename _Tp::template rebind<_Up>::other type;\n};\n\n#ifndef _LIBCPP_HAS_NO_VARIADICS\n\ntemplate <template <class, class...> class _Alloc, class _Tp, class ..._Args, class _Up>\nstruct __allocator_traits_rebind<_Alloc<_Tp, _Args...>, _Up, true>\n{\n    typedef typename _Alloc<_Tp, _Args...>::template rebind<_Up>::other type;\n};\n\ntemplate <template <class, class...> class _Alloc, class _Tp, class ..._Args, class _Up>\nstruct __allocator_traits_rebind<_Alloc<_Tp, _Args...>, _Up, false>\n{\n    typedef _Alloc<_Up, _Args...> type;\n};\n\n#else  // _LIBCPP_HAS_NO_VARIADICS\n\ntemplate <template <class> class _Alloc, class _Tp, class _Up>\nstruct __allocator_traits_rebind<_Alloc<_Tp>, _Up, true>\n{\n    typedef typename _Alloc<_Tp>::template rebind<_Up>::other type;\n};\n\ntemplate <template <class> class _Alloc, class _Tp, class _Up>\nstruct __allocator_traits_rebind<_Alloc<_Tp>, _Up, false>\n{\n    typedef _Alloc<_Up> type;\n};\n\ntemplate <template <class, class> class _Alloc, class _Tp, class _A0, class _Up>\nstruct __allocator_traits_rebind<_Alloc<_Tp, _A0>, _Up, true>\n{\n    typedef typename _Alloc<_Tp, _A0>::template rebind<_Up>::other type;\n};\n\ntemplate <template <class, class> class _Alloc, class _Tp, class _A0, class _Up>\nstruct __allocator_traits_rebind<_Alloc<_Tp, _A0>, _Up, false>\n{\n    typedef _Alloc<_Up, _A0> type;\n};\n\ntemplate <template <class, class, class> class _Alloc, class _Tp, class _A0,\n                                         class _A1, class _Up>\nstruct __allocator_traits_rebind<_Alloc<_Tp, _A0, _A1>, _Up, true>\n{\n    typedef typename _Alloc<_Tp, _A0, _A1>::template rebind<_Up>::other type;\n};\n\ntemplate <template <class, class, class> class _Alloc, class _Tp, class _A0,\n                                         class _A1, class _Up>\nstruct __allocator_traits_rebind<_Alloc<_Tp, _A0, _A1>, _Up, false>\n{\n    typedef _Alloc<_Up, _A0, _A1> type;\n};\n\ntemplate <template <class, class, class, class> class _Alloc, class _Tp, class _A0,\n                                                class _A1, class _A2, class _Up>\nstruct __allocator_traits_rebind<_Alloc<_Tp, _A0, _A1, _A2>, _Up, true>\n{\n    typedef typename _Alloc<_Tp, _A0, _A1, _A2>::template rebind<_Up>::other type;\n};\n\ntemplate <template <class, class, class, class> class _Alloc, class _Tp, class _A0,\n                                                class _A1, class _A2, class _Up>\nstruct __allocator_traits_rebind<_Alloc<_Tp, _A0, _A1, _A2>, _Up, false>\n{\n    typedef _Alloc<_Up, _A0, _A1, _A2> type;\n};\n\n#endif  // _LIBCPP_HAS_NO_VARIADICS\n\n#ifndef _LIBCPP_CXX03_LANG\n\ntemplate <class _Alloc, class _SizeType, class _ConstVoidPtr>\nauto\n__has_allocate_hint_test(_Alloc&& __a, _SizeType&& __sz, _ConstVoidPtr&& __p)\n    -> decltype(__a.allocate(__sz, __p), true_type());\n\ntemplate <class _Alloc, class _SizeType, class _ConstVoidPtr>\nauto\n__has_allocate_hint_test(const _Alloc& __a, _SizeType&& __sz, _ConstVoidPtr&& __p)\n    -> false_type;\n\ntemplate <class _Alloc, class _SizeType, class _ConstVoidPtr>\nstruct __has_allocate_hint\n    : integral_constant<bool,\n        is_same<\n            decltype(__has_allocate_hint_test(declval<_Alloc>(),\n                                          declval<_SizeType>(),\n                                          declval<_ConstVoidPtr>())),\n            true_type>::value>\n{\n};\n\n#else  // _LIBCPP_CXX03_LANG\n\ntemplate <class _Alloc, class _SizeType, class _ConstVoidPtr>\nstruct __has_allocate_hint\n    : true_type\n{\n};\n\n#endif  // _LIBCPP_CXX03_LANG\n\n#if !defined(_LIBCPP_CXX03_LANG)\n\ntemplate <class _Alloc, class _Tp, class ..._Args>\ndecltype(_VSTD::declval<_Alloc>().construct(_VSTD::declval<_Tp*>(),\n                                           _VSTD::declval<_Args>()...),\n                                           true_type())\n__has_construct_test(_Alloc&& __a, _Tp* __p, _Args&& ...__args);\n\ntemplate <class _Alloc, class _Pointer, class ..._Args>\nfalse_type\n__has_construct_test(const _Alloc& __a, _Pointer&& __p, _Args&& ...__args);\n\ntemplate <class _Alloc, class _Pointer, class ..._Args>\nstruct __has_construct\n    : integral_constant<bool,\n        is_same<\n            decltype(__has_construct_test(declval<_Alloc>(),\n                                          declval<_Pointer>(),\n                                          declval<_Args>()...)),\n            true_type>::value>\n{\n};\n\ntemplate <class _Alloc, class _Pointer>\nauto\n__has_destroy_test(_Alloc&& __a, _Pointer&& __p)\n    -> decltype(__a.destroy(__p), true_type());\n\ntemplate <class _Alloc, class _Pointer>\nauto\n__has_destroy_test(const _Alloc& __a, _Pointer&& __p)\n    -> false_type;\n\ntemplate <class _Alloc, class _Pointer>\nstruct __has_destroy\n    : integral_constant<bool,\n        is_same<\n            decltype(__has_destroy_test(declval<_Alloc>(),\n                                        declval<_Pointer>())),\n            true_type>::value>\n{\n};\n\ntemplate <class _Alloc>\nauto\n__has_max_size_test(_Alloc&& __a)\n    -> decltype(__a.max_size(), true_type());\n\ntemplate <class _Alloc>\nauto\n__has_max_size_test(const volatile _Alloc& __a)\n    -> false_type;\n\ntemplate <class _Alloc>\nstruct __has_max_size\n    : integral_constant<bool,\n        is_same<\n            decltype(__has_max_size_test(declval<_Alloc&>())),\n            true_type>::value>\n{\n};\n\ntemplate <class _Alloc>\nauto\n__has_select_on_container_copy_construction_test(_Alloc&& __a)\n    -> decltype(__a.select_on_container_copy_construction(), true_type());\n\ntemplate <class _Alloc>\nauto\n__has_select_on_container_copy_construction_test(const volatile _Alloc& __a)\n    -> false_type;\n\ntemplate <class _Alloc>\nstruct __has_select_on_container_copy_construction\n    : integral_constant<bool,\n        is_same<\n            decltype(__has_select_on_container_copy_construction_test(declval<_Alloc&>())),\n            true_type>::value>\n{\n};\n\n#else  // _LIBCPP_CXX03_LANG\n\n#ifndef _LIBCPP_HAS_NO_VARIADICS\n\ntemplate <class _Alloc, class _Pointer, class ..._Args>\nstruct __has_construct\n    : false_type\n{\n};\n\n#else  // _LIBCPP_HAS_NO_VARIADICS\n\ntemplate <class _Alloc, class _Pointer, class _Args>\nstruct __has_construct\n    : false_type\n{\n};\n\n#endif  // _LIBCPP_HAS_NO_VARIADICS\n\ntemplate <class _Alloc, class _Pointer>\nstruct __has_destroy\n    : false_type\n{\n};\n\ntemplate <class _Alloc>\nstruct __has_max_size\n    : true_type\n{\n};\n\ntemplate <class _Alloc>\nstruct __has_select_on_container_copy_construction\n    : false_type\n{\n};\n\n#endif  // _LIBCPP_CXX03_LANG\n\ntemplate <class _Alloc, class _Ptr, bool = __has_difference_type<_Alloc>::value>\nstruct __alloc_traits_difference_type\n{\n    typedef typename pointer_traits<_Ptr>::difference_type type;\n};\n\ntemplate <class _Alloc, class _Ptr>\nstruct __alloc_traits_difference_type<_Alloc, _Ptr, true>\n{\n    typedef typename _Alloc::difference_type type;\n};\n\ntemplate <class _Alloc>\nstruct _LIBCPP_TEMPLATE_VIS allocator_traits\n{\n    typedef _Alloc                              allocator_type;\n    typedef typename allocator_type::value_type value_type;\n\n    typedef typename __pointer_type<value_type, allocator_type>::type pointer;\n    typedef typename __const_pointer<value_type, pointer, allocator_type>::type const_pointer;\n    typedef typename __void_pointer<pointer, allocator_type>::type void_pointer;\n    typedef typename __const_void_pointer<pointer, allocator_type>::type const_void_pointer;\n\n    typedef typename __alloc_traits_difference_type<allocator_type, pointer>::type difference_type;\n    typedef typename __size_type<allocator_type, difference_type>::type size_type;\n\n    typedef typename __propagate_on_container_copy_assignment<allocator_type>::type\n                     propagate_on_container_copy_assignment;\n    typedef typename __propagate_on_container_move_assignment<allocator_type>::type\n                     propagate_on_container_move_assignment;\n    typedef typename __propagate_on_container_swap<allocator_type>::type\n                     propagate_on_container_swap;\n    typedef typename __is_always_equal<allocator_type>::type\n                     is_always_equal;\n\n#ifndef _LIBCPP_CXX03_LANG\n    template <class _Tp> using rebind_alloc =\n                  typename __allocator_traits_rebind<allocator_type, _Tp>::type;\n    template <class _Tp> using rebind_traits = allocator_traits<rebind_alloc<_Tp>>;\n#else  // _LIBCPP_CXX03_LANG\n    template <class _Tp> struct rebind_alloc\n        {typedef typename __allocator_traits_rebind<allocator_type, _Tp>::type other;};\n    template <class _Tp> struct rebind_traits\n        {typedef allocator_traits<typename rebind_alloc<_Tp>::other> other;};\n#endif  // _LIBCPP_CXX03_LANG\n\n    _LIBCPP_INLINE_VISIBILITY\n    static pointer allocate(allocator_type& __a, size_type __n)\n        {return __a.allocate(__n);}\n    _LIBCPP_INLINE_VISIBILITY\n    static pointer allocate(allocator_type& __a, size_type __n, const_void_pointer __hint)\n        {return allocate(__a, __n, __hint,\n            __has_allocate_hint<allocator_type, size_type, const_void_pointer>());}\n\n    _LIBCPP_INLINE_VISIBILITY\n    static void deallocate(allocator_type& __a, pointer __p, size_type __n) _NOEXCEPT\n        {__a.deallocate(__p, __n);}\n\n#ifndef _LIBCPP_HAS_NO_VARIADICS\n    template <class _Tp, class... _Args>\n        _LIBCPP_INLINE_VISIBILITY\n        static void construct(allocator_type& __a, _Tp* __p, _Args&&... __args)\n            {__construct(__has_construct<allocator_type, _Tp*, _Args...>(),\n                         __a, __p, _VSTD::forward<_Args>(__args)...);}\n#else  // _LIBCPP_HAS_NO_VARIADICS\n    template <class _Tp>\n        _LIBCPP_INLINE_VISIBILITY\n        static void construct(allocator_type& __a, _Tp* __p)\n            {\n                ::new ((void*)__p) _Tp();\n            }\n    template <class _Tp, class _A0>\n        _LIBCPP_INLINE_VISIBILITY\n        static void construct(allocator_type& __a, _Tp* __p, const _A0& __a0)\n            {\n                ::new ((void*)__p) _Tp(__a0);\n            }\n    template <class _Tp, class _A0, class _A1>\n        _LIBCPP_INLINE_VISIBILITY\n        static void construct(allocator_type& __a, _Tp* __p, const _A0& __a0,\n                              const _A1& __a1)\n            {\n                ::new ((void*)__p) _Tp(__a0, __a1);\n            }\n    template <class _Tp, class _A0, class _A1, class _A2>\n        _LIBCPP_INLINE_VISIBILITY\n        static void construct(allocator_type& __a, _Tp* __p, const _A0& __a0,\n                              const _A1& __a1, const _A2& __a2)\n            {\n                ::new ((void*)__p) _Tp(__a0, __a1, __a2);\n            }\n#endif  // _LIBCPP_HAS_NO_VARIADICS\n\n    template <class _Tp>\n        _LIBCPP_INLINE_VISIBILITY\n        static void destroy(allocator_type& __a, _Tp* __p)\n            {__destroy(__has_destroy<allocator_type, _Tp*>(), __a, __p);}\n\n    _LIBCPP_INLINE_VISIBILITY\n    static size_type max_size(const allocator_type& __a) _NOEXCEPT\n        {return __max_size(__has_max_size<const allocator_type>(), __a);}\n\n    _LIBCPP_INLINE_VISIBILITY\n    static allocator_type\n        select_on_container_copy_construction(const allocator_type& __a)\n            {return select_on_container_copy_construction(\n                __has_select_on_container_copy_construction<const allocator_type>(),\n                __a);}\n\n    template <class _Ptr>\n        _LIBCPP_INLINE_VISIBILITY\n        static\n        void\n        __construct_forward(allocator_type& __a, _Ptr __begin1, _Ptr __end1, _Ptr& __begin2)\n        {\n            for (; __begin1 != __end1; ++__begin1, ++__begin2)\n                construct(__a, _VSTD::__to_raw_pointer(__begin2), _VSTD::move_if_noexcept(*__begin1));\n        }\n\n    template <class _Tp>\n        _LIBCPP_INLINE_VISIBILITY\n        static\n        typename enable_if\n        <\n            (is_same<allocator_type, allocator<_Tp> >::value\n                || !__has_construct<allocator_type, _Tp*, _Tp>::value) &&\n             is_trivially_move_constructible<_Tp>::value,\n            void\n        >::type\n        __construct_forward(allocator_type&, _Tp* __begin1, _Tp* __end1, _Tp*& __begin2)\n        {\n            ptrdiff_t _Np = __end1 - __begin1;\n            if (_Np > 0)\n            {\n                _VSTD::memcpy(__begin2, __begin1, _Np * sizeof(_Tp));\n                __begin2 += _Np;\n            }\n        }\n\n    template <class _Iter, class _Ptr>\n        _LIBCPP_INLINE_VISIBILITY\n        static\n        void\n        __construct_range_forward(allocator_type& __a, _Iter __begin1, _Iter __end1, _Ptr& __begin2)\n        {\n            for (; __begin1 != __end1; ++__begin1, (void) ++__begin2)\n                construct(__a, _VSTD::__to_raw_pointer(__begin2), *__begin1);\n        }\n\n    template <class _Tp>\n        _LIBCPP_INLINE_VISIBILITY\n        static\n        typename enable_if\n        <\n            (is_same<allocator_type, allocator<_Tp> >::value\n                || !__has_construct<allocator_type, _Tp*, _Tp>::value) &&\n             is_trivially_move_constructible<_Tp>::value,\n            void\n        >::type\n        __construct_range_forward(allocator_type&, _Tp* __begin1, _Tp* __end1, _Tp*& __begin2)\n        {\n            typedef typename remove_const<_Tp>::type _Vp;\n            ptrdiff_t _Np = __end1 - __begin1;\n            if (_Np > 0)\n            {\n                _VSTD::memcpy(const_cast<_Vp*>(__begin2), __begin1, _Np * sizeof(_Tp));\n                __begin2 += _Np;\n            }\n        }\n\n    template <class _Ptr>\n        _LIBCPP_INLINE_VISIBILITY\n        static\n        void\n        __construct_backward(allocator_type& __a, _Ptr __begin1, _Ptr __end1, _Ptr& __end2)\n        {\n            while (__end1 != __begin1)\n            {\n                construct(__a, _VSTD::__to_raw_pointer(__end2-1), _VSTD::move_if_noexcept(*--__end1));\n                --__end2;\n            }\n        }\n\n    template <class _Tp>\n        _LIBCPP_INLINE_VISIBILITY\n        static\n        typename enable_if\n        <\n            (is_same<allocator_type, allocator<_Tp> >::value\n                || !__has_construct<allocator_type, _Tp*, _Tp>::value) &&\n             is_trivially_move_constructible<_Tp>::value,\n            void\n        >::type\n        __construct_backward(allocator_type&, _Tp* __begin1, _Tp* __end1, _Tp*& __end2)\n        {\n            ptrdiff_t _Np = __end1 - __begin1;\n            __end2 -= _Np;\n            if (_Np > 0)\n                _VSTD::memcpy(__end2, __begin1, _Np * sizeof(_Tp));\n        }\n\nprivate:\n\n    _LIBCPP_INLINE_VISIBILITY\n    static pointer allocate(allocator_type& __a, size_type __n,\n        const_void_pointer __hint, true_type)\n        {return __a.allocate(__n, __hint);}\n    _LIBCPP_INLINE_VISIBILITY\n    static pointer allocate(allocator_type& __a, size_type __n,\n        const_void_pointer, false_type)\n        {return __a.allocate(__n);}\n\n#ifndef _LIBCPP_HAS_NO_VARIADICS\n    template <class _Tp, class... _Args>\n        _LIBCPP_INLINE_VISIBILITY\n        static void __construct(true_type, allocator_type& __a, _Tp* __p, _Args&&... __args)\n            {__a.construct(__p, _VSTD::forward<_Args>(__args)...);}\n    template <class _Tp, class... _Args>\n        _LIBCPP_INLINE_VISIBILITY\n        static void __construct(false_type, allocator_type&, _Tp* __p, _Args&&... __args)\n            {\n                ::new ((void*)__p) _Tp(_VSTD::forward<_Args>(__args)...);\n            }\n#endif  // _LIBCPP_HAS_NO_VARIADICS\n\n    template <class _Tp>\n        _LIBCPP_INLINE_VISIBILITY\n        static void __destroy(true_type, allocator_type& __a, _Tp* __p)\n            {__a.destroy(__p);}\n    template <class _Tp>\n        _LIBCPP_INLINE_VISIBILITY\n        static void __destroy(false_type, allocator_type&, _Tp* __p)\n            {\n                __p->~_Tp();\n            }\n\n    _LIBCPP_INLINE_VISIBILITY\n    static size_type __max_size(true_type, const allocator_type& __a)\n            {return __a.max_size();}\n    _LIBCPP_INLINE_VISIBILITY\n    static size_type __max_size(false_type, const allocator_type&)\n            {return numeric_limits<size_type>::max() / sizeof(value_type);}\n\n    _LIBCPP_INLINE_VISIBILITY\n    static allocator_type\n        select_on_container_copy_construction(true_type, const allocator_type& __a)\n            {return __a.select_on_container_copy_construction();}\n    _LIBCPP_INLINE_VISIBILITY\n    static allocator_type\n        select_on_container_copy_construction(false_type, const allocator_type& __a)\n            {return __a;}\n};\n\ntemplate <class _Traits, class _Tp>\nstruct __rebind_alloc_helper\n{\n#ifndef _LIBCPP_CXX03_LANG\n    typedef typename _Traits::template rebind_alloc<_Tp>        type;\n#else\n    typedef typename _Traits::template rebind_alloc<_Tp>::other type;\n#endif\n};\n\n// allocator\n\ntemplate <class _Tp>\nclass _LIBCPP_TEMPLATE_VIS allocator\n{\npublic:\n    typedef size_t            size_type;\n    typedef ptrdiff_t         difference_type;\n    typedef _Tp*              pointer;\n    typedef const _Tp*        const_pointer;\n    typedef _Tp&              reference;\n    typedef const _Tp&        const_reference;\n    typedef _Tp               value_type;\n\n    typedef true_type propagate_on_container_move_assignment;\n    typedef true_type is_always_equal;\n\n    template <class _Up> struct rebind {typedef allocator<_Up> other;};\n\n    _LIBCPP_INLINE_VISIBILITY allocator() _NOEXCEPT {}\n    template <class _Up> _LIBCPP_INLINE_VISIBILITY allocator(const allocator<_Up>&) _NOEXCEPT {}\n    _LIBCPP_INLINE_VISIBILITY pointer address(reference __x) const _NOEXCEPT\n        {return _VSTD::addressof(__x);}\n    _LIBCPP_INLINE_VISIBILITY const_pointer address(const_reference __x) const _NOEXCEPT\n        {return _VSTD::addressof(__x);}\n    _LIBCPP_INLINE_VISIBILITY pointer allocate(size_type __n, allocator<void>::const_pointer = 0)\n        {\n        if (__n > max_size())\n            __throw_length_error(\"allocator<T>::allocate(size_t n)\"\n                                 \" 'n' exceeds maximum supported size\");\n        return static_cast<pointer>(_VSTD::__allocate(__n * sizeof(_Tp)));\n        }\n    _LIBCPP_INLINE_VISIBILITY void deallocate(pointer __p, size_type) _NOEXCEPT\n        {_VSTD::__libcpp_deallocate((void*)__p);}\n    _LIBCPP_INLINE_VISIBILITY size_type max_size() const _NOEXCEPT\n        {return size_type(~0) / sizeof(_Tp);}\n#if !defined(_LIBCPP_HAS_NO_RVALUE_REFERENCES) && !defined(_LIBCPP_HAS_NO_VARIADICS)\n    template <class _Up, class... _Args>\n        _LIBCPP_INLINE_VISIBILITY\n        void\n        construct(_Up* __p, _Args&&... __args)\n        {\n            ::new((void*)__p) _Up(_VSTD::forward<_Args>(__args)...);\n        }\n#else  // !defined(_LIBCPP_HAS_NO_RVALUE_REFERENCES) && !defined(_LIBCPP_HAS_NO_VARIADICS)\n        _LIBCPP_INLINE_VISIBILITY\n        void\n        construct(pointer __p)\n        {\n            ::new((void*)__p) _Tp();\n        }\n# if defined(_LIBCPP_HAS_NO_RVALUE_REFERENCES)\n\n    template <class _A0>\n        _LIBCPP_INLINE_VISIBILITY\n        void\n        construct(pointer __p, _A0& __a0)\n        {\n            ::new((void*)__p) _Tp(__a0);\n        }\n    template <class _A0>\n        _LIBCPP_INLINE_VISIBILITY\n        void\n        construct(pointer __p, const _A0& __a0)\n        {\n            ::new((void*)__p) _Tp(__a0);\n        }\n# endif  // defined(_LIBCPP_HAS_NO_RVALUE_REFERENCES)\n    template <class _A0, class _A1>\n        _LIBCPP_INLINE_VISIBILITY\n        void\n        construct(pointer __p, _A0& __a0, _A1& __a1)\n        {\n            ::new((void*)__p) _Tp(__a0, __a1);\n        }\n    template <class _A0, class _A1>\n        _LIBCPP_INLINE_VISIBILITY\n        void\n        construct(pointer __p, const _A0& __a0, _A1& __a1)\n        {\n            ::new((void*)__p) _Tp(__a0, __a1);\n        }\n    template <class _A0, class _A1>\n        _LIBCPP_INLINE_VISIBILITY\n        void\n        construct(pointer __p, _A0& __a0, const _A1& __a1)\n        {\n            ::new((void*)__p) _Tp(__a0, __a1);\n        }\n    template <class _A0, class _A1>\n        _LIBCPP_INLINE_VISIBILITY\n        void\n        construct(pointer __p, const _A0& __a0, const _A1& __a1)\n        {\n            ::new((void*)__p) _Tp(__a0, __a1);\n        }\n#endif  // !defined(_LIBCPP_HAS_NO_RVALUE_REFERENCES) && !defined(_LIBCPP_HAS_NO_VARIADICS)\n    _LIBCPP_INLINE_VISIBILITY void destroy(pointer __p) {__p->~_Tp();}\n};\n\ntemplate <class _Tp>\nclass _LIBCPP_TEMPLATE_VIS allocator<const _Tp>\n{\npublic:\n    typedef size_t            size_type;\n    typedef ptrdiff_t         difference_type;\n    typedef const _Tp*        pointer;\n    typedef const _Tp*        const_pointer;\n    typedef const _Tp&        reference;\n    typedef const _Tp&        const_reference;\n    typedef const _Tp         value_type;\n\n    typedef true_type propagate_on_container_move_assignment;\n    typedef true_type is_always_equal;\n\n    template <class _Up> struct rebind {typedef allocator<_Up> other;};\n\n    _LIBCPP_INLINE_VISIBILITY allocator() _NOEXCEPT {}\n    template <class _Up> _LIBCPP_INLINE_VISIBILITY allocator(const allocator<_Up>&) _NOEXCEPT {}\n    _LIBCPP_INLINE_VISIBILITY const_pointer address(const_reference __x) const _NOEXCEPT\n        {return _VSTD::addressof(__x);}\n    _LIBCPP_INLINE_VISIBILITY pointer allocate(size_type __n, allocator<void>::const_pointer = 0)\n    {\n        if (__n > max_size())\n            __throw_length_error(\"allocator<const T>::allocate(size_t n)\"\n                                 \" 'n' exceeds maximum supported size\");\n        return static_cast<pointer>(_VSTD::__allocate(__n * sizeof(_Tp)));\n    }\n    _LIBCPP_INLINE_VISIBILITY void deallocate(pointer __p, size_type) _NOEXCEPT\n        {_VSTD::__libcpp_deallocate((void*)__p);}\n    _LIBCPP_INLINE_VISIBILITY size_type max_size() const _NOEXCEPT\n        {return size_type(~0) / sizeof(_Tp);}\n#if !defined(_LIBCPP_HAS_NO_RVALUE_REFERENCES) && !defined(_LIBCPP_HAS_NO_VARIADICS)\n    template <class _Up, class... _Args>\n        _LIBCPP_INLINE_VISIBILITY\n        void\n        construct(_Up* __p, _Args&&... __args)\n        {\n            ::new((void*)__p) _Up(_VSTD::forward<_Args>(__args)...);\n        }\n#else  // !defined(_LIBCPP_HAS_NO_RVALUE_REFERENCES) && !defined(_LIBCPP_HAS_NO_VARIADICS)\n        _LIBCPP_INLINE_VISIBILITY\n        void\n        construct(pointer __p)\n        {\n            ::new((void*)__p) _Tp();\n        }\n# if defined(_LIBCPP_HAS_NO_RVALUE_REFERENCES)\n\n    template <class _A0>\n        _LIBCPP_INLINE_VISIBILITY\n        void\n        construct(pointer __p, _A0& __a0)\n        {\n            ::new((void*)__p) _Tp(__a0);\n        }\n    template <class _A0>\n        _LIBCPP_INLINE_VISIBILITY\n        void\n        construct(pointer __p, const _A0& __a0)\n        {\n            ::new((void*)__p) _Tp(__a0);\n        }\n# endif  // defined(_LIBCPP_HAS_NO_RVALUE_REFERENCES)\n    template <class _A0, class _A1>\n        _LIBCPP_INLINE_VISIBILITY\n        void\n        construct(pointer __p, _A0& __a0, _A1& __a1)\n        {\n            ::new((void*)__p) _Tp(__a0, __a1);\n        }\n    template <class _A0, class _A1>\n        _LIBCPP_INLINE_VISIBILITY\n        void\n        construct(pointer __p, const _A0& __a0, _A1& __a1)\n        {\n            ::new((void*)__p) _Tp(__a0, __a1);\n        }\n    template <class _A0, class _A1>\n        _LIBCPP_INLINE_VISIBILITY\n        void\n        construct(pointer __p, _A0& __a0, const _A1& __a1)\n        {\n            ::new((void*)__p) _Tp(__a0, __a1);\n        }\n    template <class _A0, class _A1>\n        _LIBCPP_INLINE_VISIBILITY\n        void\n        construct(pointer __p, const _A0& __a0, const _A1& __a1)\n        {\n            ::new((void*)__p) _Tp(__a0, __a1);\n        }\n#endif  // !defined(_LIBCPP_HAS_NO_RVALUE_REFERENCES) && !defined(_LIBCPP_HAS_NO_VARIADICS)\n    _LIBCPP_INLINE_VISIBILITY void destroy(pointer __p) {__p->~_Tp();}\n};\n\ntemplate <class _Tp, class _Up>\ninline _LIBCPP_INLINE_VISIBILITY\nbool operator==(const allocator<_Tp>&, const allocator<_Up>&) _NOEXCEPT {return true;}\n\ntemplate <class _Tp, class _Up>\ninline _LIBCPP_INLINE_VISIBILITY\nbool operator!=(const allocator<_Tp>&, const allocator<_Up>&) _NOEXCEPT {return false;}\n\ntemplate <class _OutputIterator, class _Tp>\nclass _LIBCPP_TEMPLATE_VIS raw_storage_iterator\n    : public iterator<output_iterator_tag,\n                      _Tp,                                         // purposefully not C++03\n                      ptrdiff_t,                                   // purposefully not C++03\n                      _Tp*,                                        // purposefully not C++03\n                      raw_storage_iterator<_OutputIterator, _Tp>&> // purposefully not C++03\n{\nprivate:\n    _OutputIterator __x_;\npublic:\n    _LIBCPP_INLINE_VISIBILITY explicit raw_storage_iterator(_OutputIterator __x) : __x_(__x) {}\n    _LIBCPP_INLINE_VISIBILITY raw_storage_iterator& operator*() {return *this;}\n    _LIBCPP_INLINE_VISIBILITY raw_storage_iterator& operator=(const _Tp& __element)\n        {::new(&*__x_) _Tp(__element); return *this;}\n#if _LIBCPP_STD_VER >= 14\n    _LIBCPP_INLINE_VISIBILITY raw_storage_iterator& operator=(_Tp&& __element)\n        {::new(&*__x_) _Tp(_VSTD::move(__element)); return *this;}\n#endif\n    _LIBCPP_INLINE_VISIBILITY raw_storage_iterator& operator++() {++__x_; return *this;}\n    _LIBCPP_INLINE_VISIBILITY raw_storage_iterator  operator++(int)\n        {raw_storage_iterator __t(*this); ++__x_; return __t;}\n#if _LIBCPP_STD_VER >= 14\n    _LIBCPP_INLINE_VISIBILITY _OutputIterator base() const { return __x_; } \n#endif\n};\n\ntemplate <class _Tp>\npair<_Tp*, ptrdiff_t>\nget_temporary_buffer(ptrdiff_t __n) _NOEXCEPT\n{\n    pair<_Tp*, ptrdiff_t> __r(0, 0);\n    const ptrdiff_t __m = (~ptrdiff_t(0) ^\n                           ptrdiff_t(ptrdiff_t(1) << (sizeof(ptrdiff_t) * __CHAR_BIT__ - 1)))\n                           / sizeof(_Tp);\n    if (__n > __m)\n        __n = __m;\n    while (__n > 0)\n    {\n        __r.first = static_cast<_Tp*>(::operator new(__n * sizeof(_Tp), nothrow));\n        if (__r.first)\n        {\n            __r.second = __n;\n            break;\n        }\n        __n /= 2;\n    }\n    return __r;\n}\n\ntemplate <class _Tp>\ninline _LIBCPP_INLINE_VISIBILITY\nvoid return_temporary_buffer(_Tp* __p) _NOEXCEPT {::operator delete(__p);}\n\ntemplate <class _Tp>\nstruct auto_ptr_ref\n{\n    _Tp* __ptr_;\n};\n\ntemplate<class _Tp>\nclass _LIBCPP_TEMPLATE_VIS auto_ptr\n{\nprivate:\n    _Tp* __ptr_;\npublic:\n    typedef _Tp element_type;\n\n    _LIBCPP_INLINE_VISIBILITY explicit auto_ptr(_Tp* __p = 0) throw() : __ptr_(__p) {}\n    _LIBCPP_INLINE_VISIBILITY auto_ptr(auto_ptr& __p) throw() : __ptr_(__p.release()) {}\n    template<class _Up> _LIBCPP_INLINE_VISIBILITY auto_ptr(auto_ptr<_Up>& __p) throw()\n        : __ptr_(__p.release()) {}\n    _LIBCPP_INLINE_VISIBILITY auto_ptr& operator=(auto_ptr& __p) throw()\n        {reset(__p.release()); return *this;}\n    template<class _Up> _LIBCPP_INLINE_VISIBILITY auto_ptr& operator=(auto_ptr<_Up>& __p) throw()\n        {reset(__p.release()); return *this;}\n    _LIBCPP_INLINE_VISIBILITY auto_ptr& operator=(auto_ptr_ref<_Tp> __p) throw()\n        {reset(__p.__ptr_); return *this;}\n    _LIBCPP_INLINE_VISIBILITY ~auto_ptr() throw() {delete __ptr_;}\n\n    _LIBCPP_INLINE_VISIBILITY _Tp& operator*() const throw()\n        {return *__ptr_;}\n    _LIBCPP_INLINE_VISIBILITY _Tp* operator->() const throw() {return __ptr_;}\n    _LIBCPP_INLINE_VISIBILITY _Tp* get() const throw() {return __ptr_;}\n    _LIBCPP_INLINE_VISIBILITY _Tp* release() throw()\n    {\n        _Tp* __t = __ptr_;\n        __ptr_ = 0;\n        return __t;\n    }\n    _LIBCPP_INLINE_VISIBILITY void reset(_Tp* __p = 0) throw()\n    {\n        if (__ptr_ != __p)\n            delete __ptr_;\n        __ptr_ = __p;\n    }\n\n    _LIBCPP_INLINE_VISIBILITY auto_ptr(auto_ptr_ref<_Tp> __p) throw() : __ptr_(__p.__ptr_) {}\n    template<class _Up> _LIBCPP_INLINE_VISIBILITY operator auto_ptr_ref<_Up>() throw()\n        {auto_ptr_ref<_Up> __t; __t.__ptr_ = release(); return __t;}\n    template<class _Up> _LIBCPP_INLINE_VISIBILITY operator auto_ptr<_Up>() throw()\n        {return auto_ptr<_Up>(release());}\n};\n\ntemplate <>\nclass _LIBCPP_TEMPLATE_VIS auto_ptr<void>\n{\npublic:\n    typedef void element_type;\n};\n\ntemplate <class _T1, class _T2, bool = is_same<typename remove_cv<_T1>::type,\n                                                     typename remove_cv<_T2>::type>::value,\n                                bool = is_empty<_T1>::value\n                                       && !__libcpp_is_final<_T1>::value,\n                                bool = is_empty<_T2>::value\n                                       && !__libcpp_is_final<_T2>::value\n         >\nstruct __libcpp_compressed_pair_switch;\n\ntemplate <class _T1, class _T2, bool IsSame>\nstruct __libcpp_compressed_pair_switch<_T1, _T2, IsSame, false, false> {enum {value = 0};};\n\ntemplate <class _T1, class _T2, bool IsSame>\nstruct __libcpp_compressed_pair_switch<_T1, _T2, IsSame, true, false>  {enum {value = 1};};\n\ntemplate <class _T1, class _T2, bool IsSame>\nstruct __libcpp_compressed_pair_switch<_T1, _T2, IsSame, false, true>  {enum {value = 2};};\n\ntemplate <class _T1, class _T2>\nstruct __libcpp_compressed_pair_switch<_T1, _T2, false, true, true>    {enum {value = 3};};\n\ntemplate <class _T1, class _T2>\nstruct __libcpp_compressed_pair_switch<_T1, _T2, true, true, true>     {enum {value = 1};};\n\ntemplate <class _T1, class _T2, unsigned = __libcpp_compressed_pair_switch<_T1, _T2>::value>\nclass __libcpp_compressed_pair_imp;\n\ntemplate <class _T1, class _T2>\nclass __libcpp_compressed_pair_imp<_T1, _T2, 0>\n{\nprivate:\n    _T1 __first_;\n    _T2 __second_;\npublic:\n    typedef _T1 _T1_param;\n    typedef _T2 _T2_param;\n\n    typedef typename remove_reference<_T1>::type& _T1_reference;\n    typedef typename remove_reference<_T2>::type& _T2_reference;\n\n    typedef const typename remove_reference<_T1>::type& _T1_const_reference;\n    typedef const typename remove_reference<_T2>::type& _T2_const_reference;\n\n    _LIBCPP_INLINE_VISIBILITY __libcpp_compressed_pair_imp() : __first_(), __second_() {}\n    _LIBCPP_INLINE_VISIBILITY explicit __libcpp_compressed_pair_imp(_T1_param __t1)\n        : __first_(_VSTD::forward<_T1_param>(__t1)), __second_() {}\n    _LIBCPP_INLINE_VISIBILITY explicit __libcpp_compressed_pair_imp(_T2_param __t2)\n        : __first_(), __second_(_VSTD::forward<_T2_param>(__t2)) {}\n    _LIBCPP_INLINE_VISIBILITY __libcpp_compressed_pair_imp(_T1_param __t1, _T2_param __t2)\n        : __first_(_VSTD::forward<_T1_param>(__t1)), __second_(_VSTD::forward<_T2_param>(__t2)) {}\n\n#ifndef _LIBCPP_HAS_NO_VARIADICS\n\n    template <class... _Args1, class... _Args2, size_t... _I1, size_t... _I2>\n        _LIBCPP_INLINE_VISIBILITY\n        __libcpp_compressed_pair_imp(piecewise_construct_t,\n                                     tuple<_Args1...> __first_args,\n                                     tuple<_Args2...> __second_args,\n                                     __tuple_indices<_I1...>,\n                                     __tuple_indices<_I2...>)\n            : __first_(_VSTD::forward<_Args1>(_VSTD::get<_I1>(__first_args))...),\n              __second_(_VSTD::forward<_Args2>(_VSTD::get<_I2>(__second_args))...)\n            {}\n\n#endif  // _LIBCPP_HAS_NO_VARIADICS\n\n    _LIBCPP_INLINE_VISIBILITY _T1_reference       first() _NOEXCEPT       {return __first_;}\n    _LIBCPP_INLINE_VISIBILITY _T1_const_reference first() const _NOEXCEPT {return __first_;}\n\n    _LIBCPP_INLINE_VISIBILITY _T2_reference       second() _NOEXCEPT       {return __second_;}\n    _LIBCPP_INLINE_VISIBILITY _T2_const_reference second() const _NOEXCEPT {return __second_;}\n\n    _LIBCPP_INLINE_VISIBILITY void swap(__libcpp_compressed_pair_imp& __x)\n        _NOEXCEPT_(__is_nothrow_swappable<_T1>::value &&\n                   __is_nothrow_swappable<_T2>::value)\n    {\n        using _VSTD::swap;\n        swap(__first_, __x.__first_);\n        swap(__second_, __x.__second_);\n    }\n};\n\ntemplate <class _T1, class _T2>\nclass __libcpp_compressed_pair_imp<_T1, _T2, 1>\n    : private _T1\n{\nprivate:\n    _T2 __second_;\npublic:\n    typedef _T1 _T1_param;\n    typedef _T2 _T2_param;\n\n    typedef _T1&                                        _T1_reference;\n    typedef typename remove_reference<_T2>::type& _T2_reference;\n\n    typedef const _T1&                                        _T1_const_reference;\n    typedef const typename remove_reference<_T2>::type& _T2_const_reference;\n\n    _LIBCPP_INLINE_VISIBILITY __libcpp_compressed_pair_imp() : __second_() {}\n    _LIBCPP_INLINE_VISIBILITY explicit __libcpp_compressed_pair_imp(_T1_param __t1)\n        : _T1(_VSTD::forward<_T1_param>(__t1)), __second_() {}\n    _LIBCPP_INLINE_VISIBILITY explicit __libcpp_compressed_pair_imp(_T2_param __t2)\n        : __second_(_VSTD::forward<_T2_param>(__t2)) {}\n    _LIBCPP_INLINE_VISIBILITY __libcpp_compressed_pair_imp(_T1_param __t1, _T2_param __t2)\n        : _T1(_VSTD::forward<_T1_param>(__t1)), __second_(_VSTD::forward<_T2_param>(__t2)) {}\n\n#ifndef _LIBCPP_HAS_NO_VARIADICS\n\n    template <class... _Args1, class... _Args2, size_t... _I1, size_t... _I2>\n        _LIBCPP_INLINE_VISIBILITY\n        __libcpp_compressed_pair_imp(piecewise_construct_t,\n                                     tuple<_Args1...> __first_args,\n                                     tuple<_Args2...> __second_args,\n                                     __tuple_indices<_I1...>,\n                                     __tuple_indices<_I2...>)\n            : _T1(_VSTD::forward<_Args1>(_VSTD::get<_I1>(__first_args))...),\n              __second_(_VSTD::forward<_Args2>(_VSTD::get<_I2>(__second_args))...)\n            {}\n\n#endif  // _LIBCPP_HAS_NO_VARIADICS\n\n    _LIBCPP_INLINE_VISIBILITY _T1_reference       first() _NOEXCEPT       {return *this;}\n    _LIBCPP_INLINE_VISIBILITY _T1_const_reference first() const _NOEXCEPT {return *this;}\n\n    _LIBCPP_INLINE_VISIBILITY _T2_reference       second() _NOEXCEPT       {return __second_;}\n    _LIBCPP_INLINE_VISIBILITY _T2_const_reference second() const _NOEXCEPT {return __second_;}\n\n    _LIBCPP_INLINE_VISIBILITY void swap(__libcpp_compressed_pair_imp& __x)\n        _NOEXCEPT_(__is_nothrow_swappable<_T1>::value &&\n                   __is_nothrow_swappable<_T2>::value)\n    {\n        using _VSTD::swap;\n        swap(__second_, __x.__second_);\n    }\n};\n\ntemplate <class _T1, class _T2>\nclass __libcpp_compressed_pair_imp<_T1, _T2, 2>\n    : private _T2\n{\nprivate:\n    _T1 __first_;\npublic:\n    typedef _T1 _T1_param;\n    typedef _T2 _T2_param;\n\n    typedef typename remove_reference<_T1>::type& _T1_reference;\n    typedef _T2&                                        _T2_reference;\n\n    typedef const typename remove_reference<_T1>::type& _T1_const_reference;\n    typedef const _T2&                                        _T2_const_reference;\n\n    _LIBCPP_INLINE_VISIBILITY __libcpp_compressed_pair_imp() : __first_() {}\n    _LIBCPP_INLINE_VISIBILITY explicit __libcpp_compressed_pair_imp(_T1_param __t1)\n        : __first_(_VSTD::forward<_T1_param>(__t1)) {}\n    _LIBCPP_INLINE_VISIBILITY explicit __libcpp_compressed_pair_imp(_T2_param __t2)\n        : _T2(_VSTD::forward<_T2_param>(__t2)), __first_() {}\n    _LIBCPP_INLINE_VISIBILITY __libcpp_compressed_pair_imp(_T1_param __t1, _T2_param __t2)\n        _NOEXCEPT_(is_nothrow_move_constructible<_T1>::value &&\n                   is_nothrow_move_constructible<_T2>::value)\n        : _T2(_VSTD::forward<_T2_param>(__t2)), __first_(_VSTD::forward<_T1_param>(__t1)) {}\n\n#ifndef _LIBCPP_HAS_NO_VARIADICS\n\n    template <class... _Args1, class... _Args2, size_t... _I1, size_t... _I2>\n        _LIBCPP_INLINE_VISIBILITY\n        __libcpp_compressed_pair_imp(piecewise_construct_t,\n                                     tuple<_Args1...> __first_args,\n                                     tuple<_Args2...> __second_args,\n                                     __tuple_indices<_I1...>,\n                                     __tuple_indices<_I2...>)\n            : _T2(_VSTD::forward<_Args2>(_VSTD::get<_I2>(__second_args))...),\n              __first_(_VSTD::forward<_Args1>(_VSTD::get<_I1>(__first_args))...)\n              \n            {}\n\n#endif  // _LIBCPP_HAS_NO_VARIADICS\n\n    _LIBCPP_INLINE_VISIBILITY _T1_reference       first() _NOEXCEPT       {return __first_;}\n    _LIBCPP_INLINE_VISIBILITY _T1_const_reference first() const _NOEXCEPT {return __first_;}\n\n    _LIBCPP_INLINE_VISIBILITY _T2_reference       second() _NOEXCEPT       {return *this;}\n    _LIBCPP_INLINE_VISIBILITY _T2_const_reference second() const _NOEXCEPT {return *this;}\n\n    _LIBCPP_INLINE_VISIBILITY void swap(__libcpp_compressed_pair_imp& __x)\n        _NOEXCEPT_(__is_nothrow_swappable<_T1>::value &&\n                   __is_nothrow_swappable<_T2>::value)\n    {\n        using _VSTD::swap;\n        swap(__first_, __x.__first_);\n    }\n};\n\ntemplate <class _T1, class _T2>\nclass __libcpp_compressed_pair_imp<_T1, _T2, 3>\n    : private _T1,\n      private _T2\n{\npublic:\n    typedef _T1 _T1_param;\n    typedef _T2 _T2_param;\n\n    typedef _T1& _T1_reference;\n    typedef _T2& _T2_reference;\n\n    typedef const _T1& _T1_const_reference;\n    typedef const _T2& _T2_const_reference;\n\n    _LIBCPP_INLINE_VISIBILITY __libcpp_compressed_pair_imp() {}\n    _LIBCPP_INLINE_VISIBILITY explicit __libcpp_compressed_pair_imp(_T1_param __t1)\n        : _T1(_VSTD::forward<_T1_param>(__t1)) {}\n    _LIBCPP_INLINE_VISIBILITY explicit __libcpp_compressed_pair_imp(_T2_param __t2)\n        : _T2(_VSTD::forward<_T2_param>(__t2)) {}\n    _LIBCPP_INLINE_VISIBILITY __libcpp_compressed_pair_imp(_T1_param __t1, _T2_param __t2)\n        : _T1(_VSTD::forward<_T1_param>(__t1)), _T2(_VSTD::forward<_T2_param>(__t2)) {}\n\n#ifndef _LIBCPP_HAS_NO_VARIADICS\n\n    template <class... _Args1, class... _Args2, size_t... _I1, size_t... _I2>\n        _LIBCPP_INLINE_VISIBILITY\n        __libcpp_compressed_pair_imp(piecewise_construct_t,\n                                     tuple<_Args1...> __first_args,\n                                     tuple<_Args2...> __second_args,\n                                     __tuple_indices<_I1...>,\n                                     __tuple_indices<_I2...>)\n            : _T1(_VSTD::forward<_Args1>(_VSTD::get<_I1>(__first_args))...),\n              _T2(_VSTD::forward<_Args2>(_VSTD::get<_I2>(__second_args))...)\n            {}\n\n#endif  // _LIBCPP_HAS_NO_VARIADICS\n\n    _LIBCPP_INLINE_VISIBILITY _T1_reference       first() _NOEXCEPT       {return *this;}\n    _LIBCPP_INLINE_VISIBILITY _T1_const_reference first() const _NOEXCEPT {return *this;}\n\n    _LIBCPP_INLINE_VISIBILITY _T2_reference       second() _NOEXCEPT       {return *this;}\n    _LIBCPP_INLINE_VISIBILITY _T2_const_reference second() const _NOEXCEPT {return *this;}\n\n    _LIBCPP_INLINE_VISIBILITY void swap(__libcpp_compressed_pair_imp&)\n        _NOEXCEPT_(__is_nothrow_swappable<_T1>::value &&\n                   __is_nothrow_swappable<_T2>::value)\n    {\n    }\n};\n\ntemplate <class _T1, class _T2>\nclass __compressed_pair\n    : private __libcpp_compressed_pair_imp<_T1, _T2>\n{\n    typedef __libcpp_compressed_pair_imp<_T1, _T2> base;\npublic:\n    typedef typename base::_T1_param _T1_param;\n    typedef typename base::_T2_param _T2_param;\n\n    typedef typename base::_T1_reference _T1_reference;\n    typedef typename base::_T2_reference _T2_reference;\n\n    typedef typename base::_T1_const_reference _T1_const_reference;\n    typedef typename base::_T2_const_reference _T2_const_reference;\n\n    _LIBCPP_INLINE_VISIBILITY __compressed_pair() {}\n    _LIBCPP_INLINE_VISIBILITY explicit __compressed_pair(_T1_param __t1)\n        : base(_VSTD::forward<_T1_param>(__t1)) {}\n    _LIBCPP_INLINE_VISIBILITY explicit __compressed_pair(_T2_param __t2)\n        : base(_VSTD::forward<_T2_param>(__t2)) {}\n    _LIBCPP_INLINE_VISIBILITY __compressed_pair(_T1_param __t1, _T2_param __t2)\n        : base(_VSTD::forward<_T1_param>(__t1), _VSTD::forward<_T2_param>(__t2)) {}\n\n#ifndef _LIBCPP_HAS_NO_VARIADICS\n\n    template <class... _Args1, class... _Args2>\n        _LIBCPP_INLINE_VISIBILITY\n        __compressed_pair(piecewise_construct_t __pc, tuple<_Args1...> __first_args,\n                                                      tuple<_Args2...> __second_args)\n            : base(__pc, _VSTD::move(__first_args), _VSTD::move(__second_args),\n                   typename __make_tuple_indices<sizeof...(_Args1)>::type(),\n                   typename __make_tuple_indices<sizeof...(_Args2) >::type())\n            {}\n\n#endif  // _LIBCPP_HAS_NO_VARIADICS\n\n    _LIBCPP_INLINE_VISIBILITY _T1_reference       first() _NOEXCEPT       {return base::first();}\n    _LIBCPP_INLINE_VISIBILITY _T1_const_reference first() const _NOEXCEPT {return base::first();}\n\n    _LIBCPP_INLINE_VISIBILITY _T2_reference       second() _NOEXCEPT       {return base::second();}\n    _LIBCPP_INLINE_VISIBILITY _T2_const_reference second() const _NOEXCEPT {return base::second();}\n\n    _LIBCPP_INLINE_VISIBILITY void swap(__compressed_pair& __x)\n        _NOEXCEPT_(__is_nothrow_swappable<_T1>::value &&\n                   __is_nothrow_swappable<_T2>::value)\n        {base::swap(__x);}\n};\n\ntemplate <class _T1, class _T2>\ninline _LIBCPP_INLINE_VISIBILITY\nvoid\nswap(__compressed_pair<_T1, _T2>& __x, __compressed_pair<_T1, _T2>& __y)\n        _NOEXCEPT_(__is_nothrow_swappable<_T1>::value &&\n                   __is_nothrow_swappable<_T2>::value)\n    {__x.swap(__y);}\n\n// __same_or_less_cv_qualified\n\ntemplate <class _Ptr1, class _Ptr2,\n          bool = is_same<typename remove_cv<typename pointer_traits<_Ptr1>::element_type>::type,\n                         typename remove_cv<typename pointer_traits<_Ptr2>::element_type>::type\n                        >::value\n         >\nstruct __same_or_less_cv_qualified_imp\n    : is_convertible<_Ptr1, _Ptr2> {};\n\ntemplate <class _Ptr1, class _Ptr2>\nstruct __same_or_less_cv_qualified_imp<_Ptr1, _Ptr2, false>\n    : false_type {};\n\ntemplate <class _Ptr1, class _Ptr2, bool = is_pointer<_Ptr1>::value ||\n                                           is_same<_Ptr1, _Ptr2>::value ||\n                                           __has_element_type<_Ptr1>::value>\nstruct __same_or_less_cv_qualified\n    : __same_or_less_cv_qualified_imp<_Ptr1, _Ptr2> {};\n\ntemplate <class _Ptr1, class _Ptr2>\nstruct __same_or_less_cv_qualified<_Ptr1, _Ptr2, false>\n    : false_type {};\n\n// default_delete\n\ntemplate <class _Tp>\nstruct _LIBCPP_TEMPLATE_VIS default_delete\n{\n#ifndef _LIBCPP_CXX03_LANG\n    _LIBCPP_INLINE_VISIBILITY _LIBCPP_CONSTEXPR default_delete() _NOEXCEPT = default;\n#else\n    _LIBCPP_INLINE_VISIBILITY _LIBCPP_CONSTEXPR default_delete() _NOEXCEPT {}\n#endif\n    template <class _Up>\n        _LIBCPP_INLINE_VISIBILITY default_delete(const default_delete<_Up>&,\n             typename enable_if<is_convertible<_Up*, _Tp*>::value>::type* = 0) _NOEXCEPT {}\n    _LIBCPP_INLINE_VISIBILITY void operator() (_Tp* __ptr) const _NOEXCEPT\n        {\n            static_assert(sizeof(_Tp) > 0, \"default_delete can not delete incomplete type\");\n            static_assert(!is_void<_Tp>::value, \"default_delete can not delete incomplete type\");\n            delete __ptr;\n        }\n};\n\ntemplate <class _Tp>\nstruct _LIBCPP_TEMPLATE_VIS default_delete<_Tp[]>\n{\npublic:\n#ifndef _LIBCPP_CXX03_LANG\n    _LIBCPP_INLINE_VISIBILITY _LIBCPP_CONSTEXPR default_delete() _NOEXCEPT = default;\n#else\n    _LIBCPP_INLINE_VISIBILITY _LIBCPP_CONSTEXPR default_delete() _NOEXCEPT {}\n#endif\n    template <class _Up>\n        _LIBCPP_INLINE_VISIBILITY default_delete(const default_delete<_Up[]>&,\n             typename enable_if<__same_or_less_cv_qualified<_Up*, _Tp*>::value>::type* = 0) _NOEXCEPT {}\n    template <class _Up>\n        _LIBCPP_INLINE_VISIBILITY\n        void operator() (_Up* __ptr,\n                         typename enable_if<__same_or_less_cv_qualified<_Up*, _Tp*>::value>::type* = 0) const _NOEXCEPT\n        {\n            static_assert(sizeof(_Tp) > 0, \"default_delete can not delete incomplete type\");\n            static_assert(!is_void<_Tp>::value, \"default_delete can not delete void type\");\n            delete [] __ptr;\n        }\n};\n\ntemplate <class _Tp, class _Dp = default_delete<_Tp> >\nclass _LIBCPP_TEMPLATE_VIS unique_ptr\n{\npublic:\n    typedef _Tp element_type;\n    typedef _Dp deleter_type;\n    typedef typename __pointer_type<_Tp, deleter_type>::type pointer;\nprivate:\n    __compressed_pair<pointer, deleter_type> __ptr_;\n\n#ifdef _LIBCPP_HAS_NO_RVALUE_REFERENCES\n    unique_ptr(unique_ptr&);\n    template <class _Up, class _Ep>\n        unique_ptr(unique_ptr<_Up, _Ep>&);\n    unique_ptr& operator=(unique_ptr&);\n    template <class _Up, class _Ep>\n        unique_ptr& operator=(unique_ptr<_Up, _Ep>&);\n#endif  // _LIBCPP_HAS_NO_RVALUE_REFERENCES\n\n    struct __nat {int __for_bool_;};\n\n    typedef       typename remove_reference<deleter_type>::type& _Dp_reference;\n    typedef const typename remove_reference<deleter_type>::type& _Dp_const_reference;\npublic:\n    _LIBCPP_INLINE_VISIBILITY _LIBCPP_CONSTEXPR unique_ptr() _NOEXCEPT\n        : __ptr_(pointer())\n        {\n            static_assert(!is_pointer<deleter_type>::value,\n                \"unique_ptr constructed with null function pointer deleter\");\n        }\n    _LIBCPP_INLINE_VISIBILITY _LIBCPP_CONSTEXPR unique_ptr(nullptr_t) _NOEXCEPT\n        : __ptr_(pointer())\n        {\n            static_assert(!is_pointer<deleter_type>::value,\n                \"unique_ptr constructed with null function pointer deleter\");\n        }\n    _LIBCPP_INLINE_VISIBILITY explicit unique_ptr(pointer __p) _NOEXCEPT\n        : __ptr_(_VSTD::move(__p))\n        {\n            static_assert(!is_pointer<deleter_type>::value,\n                \"unique_ptr constructed with null function pointer deleter\");\n        }\n\n#ifndef _LIBCPP_HAS_NO_RVALUE_REFERENCES\n    _LIBCPP_INLINE_VISIBILITY unique_ptr(pointer __p, typename conditional<\n                                        is_reference<deleter_type>::value,\n                                        deleter_type,\n                                        typename add_lvalue_reference<const deleter_type>::type>::type __d)\n             _NOEXCEPT\n        : __ptr_(__p, __d) {}\n\n    _LIBCPP_INLINE_VISIBILITY unique_ptr(pointer __p, typename remove_reference<deleter_type>::type&& __d)\n             _NOEXCEPT\n        : __ptr_(__p, _VSTD::move(__d))\n        {\n            static_assert(!is_reference<deleter_type>::value, \"rvalue deleter bound to reference\");\n        }\n    _LIBCPP_INLINE_VISIBILITY unique_ptr(unique_ptr&& __u) _NOEXCEPT\n        : __ptr_(__u.release(), _VSTD::forward<deleter_type>(__u.get_deleter())) {}\n    template <class _Up, class _Ep>\n        _LIBCPP_INLINE_VISIBILITY\n        unique_ptr(unique_ptr<_Up, _Ep>&& __u,\n                   typename enable_if\n                      <\n                        !is_array<_Up>::value &&\n                         is_convertible<typename unique_ptr<_Up, _Ep>::pointer, pointer>::value &&\n                         is_convertible<_Ep, deleter_type>::value &&\n                         (\n                            !is_reference<deleter_type>::value ||\n                            is_same<deleter_type, _Ep>::value\n                         ),\n                         __nat\n                      >::type = __nat()) _NOEXCEPT\n            : __ptr_(__u.release(), _VSTD::forward<_Ep>(__u.get_deleter())) {}\n\n    template <class _Up>\n        _LIBCPP_INLINE_VISIBILITY unique_ptr(auto_ptr<_Up>&& __p,\n                typename enable_if<\n                                      is_convertible<_Up*, _Tp*>::value &&\n                                      is_same<_Dp, default_delete<_Tp> >::value,\n                                      __nat\n                                  >::type = __nat()) _NOEXCEPT\n            : __ptr_(__p.release())\n            {\n            }\n\n        _LIBCPP_INLINE_VISIBILITY unique_ptr& operator=(unique_ptr&& __u) _NOEXCEPT\n            {\n                reset(__u.release());\n                __ptr_.second() = _VSTD::forward<deleter_type>(__u.get_deleter());\n                return *this;\n            }\n\n        template <class _Up, class _Ep>\n            _LIBCPP_INLINE_VISIBILITY\n            typename enable_if\n            <\n                !is_array<_Up>::value &&\n                is_convertible<typename unique_ptr<_Up, _Ep>::pointer, pointer>::value &&\n                is_assignable<deleter_type&, _Ep&&>::value,\n                unique_ptr&\n            >::type\n            operator=(unique_ptr<_Up, _Ep>&& __u) _NOEXCEPT\n            {\n                reset(__u.release());\n                __ptr_.second() = _VSTD::forward<_Ep>(__u.get_deleter());\n                return *this;\n            }\n#else  // _LIBCPP_HAS_NO_RVALUE_REFERENCES\n\n    _LIBCPP_INLINE_VISIBILITY operator __rv<unique_ptr>()\n    {\n        return __rv<unique_ptr>(*this);\n    }\n\n    _LIBCPP_INLINE_VISIBILITY unique_ptr(__rv<unique_ptr> __u)\n        : __ptr_(__u->release(), _VSTD::forward<deleter_type>(__u->get_deleter())) {}\n\n    template <class _Up, class _Ep>\n    _LIBCPP_INLINE_VISIBILITY\n    typename enable_if<\n        !is_array<_Up>::value &&\n        is_convertible<typename unique_ptr<_Up, _Ep>::pointer, pointer>::value &&\n        is_assignable<deleter_type&, _Ep&>::value,\n        unique_ptr&\n    >::type\n    operator=(unique_ptr<_Up, _Ep> __u)\n    {\n        reset(__u.release());\n        __ptr_.second() = _VSTD::forward<_Ep>(__u.get_deleter());\n        return *this;\n    }\n\n    _LIBCPP_INLINE_VISIBILITY unique_ptr(pointer __p, deleter_type __d)\n        : __ptr_(_VSTD::move(__p), _VSTD::move(__d)) {}\n\n    template <class _Up>\n        _LIBCPP_INLINE_VISIBILITY\n                typename enable_if<\n                                      is_convertible<_Up*, _Tp*>::value &&\n                                      is_same<_Dp, default_delete<_Tp> >::value,\n                                      unique_ptr&\n                                  >::type\n        operator=(auto_ptr<_Up> __p)\n            {reset(__p.release()); return *this;}\n\n#endif  // _LIBCPP_HAS_NO_RVALUE_REFERENCES\n    _LIBCPP_INLINE_VISIBILITY ~unique_ptr() {reset();}\n\n    _LIBCPP_INLINE_VISIBILITY unique_ptr& operator=(nullptr_t) _NOEXCEPT\n    {\n        reset();\n        return *this;\n    }\n\n    _LIBCPP_INLINE_VISIBILITY typename add_lvalue_reference<_Tp>::type operator*() const\n        {return *__ptr_.first();}\n    _LIBCPP_INLINE_VISIBILITY pointer operator->() const _NOEXCEPT {return __ptr_.first();}\n    _LIBCPP_INLINE_VISIBILITY pointer get() const _NOEXCEPT {return __ptr_.first();}\n    _LIBCPP_INLINE_VISIBILITY       _Dp_reference get_deleter() _NOEXCEPT\n        {return __ptr_.second();}\n    _LIBCPP_INLINE_VISIBILITY _Dp_const_reference get_deleter() const _NOEXCEPT\n        {return __ptr_.second();}\n    _LIBCPP_INLINE_VISIBILITY\n        _LIBCPP_EXPLICIT operator bool() const _NOEXCEPT\n        {return __ptr_.first() != nullptr;}\n\n    _LIBCPP_INLINE_VISIBILITY pointer release() _NOEXCEPT\n    {\n        pointer __t = __ptr_.first();\n        __ptr_.first() = pointer();\n        return __t;\n    }\n\n    _LIBCPP_INLINE_VISIBILITY void reset(pointer __p = pointer()) _NOEXCEPT\n    {\n        pointer __tmp = __ptr_.first();\n        __ptr_.first() = __p;\n        if (__tmp)\n            __ptr_.second()(__tmp);\n    }\n\n    _LIBCPP_INLINE_VISIBILITY void swap(unique_ptr& __u) _NOEXCEPT\n        {__ptr_.swap(__u.__ptr_);}\n};\n\ntemplate <class _Tp, class _Dp>\nclass _LIBCPP_TEMPLATE_VIS unique_ptr<_Tp[], _Dp>\n{\npublic:\n    typedef _Tp element_type;\n    typedef _Dp deleter_type;\n    typedef typename __pointer_type<_Tp, deleter_type>::type pointer;\nprivate:\n    __compressed_pair<pointer, deleter_type> __ptr_;\n\n#ifdef _LIBCPP_HAS_NO_RVALUE_REFERENCES\n    unique_ptr(unique_ptr&);\n    template <class _Up>\n        unique_ptr(unique_ptr<_Up>&);\n    unique_ptr& operator=(unique_ptr&);\n    template <class _Up>\n        unique_ptr& operator=(unique_ptr<_Up>&);\n#endif  // _LIBCPP_HAS_NO_RVALUE_REFERENCES\n\n    struct __nat {int __for_bool_;};\n\n    typedef       typename remove_reference<deleter_type>::type& _Dp_reference;\n    typedef const typename remove_reference<deleter_type>::type& _Dp_const_reference;\npublic:\n    _LIBCPP_INLINE_VISIBILITY _LIBCPP_CONSTEXPR unique_ptr() _NOEXCEPT\n        : __ptr_(pointer())\n        {\n            static_assert(!is_pointer<deleter_type>::value,\n                \"unique_ptr constructed with null function pointer deleter\");\n        }\n    _LIBCPP_INLINE_VISIBILITY _LIBCPP_CONSTEXPR unique_ptr(nullptr_t) _NOEXCEPT\n        : __ptr_(pointer())\n        {\n            static_assert(!is_pointer<deleter_type>::value,\n                \"unique_ptr constructed with null function pointer deleter\");\n        }\n#ifndef _LIBCPP_HAS_NO_RVALUE_REFERENCES\n    template <class _Pp>\n    _LIBCPP_INLINE_VISIBILITY explicit unique_ptr(_Pp __p,\n            typename enable_if<__same_or_less_cv_qualified<_Pp, pointer>::value, __nat>::type = __nat()) _NOEXCEPT\n        : __ptr_(__p)\n        {\n            static_assert(!is_pointer<deleter_type>::value,\n                \"unique_ptr constructed with null function pointer deleter\");\n        }\n\n    template <class _Pp>\n    _LIBCPP_INLINE_VISIBILITY unique_ptr(_Pp __p, typename conditional<\n                                       is_reference<deleter_type>::value,\n                                       deleter_type,\n                                       typename add_lvalue_reference<const deleter_type>::type>::type __d,\n                                       typename enable_if<__same_or_less_cv_qualified<_Pp, pointer>::value, __nat>::type = __nat())\n             _NOEXCEPT\n        : __ptr_(__p, __d) {}\n\n    _LIBCPP_INLINE_VISIBILITY unique_ptr(nullptr_t, typename conditional<\n                                       is_reference<deleter_type>::value,\n                                       deleter_type,\n                                       typename add_lvalue_reference<const deleter_type>::type>::type __d)\n             _NOEXCEPT\n        : __ptr_(pointer(), __d) {}\n\n    template <class _Pp>\n    _LIBCPP_INLINE_VISIBILITY unique_ptr(_Pp __p,\n                                         typename remove_reference<deleter_type>::type&& __d,\n                                         typename enable_if<__same_or_less_cv_qualified<_Pp, pointer>::value, __nat>::type = __nat())\n             _NOEXCEPT\n        : __ptr_(__p, _VSTD::move(__d))\n        {\n            static_assert(!is_reference<deleter_type>::value, \"rvalue deleter bound to reference\");\n        }\n\n    _LIBCPP_INLINE_VISIBILITY unique_ptr(nullptr_t, typename remove_reference<deleter_type>::type&& __d)\n             _NOEXCEPT\n        : __ptr_(pointer(), _VSTD::move(__d))\n        {\n            static_assert(!is_reference<deleter_type>::value, \"rvalue deleter bound to reference\");\n        }\n\n    _LIBCPP_INLINE_VISIBILITY unique_ptr(unique_ptr&& __u) _NOEXCEPT\n        : __ptr_(__u.release(), _VSTD::forward<deleter_type>(__u.get_deleter())) {}\n\n    _LIBCPP_INLINE_VISIBILITY unique_ptr& operator=(unique_ptr&& __u) _NOEXCEPT\n        {\n            reset(__u.release());\n            __ptr_.second() = _VSTD::forward<deleter_type>(__u.get_deleter());\n            return *this;\n        }\n\n    template <class _Up, class _Ep>\n        _LIBCPP_INLINE_VISIBILITY\n        unique_ptr(unique_ptr<_Up, _Ep>&& __u,\n                   typename enable_if\n                            <\n                                is_array<_Up>::value &&\n                                __same_or_less_cv_qualified<typename unique_ptr<_Up, _Ep>::pointer, pointer>::value\n                                && is_convertible<_Ep, deleter_type>::value &&\n                                (\n                                    !is_reference<deleter_type>::value ||\n                                    is_same<deleter_type, _Ep>::value\n                                ),\n                                __nat\n                            >::type = __nat()\n                  ) _NOEXCEPT\n        : __ptr_(__u.release(), _VSTD::forward<deleter_type>(__u.get_deleter())) {}\n\n\n        template <class _Up, class _Ep>\n            _LIBCPP_INLINE_VISIBILITY\n            typename enable_if\n            <\n                is_array<_Up>::value &&\n                __same_or_less_cv_qualified<typename unique_ptr<_Up, _Ep>::pointer, pointer>::value &&\n                is_assignable<deleter_type&, _Ep&&>::value,\n                unique_ptr&\n            >::type\n            operator=(unique_ptr<_Up, _Ep>&& __u) _NOEXCEPT\n            {\n                reset(__u.release());\n                __ptr_.second() = _VSTD::forward<_Ep>(__u.get_deleter());\n                return *this;\n            }\n#else  // _LIBCPP_HAS_NO_RVALUE_REFERENCES\n\n    _LIBCPP_INLINE_VISIBILITY explicit unique_ptr(pointer __p)\n        : __ptr_(__p)\n        {\n            static_assert(!is_pointer<deleter_type>::value,\n                \"unique_ptr constructed with null function pointer deleter\");\n        }\n\n    _LIBCPP_INLINE_VISIBILITY unique_ptr(pointer __p, deleter_type __d)\n        : __ptr_(__p, _VSTD::forward<deleter_type>(__d)) {}\n\n    _LIBCPP_INLINE_VISIBILITY unique_ptr(nullptr_t, deleter_type __d)\n        : __ptr_(pointer(), _VSTD::forward<deleter_type>(__d)) {}\n\n    _LIBCPP_INLINE_VISIBILITY operator __rv<unique_ptr>()\n    {\n        return __rv<unique_ptr>(*this);\n    }\n\n    _LIBCPP_INLINE_VISIBILITY unique_ptr(__rv<unique_ptr> __u)\n        : __ptr_(__u->release(), _VSTD::forward<deleter_type>(__u->get_deleter())) {}\n\n    _LIBCPP_INLINE_VISIBILITY unique_ptr& operator=(__rv<unique_ptr> __u)\n    {\n        reset(__u->release());\n        __ptr_.second() = _VSTD::forward<deleter_type>(__u->get_deleter());\n        return *this;\n    }\n\n#endif  // _LIBCPP_HAS_NO_RVALUE_REFERENCES\n    _LIBCPP_INLINE_VISIBILITY ~unique_ptr() {reset();}\n\n    _LIBCPP_INLINE_VISIBILITY unique_ptr& operator=(nullptr_t) _NOEXCEPT\n    {\n        reset();\n        return *this;\n    }\n\n    _LIBCPP_INLINE_VISIBILITY typename add_lvalue_reference<_Tp>::type operator[](size_t __i) const\n        {return __ptr_.first()[__i];}\n    _LIBCPP_INLINE_VISIBILITY pointer get() const _NOEXCEPT {return __ptr_.first();}\n    _LIBCPP_INLINE_VISIBILITY       _Dp_reference get_deleter() _NOEXCEPT\n        {return __ptr_.second();}\n    _LIBCPP_INLINE_VISIBILITY _Dp_const_reference get_deleter() const _NOEXCEPT\n        {return __ptr_.second();}\n    _LIBCPP_INLINE_VISIBILITY\n        _LIBCPP_EXPLICIT operator bool() const _NOEXCEPT\n        {return __ptr_.first() != nullptr;}\n\n    _LIBCPP_INLINE_VISIBILITY pointer release() _NOEXCEPT\n    {\n        pointer __t = __ptr_.first();\n        __ptr_.first() = pointer();\n        return __t;\n    }\n\n    template <class _Pp>\n    _LIBCPP_INLINE_VISIBILITY\n    typename enable_if<__same_or_less_cv_qualified<_Pp, pointer>::value, void>::type\n    reset(_Pp __p) _NOEXCEPT\n    {\n        pointer __tmp = __ptr_.first();\n        __ptr_.first() = __p;\n        if (__tmp)\n            __ptr_.second()(__tmp);\n    }\n    _LIBCPP_INLINE_VISIBILITY void reset(nullptr_t = nullptr) _NOEXCEPT\n    {\n        pointer __tmp = __ptr_.first();\n        __ptr_.first() = nullptr;\n        if (__tmp)\n            __ptr_.second()(__tmp);\n    }\n\n    _LIBCPP_INLINE_VISIBILITY void swap(unique_ptr& __u) {__ptr_.swap(__u.__ptr_);}\nprivate:\n\n#ifdef _LIBCPP_HAS_NO_RVALUE_REFERENCES\n    template <class _Up>\n        explicit unique_ptr(_Up);\n    template <class _Up>\n        unique_ptr(_Up __u,\n                   typename conditional<\n                                       is_reference<deleter_type>::value,\n                                       deleter_type,\n                                       typename add_lvalue_reference<const deleter_type>::type>::type,\n                   typename enable_if\n                      <\n                         is_convertible<_Up, pointer>::value,\n                         __nat\n                      >::type = __nat());\n#endif  // _LIBCPP_HAS_NO_RVALUE_REFERENCES\n};\n\ntemplate <class _Tp, class _Dp>\ninline _LIBCPP_INLINE_VISIBILITY\ntypename enable_if<\n    __is_swappable<_Dp>::value,\n    void\n>::type\nswap(unique_ptr<_Tp, _Dp>& __x, unique_ptr<_Tp, _Dp>& __y) _NOEXCEPT {__x.swap(__y);}\n\ntemplate <class _T1, class _D1, class _T2, class _D2>\ninline _LIBCPP_INLINE_VISIBILITY\nbool\noperator==(const unique_ptr<_T1, _D1>& __x, const unique_ptr<_T2, _D2>& __y) {return __x.get() == __y.get();}\n\ntemplate <class _T1, class _D1, class _T2, class _D2>\ninline _LIBCPP_INLINE_VISIBILITY\nbool\noperator!=(const unique_ptr<_T1, _D1>& __x, const unique_ptr<_T2, _D2>& __y) {return !(__x == __y);}\n\ntemplate <class _T1, class _D1, class _T2, class _D2>\ninline _LIBCPP_INLINE_VISIBILITY\nbool\noperator< (const unique_ptr<_T1, _D1>& __x, const unique_ptr<_T2, _D2>& __y)\n{\n    typedef typename unique_ptr<_T1, _D1>::pointer _P1;\n    typedef typename unique_ptr<_T2, _D2>::pointer _P2;\n    typedef typename common_type<_P1, _P2>::type _Vp;\n    return less<_Vp>()(__x.get(), __y.get());\n}\n\ntemplate <class _T1, class _D1, class _T2, class _D2>\ninline _LIBCPP_INLINE_VISIBILITY\nbool\noperator> (const unique_ptr<_T1, _D1>& __x, const unique_ptr<_T2, _D2>& __y) {return __y < __x;}\n\ntemplate <class _T1, class _D1, class _T2, class _D2>\ninline _LIBCPP_INLINE_VISIBILITY\nbool\noperator<=(const unique_ptr<_T1, _D1>& __x, const unique_ptr<_T2, _D2>& __y) {return !(__y < __x);}\n\ntemplate <class _T1, class _D1, class _T2, class _D2>\ninline _LIBCPP_INLINE_VISIBILITY\nbool\noperator>=(const unique_ptr<_T1, _D1>& __x, const unique_ptr<_T2, _D2>& __y) {return !(__x < __y);}\n\ntemplate <class _T1, class _D1>\ninline _LIBCPP_INLINE_VISIBILITY\nbool\noperator==(const unique_ptr<_T1, _D1>& __x, nullptr_t) _NOEXCEPT\n{\n    return !__x;\n}\n\ntemplate <class _T1, class _D1>\ninline _LIBCPP_INLINE_VISIBILITY\nbool\noperator==(nullptr_t, const unique_ptr<_T1, _D1>& __x) _NOEXCEPT\n{\n    return !__x;\n}\n\ntemplate <class _T1, class _D1>\ninline _LIBCPP_INLINE_VISIBILITY\nbool\noperator!=(const unique_ptr<_T1, _D1>& __x, nullptr_t) _NOEXCEPT\n{\n    return static_cast<bool>(__x);\n}\n\ntemplate <class _T1, class _D1>\ninline _LIBCPP_INLINE_VISIBILITY\nbool\noperator!=(nullptr_t, const unique_ptr<_T1, _D1>& __x) _NOEXCEPT\n{\n    return static_cast<bool>(__x);\n}\n\ntemplate <class _T1, class _D1>\ninline _LIBCPP_INLINE_VISIBILITY\nbool\noperator<(const unique_ptr<_T1, _D1>& __x, nullptr_t)\n{\n    typedef typename unique_ptr<_T1, _D1>::pointer _P1;\n    return less<_P1>()(__x.get(), nullptr);\n}\n\ntemplate <class _T1, class _D1>\ninline _LIBCPP_INLINE_VISIBILITY\nbool\noperator<(nullptr_t, const unique_ptr<_T1, _D1>& __x)\n{\n    typedef typename unique_ptr<_T1, _D1>::pointer _P1;\n    return less<_P1>()(nullptr, __x.get());\n}\n\ntemplate <class _T1, class _D1>\ninline _LIBCPP_INLINE_VISIBILITY\nbool\noperator>(const unique_ptr<_T1, _D1>& __x, nullptr_t)\n{\n    return nullptr < __x;\n}\n\ntemplate <class _T1, class _D1>\ninline _LIBCPP_INLINE_VISIBILITY\nbool\noperator>(nullptr_t, const unique_ptr<_T1, _D1>& __x)\n{\n    return __x < nullptr;\n}\n\ntemplate <class _T1, class _D1>\ninline _LIBCPP_INLINE_VISIBILITY\nbool\noperator<=(const unique_ptr<_T1, _D1>& __x, nullptr_t)\n{\n    return !(nullptr < __x);\n}\n\ntemplate <class _T1, class _D1>\ninline _LIBCPP_INLINE_VISIBILITY\nbool\noperator<=(nullptr_t, const unique_ptr<_T1, _D1>& __x)\n{\n    return !(__x < nullptr);\n}\n\ntemplate <class _T1, class _D1>\ninline _LIBCPP_INLINE_VISIBILITY\nbool\noperator>=(const unique_ptr<_T1, _D1>& __x, nullptr_t)\n{\n    return !(__x < nullptr);\n}\n\ntemplate <class _T1, class _D1>\ninline _LIBCPP_INLINE_VISIBILITY\nbool\noperator>=(nullptr_t, const unique_ptr<_T1, _D1>& __x)\n{\n    return !(nullptr < __x);\n}\n\n#ifdef _LIBCPP_HAS_NO_RVALUE_REFERENCES\n\ntemplate <class _Tp, class _Dp>\ninline _LIBCPP_INLINE_VISIBILITY\nunique_ptr<_Tp, _Dp>\nmove(unique_ptr<_Tp, _Dp>& __t)\n{\n    return unique_ptr<_Tp, _Dp>(__rv<unique_ptr<_Tp, _Dp> >(__t));\n}\n\n#endif\n\n#if _LIBCPP_STD_VER > 11\n\ntemplate<class _Tp>\nstruct __unique_if\n{\n    typedef unique_ptr<_Tp> __unique_single;\n};\n\ntemplate<class _Tp>\nstruct __unique_if<_Tp[]>\n{\n    typedef unique_ptr<_Tp[]> __unique_array_unknown_bound;\n};\n\ntemplate<class _Tp, size_t _Np>\nstruct __unique_if<_Tp[_Np]>\n{\n    typedef void __unique_array_known_bound;\n};\n\ntemplate<class _Tp, class... _Args>\ninline _LIBCPP_INLINE_VISIBILITY\ntypename __unique_if<_Tp>::__unique_single\nmake_unique(_Args&&... __args)\n{\n    return unique_ptr<_Tp>(new _Tp(_VSTD::forward<_Args>(__args)...));\n}\n\ntemplate<class _Tp>\ninline _LIBCPP_INLINE_VISIBILITY\ntypename __unique_if<_Tp>::__unique_array_unknown_bound\nmake_unique(size_t __n)\n{\n    typedef typename remove_extent<_Tp>::type _Up;\n    return unique_ptr<_Tp>(new _Up[__n]());\n}\n\ntemplate<class _Tp, class... _Args>\n    typename __unique_if<_Tp>::__unique_array_known_bound\n    make_unique(_Args&&...) = delete;\n\n#endif  // _LIBCPP_STD_VER > 11\n\ntemplate <class _Size>\ninline _LIBCPP_INLINE_VISIBILITY\n_Size\n__loadword(const void* __p)\n{\n    _Size __r;\n    std::memcpy(&__r, __p, sizeof(__r));\n    return __r;\n}\n\n// We use murmur2 when size_t is 32 bits, and cityhash64 when size_t\n// is 64 bits.  This is because cityhash64 uses 64bit x 64bit\n// multiplication, which can be very slow on 32-bit systems.\ntemplate <class _Size, size_t = sizeof(_Size)*__CHAR_BIT__>\nstruct __murmur2_or_cityhash;\n\ntemplate <class _Size>\nstruct __murmur2_or_cityhash<_Size, 32>\n{\n    _Size operator()(const void* __key, _Size __len);\n};\n\n// murmur2\ntemplate <class _Size>\n_Size\n__murmur2_or_cityhash<_Size, 32>::operator()(const void* __key, _Size __len) _LIBCPP_DISABLE_UBSAN_UNSIGNED_INTEGER_CHECK \n{\n    const _Size __m = 0x5bd1e995;\n    const _Size __r = 24;\n    _Size __h = __len;\n    const unsigned char* __data = static_cast<const unsigned char*>(__key);\n    for (; __len >= 4; __data += 4, __len -= 4)\n    {\n        _Size __k = __loadword<_Size>(__data);\n        __k *= __m;\n        __k ^= __k >> __r;\n        __k *= __m;\n        __h *= __m;\n        __h ^= __k;\n    }\n    switch (__len)\n    {\n    case 3:\n        __h ^= __data[2] << 16;\n    case 2:\n        __h ^= __data[1] << 8;\n    case 1:\n        __h ^= __data[0];\n        __h *= __m;\n    }\n    __h ^= __h >> 13;\n    __h *= __m;\n    __h ^= __h >> 15;\n    return __h;\n}\n\ntemplate <class _Size>\nstruct __murmur2_or_cityhash<_Size, 64>\n{\n    _Size operator()(const void* __key, _Size __len);\n\n private:\n  // Some primes between 2^63 and 2^64.\n  static const _Size __k0 = 0xc3a5c85c97cb3127ULL;\n  static const _Size __k1 = 0xb492b66fbe98f273ULL;\n  static const _Size __k2 = 0x9ae16a3b2f90404fULL;\n  static const _Size __k3 = 0xc949d7c7509e6557ULL;\n\n  static _Size __rotate(_Size __val, int __shift) {\n    return __shift == 0 ? __val : ((__val >> __shift) | (__val << (64 - __shift)));\n  }\n\n  static _Size __rotate_by_at_least_1(_Size __val, int __shift) {\n    return (__val >> __shift) | (__val << (64 - __shift));\n  }\n\n  static _Size __shift_mix(_Size __val) {\n    return __val ^ (__val >> 47);\n  }\n\n  static _Size __hash_len_16(_Size __u, _Size __v) {\n    const _Size __mul = 0x9ddfea08eb382d69ULL;\n    _Size __a = (__u ^ __v) * __mul;\n    __a ^= (__a >> 47);\n    _Size __b = (__v ^ __a) * __mul;\n    __b ^= (__b >> 47);\n    __b *= __mul;\n    return __b;\n  }\n\n  static _Size __hash_len_0_to_16(const char* __s, _Size __len) {\n    if (__len > 8) {\n      const _Size __a = __loadword<_Size>(__s);\n      const _Size __b = __loadword<_Size>(__s + __len - 8);\n      return __hash_len_16(__a, __rotate_by_at_least_1(__b + __len, __len)) ^ __b;\n    }\n    if (__len >= 4) {\n      const uint32_t __a = __loadword<uint32_t>(__s);\n      const uint32_t __b = __loadword<uint32_t>(__s + __len - 4);\n      return __hash_len_16(__len + (__a << 3), __b);\n    }\n    if (__len > 0) {\n      const unsigned char __a = __s[0];\n      const unsigned char __b = __s[__len >> 1];\n      const unsigned char __c = __s[__len - 1];\n      const uint32_t __y = static_cast<uint32_t>(__a) +\n                           (static_cast<uint32_t>(__b) << 8);\n      const uint32_t __z = __len + (static_cast<uint32_t>(__c) << 2);\n      return __shift_mix(__y * __k2 ^ __z * __k3) * __k2;\n    }\n    return __k2;\n  }\n\n  static _Size __hash_len_17_to_32(const char *__s, _Size __len) {\n    const _Size __a = __loadword<_Size>(__s) * __k1;\n    const _Size __b = __loadword<_Size>(__s + 8);\n    const _Size __c = __loadword<_Size>(__s + __len - 8) * __k2;\n    const _Size __d = __loadword<_Size>(__s + __len - 16) * __k0;\n    return __hash_len_16(__rotate(__a - __b, 43) + __rotate(__c, 30) + __d,\n                         __a + __rotate(__b ^ __k3, 20) - __c + __len);\n  }\n\n  // Return a 16-byte hash for 48 bytes.  Quick and dirty.\n  // Callers do best to use \"random-looking\" values for a and b.\n  static pair<_Size, _Size> __weak_hash_len_32_with_seeds(\n      _Size __w, _Size __x, _Size __y, _Size __z, _Size __a, _Size __b) {\n    __a += __w;\n    __b = __rotate(__b + __a + __z, 21);\n    const _Size __c = __a;\n    __a += __x;\n    __a += __y;\n    __b += __rotate(__a, 44);\n    return pair<_Size, _Size>(__a + __z, __b + __c);\n  }\n\n  // Return a 16-byte hash for s[0] ... s[31], a, and b.  Quick and dirty.\n  static pair<_Size, _Size> __weak_hash_len_32_with_seeds(\n      const char* __s, _Size __a, _Size __b) {\n    return __weak_hash_len_32_with_seeds(__loadword<_Size>(__s),\n                                         __loadword<_Size>(__s + 8),\n                                         __loadword<_Size>(__s + 16),\n                                         __loadword<_Size>(__s + 24),\n                                         __a,\n                                         __b);\n  }\n\n  // Return an 8-byte hash for 33 to 64 bytes.\n  static _Size __hash_len_33_to_64(const char *__s, size_t __len) {\n    _Size __z = __loadword<_Size>(__s + 24);\n    _Size __a = __loadword<_Size>(__s) +\n                (__len + __loadword<_Size>(__s + __len - 16)) * __k0;\n    _Size __b = __rotate(__a + __z, 52);\n    _Size __c = __rotate(__a, 37);\n    __a += __loadword<_Size>(__s + 8);\n    __c += __rotate(__a, 7);\n    __a += __loadword<_Size>(__s + 16);\n    _Size __vf = __a + __z;\n    _Size __vs = __b + __rotate(__a, 31) + __c;\n    __a = __loadword<_Size>(__s + 16) + __loadword<_Size>(__s + __len - 32);\n    __z += __loadword<_Size>(__s + __len - 8);\n    __b = __rotate(__a + __z, 52);\n    __c = __rotate(__a, 37);\n    __a += __loadword<_Size>(__s + __len - 24);\n    __c += __rotate(__a, 7);\n    __a += __loadword<_Size>(__s + __len - 16);\n    _Size __wf = __a + __z;\n    _Size __ws = __b + __rotate(__a, 31) + __c;\n    _Size __r = __shift_mix((__vf + __ws) * __k2 + (__wf + __vs) * __k0);\n    return __shift_mix(__r * __k0 + __vs) * __k2;\n  }\n};\n\n// cityhash64\ntemplate <class _Size>\n_Size\n__murmur2_or_cityhash<_Size, 64>::operator()(const void* __key, _Size __len) _LIBCPP_DISABLE_UBSAN_UNSIGNED_INTEGER_CHECK \n{\n  const char* __s = static_cast<const char*>(__key);\n  if (__len <= 32) {\n    if (__len <= 16) {\n      return __hash_len_0_to_16(__s, __len);\n    } else {\n      return __hash_len_17_to_32(__s, __len);\n    }\n  } else if (__len <= 64) {\n    return __hash_len_33_to_64(__s, __len);\n  }\n\n  // For strings over 64 bytes we hash the end first, and then as we\n  // loop we keep 56 bytes of state: v, w, x, y, and z.\n  _Size __x = __loadword<_Size>(__s + __len - 40);\n  _Size __y = __loadword<_Size>(__s + __len - 16) +\n              __loadword<_Size>(__s + __len - 56);\n  _Size __z = __hash_len_16(__loadword<_Size>(__s + __len - 48) + __len,\n                          __loadword<_Size>(__s + __len - 24));\n  pair<_Size, _Size> __v = __weak_hash_len_32_with_seeds(__s + __len - 64, __len, __z);\n  pair<_Size, _Size> __w = __weak_hash_len_32_with_seeds(__s + __len - 32, __y + __k1, __x);\n  __x = __x * __k1 + __loadword<_Size>(__s);\n\n  // Decrease len to the nearest multiple of 64, and operate on 64-byte chunks.\n  __len = (__len - 1) & ~static_cast<_Size>(63);\n  do {\n    __x = __rotate(__x + __y + __v.first + __loadword<_Size>(__s + 8), 37) * __k1;\n    __y = __rotate(__y + __v.second + __loadword<_Size>(__s + 48), 42) * __k1;\n    __x ^= __w.second;\n    __y += __v.first + __loadword<_Size>(__s + 40);\n    __z = __rotate(__z + __w.first, 33) * __k1;\n    __v = __weak_hash_len_32_with_seeds(__s, __v.second * __k1, __x + __w.first);\n    __w = __weak_hash_len_32_with_seeds(__s + 32, __z + __w.second,\n                                        __y + __loadword<_Size>(__s + 16));\n    std::swap(__z, __x);\n    __s += 64;\n    __len -= 64;\n  } while (__len != 0);\n  return __hash_len_16(\n      __hash_len_16(__v.first, __w.first) + __shift_mix(__y) * __k1 + __z,\n      __hash_len_16(__v.second, __w.second) + __x);\n}\n\ntemplate <class _Tp, size_t = sizeof(_Tp) / sizeof(size_t)>\nstruct __scalar_hash;\n\ntemplate <class _Tp>\nstruct __scalar_hash<_Tp, 0>\n    : public unary_function<_Tp, size_t>\n{\n    _LIBCPP_INLINE_VISIBILITY\n    size_t operator()(_Tp __v) const _NOEXCEPT\n    {\n        union\n        {\n            _Tp    __t;\n            size_t __a;\n        } __u;\n        __u.__a = 0;\n        __u.__t = __v;\n        return __u.__a;\n    }\n};\n\ntemplate <class _Tp>\nstruct __scalar_hash<_Tp, 1>\n    : public unary_function<_Tp, size_t>\n{\n    _LIBCPP_INLINE_VISIBILITY\n    size_t operator()(_Tp __v) const _NOEXCEPT\n    {\n        union\n        {\n            _Tp    __t;\n            size_t __a;\n        } __u;\n        __u.__t = __v;\n        return __u.__a;\n    }\n};\n\ntemplate <class _Tp>\nstruct __scalar_hash<_Tp, 2>\n    : public unary_function<_Tp, size_t>\n{\n    _LIBCPP_INLINE_VISIBILITY\n    size_t operator()(_Tp __v) const _NOEXCEPT\n    {\n        union\n        {\n            _Tp __t;\n            struct\n            {\n                size_t __a;\n                size_t __b;\n            } __s;\n        } __u;\n        __u.__t = __v;\n        return __murmur2_or_cityhash<size_t>()(&__u, sizeof(__u));\n    }\n};\n\ntemplate <class _Tp>\nstruct __scalar_hash<_Tp, 3>\n    : public unary_function<_Tp, size_t>\n{\n    _LIBCPP_INLINE_VISIBILITY\n    size_t operator()(_Tp __v) const _NOEXCEPT\n    {\n        union\n        {\n            _Tp __t;\n            struct\n            {\n                size_t __a;\n                size_t __b;\n                size_t __c;\n            } __s;\n        } __u;\n        __u.__t = __v;\n        return __murmur2_or_cityhash<size_t>()(&__u, sizeof(__u));\n    }\n};\n\ntemplate <class _Tp>\nstruct __scalar_hash<_Tp, 4>\n    : public unary_function<_Tp, size_t>\n{\n    _LIBCPP_INLINE_VISIBILITY\n    size_t operator()(_Tp __v) const _NOEXCEPT\n    {\n        union\n        {\n            _Tp __t;\n            struct\n            {\n                size_t __a;\n                size_t __b;\n                size_t __c;\n                size_t __d;\n            } __s;\n        } __u;\n        __u.__t = __v;\n        return __murmur2_or_cityhash<size_t>()(&__u, sizeof(__u));\n    }\n};\n\nstruct _PairT {\n  size_t first;\n  size_t second;\n};\n\n_LIBCPP_INLINE_VISIBILITY\ninline size_t __hash_combine(size_t __lhs, size_t __rhs) _NOEXCEPT {\n    typedef __scalar_hash<_PairT> _HashT;\n    const _PairT __p = {__lhs, __rhs};\n    return _HashT()(__p);\n}\n\ntemplate<class _Tp>\nstruct _LIBCPP_TEMPLATE_VIS hash<_Tp*>\n    : public unary_function<_Tp*, size_t>\n{\n    _LIBCPP_INLINE_VISIBILITY\n    size_t operator()(_Tp* __v) const _NOEXCEPT\n    {\n        union\n        {\n            _Tp* __t;\n            size_t __a;\n        } __u;\n        __u.__t = __v;\n        return __murmur2_or_cityhash<size_t>()(&__u, sizeof(__u));\n    }\n};\n\ntemplate <class _Tp, class _Dp>\nstruct _LIBCPP_TEMPLATE_VIS hash<unique_ptr<_Tp, _Dp> >\n{\n    typedef unique_ptr<_Tp, _Dp> argument_type;\n    typedef size_t               result_type;\n    _LIBCPP_INLINE_VISIBILITY\n    result_type operator()(const argument_type& __ptr) const _NOEXCEPT\n    {\n        typedef typename argument_type::pointer pointer;\n        return hash<pointer>()(__ptr.get());\n    }\n};\n\nstruct __destruct_n\n{\nprivate:\n    size_t size;\n\n    template <class _Tp>\n    _LIBCPP_INLINE_VISIBILITY void __process(_Tp* __p, false_type) _NOEXCEPT\n        {for (size_t __i = 0; __i < size; ++__i, ++__p) __p->~_Tp();}\n\n    template <class _Tp>\n    _LIBCPP_INLINE_VISIBILITY void __process(_Tp*, true_type) _NOEXCEPT\n        {}\n\n    _LIBCPP_INLINE_VISIBILITY void __incr(false_type) _NOEXCEPT\n        {++size;}\n    _LIBCPP_INLINE_VISIBILITY void __incr(true_type) _NOEXCEPT\n        {}\n\n    _LIBCPP_INLINE_VISIBILITY void __set(size_t __s, false_type) _NOEXCEPT\n        {size = __s;}\n    _LIBCPP_INLINE_VISIBILITY void __set(size_t, true_type) _NOEXCEPT\n        {}\npublic:\n    _LIBCPP_INLINE_VISIBILITY explicit __destruct_n(size_t __s) _NOEXCEPT\n        : size(__s) {}\n\n    template <class _Tp>\n    _LIBCPP_INLINE_VISIBILITY void __incr(_Tp*) _NOEXCEPT\n        {__incr(integral_constant<bool, is_trivially_destructible<_Tp>::value>());}\n\n    template <class _Tp>\n    _LIBCPP_INLINE_VISIBILITY void __set(size_t __s, _Tp*) _NOEXCEPT\n        {__set(__s, integral_constant<bool, is_trivially_destructible<_Tp>::value>());}\n\n    template <class _Tp>\n    _LIBCPP_INLINE_VISIBILITY void operator()(_Tp* __p) _NOEXCEPT\n        {__process(__p, integral_constant<bool, is_trivially_destructible<_Tp>::value>());}\n};\n\ntemplate <class _Alloc>\nclass __allocator_destructor\n{\n    typedef allocator_traits<_Alloc> __alloc_traits;\npublic:\n    typedef typename __alloc_traits::pointer pointer;\n    typedef typename __alloc_traits::size_type size_type;\nprivate:\n    _Alloc& __alloc_;\n    size_type __s_;\npublic:\n    _LIBCPP_INLINE_VISIBILITY __allocator_destructor(_Alloc& __a, size_type __s)\n             _NOEXCEPT\n        : __alloc_(__a), __s_(__s) {}\n    _LIBCPP_INLINE_VISIBILITY\n    void operator()(pointer __p) _NOEXCEPT\n        {__alloc_traits::deallocate(__alloc_, __p, __s_);}\n};\n\ntemplate <class _InputIterator, class _ForwardIterator>\n_ForwardIterator\nuninitialized_copy(_InputIterator __f, _InputIterator __l, _ForwardIterator __r)\n{\n    typedef typename iterator_traits<_ForwardIterator>::value_type value_type;\n#ifndef _LIBCPP_NO_EXCEPTIONS\n    _ForwardIterator __s = __r;\n    try\n    {\n#endif\n        for (; __f != __l; ++__f, (void) ++__r)\n            ::new (static_cast<void*>(_VSTD::addressof(*__r))) value_type(*__f);\n#ifndef _LIBCPP_NO_EXCEPTIONS\n    }\n    catch (...)\n    {\n        for (; __s != __r; ++__s)\n            __s->~value_type();\n        throw;\n    }\n#endif\n    return __r;\n}\n\ntemplate <class _InputIterator, class _Size, class _ForwardIterator>\n_ForwardIterator\nuninitialized_copy_n(_InputIterator __f, _Size __n, _ForwardIterator __r)\n{\n    typedef typename iterator_traits<_ForwardIterator>::value_type value_type;\n#ifndef _LIBCPP_NO_EXCEPTIONS\n    _ForwardIterator __s = __r;\n    try\n    {\n#endif\n        for (; __n > 0; ++__f, (void) ++__r, (void) --__n)\n            ::new (static_cast<void*>(_VSTD::addressof(*__r))) value_type(*__f);\n#ifndef _LIBCPP_NO_EXCEPTIONS\n    }\n    catch (...)\n    {\n        for (; __s != __r; ++__s)\n            __s->~value_type();\n        throw;\n    }\n#endif\n    return __r;\n}\n\ntemplate <class _ForwardIterator, class _Tp>\nvoid\nuninitialized_fill(_ForwardIterator __f, _ForwardIterator __l, const _Tp& __x)\n{\n    typedef typename iterator_traits<_ForwardIterator>::value_type value_type;\n#ifndef _LIBCPP_NO_EXCEPTIONS\n    _ForwardIterator __s = __f;\n    try\n    {\n#endif\n        for (; __f != __l; ++__f)\n            ::new (static_cast<void*>(_VSTD::addressof(*__f))) value_type(__x);\n#ifndef _LIBCPP_NO_EXCEPTIONS\n    }\n    catch (...)\n    {\n        for (; __s != __f; ++__s)\n            __s->~value_type();\n        throw;\n    }\n#endif\n}\n\ntemplate <class _ForwardIterator, class _Size, class _Tp>\n_ForwardIterator\nuninitialized_fill_n(_ForwardIterator __f, _Size __n, const _Tp& __x)\n{\n    typedef typename iterator_traits<_ForwardIterator>::value_type value_type;\n#ifndef _LIBCPP_NO_EXCEPTIONS\n    _ForwardIterator __s = __f;\n    try\n    {\n#endif\n        for (; __n > 0; ++__f, (void) --__n)\n            ::new (static_cast<void*>(_VSTD::addressof(*__f))) value_type(__x);\n#ifndef _LIBCPP_NO_EXCEPTIONS\n    }\n    catch (...)\n    {\n        for (; __s != __f; ++__s)\n            __s->~value_type();\n        throw;\n    }\n#endif\n    return __f;\n}\n\n#if _LIBCPP_STD_VER > 14\n\ntemplate <class _Tp>\ninline _LIBCPP_INLINE_VISIBILITY\nvoid destroy_at(_Tp* __loc) {\n    _LIBCPP_ASSERT(__loc, \"null pointer given to destroy_at\");\n    __loc->~_Tp();\n}\n\ntemplate <class _ForwardIterator>\ninline _LIBCPP_INLINE_VISIBILITY\nvoid destroy(_ForwardIterator __first, _ForwardIterator __last) {\n    for (; __first != __last; ++__first)\n        _VSTD::destroy_at(_VSTD::addressof(*__first));\n}\n\ntemplate <class _ForwardIterator, class _Size>\ninline _LIBCPP_INLINE_VISIBILITY\n_ForwardIterator destroy_n(_ForwardIterator __first, _Size __n) {\n    for (; __n > 0; (void)++__first, --__n)\n        _VSTD::destroy_at(_VSTD::addressof(*__first));\n    return __first;\n}\n\ntemplate <class _ForwardIterator>\ninline _LIBCPP_INLINE_VISIBILITY\nvoid uninitialized_default_construct(_ForwardIterator __first, _ForwardIterator __last) {\n    using _Vt = typename iterator_traits<_ForwardIterator>::value_type;\n    auto __idx = __first;\n#ifndef _LIBCPP_NO_EXCEPTIONS\n    try {\n#endif\n    for (; __idx != __last; ++__idx)\n        ::new((void*)_VSTD::addressof(*__idx)) _Vt;\n#ifndef _LIBCPP_NO_EXCEPTIONS\n    } catch (...) {\n        _VSTD::destroy(__first, __idx);\n        throw;\n    }\n#endif\n}\n\ntemplate <class _ForwardIterator, class _Size>\ninline _LIBCPP_INLINE_VISIBILITY\n_ForwardIterator uninitialized_default_construct_n(_ForwardIterator __first, _Size __n) {\n    using _Vt = typename iterator_traits<_ForwardIterator>::value_type;\n    auto __idx = __first;\n#ifndef _LIBCPP_NO_EXCEPTIONS\n    try {\n#endif\n    for (; __n > 0; (void)++__idx, --__n)\n        ::new((void*)_VSTD::addressof(*__idx)) _Vt;\n    return __idx;\n#ifndef _LIBCPP_NO_EXCEPTIONS\n    } catch (...) {\n        _VSTD::destroy(__first, __idx);\n        throw;\n    }\n#endif\n}\n\n\ntemplate <class _ForwardIterator>\ninline _LIBCPP_INLINE_VISIBILITY\nvoid uninitialized_value_construct(_ForwardIterator __first, _ForwardIterator __last) {\n    using _Vt = typename iterator_traits<_ForwardIterator>::value_type;\n    auto __idx = __first;\n#ifndef _LIBCPP_NO_EXCEPTIONS\n    try {\n#endif\n    for (; __idx != __last; ++__idx)\n        ::new((void*)_VSTD::addressof(*__idx)) _Vt();\n#ifndef _LIBCPP_NO_EXCEPTIONS\n    } catch (...) {\n        _VSTD::destroy(__first, __idx);\n        throw;\n    }\n#endif\n}\n\ntemplate <class _ForwardIterator, class _Size>\ninline _LIBCPP_INLINE_VISIBILITY\n_ForwardIterator uninitialized_value_construct_n(_ForwardIterator __first, _Size __n) {\n    using _Vt = typename iterator_traits<_ForwardIterator>::value_type;\n    auto __idx = __first;\n#ifndef _LIBCPP_NO_EXCEPTIONS\n    try {\n#endif\n    for (; __n > 0; (void)++__idx, --__n)\n        ::new((void*)_VSTD::addressof(*__idx)) _Vt();\n    return __idx;\n#ifndef _LIBCPP_NO_EXCEPTIONS\n    } catch (...) {\n        _VSTD::destroy(__first, __idx);\n        throw;\n    }\n#endif\n}\n\n\ntemplate <class _InputIt, class _ForwardIt>\ninline _LIBCPP_INLINE_VISIBILITY\n_ForwardIt uninitialized_move(_InputIt __first, _InputIt __last, _ForwardIt __first_res) {\n    using _Vt = typename iterator_traits<_ForwardIt>::value_type;\n    auto __idx = __first_res;\n#ifndef _LIBCPP_NO_EXCEPTIONS\n    try {\n#endif\n    for (; __first != __last; (void)++__idx, ++__first)\n        ::new((void*)_VSTD::addressof(*__idx)) _Vt(std::move(*__first));\n    return __idx;\n#ifndef _LIBCPP_NO_EXCEPTIONS\n    } catch (...) {\n        _VSTD::destroy(__first_res, __idx);\n        throw;\n    }\n#endif\n}\n\ntemplate <class _InputIt, class _Size, class _ForwardIt>\ninline _LIBCPP_INLINE_VISIBILITY\npair<_InputIt, _ForwardIt>\nuninitialized_move_n(_InputIt __first, _Size __n, _ForwardIt __first_res) {\n    using _Vt = typename iterator_traits<_ForwardIt>::value_type;\n    auto __idx = __first_res;\n#ifndef _LIBCPP_NO_EXCEPTIONS\n    try {\n#endif\n    for (; __n > 0; ++__idx, (void)++__first, --__n)\n        ::new((void*)_VSTD::addressof(*__idx)) _Vt(std::move(*__first));\n    return {__first, __idx};\n#ifndef _LIBCPP_NO_EXCEPTIONS\n    } catch (...) {\n        _VSTD::destroy(__first_res, __idx);\n        throw;\n    }\n#endif\n}\n\n\n#endif // _LIBCPP_STD_VER > 14\n\nclass _LIBCPP_EXCEPTION_ABI bad_weak_ptr\n    : public std::exception\n{\npublic:\n    virtual ~bad_weak_ptr() _NOEXCEPT;\n    virtual const char* what() const  _NOEXCEPT;\n};\n\n_LIBCPP_NORETURN inline _LIBCPP_ALWAYS_INLINE\nvoid __throw_bad_weak_ptr()\n{\n#ifndef _LIBCPP_NO_EXCEPTIONS\n    throw bad_weak_ptr();\n#else\n    _VSTD::abort();\n#endif\n}\n\ntemplate<class _Tp> class _LIBCPP_TEMPLATE_VIS weak_ptr;\n\nclass _LIBCPP_TYPE_VIS __shared_count\n{\n    __shared_count(const __shared_count&);\n    __shared_count& operator=(const __shared_count&);\n\nprotected:\n    long __shared_owners_;\n    virtual ~__shared_count();\nprivate:\n    virtual void __on_zero_shared() _NOEXCEPT = 0;\n\npublic:\n    _LIBCPP_INLINE_VISIBILITY\n    explicit __shared_count(long __refs = 0) _NOEXCEPT\n        : __shared_owners_(__refs) {}\n\n    void __add_shared() _NOEXCEPT;\n    bool __release_shared() _NOEXCEPT;\n    _LIBCPP_INLINE_VISIBILITY\n    long use_count() const _NOEXCEPT {\n        return __libcpp_relaxed_load(&__shared_owners_) + 1;\n    }\n};\n\nclass _LIBCPP_TYPE_VIS __shared_weak_count\n    : private __shared_count\n{\n    long __shared_weak_owners_;\n\npublic:\n    _LIBCPP_INLINE_VISIBILITY\n    explicit __shared_weak_count(long __refs = 0) _NOEXCEPT\n        : __shared_count(__refs),\n          __shared_weak_owners_(__refs) {}\nprotected:\n    virtual ~__shared_weak_count();\n\npublic:\n    void __add_shared() _NOEXCEPT;\n    void __add_weak() _NOEXCEPT;\n    void __release_shared() _NOEXCEPT;\n    void __release_weak() _NOEXCEPT;\n    _LIBCPP_INLINE_VISIBILITY\n    long use_count() const _NOEXCEPT {return __shared_count::use_count();}\n    __shared_weak_count* lock() _NOEXCEPT;\n\n    // Define the function out only if we build static libc++ without RTTI.\n    // Otherwise we may break clients who need to compile their projects with\n    // -fno-rtti and yet link against a libc++.dylib compiled\n    // without -fno-rtti.\n#if !defined(_LIBCPP_NO_RTTI) || !defined(_LIBCPP_BUILD_STATIC)\n    virtual const void* __get_deleter(const type_info&) const _NOEXCEPT;\n#endif\nprivate:\n    virtual void __on_zero_shared_weak() _NOEXCEPT = 0;\n};\n\ntemplate <class _Tp, class _Dp, class _Alloc>\nclass __shared_ptr_pointer\n    : public __shared_weak_count\n{\n    __compressed_pair<__compressed_pair<_Tp, _Dp>, _Alloc> __data_;\npublic:\n    _LIBCPP_INLINE_VISIBILITY\n    __shared_ptr_pointer(_Tp __p, _Dp __d, _Alloc __a)\n        :  __data_(__compressed_pair<_Tp, _Dp>(__p, _VSTD::move(__d)), _VSTD::move(__a)) {}\n\n#ifndef _LIBCPP_NO_RTTI\n    virtual const void* __get_deleter(const type_info&) const _NOEXCEPT;\n#endif\n\nprivate:\n    virtual void __on_zero_shared() _NOEXCEPT;\n    virtual void __on_zero_shared_weak() _NOEXCEPT;\n};\n\n#ifndef _LIBCPP_NO_RTTI\n\ntemplate <class _Tp, class _Dp, class _Alloc>\nconst void*\n__shared_ptr_pointer<_Tp, _Dp, _Alloc>::__get_deleter(const type_info& __t) const _NOEXCEPT\n{\n    return __t == typeid(_Dp) ? _VSTD::addressof(__data_.first().second()) : 0;\n}\n\n#endif  // _LIBCPP_NO_RTTI\n\ntemplate <class _Tp, class _Dp, class _Alloc>\nvoid\n__shared_ptr_pointer<_Tp, _Dp, _Alloc>::__on_zero_shared() _NOEXCEPT\n{\n    __data_.first().second()(__data_.first().first());\n    __data_.first().second().~_Dp();\n}\n\ntemplate <class _Tp, class _Dp, class _Alloc>\nvoid\n__shared_ptr_pointer<_Tp, _Dp, _Alloc>::__on_zero_shared_weak() _NOEXCEPT\n{\n    typedef typename __allocator_traits_rebind<_Alloc, __shared_ptr_pointer>::type _Al;\n    typedef allocator_traits<_Al> _ATraits;\n    typedef pointer_traits<typename _ATraits::pointer> _PTraits;\n\n    _Al __a(__data_.second());\n    __data_.second().~_Alloc();\n    __a.deallocate(_PTraits::pointer_to(*this), 1);\n}\n\ntemplate <class _Tp, class _Alloc>\nclass __shared_ptr_emplace\n    : public __shared_weak_count\n{\n    __compressed_pair<_Alloc, _Tp> __data_;\npublic:\n#ifndef _LIBCPP_HAS_NO_VARIADICS\n\n    _LIBCPP_INLINE_VISIBILITY\n    __shared_ptr_emplace(_Alloc __a)\n        :  __data_(_VSTD::move(__a)) {}\n\n    template <class ..._Args>\n        _LIBCPP_INLINE_VISIBILITY\n        __shared_ptr_emplace(_Alloc __a, _Args&& ...__args)\n            :  __data_(piecewise_construct, _VSTD::forward_as_tuple(__a),\n                   _VSTD::forward_as_tuple(_VSTD::forward<_Args>(__args)...)) {}\n\n#else  // _LIBCPP_HAS_NO_VARIADICS\n\n    _LIBCPP_INLINE_VISIBILITY\n    __shared_ptr_emplace(_Alloc __a)\n        :  __data_(__a) {}\n\n    template <class _A0>\n        _LIBCPP_INLINE_VISIBILITY\n        __shared_ptr_emplace(_Alloc __a, _A0& __a0)\n            :  __data_(__a, _Tp(__a0)) {}\n\n    template <class _A0, class _A1>\n        _LIBCPP_INLINE_VISIBILITY\n        __shared_ptr_emplace(_Alloc __a, _A0& __a0, _A1& __a1)\n            :  __data_(__a, _Tp(__a0, __a1)) {}\n\n    template <class _A0, class _A1, class _A2>\n        _LIBCPP_INLINE_VISIBILITY\n        __shared_ptr_emplace(_Alloc __a, _A0& __a0, _A1& __a1, _A2& __a2)\n            :  __data_(__a, _Tp(__a0, __a1, __a2)) {}\n\n#endif  // _LIBCPP_HAS_NO_VARIADICS\n\nprivate:\n    virtual void __on_zero_shared() _NOEXCEPT;\n    virtual void __on_zero_shared_weak() _NOEXCEPT;\npublic:\n    _LIBCPP_INLINE_VISIBILITY\n    _Tp* get() _NOEXCEPT {return &__data_.second();}\n};\n\ntemplate <class _Tp, class _Alloc>\nvoid\n__shared_ptr_emplace<_Tp, _Alloc>::__on_zero_shared() _NOEXCEPT\n{\n    __data_.second().~_Tp();\n}\n\ntemplate <class _Tp, class _Alloc>\nvoid\n__shared_ptr_emplace<_Tp, _Alloc>::__on_zero_shared_weak() _NOEXCEPT\n{\n    typedef typename __allocator_traits_rebind<_Alloc, __shared_ptr_emplace>::type _Al;\n    typedef allocator_traits<_Al> _ATraits;\n    typedef pointer_traits<typename _ATraits::pointer> _PTraits;\n    _Al __a(__data_.first());\n    __data_.first().~_Alloc();\n    __a.deallocate(_PTraits::pointer_to(*this), 1);\n}\n\ntemplate<class _Tp> class _LIBCPP_TEMPLATE_VIS enable_shared_from_this;\n\ntemplate<class _Tp>\nclass _LIBCPP_TEMPLATE_VIS shared_ptr\n{\npublic:\n    typedef _Tp element_type;\n\n#if _LIBCPP_STD_VER > 14\n    typedef weak_ptr<_Tp> weak_type;\n#endif\nprivate:\n    element_type*      __ptr_;\n    __shared_weak_count* __cntrl_;\n\n    struct __nat {int __for_bool_;};\npublic:\n    _LIBCPP_INLINE_VISIBILITY\n    _LIBCPP_CONSTEXPR shared_ptr() _NOEXCEPT;\n    _LIBCPP_INLINE_VISIBILITY\n    _LIBCPP_CONSTEXPR shared_ptr(nullptr_t) _NOEXCEPT;\n    template<class _Yp>\n        explicit shared_ptr(_Yp* __p,\n                            typename enable_if<is_convertible<_Yp*, element_type*>::value, __nat>::type = __nat());\n    template<class _Yp, class _Dp>\n        shared_ptr(_Yp* __p, _Dp __d,\n                   typename enable_if<is_convertible<_Yp*, element_type*>::value, __nat>::type = __nat());\n    template<class _Yp, class _Dp, class _Alloc>\n        shared_ptr(_Yp* __p, _Dp __d, _Alloc __a,\n                   typename enable_if<is_convertible<_Yp*, element_type*>::value, __nat>::type = __nat());\n    template <class _Dp> shared_ptr(nullptr_t __p, _Dp __d);\n    template <class _Dp, class _Alloc> shared_ptr(nullptr_t __p, _Dp __d, _Alloc __a);\n    template<class _Yp> _LIBCPP_INLINE_VISIBILITY shared_ptr(const shared_ptr<_Yp>& __r, element_type* __p) _NOEXCEPT;\n    _LIBCPP_INLINE_VISIBILITY\n    shared_ptr(const shared_ptr& __r) _NOEXCEPT;\n    template<class _Yp>\n        _LIBCPP_INLINE_VISIBILITY\n        shared_ptr(const shared_ptr<_Yp>& __r,\n                   typename enable_if<is_convertible<_Yp*, element_type*>::value, __nat>::type = __nat())\n                       _NOEXCEPT;\n#ifndef _LIBCPP_HAS_NO_RVALUE_REFERENCES\n    _LIBCPP_INLINE_VISIBILITY\n    shared_ptr(shared_ptr&& __r) _NOEXCEPT;\n    template<class _Yp> _LIBCPP_INLINE_VISIBILITY  shared_ptr(shared_ptr<_Yp>&& __r,\n                   typename enable_if<is_convertible<_Yp*, element_type*>::value, __nat>::type = __nat())\n                       _NOEXCEPT;\n#endif  // _LIBCPP_HAS_NO_RVALUE_REFERENCES\n    template<class _Yp> explicit shared_ptr(const weak_ptr<_Yp>& __r,\n                   typename enable_if<is_convertible<_Yp*, element_type*>::value, __nat>::type= __nat());\n#ifndef _LIBCPP_HAS_NO_RVALUE_REFERENCES\n    template<class _Yp>\n        shared_ptr(auto_ptr<_Yp>&& __r,\n                   typename enable_if<is_convertible<_Yp*, element_type*>::value, __nat>::type = __nat());\n#else\n    template<class _Yp>\n        shared_ptr(auto_ptr<_Yp> __r,\n                   typename enable_if<is_convertible<_Yp*, element_type*>::value, __nat>::type = __nat());\n#endif\n#ifndef _LIBCPP_HAS_NO_RVALUE_REFERENCES\n    template <class _Yp, class _Dp>\n        shared_ptr(unique_ptr<_Yp, _Dp>&&,\n                   typename enable_if\n                   <\n                       !is_lvalue_reference<_Dp>::value &&\n                       !is_array<_Yp>::value &&\n                       is_convertible<typename unique_ptr<_Yp, _Dp>::pointer, element_type*>::value,\n                       __nat\n                   >::type = __nat());\n    template <class _Yp, class _Dp>\n        shared_ptr(unique_ptr<_Yp, _Dp>&&,\n                   typename enable_if\n                   <\n                       is_lvalue_reference<_Dp>::value &&\n                       !is_array<_Yp>::value &&\n                       is_convertible<typename unique_ptr<_Yp, _Dp>::pointer, element_type*>::value,\n                       __nat\n                   >::type = __nat());\n#else  // _LIBCPP_HAS_NO_RVALUE_REFERENCES\n    template <class _Yp, class _Dp>\n        shared_ptr(unique_ptr<_Yp, _Dp>,\n                   typename enable_if\n                   <\n                       !is_lvalue_reference<_Dp>::value &&\n                       !is_array<_Yp>::value &&\n                       is_convertible<typename unique_ptr<_Yp, _Dp>::pointer, element_type*>::value,\n                       __nat\n                   >::type = __nat());\n    template <class _Yp, class _Dp>\n        shared_ptr(unique_ptr<_Yp, _Dp>,\n                   typename enable_if\n                   <\n                       is_lvalue_reference<_Dp>::value &&\n                       !is_array<_Yp>::value &&\n                       is_convertible<typename unique_ptr<_Yp, _Dp>::pointer, element_type*>::value,\n                       __nat\n                   >::type = __nat());\n#endif  // _LIBCPP_HAS_NO_RVALUE_REFERENCES\n\n    ~shared_ptr();\n\n    _LIBCPP_INLINE_VISIBILITY\n    shared_ptr& operator=(const shared_ptr& __r) _NOEXCEPT;\n    template<class _Yp>\n        typename enable_if\n        <\n            is_convertible<_Yp*, element_type*>::value,\n            shared_ptr&\n        >::type\n        _LIBCPP_INLINE_VISIBILITY\n        operator=(const shared_ptr<_Yp>& __r) _NOEXCEPT;\n#ifndef _LIBCPP_HAS_NO_RVALUE_REFERENCES\n    _LIBCPP_INLINE_VISIBILITY\n    shared_ptr& operator=(shared_ptr&& __r) _NOEXCEPT;\n    template<class _Yp>\n        typename enable_if\n        <\n            is_convertible<_Yp*, element_type*>::value,\n            shared_ptr<_Tp>&\n        >::type\n        _LIBCPP_INLINE_VISIBILITY\n        operator=(shared_ptr<_Yp>&& __r);\n    template<class _Yp>\n        _LIBCPP_INLINE_VISIBILITY\n        typename enable_if\n        <\n            !is_array<_Yp>::value &&\n            is_convertible<_Yp*, element_type*>::value,\n            shared_ptr\n        >::type&\n        operator=(auto_ptr<_Yp>&& __r);\n#else  // _LIBCPP_HAS_NO_RVALUE_REFERENCES\n    template<class _Yp>\n        _LIBCPP_INLINE_VISIBILITY\n        typename enable_if\n        <\n            !is_array<_Yp>::value &&\n            is_convertible<_Yp*, element_type*>::value,\n            shared_ptr&\n        >::type\n        operator=(auto_ptr<_Yp> __r);\n#endif\n    template <class _Yp, class _Dp>\n        typename enable_if\n        <\n            !is_array<_Yp>::value &&\n            is_convertible<typename unique_ptr<_Yp, _Dp>::pointer, element_type*>::value,\n            shared_ptr&\n        >::type\n#ifndef _LIBCPP_HAS_NO_RVALUE_REFERENCES\n        _LIBCPP_INLINE_VISIBILITY\n        operator=(unique_ptr<_Yp, _Dp>&& __r);\n#else  // _LIBCPP_HAS_NO_RVALUE_REFERENCES\n        _LIBCPP_INLINE_VISIBILITY\n        operator=(unique_ptr<_Yp, _Dp> __r);\n#endif\n\n    _LIBCPP_INLINE_VISIBILITY\n    void swap(shared_ptr& __r) _NOEXCEPT;\n    _LIBCPP_INLINE_VISIBILITY\n    void reset() _NOEXCEPT;\n    template<class _Yp>\n        typename enable_if\n        <\n            is_convertible<_Yp*, element_type*>::value,\n            void\n        >::type\n        _LIBCPP_INLINE_VISIBILITY\n        reset(_Yp* __p);\n    template<class _Yp, class _Dp>\n        typename enable_if\n        <\n            is_convertible<_Yp*, element_type*>::value,\n            void\n        >::type\n        _LIBCPP_INLINE_VISIBILITY\n        reset(_Yp* __p, _Dp __d);\n    template<class _Yp, class _Dp, class _Alloc>\n        typename enable_if\n        <\n            is_convertible<_Yp*, element_type*>::value,\n            void\n        >::type\n        _LIBCPP_INLINE_VISIBILITY\n        reset(_Yp* __p, _Dp __d, _Alloc __a);\n\n    _LIBCPP_INLINE_VISIBILITY\n    element_type* get() const _NOEXCEPT {return __ptr_;}\n    _LIBCPP_INLINE_VISIBILITY\n    typename add_lvalue_reference<element_type>::type operator*() const _NOEXCEPT\n        {return *__ptr_;}\n    _LIBCPP_INLINE_VISIBILITY\n    element_type* operator->() const _NOEXCEPT {return __ptr_;}\n    _LIBCPP_INLINE_VISIBILITY\n    long use_count() const _NOEXCEPT {return __cntrl_ ? __cntrl_->use_count() : 0;}\n    _LIBCPP_INLINE_VISIBILITY\n    bool unique() const _NOEXCEPT {return use_count() == 1;}\n    _LIBCPP_INLINE_VISIBILITY\n    _LIBCPP_EXPLICIT operator bool() const _NOEXCEPT {return get() != 0;}\n    template <class _Up>\n        _LIBCPP_INLINE_VISIBILITY\n        bool owner_before(shared_ptr<_Up> const& __p) const\n        {return __cntrl_ < __p.__cntrl_;}\n    template <class _Up>\n        _LIBCPP_INLINE_VISIBILITY\n        bool owner_before(weak_ptr<_Up> const& __p) const\n        {return __cntrl_ < __p.__cntrl_;}\n    _LIBCPP_INLINE_VISIBILITY\n    bool\n    __owner_equivalent(const shared_ptr& __p) const\n        {return __cntrl_ == __p.__cntrl_;}\n\n#ifndef _LIBCPP_NO_RTTI\n    template <class _Dp>\n        _LIBCPP_INLINE_VISIBILITY\n        _Dp* __get_deleter() const _NOEXCEPT\n            {return (_Dp*)(__cntrl_ ? __cntrl_->__get_deleter(typeid(_Dp)) : 0);}\n#endif  // _LIBCPP_NO_RTTI\n\n#ifndef _LIBCPP_HAS_NO_VARIADICS\n\n    template<class ..._Args>\n        static\n        shared_ptr<_Tp>\n        make_shared(_Args&& ...__args);\n\n    template<class _Alloc, class ..._Args>\n        static\n        shared_ptr<_Tp>\n        allocate_shared(const _Alloc& __a, _Args&& ...__args);\n\n#else  // _LIBCPP_HAS_NO_VARIADICS\n\n    static shared_ptr<_Tp> make_shared();\n\n    template<class _A0>\n        static shared_ptr<_Tp> make_shared(_A0&);\n\n    template<class _A0, class _A1>\n        static shared_ptr<_Tp> make_shared(_A0&, _A1&);\n\n    template<class _A0, class _A1, class _A2>\n        static shared_ptr<_Tp> make_shared(_A0&, _A1&, _A2&);\n\n    template<class _Alloc>\n        static shared_ptr<_Tp>\n        allocate_shared(const _Alloc& __a);\n\n    template<class _Alloc, class _A0>\n        static shared_ptr<_Tp>\n        allocate_shared(const _Alloc& __a, _A0& __a0);\n\n    template<class _Alloc, class _A0, class _A1>\n        static shared_ptr<_Tp>\n        allocate_shared(const _Alloc& __a, _A0& __a0, _A1& __a1);\n\n    template<class _Alloc, class _A0, class _A1, class _A2>\n        static shared_ptr<_Tp>\n        allocate_shared(const _Alloc& __a, _A0& __a0, _A1& __a1, _A2& __a2);\n\n#endif  // _LIBCPP_HAS_NO_VARIADICS\n\nprivate:\n\n    template <class _Yp, class _OrigPtr>\n        _LIBCPP_INLINE_VISIBILITY\n        void\n        __enable_weak_this(const enable_shared_from_this<_Yp>* __e,\n                           _OrigPtr* __ptr) _NOEXCEPT\n        {\n            typedef typename remove_cv<_Yp>::type _RawYp;\n            if (__e && __e->__weak_this_.expired())\n            {\n                __e->__weak_this_ = shared_ptr<_RawYp>(*this,\n                    const_cast<_RawYp*>(static_cast<const _Yp*>(__ptr)));\n            }\n        }\n\n    _LIBCPP_INLINE_VISIBILITY\n    void __enable_weak_this(const volatile void*, const volatile void*) _NOEXCEPT {}\n\n    template <class _Up> friend class _LIBCPP_TEMPLATE_VIS shared_ptr;\n    template <class _Up> friend class _LIBCPP_TEMPLATE_VIS weak_ptr;\n};\n\ntemplate<class _Tp>\ninline\n_LIBCPP_CONSTEXPR\nshared_ptr<_Tp>::shared_ptr() _NOEXCEPT\n    : __ptr_(0),\n      __cntrl_(0)\n{\n}\n\ntemplate<class _Tp>\ninline\n_LIBCPP_CONSTEXPR\nshared_ptr<_Tp>::shared_ptr(nullptr_t) _NOEXCEPT\n    : __ptr_(0),\n      __cntrl_(0)\n{\n}\n\ntemplate<class _Tp>\ntemplate<class _Yp>\nshared_ptr<_Tp>::shared_ptr(_Yp* __p,\n                            typename enable_if<is_convertible<_Yp*, element_type*>::value, __nat>::type)\n    : __ptr_(__p)\n{\n    unique_ptr<_Yp> __hold(__p);\n    typedef __shared_ptr_pointer<_Yp*, default_delete<_Yp>, allocator<_Yp> > _CntrlBlk;\n    __cntrl_ = new _CntrlBlk(__p, default_delete<_Yp>(), allocator<_Yp>());\n    __hold.release();\n    __enable_weak_this(__p, __p);\n}\n\ntemplate<class _Tp>\ntemplate<class _Yp, class _Dp>\nshared_ptr<_Tp>::shared_ptr(_Yp* __p, _Dp __d,\n                            typename enable_if<is_convertible<_Yp*, element_type*>::value, __nat>::type)\n    : __ptr_(__p)\n{\n#ifndef _LIBCPP_NO_EXCEPTIONS\n    try\n    {\n#endif  // _LIBCPP_NO_EXCEPTIONS\n        typedef __shared_ptr_pointer<_Yp*, _Dp, allocator<_Yp> > _CntrlBlk;\n        __cntrl_ = new _CntrlBlk(__p, __d, allocator<_Yp>());\n        __enable_weak_this(__p, __p);\n#ifndef _LIBCPP_NO_EXCEPTIONS\n    }\n    catch (...)\n    {\n        __d(__p);\n        throw;\n    }\n#endif  // _LIBCPP_NO_EXCEPTIONS\n}\n\ntemplate<class _Tp>\ntemplate<class _Dp>\nshared_ptr<_Tp>::shared_ptr(nullptr_t __p, _Dp __d)\n    : __ptr_(0)\n{\n#ifndef _LIBCPP_NO_EXCEPTIONS\n    try\n    {\n#endif  // _LIBCPP_NO_EXCEPTIONS\n        typedef __shared_ptr_pointer<nullptr_t, _Dp, allocator<_Tp> > _CntrlBlk;\n        __cntrl_ = new _CntrlBlk(__p, __d, allocator<_Tp>());\n#ifndef _LIBCPP_NO_EXCEPTIONS\n    }\n    catch (...)\n    {\n        __d(__p);\n        throw;\n    }\n#endif  // _LIBCPP_NO_EXCEPTIONS\n}\n\ntemplate<class _Tp>\ntemplate<class _Yp, class _Dp, class _Alloc>\nshared_ptr<_Tp>::shared_ptr(_Yp* __p, _Dp __d, _Alloc __a,\n                            typename enable_if<is_convertible<_Yp*, element_type*>::value, __nat>::type)\n    : __ptr_(__p)\n{\n#ifndef _LIBCPP_NO_EXCEPTIONS\n    try\n    {\n#endif  // _LIBCPP_NO_EXCEPTIONS\n        typedef __shared_ptr_pointer<_Yp*, _Dp, _Alloc> _CntrlBlk;\n        typedef typename __allocator_traits_rebind<_Alloc, _CntrlBlk>::type _A2;\n        typedef __allocator_destructor<_A2> _D2;\n        _A2 __a2(__a);\n        unique_ptr<_CntrlBlk, _D2> __hold2(__a2.allocate(1), _D2(__a2, 1));\n        ::new(static_cast<void*>(_VSTD::addressof(*__hold2.get())))\n            _CntrlBlk(__p, __d, __a);\n        __cntrl_ = _VSTD::addressof(*__hold2.release());\n        __enable_weak_this(__p, __p);\n#ifndef _LIBCPP_NO_EXCEPTIONS\n    }\n    catch (...)\n    {\n        __d(__p);\n        throw;\n    }\n#endif  // _LIBCPP_NO_EXCEPTIONS\n}\n\ntemplate<class _Tp>\ntemplate<class _Dp, class _Alloc>\nshared_ptr<_Tp>::shared_ptr(nullptr_t __p, _Dp __d, _Alloc __a)\n    : __ptr_(0)\n{\n#ifndef _LIBCPP_NO_EXCEPTIONS\n    try\n    {\n#endif  // _LIBCPP_NO_EXCEPTIONS\n        typedef __shared_ptr_pointer<nullptr_t, _Dp, _Alloc> _CntrlBlk;\n        typedef typename __allocator_traits_rebind<_Alloc, _CntrlBlk>::type _A2;\n        typedef __allocator_destructor<_A2> _D2;\n        _A2 __a2(__a);\n        unique_ptr<_CntrlBlk, _D2> __hold2(__a2.allocate(1), _D2(__a2, 1));\n        ::new(static_cast<void*>(_VSTD::addressof(*__hold2.get())))\n            _CntrlBlk(__p, __d, __a);\n        __cntrl_ = _VSTD::addressof(*__hold2.release());\n#ifndef _LIBCPP_NO_EXCEPTIONS\n    }\n    catch (...)\n    {\n        __d(__p);\n        throw;\n    }\n#endif  // _LIBCPP_NO_EXCEPTIONS\n}\n\ntemplate<class _Tp>\ntemplate<class _Yp>\ninline\nshared_ptr<_Tp>::shared_ptr(const shared_ptr<_Yp>& __r, element_type *__p) _NOEXCEPT\n    : __ptr_(__p),\n      __cntrl_(__r.__cntrl_)\n{\n    if (__cntrl_)\n        __cntrl_->__add_shared();\n}\n\ntemplate<class _Tp>\ninline\nshared_ptr<_Tp>::shared_ptr(const shared_ptr& __r) _NOEXCEPT\n    : __ptr_(__r.__ptr_),\n      __cntrl_(__r.__cntrl_)\n{\n    if (__cntrl_)\n        __cntrl_->__add_shared();\n}\n\ntemplate<class _Tp>\ntemplate<class _Yp>\ninline\nshared_ptr<_Tp>::shared_ptr(const shared_ptr<_Yp>& __r,\n                            typename enable_if<is_convertible<_Yp*, element_type*>::value, __nat>::type)\n         _NOEXCEPT\n    : __ptr_(__r.__ptr_),\n      __cntrl_(__r.__cntrl_)\n{\n    if (__cntrl_)\n        __cntrl_->__add_shared();\n}\n\n#ifndef _LIBCPP_HAS_NO_RVALUE_REFERENCES\n\ntemplate<class _Tp>\ninline\nshared_ptr<_Tp>::shared_ptr(shared_ptr&& __r) _NOEXCEPT\n    : __ptr_(__r.__ptr_),\n      __cntrl_(__r.__cntrl_)\n{\n    __r.__ptr_ = 0;\n    __r.__cntrl_ = 0;\n}\n\ntemplate<class _Tp>\ntemplate<class _Yp>\ninline\nshared_ptr<_Tp>::shared_ptr(shared_ptr<_Yp>&& __r,\n                            typename enable_if<is_convertible<_Yp*, element_type*>::value, __nat>::type)\n         _NOEXCEPT\n    : __ptr_(__r.__ptr_),\n      __cntrl_(__r.__cntrl_)\n{\n    __r.__ptr_ = 0;\n    __r.__cntrl_ = 0;\n}\n\n#endif  // _LIBCPP_HAS_NO_RVALUE_REFERENCES\n\ntemplate<class _Tp>\ntemplate<class _Yp>\n#ifndef _LIBCPP_HAS_NO_RVALUE_REFERENCES\nshared_ptr<_Tp>::shared_ptr(auto_ptr<_Yp>&& __r,\n#else\nshared_ptr<_Tp>::shared_ptr(auto_ptr<_Yp> __r,\n#endif\n                            typename enable_if<is_convertible<_Yp*, element_type*>::value, __nat>::type)\n    : __ptr_(__r.get())\n{\n    typedef __shared_ptr_pointer<_Yp*, default_delete<_Yp>, allocator<_Yp> > _CntrlBlk;\n    __cntrl_ = new _CntrlBlk(__r.get(), default_delete<_Yp>(), allocator<_Yp>());\n    __enable_weak_this(__r.get(), __r.get());\n    __r.release();\n}\n\ntemplate<class _Tp>\ntemplate <class _Yp, class _Dp>\n#ifndef _LIBCPP_HAS_NO_RVALUE_REFERENCES\nshared_ptr<_Tp>::shared_ptr(unique_ptr<_Yp, _Dp>&& __r,\n#else\nshared_ptr<_Tp>::shared_ptr(unique_ptr<_Yp, _Dp> __r,\n#endif\n                            typename enable_if\n                            <\n                                !is_lvalue_reference<_Dp>::value &&\n                                !is_array<_Yp>::value &&\n                                is_convertible<typename unique_ptr<_Yp, _Dp>::pointer, element_type*>::value,\n                                __nat\n                            >::type)\n    : __ptr_(__r.get())\n{\n#if _LIBCPP_STD_VER > 11\n    if (__ptr_ == nullptr)\n        __cntrl_ = nullptr;\n    else\n#endif\n    {\n        typedef __shared_ptr_pointer<_Yp*, _Dp, allocator<_Yp> > _CntrlBlk;\n        __cntrl_ = new _CntrlBlk(__r.get(), __r.get_deleter(), allocator<_Yp>());\n        __enable_weak_this(__r.get(), __r.get());\n    }\n    __r.release();\n}\n\ntemplate<class _Tp>\ntemplate <class _Yp, class _Dp>\n#ifndef _LIBCPP_HAS_NO_RVALUE_REFERENCES\nshared_ptr<_Tp>::shared_ptr(unique_ptr<_Yp, _Dp>&& __r,\n#else\nshared_ptr<_Tp>::shared_ptr(unique_ptr<_Yp, _Dp> __r,\n#endif\n                            typename enable_if\n                            <\n                                is_lvalue_reference<_Dp>::value &&\n                                !is_array<_Yp>::value &&\n                                is_convertible<typename unique_ptr<_Yp, _Dp>::pointer, element_type*>::value,\n                                __nat\n                            >::type)\n    : __ptr_(__r.get())\n{\n#if _LIBCPP_STD_VER > 11\n    if (__ptr_ == nullptr)\n        __cntrl_ = nullptr;\n    else\n#endif\n    {\n        typedef __shared_ptr_pointer<_Yp*,\n                                     reference_wrapper<typename remove_reference<_Dp>::type>,\n                                     allocator<_Yp> > _CntrlBlk;\n        __cntrl_ = new _CntrlBlk(__r.get(), ref(__r.get_deleter()), allocator<_Yp>());\n        __enable_weak_this(__r.get(), __r.get());\n    }\n    __r.release();\n}\n\n#ifndef _LIBCPP_HAS_NO_VARIADICS\n\ntemplate<class _Tp>\ntemplate<class ..._Args>\nshared_ptr<_Tp>\nshared_ptr<_Tp>::make_shared(_Args&& ...__args)\n{\n    typedef __shared_ptr_emplace<_Tp, allocator<_Tp> > _CntrlBlk;\n    typedef allocator<_CntrlBlk> _A2;\n    typedef __allocator_destructor<_A2> _D2;\n    _A2 __a2;\n    unique_ptr<_CntrlBlk, _D2> __hold2(__a2.allocate(1), _D2(__a2, 1));\n    ::new(__hold2.get()) _CntrlBlk(__a2, _VSTD::forward<_Args>(__args)...);\n    shared_ptr<_Tp> __r;\n    __r.__ptr_ = __hold2.get()->get();\n    __r.__cntrl_ = __hold2.release();\n    __r.__enable_weak_this(__r.__ptr_, __r.__ptr_);\n    return __r;\n}\n\ntemplate<class _Tp>\ntemplate<class _Alloc, class ..._Args>\nshared_ptr<_Tp>\nshared_ptr<_Tp>::allocate_shared(const _Alloc& __a, _Args&& ...__args)\n{\n    typedef __shared_ptr_emplace<_Tp, _Alloc> _CntrlBlk;\n    typedef typename __allocator_traits_rebind<_Alloc, _CntrlBlk>::type _A2;\n    typedef __allocator_destructor<_A2> _D2;\n    _A2 __a2(__a);\n    unique_ptr<_CntrlBlk, _D2> __hold2(__a2.allocate(1), _D2(__a2, 1));\n    ::new(static_cast<void*>(_VSTD::addressof(*__hold2.get())))\n        _CntrlBlk(__a, _VSTD::forward<_Args>(__args)...);\n    shared_ptr<_Tp> __r;\n    __r.__ptr_ = __hold2.get()->get();\n    __r.__cntrl_ = _VSTD::addressof(*__hold2.release());\n    __r.__enable_weak_this(__r.__ptr_, __r.__ptr_);\n    return __r;\n}\n\n#else  // _LIBCPP_HAS_NO_VARIADICS\n\ntemplate<class _Tp>\nshared_ptr<_Tp>\nshared_ptr<_Tp>::make_shared()\n{\n    typedef __shared_ptr_emplace<_Tp, allocator<_Tp> > _CntrlBlk;\n    typedef allocator<_CntrlBlk> _Alloc2;\n    typedef __allocator_destructor<_Alloc2> _D2;\n    _Alloc2 __alloc2;\n    unique_ptr<_CntrlBlk, _D2> __hold2(__alloc2.allocate(1), _D2(__alloc2, 1));\n    ::new(__hold2.get()) _CntrlBlk(__alloc2);\n    shared_ptr<_Tp> __r;\n    __r.__ptr_ = __hold2.get()->get();\n    __r.__cntrl_ = __hold2.release();\n    __r.__enable_weak_this(__r.__ptr_, __r.__ptr_);\n    return __r;\n}\n\ntemplate<class _Tp>\ntemplate<class _A0>\nshared_ptr<_Tp>\nshared_ptr<_Tp>::make_shared(_A0& __a0)\n{\n    typedef __shared_ptr_emplace<_Tp, allocator<_Tp> > _CntrlBlk;\n    typedef allocator<_CntrlBlk> _Alloc2;\n    typedef __allocator_destructor<_Alloc2> _D2;\n    _Alloc2 __alloc2;\n    unique_ptr<_CntrlBlk, _D2> __hold2(__alloc2.allocate(1), _D2(__alloc2, 1));\n    ::new(__hold2.get()) _CntrlBlk(__alloc2, __a0);\n    shared_ptr<_Tp> __r;\n    __r.__ptr_ = __hold2.get()->get();\n    __r.__cntrl_ = __hold2.release();\n    __r.__enable_weak_this(__r.__ptr_, __r.__ptr_);\n    return __r;\n}\n\ntemplate<class _Tp>\ntemplate<class _A0, class _A1>\nshared_ptr<_Tp>\nshared_ptr<_Tp>::make_shared(_A0& __a0, _A1& __a1)\n{\n    typedef __shared_ptr_emplace<_Tp, allocator<_Tp> > _CntrlBlk;\n    typedef allocator<_CntrlBlk> _Alloc2;\n    typedef __allocator_destructor<_Alloc2> _D2;\n    _Alloc2 __alloc2;\n    unique_ptr<_CntrlBlk, _D2> __hold2(__alloc2.allocate(1), _D2(__alloc2, 1));\n    ::new(__hold2.get()) _CntrlBlk(__alloc2, __a0, __a1);\n    shared_ptr<_Tp> __r;\n    __r.__ptr_ = __hold2.get()->get();\n    __r.__cntrl_ = __hold2.release();\n    __r.__enable_weak_this(__r.__ptr_, __r.__ptr_);\n    return __r;\n}\n\ntemplate<class _Tp>\ntemplate<class _A0, class _A1, class _A2>\nshared_ptr<_Tp>\nshared_ptr<_Tp>::make_shared(_A0& __a0, _A1& __a1, _A2& __a2)\n{\n    typedef __shared_ptr_emplace<_Tp, allocator<_Tp> > _CntrlBlk;\n    typedef allocator<_CntrlBlk> _Alloc2;\n    typedef __allocator_destructor<_Alloc2> _D2;\n    _Alloc2 __alloc2;\n    unique_ptr<_CntrlBlk, _D2> __hold2(__alloc2.allocate(1), _D2(__alloc2, 1));\n    ::new(__hold2.get()) _CntrlBlk(__alloc2, __a0, __a1, __a2);\n    shared_ptr<_Tp> __r;\n    __r.__ptr_ = __hold2.get()->get();\n    __r.__cntrl_ = __hold2.release();\n    __r.__enable_weak_this(__r.__ptr_, __r.__ptr_);\n    return __r;\n}\n\ntemplate<class _Tp>\ntemplate<class _Alloc>\nshared_ptr<_Tp>\nshared_ptr<_Tp>::allocate_shared(const _Alloc& __a)\n{\n    typedef __shared_ptr_emplace<_Tp, _Alloc> _CntrlBlk;\n    typedef typename __allocator_traits_rebind<_Alloc, _CntrlBlk>::type _Alloc2;\n    typedef __allocator_destructor<_Alloc2> _D2;\n    _Alloc2 __alloc2(__a);\n    unique_ptr<_CntrlBlk, _D2> __hold2(__alloc2.allocate(1), _D2(__alloc2, 1));\n    ::new(static_cast<void*>(_VSTD::addressof(*__hold2.get())))\n        _CntrlBlk(__a);\n    shared_ptr<_Tp> __r;\n    __r.__ptr_ = __hold2.get()->get();\n    __r.__cntrl_ = _VSTD::addressof(*__hold2.release());\n    __r.__enable_weak_this(__r.__ptr_, __r.__ptr_);\n    return __r;\n}\n\ntemplate<class _Tp>\ntemplate<class _Alloc, class _A0>\nshared_ptr<_Tp>\nshared_ptr<_Tp>::allocate_shared(const _Alloc& __a, _A0& __a0)\n{\n    typedef __shared_ptr_emplace<_Tp, _Alloc> _CntrlBlk;\n    typedef typename __allocator_traits_rebind<_Alloc, _CntrlBlk>::type _Alloc2;\n    typedef __allocator_destructor<_Alloc2> _D2;\n    _Alloc2 __alloc2(__a);\n    unique_ptr<_CntrlBlk, _D2> __hold2(__alloc2.allocate(1), _D2(__alloc2, 1));\n    ::new(static_cast<void*>(_VSTD::addressof(*__hold2.get())))\n        _CntrlBlk(__a, __a0);\n    shared_ptr<_Tp> __r;\n    __r.__ptr_ = __hold2.get()->get();\n    __r.__cntrl_ = _VSTD::addressof(*__hold2.release());\n    __r.__enable_weak_this(__r.__ptr_, __r.__ptr_);\n    return __r;\n}\n\ntemplate<class _Tp>\ntemplate<class _Alloc, class _A0, class _A1>\nshared_ptr<_Tp>\nshared_ptr<_Tp>::allocate_shared(const _Alloc& __a, _A0& __a0, _A1& __a1)\n{\n    typedef __shared_ptr_emplace<_Tp, _Alloc> _CntrlBlk;\n    typedef typename __allocator_traits_rebind<_Alloc, _CntrlBlk>::type _Alloc2;\n    typedef __allocator_destructor<_Alloc2> _D2;\n    _Alloc2 __alloc2(__a);\n    unique_ptr<_CntrlBlk, _D2> __hold2(__alloc2.allocate(1), _D2(__alloc2, 1));\n    ::new(static_cast<void*>(_VSTD::addressof(*__hold2.get())))\n        _CntrlBlk(__a, __a0, __a1);\n    shared_ptr<_Tp> __r;\n    __r.__ptr_ = __hold2.get()->get();\n    __r.__cntrl_ = _VSTD::addressof(*__hold2.release());\n    __r.__enable_weak_this(__r.__ptr_, __r.__ptr_);\n    return __r;\n}\n\ntemplate<class _Tp>\ntemplate<class _Alloc, class _A0, class _A1, class _A2>\nshared_ptr<_Tp>\nshared_ptr<_Tp>::allocate_shared(const _Alloc& __a, _A0& __a0, _A1& __a1, _A2& __a2)\n{\n    typedef __shared_ptr_emplace<_Tp, _Alloc> _CntrlBlk;\n    typedef typename __allocator_traits_rebind<_Alloc, _CntrlBlk>::type _Alloc2;\n    typedef __allocator_destructor<_Alloc2> _D2;\n    _Alloc2 __alloc2(__a);\n    unique_ptr<_CntrlBlk, _D2> __hold2(__alloc2.allocate(1), _D2(__alloc2, 1));\n    ::new(static_cast<void*>(_VSTD::addressof(*__hold2.get())))\n        _CntrlBlk(__a, __a0, __a1, __a2);\n    shared_ptr<_Tp> __r;\n    __r.__ptr_ = __hold2.get()->get();\n    __r.__cntrl_ = _VSTD::addressof(*__hold2.release());\n    __r.__enable_weak_this(__r.__ptr_, __r.__ptr_);\n    return __r;\n}\n\n#endif  // _LIBCPP_HAS_NO_VARIADICS\n\ntemplate<class _Tp>\nshared_ptr<_Tp>::~shared_ptr()\n{\n    if (__cntrl_)\n        __cntrl_->__release_shared();\n}\n\ntemplate<class _Tp>\ninline\nshared_ptr<_Tp>&\nshared_ptr<_Tp>::operator=(const shared_ptr& __r) _NOEXCEPT\n{\n    shared_ptr(__r).swap(*this);\n    return *this;\n}\n\ntemplate<class _Tp>\ntemplate<class _Yp>\ninline\ntypename enable_if\n<\n    is_convertible<_Yp*, typename shared_ptr<_Tp>::element_type*>::value,\n    shared_ptr<_Tp>&\n>::type\nshared_ptr<_Tp>::operator=(const shared_ptr<_Yp>& __r) _NOEXCEPT\n{\n    shared_ptr(__r).swap(*this);\n    return *this;\n}\n\n#ifndef _LIBCPP_HAS_NO_RVALUE_REFERENCES\n\ntemplate<class _Tp>\ninline\nshared_ptr<_Tp>&\nshared_ptr<_Tp>::operator=(shared_ptr&& __r) _NOEXCEPT\n{\n    shared_ptr(_VSTD::move(__r)).swap(*this);\n    return *this;\n}\n\ntemplate<class _Tp>\ntemplate<class _Yp>\ninline\ntypename enable_if\n<\n    is_convertible<_Yp*, typename shared_ptr<_Tp>::element_type*>::value,\n    shared_ptr<_Tp>&\n>::type\nshared_ptr<_Tp>::operator=(shared_ptr<_Yp>&& __r)\n{\n    shared_ptr(_VSTD::move(__r)).swap(*this);\n    return *this;\n}\n\ntemplate<class _Tp>\ntemplate<class _Yp>\ninline\ntypename enable_if\n<\n    !is_array<_Yp>::value &&\n    is_convertible<_Yp*, typename shared_ptr<_Tp>::element_type*>::value,\n    shared_ptr<_Tp>\n>::type&\nshared_ptr<_Tp>::operator=(auto_ptr<_Yp>&& __r)\n{\n    shared_ptr(_VSTD::move(__r)).swap(*this);\n    return *this;\n}\n\ntemplate<class _Tp>\ntemplate <class _Yp, class _Dp>\ninline\ntypename enable_if\n<\n    !is_array<_Yp>::value &&\n    is_convertible<typename unique_ptr<_Yp, _Dp>::pointer, \n                   typename shared_ptr<_Tp>::element_type*>::value,\n    shared_ptr<_Tp>&\n>::type\nshared_ptr<_Tp>::operator=(unique_ptr<_Yp, _Dp>&& __r)\n{\n    shared_ptr(_VSTD::move(__r)).swap(*this);\n    return *this;\n}\n\n#else  // _LIBCPP_HAS_NO_RVALUE_REFERENCES\n\ntemplate<class _Tp>\ntemplate<class _Yp>\ninline _LIBCPP_INLINE_VISIBILITY\ntypename enable_if\n<\n    !is_array<_Yp>::value &&\n    is_convertible<_Yp*, typename shared_ptr<_Tp>::element_type*>::value,\n    shared_ptr<_Tp>&\n>::type\nshared_ptr<_Tp>::operator=(auto_ptr<_Yp> __r)\n{\n    shared_ptr(__r).swap(*this);\n    return *this;\n}\n\ntemplate<class _Tp>\ntemplate <class _Yp, class _Dp>\ninline _LIBCPP_INLINE_VISIBILITY\ntypename enable_if\n<\n    !is_array<_Yp>::value &&\n    is_convertible<typename unique_ptr<_Yp, _Dp>::pointer, \n                   typename shared_ptr<_Tp>::element_type*>::value,\n    shared_ptr<_Tp>&\n>::type\nshared_ptr<_Tp>::operator=(unique_ptr<_Yp, _Dp> __r)\n{\n    shared_ptr(_VSTD::move(__r)).swap(*this);\n    return *this;\n}\n\n#endif  // _LIBCPP_HAS_NO_RVALUE_REFERENCES\n\ntemplate<class _Tp>\ninline\nvoid\nshared_ptr<_Tp>::swap(shared_ptr& __r) _NOEXCEPT\n{\n    _VSTD::swap(__ptr_, __r.__ptr_);\n    _VSTD::swap(__cntrl_, __r.__cntrl_);\n}\n\ntemplate<class _Tp>\ninline\nvoid\nshared_ptr<_Tp>::reset() _NOEXCEPT\n{\n    shared_ptr().swap(*this);\n}\n\ntemplate<class _Tp>\ntemplate<class _Yp>\ninline\ntypename enable_if\n<\n    is_convertible<_Yp*, typename shared_ptr<_Tp>::element_type*>::value,\n    void\n>::type\nshared_ptr<_Tp>::reset(_Yp* __p)\n{\n    shared_ptr(__p).swap(*this);\n}\n\ntemplate<class _Tp>\ntemplate<class _Yp, class _Dp>\ninline\ntypename enable_if\n<\n    is_convertible<_Yp*, typename shared_ptr<_Tp>::element_type*>::value,\n    void\n>::type\nshared_ptr<_Tp>::reset(_Yp* __p, _Dp __d)\n{\n    shared_ptr(__p, __d).swap(*this);\n}\n\ntemplate<class _Tp>\ntemplate<class _Yp, class _Dp, class _Alloc>\ninline\ntypename enable_if\n<\n    is_convertible<_Yp*, typename shared_ptr<_Tp>::element_type*>::value,\n    void\n>::type\nshared_ptr<_Tp>::reset(_Yp* __p, _Dp __d, _Alloc __a)\n{\n    shared_ptr(__p, __d, __a).swap(*this);\n}\n\n#ifndef _LIBCPP_HAS_NO_VARIADICS\n\ntemplate<class _Tp, class ..._Args>\ninline _LIBCPP_INLINE_VISIBILITY\ntypename enable_if\n<\n    !is_array<_Tp>::value,\n    shared_ptr<_Tp>\n>::type\nmake_shared(_Args&& ...__args)\n{\n    return shared_ptr<_Tp>::make_shared(_VSTD::forward<_Args>(__args)...);\n}\n\ntemplate<class _Tp, class _Alloc, class ..._Args>\ninline _LIBCPP_INLINE_VISIBILITY\ntypename enable_if\n<\n    !is_array<_Tp>::value,\n    shared_ptr<_Tp>\n>::type\nallocate_shared(const _Alloc& __a, _Args&& ...__args)\n{\n    return shared_ptr<_Tp>::allocate_shared(__a, _VSTD::forward<_Args>(__args)...);\n}\n\n#else  // _LIBCPP_HAS_NO_VARIADICS\n\ntemplate<class _Tp>\ninline _LIBCPP_INLINE_VISIBILITY\nshared_ptr<_Tp>\nmake_shared()\n{\n    return shared_ptr<_Tp>::make_shared();\n}\n\ntemplate<class _Tp, class _A0>\ninline _LIBCPP_INLINE_VISIBILITY\nshared_ptr<_Tp>\nmake_shared(_A0& __a0)\n{\n    return shared_ptr<_Tp>::make_shared(__a0);\n}\n\ntemplate<class _Tp, class _A0, class _A1>\ninline _LIBCPP_INLINE_VISIBILITY\nshared_ptr<_Tp>\nmake_shared(_A0& __a0, _A1& __a1)\n{\n    return shared_ptr<_Tp>::make_shared(__a0, __a1);\n}\n\ntemplate<class _Tp, class _A0, class _A1, class _A2>\ninline _LIBCPP_INLINE_VISIBILITY\nshared_ptr<_Tp>\nmake_shared(_A0& __a0, _A1& __a1, _A2& __a2)\n{\n    return shared_ptr<_Tp>::make_shared(__a0, __a1, __a2);\n}\n\ntemplate<class _Tp, class _Alloc>\ninline _LIBCPP_INLINE_VISIBILITY\nshared_ptr<_Tp>\nallocate_shared(const _Alloc& __a)\n{\n    return shared_ptr<_Tp>::allocate_shared(__a);\n}\n\ntemplate<class _Tp, class _Alloc, class _A0>\ninline _LIBCPP_INLINE_VISIBILITY\nshared_ptr<_Tp>\nallocate_shared(const _Alloc& __a, _A0& __a0)\n{\n    return shared_ptr<_Tp>::allocate_shared(__a, __a0);\n}\n\ntemplate<class _Tp, class _Alloc, class _A0, class _A1>\ninline _LIBCPP_INLINE_VISIBILITY\nshared_ptr<_Tp>\nallocate_shared(const _Alloc& __a, _A0& __a0, _A1& __a1)\n{\n    return shared_ptr<_Tp>::allocate_shared(__a, __a0, __a1);\n}\n\ntemplate<class _Tp, class _Alloc, class _A0, class _A1, class _A2>\ninline _LIBCPP_INLINE_VISIBILITY\nshared_ptr<_Tp>\nallocate_shared(const _Alloc& __a, _A0& __a0, _A1& __a1, _A2& __a2)\n{\n    return shared_ptr<_Tp>::allocate_shared(__a, __a0, __a1, __a2);\n}\n\n#endif  // _LIBCPP_HAS_NO_VARIADICS\n\ntemplate<class _Tp, class _Up>\ninline _LIBCPP_INLINE_VISIBILITY\nbool\noperator==(const shared_ptr<_Tp>& __x, const shared_ptr<_Up>& __y) _NOEXCEPT\n{\n    return __x.get() == __y.get();\n}\n\ntemplate<class _Tp, class _Up>\ninline _LIBCPP_INLINE_VISIBILITY\nbool\noperator!=(const shared_ptr<_Tp>& __x, const shared_ptr<_Up>& __y) _NOEXCEPT\n{\n    return !(__x == __y);\n}\n\ntemplate<class _Tp, class _Up>\ninline _LIBCPP_INLINE_VISIBILITY\nbool\noperator<(const shared_ptr<_Tp>& __x, const shared_ptr<_Up>& __y) _NOEXCEPT\n{\n    typedef typename common_type<_Tp*, _Up*>::type _Vp;\n    return less<_Vp>()(__x.get(), __y.get());\n}\n\ntemplate<class _Tp, class _Up>\ninline _LIBCPP_INLINE_VISIBILITY\nbool\noperator>(const shared_ptr<_Tp>& __x, const shared_ptr<_Up>& __y) _NOEXCEPT\n{\n    return __y < __x;\n}\n\ntemplate<class _Tp, class _Up>\ninline _LIBCPP_INLINE_VISIBILITY\nbool\noperator<=(const shared_ptr<_Tp>& __x, const shared_ptr<_Up>& __y) _NOEXCEPT\n{\n    return !(__y < __x);\n}\n\ntemplate<class _Tp, class _Up>\ninline _LIBCPP_INLINE_VISIBILITY\nbool\noperator>=(const shared_ptr<_Tp>& __x, const shared_ptr<_Up>& __y) _NOEXCEPT\n{\n    return !(__x < __y);\n}\n\ntemplate<class _Tp>\ninline _LIBCPP_INLINE_VISIBILITY\nbool\noperator==(const shared_ptr<_Tp>& __x, nullptr_t) _NOEXCEPT\n{\n    return !__x;\n}\n\ntemplate<class _Tp>\ninline _LIBCPP_INLINE_VISIBILITY\nbool\noperator==(nullptr_t, const shared_ptr<_Tp>& __x) _NOEXCEPT\n{\n    return !__x;\n}\n\ntemplate<class _Tp>\ninline _LIBCPP_INLINE_VISIBILITY\nbool\noperator!=(const shared_ptr<_Tp>& __x, nullptr_t) _NOEXCEPT\n{\n    return static_cast<bool>(__x);\n}\n\ntemplate<class _Tp>\ninline _LIBCPP_INLINE_VISIBILITY\nbool\noperator!=(nullptr_t, const shared_ptr<_Tp>& __x) _NOEXCEPT\n{\n    return static_cast<bool>(__x);\n}\n\ntemplate<class _Tp>\ninline _LIBCPP_INLINE_VISIBILITY\nbool\noperator<(const shared_ptr<_Tp>& __x, nullptr_t) _NOEXCEPT\n{\n    return less<_Tp*>()(__x.get(), nullptr);\n}\n\ntemplate<class _Tp>\ninline _LIBCPP_INLINE_VISIBILITY\nbool\noperator<(nullptr_t, const shared_ptr<_Tp>& __x) _NOEXCEPT\n{\n    return less<_Tp*>()(nullptr, __x.get());\n}\n\ntemplate<class _Tp>\ninline _LIBCPP_INLINE_VISIBILITY\nbool\noperator>(const shared_ptr<_Tp>& __x, nullptr_t) _NOEXCEPT\n{\n    return nullptr < __x;\n}\n\ntemplate<class _Tp>\ninline _LIBCPP_INLINE_VISIBILITY\nbool\noperator>(nullptr_t, const shared_ptr<_Tp>& __x) _NOEXCEPT\n{\n    return __x < nullptr;\n}\n\ntemplate<class _Tp>\ninline _LIBCPP_INLINE_VISIBILITY\nbool\noperator<=(const shared_ptr<_Tp>& __x, nullptr_t) _NOEXCEPT\n{\n    return !(nullptr < __x);\n}\n\ntemplate<class _Tp>\ninline _LIBCPP_INLINE_VISIBILITY\nbool\noperator<=(nullptr_t, const shared_ptr<_Tp>& __x) _NOEXCEPT\n{\n    return !(__x < nullptr);\n}\n\ntemplate<class _Tp>\ninline _LIBCPP_INLINE_VISIBILITY\nbool\noperator>=(const shared_ptr<_Tp>& __x, nullptr_t) _NOEXCEPT\n{\n    return !(__x < nullptr);\n}\n\ntemplate<class _Tp>\ninline _LIBCPP_INLINE_VISIBILITY\nbool\noperator>=(nullptr_t, const shared_ptr<_Tp>& __x) _NOEXCEPT\n{\n    return !(nullptr < __x);\n}\n\ntemplate<class _Tp>\ninline _LIBCPP_INLINE_VISIBILITY\nvoid\nswap(shared_ptr<_Tp>& __x, shared_ptr<_Tp>& __y) _NOEXCEPT\n{\n    __x.swap(__y);\n}\n\ntemplate<class _Tp, class _Up>\ninline _LIBCPP_INLINE_VISIBILITY\ntypename enable_if\n<\n    !is_array<_Tp>::value && !is_array<_Up>::value,\n    shared_ptr<_Tp>\n>::type\nstatic_pointer_cast(const shared_ptr<_Up>& __r) _NOEXCEPT\n{\n    return shared_ptr<_Tp>(__r, static_cast<_Tp*>(__r.get()));\n}\n\ntemplate<class _Tp, class _Up>\ninline _LIBCPP_INLINE_VISIBILITY\ntypename enable_if\n<\n    !is_array<_Tp>::value && !is_array<_Up>::value,\n    shared_ptr<_Tp>\n>::type\ndynamic_pointer_cast(const shared_ptr<_Up>& __r) _NOEXCEPT\n{\n    _Tp* __p = dynamic_cast<_Tp*>(__r.get());\n    return __p ? shared_ptr<_Tp>(__r, __p) : shared_ptr<_Tp>();\n}\n\ntemplate<class _Tp, class _Up>\ntypename enable_if\n<\n    is_array<_Tp>::value == is_array<_Up>::value,\n    shared_ptr<_Tp>\n>::type\nconst_pointer_cast(const shared_ptr<_Up>& __r) _NOEXCEPT\n{\n    typedef typename remove_extent<_Tp>::type _RTp;\n    return shared_ptr<_Tp>(__r, const_cast<_RTp*>(__r.get()));\n}\n\n#ifndef _LIBCPP_NO_RTTI\n\ntemplate<class _Dp, class _Tp>\ninline _LIBCPP_INLINE_VISIBILITY\n_Dp*\nget_deleter(const shared_ptr<_Tp>& __p) _NOEXCEPT\n{\n    return __p.template __get_deleter<_Dp>();\n}\n\n#endif  // _LIBCPP_NO_RTTI\n\ntemplate<class _Tp>\nclass _LIBCPP_TEMPLATE_VIS weak_ptr\n{\npublic:\n    typedef _Tp element_type;\nprivate:\n    element_type*        __ptr_;\n    __shared_weak_count* __cntrl_;\n\npublic:\n    _LIBCPP_INLINE_VISIBILITY\n    _LIBCPP_CONSTEXPR weak_ptr() _NOEXCEPT;\n    template<class _Yp> _LIBCPP_INLINE_VISIBILITY weak_ptr(shared_ptr<_Yp> const& __r,\n                   typename enable_if<is_convertible<_Yp*, _Tp*>::value, __nat*>::type = 0)\n                        _NOEXCEPT;\n    _LIBCPP_INLINE_VISIBILITY\n    weak_ptr(weak_ptr const& __r) _NOEXCEPT;\n    template<class _Yp> _LIBCPP_INLINE_VISIBILITY weak_ptr(weak_ptr<_Yp> const& __r,\n                   typename enable_if<is_convertible<_Yp*, _Tp*>::value, __nat*>::type = 0)\n                         _NOEXCEPT;\n\n#ifndef _LIBCPP_HAS_NO_RVALUE_REFERENCES\n    _LIBCPP_INLINE_VISIBILITY\n    weak_ptr(weak_ptr&& __r) _NOEXCEPT;\n    template<class _Yp> _LIBCPP_INLINE_VISIBILITY weak_ptr(weak_ptr<_Yp>&& __r,\n                   typename enable_if<is_convertible<_Yp*, _Tp*>::value, __nat*>::type = 0)\n                         _NOEXCEPT;\n#endif  // _LIBCPP_HAS_NO_RVALUE_REFERENCES\n    ~weak_ptr();\n\n    _LIBCPP_INLINE_VISIBILITY\n    weak_ptr& operator=(weak_ptr const& __r) _NOEXCEPT;\n    template<class _Yp>\n        typename enable_if\n        <\n            is_convertible<_Yp*, element_type*>::value,\n            weak_ptr&\n        >::type\n        _LIBCPP_INLINE_VISIBILITY\n        operator=(weak_ptr<_Yp> const& __r) _NOEXCEPT;\n\n#ifndef _LIBCPP_HAS_NO_RVALUE_REFERENCES\n\n    _LIBCPP_INLINE_VISIBILITY\n    weak_ptr& operator=(weak_ptr&& __r) _NOEXCEPT;\n    template<class _Yp>\n        typename enable_if\n        <\n            is_convertible<_Yp*, element_type*>::value,\n            weak_ptr&\n        >::type\n        _LIBCPP_INLINE_VISIBILITY\n        operator=(weak_ptr<_Yp>&& __r) _NOEXCEPT;\n\n#endif  // _LIBCPP_HAS_NO_RVALUE_REFERENCES\n\n    template<class _Yp>\n        typename enable_if\n        <\n            is_convertible<_Yp*, element_type*>::value,\n            weak_ptr&\n        >::type\n        _LIBCPP_INLINE_VISIBILITY\n        operator=(shared_ptr<_Yp> const& __r) _NOEXCEPT;\n\n    _LIBCPP_INLINE_VISIBILITY\n    void swap(weak_ptr& __r) _NOEXCEPT;\n    _LIBCPP_INLINE_VISIBILITY\n    void reset() _NOEXCEPT;\n\n    _LIBCPP_INLINE_VISIBILITY\n    long use_count() const _NOEXCEPT\n        {return __cntrl_ ? __cntrl_->use_count() : 0;}\n    _LIBCPP_INLINE_VISIBILITY\n    bool expired() const _NOEXCEPT\n        {return __cntrl_ == 0 || __cntrl_->use_count() == 0;}\n    shared_ptr<_Tp> lock() const _NOEXCEPT;\n    template<class _Up>\n        _LIBCPP_INLINE_VISIBILITY\n        bool owner_before(const shared_ptr<_Up>& __r) const\n        {return __cntrl_ < __r.__cntrl_;}\n    template<class _Up>\n        _LIBCPP_INLINE_VISIBILITY\n        bool owner_before(const weak_ptr<_Up>& __r) const\n        {return __cntrl_ < __r.__cntrl_;}\n\n    template <class _Up> friend class _LIBCPP_TEMPLATE_VIS weak_ptr;\n    template <class _Up> friend class _LIBCPP_TEMPLATE_VIS shared_ptr;\n};\n\ntemplate<class _Tp>\ninline\n_LIBCPP_CONSTEXPR\nweak_ptr<_Tp>::weak_ptr() _NOEXCEPT\n    : __ptr_(0),\n      __cntrl_(0)\n{\n}\n\ntemplate<class _Tp>\ninline\nweak_ptr<_Tp>::weak_ptr(weak_ptr const& __r) _NOEXCEPT\n    : __ptr_(__r.__ptr_),\n      __cntrl_(__r.__cntrl_)\n{\n    if (__cntrl_)\n        __cntrl_->__add_weak();\n}\n\ntemplate<class _Tp>\ntemplate<class _Yp>\ninline\nweak_ptr<_Tp>::weak_ptr(shared_ptr<_Yp> const& __r,\n                        typename enable_if<is_convertible<_Yp*, _Tp*>::value, __nat*>::type)\n                         _NOEXCEPT\n    : __ptr_(__r.__ptr_),\n      __cntrl_(__r.__cntrl_)\n{\n    if (__cntrl_)\n        __cntrl_->__add_weak();\n}\n\ntemplate<class _Tp>\ntemplate<class _Yp>\ninline\nweak_ptr<_Tp>::weak_ptr(weak_ptr<_Yp> const& __r,\n                        typename enable_if<is_convertible<_Yp*, _Tp*>::value, __nat*>::type)\n         _NOEXCEPT\n    : __ptr_(__r.__ptr_),\n      __cntrl_(__r.__cntrl_)\n{\n    if (__cntrl_)\n        __cntrl_->__add_weak();\n}\n\n#ifndef _LIBCPP_HAS_NO_RVALUE_REFERENCES\n\ntemplate<class _Tp>\ninline\nweak_ptr<_Tp>::weak_ptr(weak_ptr&& __r) _NOEXCEPT\n    : __ptr_(__r.__ptr_),\n      __cntrl_(__r.__cntrl_)\n{\n    __r.__ptr_ = 0;\n    __r.__cntrl_ = 0;\n}\n\ntemplate<class _Tp>\ntemplate<class _Yp>\ninline\nweak_ptr<_Tp>::weak_ptr(weak_ptr<_Yp>&& __r,\n                        typename enable_if<is_convertible<_Yp*, _Tp*>::value, __nat*>::type)\n         _NOEXCEPT\n    : __ptr_(__r.__ptr_),\n      __cntrl_(__r.__cntrl_)\n{\n    __r.__ptr_ = 0;\n    __r.__cntrl_ = 0;\n}\n\n#endif  // _LIBCPP_HAS_NO_RVALUE_REFERENCES\n\ntemplate<class _Tp>\nweak_ptr<_Tp>::~weak_ptr()\n{\n    if (__cntrl_)\n        __cntrl_->__release_weak();\n}\n\ntemplate<class _Tp>\ninline\nweak_ptr<_Tp>&\nweak_ptr<_Tp>::operator=(weak_ptr const& __r) _NOEXCEPT\n{\n    weak_ptr(__r).swap(*this);\n    return *this;\n}\n\ntemplate<class _Tp>\ntemplate<class _Yp>\ninline\ntypename enable_if\n<\n    is_convertible<_Yp*, _Tp*>::value,\n    weak_ptr<_Tp>&\n>::type\nweak_ptr<_Tp>::operator=(weak_ptr<_Yp> const& __r) _NOEXCEPT\n{\n    weak_ptr(__r).swap(*this);\n    return *this;\n}\n\n#ifndef _LIBCPP_HAS_NO_RVALUE_REFERENCES\n\ntemplate<class _Tp>\ninline\nweak_ptr<_Tp>&\nweak_ptr<_Tp>::operator=(weak_ptr&& __r) _NOEXCEPT\n{\n    weak_ptr(_VSTD::move(__r)).swap(*this);\n    return *this;\n}\n\ntemplate<class _Tp>\ntemplate<class _Yp>\ninline\ntypename enable_if\n<\n    is_convertible<_Yp*, _Tp*>::value,\n    weak_ptr<_Tp>&\n>::type\nweak_ptr<_Tp>::operator=(weak_ptr<_Yp>&& __r) _NOEXCEPT\n{\n    weak_ptr(_VSTD::move(__r)).swap(*this);\n    return *this;\n}\n\n#endif  // _LIBCPP_HAS_NO_RVALUE_REFERENCES\n\ntemplate<class _Tp>\ntemplate<class _Yp>\ninline\ntypename enable_if\n<\n    is_convertible<_Yp*, _Tp*>::value,\n    weak_ptr<_Tp>&\n>::type\nweak_ptr<_Tp>::operator=(shared_ptr<_Yp> const& __r) _NOEXCEPT\n{\n    weak_ptr(__r).swap(*this);\n    return *this;\n}\n\ntemplate<class _Tp>\ninline\nvoid\nweak_ptr<_Tp>::swap(weak_ptr& __r) _NOEXCEPT\n{\n    _VSTD::swap(__ptr_, __r.__ptr_);\n    _VSTD::swap(__cntrl_, __r.__cntrl_);\n}\n\ntemplate<class _Tp>\ninline _LIBCPP_INLINE_VISIBILITY\nvoid\nswap(weak_ptr<_Tp>& __x, weak_ptr<_Tp>& __y) _NOEXCEPT\n{\n    __x.swap(__y);\n}\n\ntemplate<class _Tp>\ninline\nvoid\nweak_ptr<_Tp>::reset() _NOEXCEPT\n{\n    weak_ptr().swap(*this);\n}\n\ntemplate<class _Tp>\ntemplate<class _Yp>\nshared_ptr<_Tp>::shared_ptr(const weak_ptr<_Yp>& __r,\n                            typename enable_if<is_convertible<_Yp*, element_type*>::value, __nat>::type)\n    : __ptr_(__r.__ptr_),\n      __cntrl_(__r.__cntrl_ ? __r.__cntrl_->lock() : __r.__cntrl_)\n{\n    if (__cntrl_ == 0)\n        __throw_bad_weak_ptr();\n}\n\ntemplate<class _Tp>\nshared_ptr<_Tp>\nweak_ptr<_Tp>::lock() const _NOEXCEPT\n{\n    shared_ptr<_Tp> __r;\n    __r.__cntrl_ = __cntrl_ ? __cntrl_->lock() : __cntrl_;\n    if (__r.__cntrl_)\n        __r.__ptr_ = __ptr_;\n    return __r;\n}\n\n#if _LIBCPP_STD_VER > 14\ntemplate <class _Tp = void> struct owner_less;\n#else\ntemplate <class _Tp> struct owner_less;\n#endif\n\ntemplate <class _Tp>\nstruct _LIBCPP_TEMPLATE_VIS owner_less<shared_ptr<_Tp> >\n    : binary_function<shared_ptr<_Tp>, shared_ptr<_Tp>, bool>\n{\n    typedef bool result_type;\n    _LIBCPP_INLINE_VISIBILITY\n    bool operator()(shared_ptr<_Tp> const& __x, shared_ptr<_Tp> const& __y) const\n        {return __x.owner_before(__y);}\n    _LIBCPP_INLINE_VISIBILITY\n    bool operator()(shared_ptr<_Tp> const& __x,   weak_ptr<_Tp> const& __y) const\n        {return __x.owner_before(__y);}\n    _LIBCPP_INLINE_VISIBILITY\n    bool operator()(  weak_ptr<_Tp> const& __x, shared_ptr<_Tp> const& __y) const\n        {return __x.owner_before(__y);}\n};\n\ntemplate <class _Tp>\nstruct _LIBCPP_TEMPLATE_VIS owner_less<weak_ptr<_Tp> >\n    : binary_function<weak_ptr<_Tp>, weak_ptr<_Tp>, bool>\n{\n    typedef bool result_type;\n    _LIBCPP_INLINE_VISIBILITY\n    bool operator()(  weak_ptr<_Tp> const& __x,   weak_ptr<_Tp> const& __y) const\n        {return __x.owner_before(__y);}\n    _LIBCPP_INLINE_VISIBILITY\n    bool operator()(shared_ptr<_Tp> const& __x,   weak_ptr<_Tp> const& __y) const\n        {return __x.owner_before(__y);}\n    _LIBCPP_INLINE_VISIBILITY\n    bool operator()(  weak_ptr<_Tp> const& __x, shared_ptr<_Tp> const& __y) const\n        {return __x.owner_before(__y);}\n};\n\n#if _LIBCPP_STD_VER > 14\ntemplate <>\nstruct _LIBCPP_TEMPLATE_VIS owner_less<void>\n{\n    template <class _Tp, class _Up>\n    _LIBCPP_INLINE_VISIBILITY\n    bool operator()( shared_ptr<_Tp> const& __x, shared_ptr<_Up> const& __y) const\n        {return __x.owner_before(__y);}\n    template <class _Tp, class _Up>\n    _LIBCPP_INLINE_VISIBILITY\n    bool operator()( shared_ptr<_Tp> const& __x,  weak_ptr<_Up> const& __y) const\n        {return __x.owner_before(__y);}\n    template <class _Tp, class _Up>\n    _LIBCPP_INLINE_VISIBILITY\n    bool operator()(   weak_ptr<_Tp> const& __x, shared_ptr<_Up> const& __y) const\n        {return __x.owner_before(__y);}\n    template <class _Tp, class _Up>\n    _LIBCPP_INLINE_VISIBILITY\n    bool operator()(   weak_ptr<_Tp> const& __x,   weak_ptr<_Up> const& __y) const\n        {return __x.owner_before(__y);}\n    typedef void is_transparent;\n};\n#endif\n\ntemplate<class _Tp>\nclass _LIBCPP_TEMPLATE_VIS enable_shared_from_this\n{\n    mutable weak_ptr<_Tp> __weak_this_;\nprotected:\n    _LIBCPP_INLINE_VISIBILITY _LIBCPP_CONSTEXPR\n    enable_shared_from_this() _NOEXCEPT {}\n    _LIBCPP_INLINE_VISIBILITY\n    enable_shared_from_this(enable_shared_from_this const&) _NOEXCEPT {}\n    _LIBCPP_INLINE_VISIBILITY\n    enable_shared_from_this& operator=(enable_shared_from_this const&) _NOEXCEPT\n        {return *this;}\n    _LIBCPP_INLINE_VISIBILITY\n    ~enable_shared_from_this() {}\npublic:\n    _LIBCPP_INLINE_VISIBILITY\n    shared_ptr<_Tp> shared_from_this()\n        {return shared_ptr<_Tp>(__weak_this_);}\n    _LIBCPP_INLINE_VISIBILITY\n    shared_ptr<_Tp const> shared_from_this() const\n        {return shared_ptr<const _Tp>(__weak_this_);}\n\n#if _LIBCPP_STD_VER > 14\n    _LIBCPP_INLINE_VISIBILITY\n    weak_ptr<_Tp> weak_from_this() _NOEXCEPT\n       { return __weak_this_; }\n\n    _LIBCPP_INLINE_VISIBILITY\n    weak_ptr<const _Tp> weak_from_this() const _NOEXCEPT\n        { return __weak_this_; }\n#endif // _LIBCPP_STD_VER > 14\n\n    template <class _Up> friend class shared_ptr;\n};\n\ntemplate <class _Tp>\nstruct _LIBCPP_TEMPLATE_VIS hash<shared_ptr<_Tp> >\n{\n    typedef shared_ptr<_Tp>      argument_type;\n    typedef size_t               result_type;\n    _LIBCPP_INLINE_VISIBILITY\n    result_type operator()(const argument_type& __ptr) const _NOEXCEPT\n    {\n        return hash<_Tp*>()(__ptr.get());\n    }\n};\n\ntemplate<class _CharT, class _Traits, class _Yp>\ninline _LIBCPP_INLINE_VISIBILITY\nbasic_ostream<_CharT, _Traits>&\noperator<<(basic_ostream<_CharT, _Traits>& __os, shared_ptr<_Yp> const& __p);\n\n\n#if !defined(_LIBCPP_HAS_NO_ATOMIC_HEADER)\n\nclass _LIBCPP_TYPE_VIS __sp_mut\n{\n    void* __lx;\npublic:\n    void lock() _NOEXCEPT;\n    void unlock() _NOEXCEPT;\n\nprivate:\n    _LIBCPP_CONSTEXPR __sp_mut(void*) _NOEXCEPT;\n    __sp_mut(const __sp_mut&);\n    __sp_mut& operator=(const __sp_mut&);\n\n    friend _LIBCPP_FUNC_VIS __sp_mut& __get_sp_mut(const void*);\n};\n\n_LIBCPP_FUNC_VIS __sp_mut& __get_sp_mut(const void*);\n\ntemplate <class _Tp>\ninline _LIBCPP_INLINE_VISIBILITY\nbool\natomic_is_lock_free(const shared_ptr<_Tp>*)\n{\n    return false;\n}\n\ntemplate <class _Tp>\nshared_ptr<_Tp>\natomic_load(const shared_ptr<_Tp>* __p)\n{\n    __sp_mut& __m = __get_sp_mut(__p);\n    __m.lock();\n    shared_ptr<_Tp> __q = *__p;\n    __m.unlock();\n    return __q;\n}\n  \ntemplate <class _Tp>\ninline _LIBCPP_INLINE_VISIBILITY\nshared_ptr<_Tp>\natomic_load_explicit(const shared_ptr<_Tp>* __p, memory_order)\n{\n    return atomic_load(__p);\n}\n\ntemplate <class _Tp>\nvoid\natomic_store(shared_ptr<_Tp>* __p, shared_ptr<_Tp> __r)\n{\n    __sp_mut& __m = __get_sp_mut(__p);\n    __m.lock();\n    __p->swap(__r);\n    __m.unlock();\n}\n\ntemplate <class _Tp>\ninline _LIBCPP_INLINE_VISIBILITY\nvoid\natomic_store_explicit(shared_ptr<_Tp>* __p, shared_ptr<_Tp> __r, memory_order)\n{\n    atomic_store(__p, __r);\n}\n\ntemplate <class _Tp>\nshared_ptr<_Tp>\natomic_exchange(shared_ptr<_Tp>* __p, shared_ptr<_Tp> __r)\n{\n    __sp_mut& __m = __get_sp_mut(__p);\n    __m.lock();\n    __p->swap(__r);\n    __m.unlock();\n    return __r;\n}\n  \ntemplate <class _Tp>\ninline _LIBCPP_INLINE_VISIBILITY\nshared_ptr<_Tp>\natomic_exchange_explicit(shared_ptr<_Tp>* __p, shared_ptr<_Tp> __r, memory_order)\n{\n    return atomic_exchange(__p, __r);\n}\n\ntemplate <class _Tp>\nbool\natomic_compare_exchange_strong(shared_ptr<_Tp>* __p, shared_ptr<_Tp>* __v, shared_ptr<_Tp> __w)\n{\n    shared_ptr<_Tp> __temp;\n    __sp_mut& __m = __get_sp_mut(__p);\n    __m.lock();\n    if (__p->__owner_equivalent(*__v))\n    {\n        _VSTD::swap(__temp, *__p);\n        *__p = __w;\n        __m.unlock();\n        return true;\n    }\n    _VSTD::swap(__temp, *__v);\n    *__v = *__p;\n    __m.unlock();\n    return false;\n}\n\ntemplate <class _Tp>\ninline _LIBCPP_INLINE_VISIBILITY\nbool\natomic_compare_exchange_weak(shared_ptr<_Tp>* __p, shared_ptr<_Tp>* __v, shared_ptr<_Tp> __w)\n{\n    return atomic_compare_exchange_strong(__p, __v, __w);\n}\n\ntemplate <class _Tp>\ninline _LIBCPP_INLINE_VISIBILITY\nbool\natomic_compare_exchange_strong_explicit(shared_ptr<_Tp>* __p, shared_ptr<_Tp>* __v,\n                                        shared_ptr<_Tp> __w, memory_order, memory_order)\n{\n    return atomic_compare_exchange_strong(__p, __v, __w);\n}\n\ntemplate <class _Tp>\ninline _LIBCPP_INLINE_VISIBILITY\nbool\natomic_compare_exchange_weak_explicit(shared_ptr<_Tp>* __p, shared_ptr<_Tp>* __v,\n                                      shared_ptr<_Tp> __w, memory_order, memory_order)\n{\n    return atomic_compare_exchange_weak(__p, __v, __w);\n}\n\n#endif  // !defined(_LIBCPP_HAS_NO_ATOMIC_HEADER)\n\n//enum class\n#if defined(_LIBCPP_ABI_POINTER_SAFETY_ENUM_TYPE)\n# ifndef _LIBCPP_CXX03_LANG\nenum class pointer_safety : unsigned char {\n  relaxed,\n  preferred,\n  strict\n};\n# endif\n#else\nstruct _LIBCPP_TYPE_VIS pointer_safety\n{\n    enum __lx\n    {\n        relaxed,\n        preferred,\n        strict\n    };\n\n    __lx __v_;\n\n    _LIBCPP_INLINE_VISIBILITY\n    pointer_safety() : __v_() {}\n\n    _LIBCPP_INLINE_VISIBILITY\n    pointer_safety(__lx __v) : __v_(__v) {}\n    _LIBCPP_INLINE_VISIBILITY\n    operator int() const {return __v_;}\n};\n#endif\n\n#if !defined(_LIBCPP_ABI_POINTER_SAFETY_ENUM_TYPE) && \\\n    defined(_LIBCPP_BUILDING_MEMORY)\n_LIBCPP_FUNC_VIS pointer_safety get_pointer_safety() _NOEXCEPT;\n#else\n// This function is only offered in C++03 under ABI v1.\n# if !defined(_LIBCPP_ABI_POINTER_SAFETY_ENUM_TYPE) || !defined(_LIBCPP_CXX03_LANG)\ninline _LIBCPP_INLINE_VISIBILITY\npointer_safety get_pointer_safety() _NOEXCEPT {\n  return pointer_safety::relaxed;\n}\n# endif\n#endif\n\n\n_LIBCPP_FUNC_VIS void declare_reachable(void* __p);\n_LIBCPP_FUNC_VIS void declare_no_pointers(char* __p, size_t __n);\n_LIBCPP_FUNC_VIS void undeclare_no_pointers(char* __p, size_t __n);\n_LIBCPP_FUNC_VIS void* __undeclare_reachable(void* __p);\n\ntemplate <class _Tp>\ninline _LIBCPP_INLINE_VISIBILITY\n_Tp*\nundeclare_reachable(_Tp* __p)\n{\n    return static_cast<_Tp*>(__undeclare_reachable(__p));\n}\n\n_LIBCPP_FUNC_VIS void* align(size_t __align, size_t __sz, void*& __ptr, size_t& __space);\n\n// --- Helper for container swap --\ntemplate <typename _Alloc>\ninline _LIBCPP_INLINE_VISIBILITY\nvoid __swap_allocator(_Alloc & __a1, _Alloc & __a2)\n#if _LIBCPP_STD_VER >= 14\n    _NOEXCEPT\n#else\n    _NOEXCEPT_(__is_nothrow_swappable<_Alloc>::value)\n#endif\n{\n    __swap_allocator(__a1, __a2, \n      integral_constant<bool, _VSTD::allocator_traits<_Alloc>::propagate_on_container_swap::value>());\n}\n\ntemplate <typename _Alloc>\n_LIBCPP_INLINE_VISIBILITY\nvoid __swap_allocator(_Alloc & __a1, _Alloc & __a2, true_type)\n#if _LIBCPP_STD_VER >= 14\n    _NOEXCEPT\n#else\n    _NOEXCEPT_(__is_nothrow_swappable<_Alloc>::value)\n#endif\n{\n    using _VSTD::swap;\n    swap(__a1, __a2);\n}\n\ntemplate <typename _Alloc>\ninline _LIBCPP_INLINE_VISIBILITY\nvoid __swap_allocator(_Alloc &, _Alloc &, false_type) _NOEXCEPT {}\n\ntemplate <typename _Alloc, typename _Traits=allocator_traits<_Alloc> >\nstruct __noexcept_move_assign_container : public integral_constant<bool, \n    _Traits::propagate_on_container_move_assignment::value\n#if _LIBCPP_STD_VER > 14\n        || _Traits::is_always_equal::value\n#else\n        && is_nothrow_move_assignable<_Alloc>::value\n#endif\n    > {};\n\n\n#ifndef _LIBCPP_HAS_NO_VARIADICS\ntemplate <class _Tp, class _Alloc>\nstruct __temp_value {\n    typedef allocator_traits<_Alloc> _Traits;\n    \n    typename aligned_storage<sizeof(_Tp), alignof(_Tp)>::type __v;\n    _Alloc &__a;\n\n    _Tp *__addr() { return reinterpret_cast<_Tp *>(addressof(__v)); }\n    _Tp &   get() { return *__addr(); }\n        \n    template<class... _Args>\n    __temp_value(_Alloc &__alloc, _Args&& ... __args) : __a(__alloc)\n    { _Traits::construct(__a, __addr(), _VSTD::forward<_Args>(__args)...); }\n    \n    ~__temp_value() { _Traits::destroy(__a, __addr()); }\n    };\n#endif\n\n_LIBCPP_END_NAMESPACE_STD\n\n#endif  // _LIBCPP_MEMORY\n","// -*- C++ -*-\n//===-------------------------- __string ----------------------------------===//\n//\n//                     The LLVM Compiler Infrastructure\n//\n// This file is distributed under the University of Illinois Open Source\n// License. See LICENSE.TXT for details.\n//\n//===----------------------------------------------------------------------===//\n\n#ifndef _LIBCPP___STRING\n#define _LIBCPP___STRING\n\n/*\n    string synopsis\n\nnamespace std\n{\n\ntemplate <class charT>\nstruct char_traits\n{\n    typedef charT     char_type;\n    typedef ...       int_type;\n    typedef streamoff off_type;\n    typedef streampos pos_type;\n    typedef mbstate_t state_type;\n\n    static constexpr void assign(char_type& c1, const char_type& c2) noexcept;\n    static constexpr bool eq(char_type c1, char_type c2) noexcept;\n    static constexpr bool lt(char_type c1, char_type c2) noexcept;\n\n    static constexpr int    compare(const char_type* s1, const char_type* s2, size_t n);\n    static constexpr size_t length(const char_type* s);\n    static constexpr const char_type* \n                            find(const char_type* s, size_t n, const char_type& a);\n    static char_type*       move(char_type* s1, const char_type* s2, size_t n);\n    static char_type*       copy(char_type* s1, const char_type* s2, size_t n);\n    static char_type*       assign(char_type* s, size_t n, char_type a);\n\n    static constexpr int_type  not_eof(int_type c) noexcept;\n    static constexpr char_type to_char_type(int_type c) noexcept;\n    static constexpr int_type  to_int_type(char_type c) noexcept;\n    static constexpr bool      eq_int_type(int_type c1, int_type c2) noexcept;\n    static constexpr int_type  eof() noexcept;\n};\n\ntemplate <> struct char_traits<char>;\ntemplate <> struct char_traits<wchar_t>;\n\n}  // std\n\n*/\n\n#include <__config>\n#include <algorithm>  // for search and min\n#include <cstdio>     // For EOF.\n#include <memory>     // for __murmur2_or_cityhash\n\n#include <__undef_min_max>\n\n#include <__debug>\n\n#if !defined(_LIBCPP_HAS_NO_PRAGMA_SYSTEM_HEADER)\n#pragma GCC system_header\n#endif\n\n_LIBCPP_BEGIN_NAMESPACE_STD\n\n// char_traits\n\ntemplate <class _CharT>\nstruct _LIBCPP_TEMPLATE_VIS char_traits\n{\n    typedef _CharT    char_type;\n    typedef int       int_type;\n    typedef streamoff off_type;\n    typedef streampos pos_type;\n    typedef mbstate_t state_type;\n\n    static inline void _LIBCPP_CONSTEXPR_AFTER_CXX14\n        assign(char_type& __c1, const char_type& __c2) _NOEXCEPT {__c1 = __c2;}\n    static inline _LIBCPP_CONSTEXPR bool eq(char_type __c1, char_type __c2) _NOEXCEPT\n        {return __c1 == __c2;}\n    static inline _LIBCPP_CONSTEXPR bool lt(char_type __c1, char_type __c2) _NOEXCEPT\n        {return __c1 < __c2;}\n\n    static _LIBCPP_CONSTEXPR_AFTER_CXX14\n    int compare(const char_type* __s1, const char_type* __s2, size_t __n);\n    _LIBCPP_INLINE_VISIBILITY static _LIBCPP_CONSTEXPR_AFTER_CXX14\n    size_t length(const char_type* __s);\n    _LIBCPP_INLINE_VISIBILITY static _LIBCPP_CONSTEXPR_AFTER_CXX14\n    const char_type* find(const char_type* __s, size_t __n, const char_type& __a);\n    static char_type*       move(char_type* __s1, const char_type* __s2, size_t __n);\n    _LIBCPP_INLINE_VISIBILITY\n    static char_type*       copy(char_type* __s1, const char_type* __s2, size_t __n);\n    _LIBCPP_INLINE_VISIBILITY\n    static char_type*       assign(char_type* __s, size_t __n, char_type __a);\n\n    static inline _LIBCPP_CONSTEXPR int_type  not_eof(int_type __c) _NOEXCEPT\n        {return eq_int_type(__c, eof()) ? ~eof() : __c;}\n    static inline _LIBCPP_CONSTEXPR char_type to_char_type(int_type __c) _NOEXCEPT\n        {return char_type(__c);}\n    static inline _LIBCPP_CONSTEXPR int_type  to_int_type(char_type __c) _NOEXCEPT\n        {return int_type(__c);}\n    static inline _LIBCPP_CONSTEXPR bool      eq_int_type(int_type __c1, int_type __c2) _NOEXCEPT\n        {return __c1 == __c2;}\n    static inline _LIBCPP_CONSTEXPR int_type  eof() _NOEXCEPT\n        {return int_type(EOF);}\n};\n\ntemplate <class _CharT>\n_LIBCPP_CONSTEXPR_AFTER_CXX14 int\nchar_traits<_CharT>::compare(const char_type* __s1, const char_type* __s2, size_t __n)\n{\n    for (; __n; --__n, ++__s1, ++__s2)\n    {\n        if (lt(*__s1, *__s2))\n            return -1;\n        if (lt(*__s2, *__s1))\n            return 1;\n    }\n    return 0;\n}\n\ntemplate <class _CharT>\ninline\n_LIBCPP_CONSTEXPR_AFTER_CXX14 size_t\nchar_traits<_CharT>::length(const char_type* __s)\n{\n    size_t __len = 0;\n    for (; !eq(*__s, char_type(0)); ++__s)\n        ++__len;\n    return __len;\n}\n\ntemplate <class _CharT>\ninline\n_LIBCPP_CONSTEXPR_AFTER_CXX14 const _CharT*\nchar_traits<_CharT>::find(const char_type* __s, size_t __n, const char_type& __a)\n{\n    for (; __n; --__n)\n    {\n        if (eq(*__s, __a))\n            return __s;\n        ++__s;\n    }\n    return 0;\n}\n\ntemplate <class _CharT>\n_CharT*\nchar_traits<_CharT>::move(char_type* __s1, const char_type* __s2, size_t __n)\n{\n    char_type* __r = __s1;\n    if (__s1 < __s2)\n    {\n        for (; __n; --__n, ++__s1, ++__s2)\n            assign(*__s1, *__s2);\n    }\n    else if (__s2 < __s1)\n    {\n        __s1 += __n;\n        __s2 += __n;\n        for (; __n; --__n)\n            assign(*--__s1, *--__s2);\n    }\n    return __r;\n}\n\ntemplate <class _CharT>\ninline\n_CharT*\nchar_traits<_CharT>::copy(char_type* __s1, const char_type* __s2, size_t __n)\n{\n    _LIBCPP_ASSERT(__s2 < __s1 || __s2 >= __s1+__n, \"char_traits::copy overlapped range\");\n    char_type* __r = __s1;\n    for (; __n; --__n, ++__s1, ++__s2)\n        assign(*__s1, *__s2);\n    return __r;\n}\n\ntemplate <class _CharT>\ninline\n_CharT*\nchar_traits<_CharT>::assign(char_type* __s, size_t __n, char_type __a)\n{\n    char_type* __r = __s;\n    for (; __n; --__n, ++__s)\n        assign(*__s, __a);\n    return __r;\n}\n\n// char_traits<char>\n\ntemplate <>\nstruct _LIBCPP_TEMPLATE_VIS char_traits<char>\n{\n    typedef char      char_type;\n    typedef int       int_type;\n    typedef streamoff off_type;\n    typedef streampos pos_type;\n    typedef mbstate_t state_type;\n\n    static inline _LIBCPP_CONSTEXPR_AFTER_CXX14\n    void assign(char_type& __c1, const char_type& __c2) _NOEXCEPT {__c1 = __c2;}\n    static inline _LIBCPP_CONSTEXPR bool eq(char_type __c1, char_type __c2) _NOEXCEPT\n            {return __c1 == __c2;}\n    static inline _LIBCPP_CONSTEXPR bool lt(char_type __c1, char_type __c2) _NOEXCEPT\n        {return (unsigned char)__c1 < (unsigned char)__c2;}\n\n    static _LIBCPP_CONSTEXPR_AFTER_CXX14\n    int compare(const char_type* __s1, const char_type* __s2, size_t __n) _NOEXCEPT;\n    static inline size_t _LIBCPP_CONSTEXPR_AFTER_CXX14\n    length(const char_type* __s)  _NOEXCEPT {return __builtin_strlen(__s);}\n    static _LIBCPP_CONSTEXPR_AFTER_CXX14\n    const char_type* find(const char_type* __s, size_t __n, const char_type& __a) _NOEXCEPT;\n    static inline char_type* move(char_type* __s1, const char_type* __s2, size_t __n) _NOEXCEPT\n        {return __n == 0 ? __s1 : (char_type*) memmove(__s1, __s2, __n);}\n    static inline char_type* copy(char_type* __s1, const char_type* __s2, size_t __n) _NOEXCEPT\n        {\n            _LIBCPP_ASSERT(__s2 < __s1 || __s2 >= __s1+__n, \"char_traits::copy overlapped range\");\n            return __n == 0 ? __s1 : (char_type*)memcpy(__s1, __s2, __n);\n        }\n    static inline char_type* assign(char_type* __s, size_t __n, char_type __a) _NOEXCEPT\n        {return __n == 0 ? __s : (char_type*)memset(__s, to_int_type(__a), __n);}\n\n    static inline _LIBCPP_CONSTEXPR int_type  not_eof(int_type __c) _NOEXCEPT\n        {return eq_int_type(__c, eof()) ? ~eof() : __c;}\n    static inline _LIBCPP_CONSTEXPR char_type to_char_type(int_type __c) _NOEXCEPT\n        {return char_type(__c);}\n    static inline _LIBCPP_CONSTEXPR int_type to_int_type(char_type __c) _NOEXCEPT\n        {return int_type((unsigned char)__c);}\n    static inline _LIBCPP_CONSTEXPR bool eq_int_type(int_type __c1, int_type __c2) _NOEXCEPT\n        {return __c1 == __c2;}\n    static inline _LIBCPP_CONSTEXPR int_type  eof() _NOEXCEPT\n        {return int_type(EOF);}\n};\n\ninline _LIBCPP_CONSTEXPR_AFTER_CXX14\nint\nchar_traits<char>::compare(const char_type* __s1, const char_type* __s2, size_t __n) _NOEXCEPT\n{\n    if (__n == 0)\n        return 0;\n#if __has_feature(cxx_constexpr_string_builtins)\n    return __builtin_memcmp(__s1, __s2, __n);\n#elif _LIBCPP_STD_VER <= 14\n    return memcmp(__s1, __s2, __n);\n#else\n    for (; __n; --__n, ++__s1, ++__s2)\n    {\n        if (lt(*__s1, *__s2))\n            return -1;\n        if (lt(*__s2, *__s1))\n            return 1;\n    }\n    return 0;\n#endif\n}\n\ninline _LIBCPP_CONSTEXPR_AFTER_CXX14\nconst char*\nchar_traits<char>::find(const char_type* __s, size_t __n, const char_type& __a) _NOEXCEPT\n{\n    if (__n == 0)\n        return NULL;\n#if __has_feature(cxx_constexpr_string_builtins)\n    return __builtin_char_memchr(__s, to_int_type(__a), __n);\n#elif _LIBCPP_STD_VER <= 14\n    return (const char_type*) memchr(__s, to_int_type(__a), __n);\n#else\n    for (; __n; --__n)\n    {\n        if (eq(*__s, __a))\n            return __s;\n        ++__s;\n    }\n    return NULL;\n#endif\n}\n\n\n// char_traits<wchar_t>\n\ntemplate <>\nstruct _LIBCPP_TEMPLATE_VIS char_traits<wchar_t>\n{\n    typedef wchar_t   char_type;\n    typedef wint_t    int_type;\n    typedef streamoff off_type;\n    typedef streampos pos_type;\n    typedef mbstate_t state_type;\n\n    static inline _LIBCPP_CONSTEXPR_AFTER_CXX14\n    void assign(char_type& __c1, const char_type& __c2) _NOEXCEPT {__c1 = __c2;}\n    static inline _LIBCPP_CONSTEXPR bool eq(char_type __c1, char_type __c2) _NOEXCEPT\n        {return __c1 == __c2;}\n    static inline _LIBCPP_CONSTEXPR bool lt(char_type __c1, char_type __c2) _NOEXCEPT\n        {return __c1 < __c2;}\n\n    static _LIBCPP_CONSTEXPR_AFTER_CXX14\n    int compare(const char_type* __s1, const char_type* __s2, size_t __n) _NOEXCEPT;\n    static _LIBCPP_CONSTEXPR_AFTER_CXX14\n    size_t length(const char_type* __s) _NOEXCEPT;\n    static _LIBCPP_CONSTEXPR_AFTER_CXX14\n    const char_type* find(const char_type* __s, size_t __n, const char_type& __a) _NOEXCEPT;\n    static inline char_type* move(char_type* __s1, const char_type* __s2, size_t __n) _NOEXCEPT\n        {return __n == 0 ? __s1 : (char_type*)wmemmove(__s1, __s2, __n);}\n    static inline char_type* copy(char_type* __s1, const char_type* __s2, size_t __n) _NOEXCEPT\n        {\n            _LIBCPP_ASSERT(__s2 < __s1 || __s2 >= __s1+__n, \"char_traits::copy overlapped range\");\n            return __n == 0 ? __s1 : (char_type*)wmemcpy(__s1, __s2, __n);\n        }\n    static inline char_type* assign(char_type* __s, size_t __n, char_type __a) _NOEXCEPT\n        {return __n == 0 ? __s : (char_type*)wmemset(__s, __a, __n);}\n\n    static inline _LIBCPP_CONSTEXPR int_type  not_eof(int_type __c) _NOEXCEPT\n        {return eq_int_type(__c, eof()) ? ~eof() : __c;}\n    static inline _LIBCPP_CONSTEXPR char_type to_char_type(int_type __c) _NOEXCEPT\n        {return char_type(__c);}\n    static inline _LIBCPP_CONSTEXPR int_type to_int_type(char_type __c) _NOEXCEPT\n        {return int_type(__c);}\n    static inline _LIBCPP_CONSTEXPR bool eq_int_type(int_type __c1, int_type __c2) _NOEXCEPT\n        {return __c1 == __c2;}\n    static inline _LIBCPP_CONSTEXPR int_type eof() _NOEXCEPT\n        {return int_type(WEOF);}\n};\n\ninline _LIBCPP_CONSTEXPR_AFTER_CXX14\nint\nchar_traits<wchar_t>::compare(const char_type* __s1, const char_type* __s2, size_t __n) _NOEXCEPT\n{\n    if (__n == 0)\n        return 0;\n#if __has_feature(cxx_constexpr_string_builtins)\n    return __builtin_wmemcmp(__s1, __s2, __n);\n#elif _LIBCPP_STD_VER <= 14\n    return wmemcmp(__s1, __s2, __n);\n#else\n    for (; __n; --__n, ++__s1, ++__s2)\n    {\n        if (lt(*__s1, *__s2))\n            return -1;\n        if (lt(*__s2, *__s1))\n            return 1;\n    }\n    return 0;\n#endif\n}\n\ninline _LIBCPP_CONSTEXPR_AFTER_CXX14\nsize_t\nchar_traits<wchar_t>::length(const char_type* __s) _NOEXCEPT\n{\n#if __has_feature(cxx_constexpr_string_builtins)\n    return __builtin_wcslen(__s);\n#elif _LIBCPP_STD_VER <= 14\n    return wcslen(__s);\n#else\n    size_t __len = 0;\n    for (; !eq(*__s, char_type(0)); ++__s)\n        ++__len;\n    return __len;\n#endif\n}\n\ninline _LIBCPP_CONSTEXPR_AFTER_CXX14\nconst wchar_t*\nchar_traits<wchar_t>::find(const char_type* __s, size_t __n, const char_type& __a) _NOEXCEPT\n{\n    if (__n == 0)\n        return NULL;\n#if __has_feature(cxx_constexpr_string_builtins)\n        return __builtin_wmemchr(__s, __a, __n);\n#elif _LIBCPP_STD_VER <= 14\n    return wmemchr(__s, __a, __n);\n#else\n    for (; __n; --__n)\n    {\n        if (eq(*__s, __a))\n            return __s;\n        ++__s;\n    }\n    return NULL;\n#endif\n}\n\n\n#ifndef _LIBCPP_HAS_NO_UNICODE_CHARS\n\ntemplate <>\nstruct _LIBCPP_TEMPLATE_VIS char_traits<char16_t>\n{\n    typedef char16_t       char_type;\n    typedef uint_least16_t int_type;\n    typedef streamoff      off_type;\n    typedef u16streampos   pos_type;\n    typedef mbstate_t      state_type;\n\n    static inline _LIBCPP_CONSTEXPR_AFTER_CXX14\n    void assign(char_type& __c1, const char_type& __c2) _NOEXCEPT {__c1 = __c2;}\n    static inline _LIBCPP_CONSTEXPR bool eq(char_type __c1, char_type __c2) _NOEXCEPT\n        {return __c1 == __c2;}\n    static inline _LIBCPP_CONSTEXPR bool lt(char_type __c1, char_type __c2) _NOEXCEPT\n        {return __c1 < __c2;}\n\n    _LIBCPP_INLINE_VISIBILITY static _LIBCPP_CONSTEXPR_AFTER_CXX14\n    int              compare(const char_type* __s1, const char_type* __s2, size_t __n) _NOEXCEPT;\n    _LIBCPP_INLINE_VISIBILITY static _LIBCPP_CONSTEXPR_AFTER_CXX14\n    size_t           length(const char_type* __s) _NOEXCEPT;\n    _LIBCPP_INLINE_VISIBILITY static _LIBCPP_CONSTEXPR_AFTER_CXX14\n    const char_type* find(const char_type* __s, size_t __n, const char_type& __a) _NOEXCEPT;\n    _LIBCPP_INLINE_VISIBILITY\n    static char_type*       move(char_type* __s1, const char_type* __s2, size_t __n) _NOEXCEPT;\n    _LIBCPP_INLINE_VISIBILITY\n    static char_type*       copy(char_type* __s1, const char_type* __s2, size_t __n) _NOEXCEPT;\n    _LIBCPP_INLINE_VISIBILITY\n    static char_type*       assign(char_type* __s, size_t __n, char_type __a) _NOEXCEPT;\n\n    static inline _LIBCPP_CONSTEXPR int_type  not_eof(int_type __c) _NOEXCEPT\n        {return eq_int_type(__c, eof()) ? ~eof() : __c;}\n    static inline _LIBCPP_CONSTEXPR char_type to_char_type(int_type __c) _NOEXCEPT\n        {return char_type(__c);}\n    static inline _LIBCPP_CONSTEXPR int_type to_int_type(char_type __c) _NOEXCEPT\n        {return int_type(__c);}\n    static inline _LIBCPP_CONSTEXPR bool eq_int_type(int_type __c1, int_type __c2) _NOEXCEPT\n        {return __c1 == __c2;}\n    static inline _LIBCPP_CONSTEXPR int_type eof() _NOEXCEPT\n        {return int_type(0xFFFF);}\n};\n\ninline _LIBCPP_CONSTEXPR_AFTER_CXX14\nint\nchar_traits<char16_t>::compare(const char_type* __s1, const char_type* __s2, size_t __n) _NOEXCEPT\n{\n    for (; __n; --__n, ++__s1, ++__s2)\n    {\n        if (lt(*__s1, *__s2))\n            return -1;\n        if (lt(*__s2, *__s1))\n            return 1;\n    }\n    return 0;\n}\n\ninline _LIBCPP_CONSTEXPR_AFTER_CXX14\nsize_t\nchar_traits<char16_t>::length(const char_type* __s) _NOEXCEPT\n{\n    size_t __len = 0;\n    for (; !eq(*__s, char_type(0)); ++__s)\n        ++__len;\n    return __len;\n}\n\ninline _LIBCPP_CONSTEXPR_AFTER_CXX14\nconst char16_t*\nchar_traits<char16_t>::find(const char_type* __s, size_t __n, const char_type& __a) _NOEXCEPT\n{\n    for (; __n; --__n)\n    {\n        if (eq(*__s, __a))\n            return __s;\n        ++__s;\n    }\n    return 0;\n}\n\ninline\nchar16_t*\nchar_traits<char16_t>::move(char_type* __s1, const char_type* __s2, size_t __n) _NOEXCEPT\n{\n    char_type* __r = __s1;\n    if (__s1 < __s2)\n    {\n        for (; __n; --__n, ++__s1, ++__s2)\n            assign(*__s1, *__s2);\n    }\n    else if (__s2 < __s1)\n    {\n        __s1 += __n;\n        __s2 += __n;\n        for (; __n; --__n)\n            assign(*--__s1, *--__s2);\n    }\n    return __r;\n}\n\ninline\nchar16_t*\nchar_traits<char16_t>::copy(char_type* __s1, const char_type* __s2, size_t __n) _NOEXCEPT\n{\n    _LIBCPP_ASSERT(__s2 < __s1 || __s2 >= __s1+__n, \"char_traits::copy overlapped range\");\n    char_type* __r = __s1;\n    for (; __n; --__n, ++__s1, ++__s2)\n        assign(*__s1, *__s2);\n    return __r;\n}\n\ninline\nchar16_t*\nchar_traits<char16_t>::assign(char_type* __s, size_t __n, char_type __a) _NOEXCEPT\n{\n    char_type* __r = __s;\n    for (; __n; --__n, ++__s)\n        assign(*__s, __a);\n    return __r;\n}\n\ntemplate <>\nstruct _LIBCPP_TEMPLATE_VIS char_traits<char32_t>\n{\n    typedef char32_t       char_type;\n    typedef uint_least32_t int_type;\n    typedef streamoff      off_type;\n    typedef u32streampos   pos_type;\n    typedef mbstate_t      state_type;\n\n    static inline _LIBCPP_CONSTEXPR_AFTER_CXX14\n    void assign(char_type& __c1, const char_type& __c2) _NOEXCEPT {__c1 = __c2;}\n    static inline _LIBCPP_CONSTEXPR bool eq(char_type __c1, char_type __c2) _NOEXCEPT\n        {return __c1 == __c2;}\n    static inline _LIBCPP_CONSTEXPR bool lt(char_type __c1, char_type __c2) _NOEXCEPT\n        {return __c1 < __c2;}\n\n    _LIBCPP_INLINE_VISIBILITY static _LIBCPP_CONSTEXPR_AFTER_CXX14\n    int              compare(const char_type* __s1, const char_type* __s2, size_t __n) _NOEXCEPT;\n    _LIBCPP_INLINE_VISIBILITY static _LIBCPP_CONSTEXPR_AFTER_CXX14\n    size_t           length(const char_type* __s) _NOEXCEPT;\n    _LIBCPP_INLINE_VISIBILITY static _LIBCPP_CONSTEXPR_AFTER_CXX14\n    const char_type* find(const char_type* __s, size_t __n, const char_type& __a) _NOEXCEPT;\n    _LIBCPP_INLINE_VISIBILITY\n    static char_type*       move(char_type* __s1, const char_type* __s2, size_t __n) _NOEXCEPT;\n    _LIBCPP_INLINE_VISIBILITY\n    static char_type*       copy(char_type* __s1, const char_type* __s2, size_t __n) _NOEXCEPT;\n    _LIBCPP_INLINE_VISIBILITY\n    static char_type*       assign(char_type* __s, size_t __n, char_type __a) _NOEXCEPT;\n\n    static inline _LIBCPP_CONSTEXPR int_type  not_eof(int_type __c) _NOEXCEPT\n        {return eq_int_type(__c, eof()) ? ~eof() : __c;}\n    static inline _LIBCPP_CONSTEXPR char_type to_char_type(int_type __c) _NOEXCEPT\n        {return char_type(__c);}\n    static inline _LIBCPP_CONSTEXPR int_type to_int_type(char_type __c) _NOEXCEPT\n        {return int_type(__c);}\n    static inline _LIBCPP_CONSTEXPR bool eq_int_type(int_type __c1, int_type __c2) _NOEXCEPT\n        {return __c1 == __c2;}\n    static inline _LIBCPP_CONSTEXPR int_type eof() _NOEXCEPT\n        {return int_type(0xFFFFFFFF);}\n};\n\ninline _LIBCPP_CONSTEXPR_AFTER_CXX14\nint\nchar_traits<char32_t>::compare(const char_type* __s1, const char_type* __s2, size_t __n) _NOEXCEPT\n{\n    for (; __n; --__n, ++__s1, ++__s2)\n    {\n        if (lt(*__s1, *__s2))\n            return -1;\n        if (lt(*__s2, *__s1))\n            return 1;\n    }\n    return 0;\n}\n\ninline _LIBCPP_CONSTEXPR_AFTER_CXX14\nsize_t\nchar_traits<char32_t>::length(const char_type* __s) _NOEXCEPT\n{\n    size_t __len = 0;\n    for (; !eq(*__s, char_type(0)); ++__s)\n        ++__len;\n    return __len;\n}\n\ninline _LIBCPP_CONSTEXPR_AFTER_CXX14\nconst char32_t*\nchar_traits<char32_t>::find(const char_type* __s, size_t __n, const char_type& __a) _NOEXCEPT\n{\n    for (; __n; --__n)\n    {\n        if (eq(*__s, __a))\n            return __s;\n        ++__s;\n    }\n    return 0;\n}\n\ninline\nchar32_t*\nchar_traits<char32_t>::move(char_type* __s1, const char_type* __s2, size_t __n) _NOEXCEPT\n{\n    char_type* __r = __s1;\n    if (__s1 < __s2)\n    {\n        for (; __n; --__n, ++__s1, ++__s2)\n            assign(*__s1, *__s2);\n    }\n    else if (__s2 < __s1)\n    {\n        __s1 += __n;\n        __s2 += __n;\n        for (; __n; --__n)\n            assign(*--__s1, *--__s2);\n    }\n    return __r;\n}\n\ninline\nchar32_t*\nchar_traits<char32_t>::copy(char_type* __s1, const char_type* __s2, size_t __n) _NOEXCEPT\n{\n    _LIBCPP_ASSERT(__s2 < __s1 || __s2 >= __s1+__n, \"char_traits::copy overlapped range\");\n    char_type* __r = __s1;\n    for (; __n; --__n, ++__s1, ++__s2)\n        assign(*__s1, *__s2);\n    return __r;\n}\n\ninline\nchar32_t*\nchar_traits<char32_t>::assign(char_type* __s, size_t __n, char_type __a) _NOEXCEPT\n{\n    char_type* __r = __s;\n    for (; __n; --__n, ++__s)\n        assign(*__s, __a);\n    return __r;\n}\n\n#endif  // _LIBCPP_HAS_NO_UNICODE_CHARS\n\n// helper fns for basic_string and string_view\n\n// __str_find\ntemplate<class _CharT, class _SizeT, class _Traits, _SizeT __npos>\ninline _SizeT _LIBCPP_CONSTEXPR_AFTER_CXX11 _LIBCPP_INLINE_VISIBILITY\n__str_find(const _CharT *__p, _SizeT __sz, \n             _CharT __c, _SizeT __pos) _NOEXCEPT\n{\n    if (__pos >= __sz)\n        return __npos;\n    const _CharT* __r = _Traits::find(__p + __pos, __sz - __pos, __c);\n    if (__r == 0)\n        return __npos;\n    return static_cast<_SizeT>(__r - __p);\n}\n\ntemplate <class _CharT, class _Traits>\ninline _LIBCPP_CONSTEXPR_AFTER_CXX11 const _CharT *\n__search_substring(const _CharT *__first1, const _CharT *__last1,\n                   const _CharT *__first2, const _CharT *__last2) {\n  // Take advantage of knowing source and pattern lengths.\n  // Stop short when source is smaller than pattern.\n  const ptrdiff_t __len2 = __last2 - __first2;\n  if (__len2 == 0)\n    return __first1;\n\n  ptrdiff_t __len1 = __last1 - __first1;\n  if (__len1 < __len2)\n    return __last1;\n\n  // First element of __first2 is loop invariant.\n  _CharT __f2 = *__first2;\n  while (true) {\n    __len1 = __last1 - __first1;\n    // Check whether __first1 still has at least __len2 bytes.\n    if (__len1 < __len2)\n      return __last1;\n\n    // Find __f2 the first byte matching in __first1.\n    __first1 = _Traits::find(__first1, __len1 - __len2 + 1, __f2);\n    if (__first1 == 0)\n      return __last1;\n\n    // It is faster to compare from the first byte of __first1 even if we\n    // already know that it matches the first byte of __first2: this is because\n    // __first2 is most likely aligned, as it is user's \"pattern\" string, and\n    // __first1 + 1 is most likely not aligned, as the match is in the middle of\n    // the string.\n    if (_Traits::compare(__first1, __first2, __len2) == 0)\n      return __first1;\n\n    ++__first1;\n  }\n}\n\ntemplate<class _CharT, class _SizeT, class _Traits, _SizeT __npos>\ninline _SizeT _LIBCPP_CONSTEXPR_AFTER_CXX11 _LIBCPP_INLINE_VISIBILITY\n__str_find(const _CharT *__p, _SizeT __sz, \n       const _CharT* __s, _SizeT __pos, _SizeT __n) _NOEXCEPT\n{\n    if (__pos > __sz)\n        return __npos;\n\n    if (__n == 0) // There is nothing to search, just return __pos.\n        return __pos;\n\n    const _CharT *__r = __search_substring<_CharT, _Traits>(\n        __p + __pos, __p + __sz, __s, __s + __n);\n\n    if (__r == __p + __sz)\n        return __npos;\n    return static_cast<_SizeT>(__r - __p);\n}\n\n\n// __str_rfind\n\ntemplate<class _CharT, class _SizeT, class _Traits, _SizeT __npos>\ninline _SizeT _LIBCPP_CONSTEXPR_AFTER_CXX11 _LIBCPP_INLINE_VISIBILITY\n__str_rfind(const _CharT *__p, _SizeT __sz, \n              _CharT __c, _SizeT __pos) _NOEXCEPT\n{\n    if (__sz < 1)\n        return __npos;\n    if (__pos < __sz)\n        ++__pos;\n    else\n        __pos = __sz;\n    for (const _CharT* __ps = __p + __pos; __ps != __p;)\n    {\n        if (_Traits::eq(*--__ps, __c))\n            return static_cast<_SizeT>(__ps - __p);\n    }\n    return __npos;\n}\n\ntemplate<class _CharT, class _SizeT, class _Traits, _SizeT __npos>\ninline _SizeT _LIBCPP_CONSTEXPR_AFTER_CXX11 _LIBCPP_INLINE_VISIBILITY\n__str_rfind(const _CharT *__p, _SizeT __sz, \n        const _CharT* __s, _SizeT __pos, _SizeT __n) _NOEXCEPT\n{\n    __pos = _VSTD::min(__pos, __sz);\n    if (__n < __sz - __pos)\n        __pos += __n;\n    else\n        __pos = __sz;\n    const _CharT* __r = _VSTD::__find_end(\n                  __p, __p + __pos, __s, __s + __n, _Traits::eq, \n                        random_access_iterator_tag(), random_access_iterator_tag());\n    if (__n > 0 && __r == __p + __pos)\n        return __npos;\n    return static_cast<_SizeT>(__r - __p);\n}\n\n// __str_find_first_of\ntemplate<class _CharT, class _SizeT, class _Traits, _SizeT __npos>\ninline _SizeT _LIBCPP_CONSTEXPR_AFTER_CXX11 _LIBCPP_INLINE_VISIBILITY\n__str_find_first_of(const _CharT *__p, _SizeT __sz,\n                const _CharT* __s, _SizeT __pos, _SizeT __n) _NOEXCEPT\n{\n    if (__pos >= __sz || __n == 0)\n        return __npos;\n    const _CharT* __r = _VSTD::__find_first_of_ce\n        (__p + __pos, __p + __sz, __s, __s + __n, _Traits::eq );\n    if (__r == __p + __sz)\n        return __npos;\n    return static_cast<_SizeT>(__r - __p);\n}\n\n\n// __str_find_last_of\ntemplate<class _CharT, class _SizeT, class _Traits, _SizeT __npos>\ninline _SizeT _LIBCPP_CONSTEXPR_AFTER_CXX11 _LIBCPP_INLINE_VISIBILITY\n__str_find_last_of(const _CharT *__p, _SizeT __sz,\n               const _CharT* __s, _SizeT __pos, _SizeT __n) _NOEXCEPT\n    {\n    if (__n != 0)\n    {\n        if (__pos < __sz)\n            ++__pos;\n        else\n            __pos = __sz;\n        for (const _CharT* __ps = __p + __pos; __ps != __p;)\n        {\n            const _CharT* __r = _Traits::find(__s, __n, *--__ps);\n            if (__r)\n                return static_cast<_SizeT>(__ps - __p);\n        }\n    }\n    return __npos;\n}\n\n\n// __str_find_first_not_of\ntemplate<class _CharT, class _SizeT, class _Traits, _SizeT __npos>\ninline _SizeT _LIBCPP_CONSTEXPR_AFTER_CXX11 _LIBCPP_INLINE_VISIBILITY\n__str_find_first_not_of(const _CharT *__p, _SizeT __sz,\n                    const _CharT* __s, _SizeT __pos, _SizeT __n) _NOEXCEPT\n{\n    if (__pos < __sz)\n    {\n        const _CharT* __pe = __p + __sz;\n        for (const _CharT* __ps = __p + __pos; __ps != __pe; ++__ps)\n            if (_Traits::find(__s, __n, *__ps) == 0)\n                return static_cast<_SizeT>(__ps - __p);\n    }\n    return __npos;\n}\n\n\ntemplate<class _CharT, class _SizeT, class _Traits, _SizeT __npos>\ninline _SizeT _LIBCPP_CONSTEXPR_AFTER_CXX11 _LIBCPP_INLINE_VISIBILITY\n__str_find_first_not_of(const _CharT *__p, _SizeT __sz,\n                          _CharT __c, _SizeT __pos) _NOEXCEPT\n{\n    if (__pos < __sz)\n    {\n        const _CharT* __pe = __p + __sz;\n        for (const _CharT* __ps = __p + __pos; __ps != __pe; ++__ps)\n            if (!_Traits::eq(*__ps, __c))\n                return static_cast<_SizeT>(__ps - __p);\n    }\n    return __npos;\n}\n\n\n// __str_find_last_not_of\ntemplate<class _CharT, class _SizeT, class _Traits, _SizeT __npos>\ninline _SizeT _LIBCPP_CONSTEXPR_AFTER_CXX11 _LIBCPP_INLINE_VISIBILITY\n__str_find_last_not_of(const _CharT *__p, _SizeT __sz,\n                   const _CharT* __s, _SizeT __pos, _SizeT __n) _NOEXCEPT\n{\n    if (__pos < __sz)\n        ++__pos;\n    else\n        __pos = __sz;\n    for (const _CharT* __ps = __p + __pos; __ps != __p;)\n        if (_Traits::find(__s, __n, *--__ps) == 0)\n            return static_cast<_SizeT>(__ps - __p);\n    return __npos;\n}\n\n\ntemplate<class _CharT, class _SizeT, class _Traits, _SizeT __npos>\ninline _SizeT _LIBCPP_CONSTEXPR_AFTER_CXX11 _LIBCPP_INLINE_VISIBILITY\n__str_find_last_not_of(const _CharT *__p, _SizeT __sz,\n                         _CharT __c, _SizeT __pos) _NOEXCEPT\n{\n    if (__pos < __sz)\n        ++__pos;\n    else\n        __pos = __sz;\n    for (const _CharT* __ps = __p + __pos; __ps != __p;)\n        if (!_Traits::eq(*--__ps, __c))\n            return static_cast<_SizeT>(__ps - __p);\n    return __npos;\n}\n\ntemplate<class _Ptr>\ninline _LIBCPP_INLINE_VISIBILITY\nsize_t __do_string_hash(_Ptr __p, _Ptr __e)\n{\n    typedef typename iterator_traits<_Ptr>::value_type value_type;\n    return __murmur2_or_cityhash<size_t>()(__p, (__e-__p)*sizeof(value_type));\n}\n\ntemplate <class _CharT, class _Iter, class _Traits=char_traits<_CharT> >\nstruct __quoted_output_proxy\n{\n    _Iter  __first;\n    _Iter  __last;\n    _CharT  __delim;\n    _CharT  __escape;\n\n    __quoted_output_proxy(_Iter __f, _Iter __l, _CharT __d, _CharT __e)\n    : __first(__f), __last(__l), __delim(__d), __escape(__e) {}\n    //  This would be a nice place for a string_ref \n};\n\n_LIBCPP_END_NAMESPACE_STD\n\n#endif  // _LIBCPP___STRING\n","// -*- C++ -*-\n//===------------------------ functional ----------------------------------===//\n//\n//                     The LLVM Compiler Infrastructure\n//\n// This file is dual licensed under the MIT and the University of Illinois Open\n// Source Licenses. See LICENSE.TXT for details.\n//\n//===----------------------------------------------------------------------===//\n\n#ifndef _LIBCPP_FUNCTIONAL\n#define _LIBCPP_FUNCTIONAL\n\n/*\n    functional synopsis\n\nnamespace std\n{\n\ntemplate <class Arg, class Result>\nstruct unary_function\n{\n    typedef Arg    argument_type;\n    typedef Result result_type;\n};\n\ntemplate <class Arg1, class Arg2, class Result>\nstruct binary_function\n{\n    typedef Arg1   first_argument_type;\n    typedef Arg2   second_argument_type;\n    typedef Result result_type;\n};\n\ntemplate <class T>\nclass reference_wrapper\n    : public unary_function<T1, R> // if wrapping a unary functor\n    : public binary_function<T1, T2, R> // if wraping a binary functor\n{\npublic:\n    // types\n    typedef T type;\n    typedef see below result_type; // Not always defined\n\n    // construct/copy/destroy\n    reference_wrapper(T&) noexcept;\n    reference_wrapper(T&&) = delete; // do not bind to temps\n    reference_wrapper(const reference_wrapper<T>& x) noexcept;\n\n    // assignment\n    reference_wrapper& operator=(const reference_wrapper<T>& x) noexcept;\n\n    // access\n    operator T& () const noexcept;\n    T& get() const noexcept;\n\n    // invoke\n    template <class... ArgTypes>\n      typename result_of<T&(ArgTypes&&...)>::type\n          operator() (ArgTypes&&...) const;\n};\n\ntemplate <class T> reference_wrapper<T> ref(T& t) noexcept;\ntemplate <class T> void ref(const T&& t) = delete;\ntemplate <class T> reference_wrapper<T> ref(reference_wrapper<T>t) noexcept;\n\ntemplate <class T> reference_wrapper<const T> cref(const T& t) noexcept;\ntemplate <class T> void cref(const T&& t) = delete;\ntemplate <class T> reference_wrapper<const T> cref(reference_wrapper<T> t) noexcept;\n\ntemplate <class T> // <class T=void> in C++14\nstruct plus : binary_function<T, T, T>\n{\n    T operator()(const T& x, const T& y) const;\n};\n\ntemplate <class T> // <class T=void> in C++14\nstruct minus : binary_function<T, T, T>\n{\n    T operator()(const T& x, const T& y) const;\n};\n\ntemplate <class T> // <class T=void> in C++14\nstruct multiplies : binary_function<T, T, T>\n{\n    T operator()(const T& x, const T& y) const;\n};\n\ntemplate <class T> // <class T=void> in C++14\nstruct divides : binary_function<T, T, T>\n{\n    T operator()(const T& x, const T& y) const;\n};\n\ntemplate <class T> // <class T=void> in C++14\nstruct modulus : binary_function<T, T, T>\n{\n    T operator()(const T& x, const T& y) const;\n};\n\ntemplate <class T> // <class T=void> in C++14\nstruct negate : unary_function<T, T>\n{\n    T operator()(const T& x) const;\n};\n\ntemplate <class T> // <class T=void> in C++14\nstruct equal_to : binary_function<T, T, bool>\n{\n    bool operator()(const T& x, const T& y) const;\n};\n\ntemplate <class T> // <class T=void> in C++14\nstruct not_equal_to : binary_function<T, T, bool>\n{\n    bool operator()(const T& x, const T& y) const;\n};\n\ntemplate <class T> // <class T=void> in C++14\nstruct greater : binary_function<T, T, bool>\n{\n    bool operator()(const T& x, const T& y) const;\n};\n\ntemplate <class T> // <class T=void> in C++14\nstruct less : binary_function<T, T, bool>\n{\n    bool operator()(const T& x, const T& y) const;\n};\n\ntemplate <class T> // <class T=void> in C++14\nstruct greater_equal : binary_function<T, T, bool>\n{\n    bool operator()(const T& x, const T& y) const;\n};\n\ntemplate <class T> // <class T=void> in C++14\nstruct less_equal : binary_function<T, T, bool>\n{\n    bool operator()(const T& x, const T& y) const;\n};\n\ntemplate <class T> // <class T=void> in C++14\nstruct logical_and : binary_function<T, T, bool>\n{\n    bool operator()(const T& x, const T& y) const;\n};\n\ntemplate <class T> // <class T=void> in C++14\nstruct logical_or : binary_function<T, T, bool>\n{\n    bool operator()(const T& x, const T& y) const;\n};\n\ntemplate <class T> // <class T=void> in C++14\nstruct logical_not : unary_function<T, bool>\n{\n    bool operator()(const T& x) const;\n};\n\ntemplate <class T> // <class T=void> in C++14\nstruct bit_and : unary_function<T, bool>\n{\n    bool operator()(const T& x, const T& y) const;\n};\n\ntemplate <class T> // <class T=void> in C++14\nstruct bit_or : unary_function<T, bool>\n{\n    bool operator()(const T& x, const T& y) const;\n};\n\ntemplate <class T> // <class T=void> in C++14\nstruct bit_xor : unary_function<T, bool>\n{\n    bool operator()(const T& x, const T& y) const;\n};\n\ntemplate <class T=void> // C++14\nstruct bit_xor : unary_function<T, bool>\n{\n    bool operator()(const T& x) const;\n};\n\ntemplate <class Predicate>\nclass unary_negate\n    : public unary_function<typename Predicate::argument_type, bool>\n{\npublic:\n    explicit unary_negate(const Predicate& pred);\n    bool operator()(const typename Predicate::argument_type& x) const;\n};\n\ntemplate <class Predicate> unary_negate<Predicate> not1(const Predicate& pred);\n\ntemplate <class Predicate>\nclass binary_negate\n    : public binary_function<typename Predicate::first_argument_type,\n                             typename Predicate::second_argument_type,\n                             bool>\n{\npublic:\n    explicit binary_negate(const Predicate& pred);\n    bool operator()(const typename Predicate::first_argument_type& x,\n                    const typename Predicate::second_argument_type& y) const;\n};\n\ntemplate <class Predicate> binary_negate<Predicate> not2(const Predicate& pred);\n\ntemplate <class F> unspecified not_fn(F&& f); // C++17\n\ntemplate<class T> struct is_bind_expression;\ntemplate<class T> struct is_placeholder;\n\n    // See C++14 20.9.9, Function object binders\ntemplate <class T> constexpr bool is_bind_expression_v\n  = is_bind_expression<T>::value; // C++17\ntemplate <class T> constexpr int is_placeholder_v\n  = is_placeholder<T>::value; // C++17\n\n\ntemplate<class Fn, class... BoundArgs>\n  unspecified bind(Fn&&, BoundArgs&&...);\ntemplate<class R, class Fn, class... BoundArgs>\n  unspecified bind(Fn&&, BoundArgs&&...);\n\nnamespace placeholders {\n  // M is the implementation-defined number of placeholders\n  extern unspecified _1;\n  extern unspecified _2;\n  .\n  .\n  .\n  extern unspecified _Mp;\n}\n\ntemplate <class Operation>\nclass binder1st\n    : public unary_function<typename Operation::second_argument_type,\n                            typename Operation::result_type>\n{\nprotected:\n    Operation                               op;\n    typename Operation::first_argument_type value;\npublic:\n    binder1st(const Operation& x, const typename Operation::first_argument_type y);\n    typename Operation::result_type operator()(      typename Operation::second_argument_type& x) const;\n    typename Operation::result_type operator()(const typename Operation::second_argument_type& x) const;\n};\n\ntemplate <class Operation, class T>\nbinder1st<Operation> bind1st(const Operation& op, const T& x);\n\ntemplate <class Operation>\nclass binder2nd\n    : public unary_function<typename Operation::first_argument_type,\n                            typename Operation::result_type>\n{\nprotected:\n    Operation                                op;\n    typename Operation::second_argument_type value;\npublic:\n    binder2nd(const Operation& x, const typename Operation::second_argument_type y);\n    typename Operation::result_type operator()(      typename Operation::first_argument_type& x) const;\n    typename Operation::result_type operator()(const typename Operation::first_argument_type& x) const;\n};\n\ntemplate <class Operation, class T>\nbinder2nd<Operation> bind2nd(const Operation& op, const T& x);\n\ntemplate <class Arg, class Result>\nclass pointer_to_unary_function : public unary_function<Arg, Result>\n{\npublic:\n    explicit pointer_to_unary_function(Result (*f)(Arg));\n    Result operator()(Arg x) const;\n};\n\ntemplate <class Arg, class Result>\npointer_to_unary_function<Arg,Result> ptr_fun(Result (*f)(Arg));\n\ntemplate <class Arg1, class Arg2, class Result>\nclass pointer_to_binary_function : public binary_function<Arg1, Arg2, Result>\n{\npublic:\n    explicit pointer_to_binary_function(Result (*f)(Arg1, Arg2));\n    Result operator()(Arg1 x, Arg2 y) const;\n};\n\ntemplate <class Arg1, class Arg2, class Result>\npointer_to_binary_function<Arg1,Arg2,Result> ptr_fun(Result (*f)(Arg1,Arg2));\n\ntemplate<class S, class T>\nclass mem_fun_t : public unary_function<T*, S>\n{\npublic:\n    explicit mem_fun_t(S (T::*p)());\n    S operator()(T* p) const;\n};\n\ntemplate<class S, class T, class A>\nclass mem_fun1_t : public binary_function<T*, A, S>\n{\npublic:\n    explicit mem_fun1_t(S (T::*p)(A));\n    S operator()(T* p, A x) const;\n};\n\ntemplate<class S, class T>          mem_fun_t<S,T>    mem_fun(S (T::*f)());\ntemplate<class S, class T, class A> mem_fun1_t<S,T,A> mem_fun(S (T::*f)(A));\n\ntemplate<class S, class T>\nclass mem_fun_ref_t : public unary_function<T, S>\n{\npublic:\n    explicit mem_fun_ref_t(S (T::*p)());\n    S operator()(T& p) const;\n};\n\ntemplate<class S, class T, class A>\nclass mem_fun1_ref_t : public binary_function<T, A, S>\n{\npublic:\n    explicit mem_fun1_ref_t(S (T::*p)(A));\n    S operator()(T& p, A x) const;\n};\n\ntemplate<class S, class T>          mem_fun_ref_t<S,T>    mem_fun_ref(S (T::*f)());\ntemplate<class S, class T, class A> mem_fun1_ref_t<S,T,A> mem_fun_ref(S (T::*f)(A));\n\ntemplate <class S, class T>\nclass const_mem_fun_t : public unary_function<const T*, S>\n{\npublic:\n    explicit const_mem_fun_t(S (T::*p)() const);\n    S operator()(const T* p) const;\n};\n\ntemplate <class S, class T, class A>\nclass const_mem_fun1_t : public binary_function<const T*, A, S>\n{\npublic:\n    explicit const_mem_fun1_t(S (T::*p)(A) const);\n    S operator()(const T* p, A x) const;\n};\n\ntemplate <class S, class T>          const_mem_fun_t<S,T>    mem_fun(S (T::*f)() const);\ntemplate <class S, class T, class A> const_mem_fun1_t<S,T,A> mem_fun(S (T::*f)(A) const);\n\ntemplate <class S, class T>\nclass const_mem_fun_ref_t : public unary_function<T, S>\n{\npublic:\n    explicit const_mem_fun_ref_t(S (T::*p)() const);\n    S operator()(const T& p) const;\n};\n\ntemplate <class S, class T, class A>\nclass const_mem_fun1_ref_t : public binary_function<T, A, S>\n{\npublic:\n    explicit const_mem_fun1_ref_t(S (T::*p)(A) const);\n    S operator()(const T& p, A x) const;\n};\n\ntemplate <class S, class T>          const_mem_fun_ref_t<S,T>    mem_fun_ref(S (T::*f)() const);\ntemplate <class S, class T, class A> const_mem_fun1_ref_t<S,T,A> mem_fun_ref(S (T::*f)(A) const);\n\ntemplate<class R, class T> unspecified mem_fn(R T::*);\n\nclass bad_function_call\n    : public exception\n{\n};\n\ntemplate<class> class function; // undefined\n\ntemplate<class R, class... ArgTypes>\nclass function<R(ArgTypes...)>\n  : public unary_function<T1, R>      // iff sizeof...(ArgTypes) == 1 and\n                                      // ArgTypes contains T1\n  : public binary_function<T1, T2, R> // iff sizeof...(ArgTypes) == 2 and\n                                      // ArgTypes contains T1 and T2\n{\npublic:\n    typedef R result_type;\n\n    // construct/copy/destroy:\n    function() noexcept;\n    function(nullptr_t) noexcept;\n    function(const function&);\n    function(function&&) noexcept;\n    template<class F>\n      function(F);\n    template<Allocator Alloc>\n      function(allocator_arg_t, const Alloc&) noexcept;            // removed in C++17\n    template<Allocator Alloc>\n      function(allocator_arg_t, const Alloc&, nullptr_t) noexcept; // removed in C++17\n    template<Allocator Alloc>\n      function(allocator_arg_t, const Alloc&, const function&);    // removed in C++17\n    template<Allocator Alloc>\n      function(allocator_arg_t, const Alloc&, function&&);         // removed in C++17\n    template<class F, Allocator Alloc>\n      function(allocator_arg_t, const Alloc&, F);                  // removed in C++17\n\n    function& operator=(const function&);\n    function& operator=(function&&) noexcept;\n    function& operator=(nullptr_t) noexcept;\n    template<class F>\n      function& operator=(F&&);\n    template<class F>\n      function& operator=(reference_wrapper<F>) noexcept;\n\n    ~function();\n\n    // function modifiers:\n    void swap(function&) noexcept;\n    template<class F, class Alloc>\n      void assign(F&&, const Alloc&);                 // Removed in C++17\n\n    // function capacity:\n    explicit operator bool() const noexcept;\n\n    // function invocation:\n    R operator()(ArgTypes...) const;\n\n    // function target access:\n    const std::type_info& target_type() const noexcept;\n    template <typename T>       T* target() noexcept;\n    template <typename T> const T* target() const noexcept;\n};\n\n// Null pointer comparisons:\ntemplate <class R, class ... ArgTypes>\n  bool operator==(const function<R(ArgTypes...)>&, nullptr_t) noexcept;\n\ntemplate <class R, class ... ArgTypes>\n  bool operator==(nullptr_t, const function<R(ArgTypes...)>&) noexcept;\n\ntemplate <class R, class ... ArgTypes>\n  bool operator!=(const function<R(ArgTypes...)>&, nullptr_t) noexcept;\n\ntemplate <class  R, class ... ArgTypes>\n  bool operator!=(nullptr_t, const function<R(ArgTypes...)>&) noexcept;\n\n// specialized algorithms:\ntemplate <class  R, class ... ArgTypes>\n  void swap(function<R(ArgTypes...)>&, function<R(ArgTypes...)>&) noexcept;\n\ntemplate <class T> struct hash;\n\ntemplate <> struct hash<bool>;\ntemplate <> struct hash<char>;\ntemplate <> struct hash<signed char>;\ntemplate <> struct hash<unsigned char>;\ntemplate <> struct hash<char16_t>;\ntemplate <> struct hash<char32_t>;\ntemplate <> struct hash<wchar_t>;\ntemplate <> struct hash<short>;\ntemplate <> struct hash<unsigned short>;\ntemplate <> struct hash<int>;\ntemplate <> struct hash<unsigned int>;\ntemplate <> struct hash<long>;\ntemplate <> struct hash<long long>;\ntemplate <> struct hash<unsigned long>;\ntemplate <> struct hash<unsigned long long>;\n\ntemplate <> struct hash<float>;\ntemplate <> struct hash<double>;\ntemplate <> struct hash<long double>;\n\ntemplate<class T> struct hash<T*>;\n\n}  // std\n\nPOLICY:  For non-variadic implementations, the number of arguments is limited\n         to 3.  It is hoped that the need for non-variadic implementations\n         will be minimal.\n\n*/\n\n#include <__config>\n#include <type_traits>\n#include <typeinfo>\n#include <exception>\n#include <memory>\n#include <tuple>\n\n#include <__functional_base>\n\n#if !defined(_LIBCPP_HAS_NO_PRAGMA_SYSTEM_HEADER)\n#pragma GCC system_header\n#endif\n\n_LIBCPP_BEGIN_NAMESPACE_STD\n\n#if _LIBCPP_STD_VER > 11\ntemplate <class _Tp = void>\n#else\ntemplate <class _Tp>\n#endif\nstruct _LIBCPP_TEMPLATE_VIS plus : binary_function<_Tp, _Tp, _Tp>\n{\n    _LIBCPP_CONSTEXPR_AFTER_CXX11 _LIBCPP_INLINE_VISIBILITY\n    _Tp operator()(const _Tp& __x, const _Tp& __y) const\n        {return __x + __y;}\n};\n\n#if _LIBCPP_STD_VER > 11\ntemplate <>\nstruct _LIBCPP_TEMPLATE_VIS plus<void>\n{\n    template <class _T1, class _T2>\n    _LIBCPP_CONSTEXPR_AFTER_CXX11 _LIBCPP_INLINE_VISIBILITY\n    auto operator()(_T1&& __t, _T2&& __u) const\n    _NOEXCEPT_(noexcept(_VSTD::forward<_T1>(__t) + _VSTD::forward<_T2>(__u)))\n    -> decltype        (_VSTD::forward<_T1>(__t) + _VSTD::forward<_T2>(__u))\n        { return        _VSTD::forward<_T1>(__t) + _VSTD::forward<_T2>(__u); }\n    typedef void is_transparent;\n};\n#endif\n\n\n#if _LIBCPP_STD_VER > 11\ntemplate <class _Tp = void>\n#else\ntemplate <class _Tp>\n#endif\nstruct _LIBCPP_TEMPLATE_VIS minus : binary_function<_Tp, _Tp, _Tp>\n{\n    _LIBCPP_CONSTEXPR_AFTER_CXX11 _LIBCPP_INLINE_VISIBILITY\n    _Tp operator()(const _Tp& __x, const _Tp& __y) const\n        {return __x - __y;}\n};\n\n#if _LIBCPP_STD_VER > 11\ntemplate <>\nstruct _LIBCPP_TEMPLATE_VIS minus<void>\n{\n    template <class _T1, class _T2>\n    _LIBCPP_CONSTEXPR_AFTER_CXX11 _LIBCPP_INLINE_VISIBILITY\n    auto operator()(_T1&& __t, _T2&& __u) const\n    _NOEXCEPT_(noexcept(_VSTD::forward<_T1>(__t) - _VSTD::forward<_T2>(__u)))\n    -> decltype        (_VSTD::forward<_T1>(__t) - _VSTD::forward<_T2>(__u))\n        { return        _VSTD::forward<_T1>(__t) - _VSTD::forward<_T2>(__u); }\n    typedef void is_transparent;\n};\n#endif\n\n\n#if _LIBCPP_STD_VER > 11\ntemplate <class _Tp = void>\n#else\ntemplate <class _Tp>\n#endif\nstruct _LIBCPP_TEMPLATE_VIS multiplies : binary_function<_Tp, _Tp, _Tp>\n{\n    _LIBCPP_CONSTEXPR_AFTER_CXX11 _LIBCPP_INLINE_VISIBILITY\n    _Tp operator()(const _Tp& __x, const _Tp& __y) const\n        {return __x * __y;}\n};\n\n#if _LIBCPP_STD_VER > 11\ntemplate <>\nstruct _LIBCPP_TEMPLATE_VIS multiplies<void>\n{\n    template <class _T1, class _T2>\n    _LIBCPP_CONSTEXPR_AFTER_CXX11 _LIBCPP_INLINE_VISIBILITY\n    auto operator()(_T1&& __t, _T2&& __u) const\n    _NOEXCEPT_(noexcept(_VSTD::forward<_T1>(__t) * _VSTD::forward<_T2>(__u)))\n    -> decltype        (_VSTD::forward<_T1>(__t) * _VSTD::forward<_T2>(__u))\n        { return        _VSTD::forward<_T1>(__t) * _VSTD::forward<_T2>(__u); }\n    typedef void is_transparent;\n};\n#endif\n\n\n#if _LIBCPP_STD_VER > 11\ntemplate <class _Tp = void>\n#else\ntemplate <class _Tp>\n#endif\nstruct _LIBCPP_TEMPLATE_VIS divides : binary_function<_Tp, _Tp, _Tp>\n{\n    _LIBCPP_CONSTEXPR_AFTER_CXX11 _LIBCPP_INLINE_VISIBILITY\n    _Tp operator()(const _Tp& __x, const _Tp& __y) const\n        {return __x / __y;}\n};\n\n#if _LIBCPP_STD_VER > 11\ntemplate <>\nstruct _LIBCPP_TEMPLATE_VIS divides<void>\n{\n    template <class _T1, class _T2>\n    _LIBCPP_CONSTEXPR_AFTER_CXX11 _LIBCPP_INLINE_VISIBILITY\n    auto operator()(_T1&& __t, _T2&& __u) const\n    _NOEXCEPT_(noexcept(_VSTD::forward<_T1>(__t) / _VSTD::forward<_T2>(__u)))\n    -> decltype        (_VSTD::forward<_T1>(__t) / _VSTD::forward<_T2>(__u))\n        { return        _VSTD::forward<_T1>(__t) / _VSTD::forward<_T2>(__u); }\n    typedef void is_transparent;\n};\n#endif\n\n\n#if _LIBCPP_STD_VER > 11\ntemplate <class _Tp = void>\n#else\ntemplate <class _Tp>\n#endif\nstruct _LIBCPP_TEMPLATE_VIS modulus : binary_function<_Tp, _Tp, _Tp>\n{\n    _LIBCPP_CONSTEXPR_AFTER_CXX11 _LIBCPP_INLINE_VISIBILITY\n    _Tp operator()(const _Tp& __x, const _Tp& __y) const\n        {return __x % __y;}\n};\n\n#if _LIBCPP_STD_VER > 11\ntemplate <>\nstruct _LIBCPP_TEMPLATE_VIS modulus<void>\n{\n    template <class _T1, class _T2>\n    _LIBCPP_CONSTEXPR_AFTER_CXX11 _LIBCPP_INLINE_VISIBILITY\n    auto operator()(_T1&& __t, _T2&& __u) const\n    _NOEXCEPT_(noexcept(_VSTD::forward<_T1>(__t) % _VSTD::forward<_T2>(__u)))\n    -> decltype        (_VSTD::forward<_T1>(__t) % _VSTD::forward<_T2>(__u))\n        { return        _VSTD::forward<_T1>(__t) % _VSTD::forward<_T2>(__u); }\n    typedef void is_transparent;\n};\n#endif\n\n\n#if _LIBCPP_STD_VER > 11\ntemplate <class _Tp = void>\n#else\ntemplate <class _Tp>\n#endif\nstruct _LIBCPP_TEMPLATE_VIS negate : unary_function<_Tp, _Tp>\n{\n    _LIBCPP_CONSTEXPR_AFTER_CXX11 _LIBCPP_INLINE_VISIBILITY\n    _Tp operator()(const _Tp& __x) const\n        {return -__x;}\n};\n\n#if _LIBCPP_STD_VER > 11\ntemplate <>\nstruct _LIBCPP_TEMPLATE_VIS negate<void>\n{\n    template <class _Tp>\n    _LIBCPP_CONSTEXPR_AFTER_CXX11 _LIBCPP_INLINE_VISIBILITY\n    auto operator()(_Tp&& __x) const\n    _NOEXCEPT_(noexcept(- _VSTD::forward<_Tp>(__x)))\n    -> decltype        (- _VSTD::forward<_Tp>(__x))\n        { return        - _VSTD::forward<_Tp>(__x); }\n    typedef void is_transparent;\n};\n#endif\n\n\n#if _LIBCPP_STD_VER > 11\ntemplate <class _Tp = void>\n#else\ntemplate <class _Tp>\n#endif\nstruct _LIBCPP_TEMPLATE_VIS equal_to : binary_function<_Tp, _Tp, bool>\n{\n    _LIBCPP_CONSTEXPR_AFTER_CXX11 _LIBCPP_INLINE_VISIBILITY\n    bool operator()(const _Tp& __x, const _Tp& __y) const\n        {return __x == __y;}\n};\n\n#if _LIBCPP_STD_VER > 11\ntemplate <>\nstruct _LIBCPP_TEMPLATE_VIS equal_to<void>\n{\n    template <class _T1, class _T2>\n    _LIBCPP_CONSTEXPR_AFTER_CXX11 _LIBCPP_INLINE_VISIBILITY\n    auto operator()(_T1&& __t, _T2&& __u) const\n    _NOEXCEPT_(noexcept(_VSTD::forward<_T1>(__t) == _VSTD::forward<_T2>(__u)))\n    -> decltype        (_VSTD::forward<_T1>(__t) == _VSTD::forward<_T2>(__u))\n        { return        _VSTD::forward<_T1>(__t) == _VSTD::forward<_T2>(__u); }\n    typedef void is_transparent;\n};\n#endif\n\n\n#if _LIBCPP_STD_VER > 11\ntemplate <class _Tp = void>\n#else\ntemplate <class _Tp>\n#endif\nstruct _LIBCPP_TEMPLATE_VIS not_equal_to : binary_function<_Tp, _Tp, bool>\n{\n    _LIBCPP_CONSTEXPR_AFTER_CXX11 _LIBCPP_INLINE_VISIBILITY\n    bool operator()(const _Tp& __x, const _Tp& __y) const\n        {return __x != __y;}\n};\n\n#if _LIBCPP_STD_VER > 11\ntemplate <>\nstruct _LIBCPP_TEMPLATE_VIS not_equal_to<void>\n{\n    template <class _T1, class _T2>\n    _LIBCPP_CONSTEXPR_AFTER_CXX11 _LIBCPP_INLINE_VISIBILITY\n    auto operator()(_T1&& __t, _T2&& __u) const\n    _NOEXCEPT_(noexcept(_VSTD::forward<_T1>(__t) != _VSTD::forward<_T2>(__u)))\n    -> decltype        (_VSTD::forward<_T1>(__t) != _VSTD::forward<_T2>(__u))\n        { return        _VSTD::forward<_T1>(__t) != _VSTD::forward<_T2>(__u); }\n    typedef void is_transparent;\n};\n#endif\n\n\n#if _LIBCPP_STD_VER > 11\ntemplate <class _Tp = void>\n#else\ntemplate <class _Tp>\n#endif\nstruct _LIBCPP_TEMPLATE_VIS greater : binary_function<_Tp, _Tp, bool>\n{\n    _LIBCPP_CONSTEXPR_AFTER_CXX11 _LIBCPP_INLINE_VISIBILITY\n    bool operator()(const _Tp& __x, const _Tp& __y) const\n        {return __x > __y;}\n};\n\n#if _LIBCPP_STD_VER > 11\ntemplate <>\nstruct _LIBCPP_TEMPLATE_VIS greater<void>\n{\n    template <class _T1, class _T2>\n    _LIBCPP_CONSTEXPR_AFTER_CXX11 _LIBCPP_INLINE_VISIBILITY\n    auto operator()(_T1&& __t, _T2&& __u) const\n    _NOEXCEPT_(noexcept(_VSTD::forward<_T1>(__t) > _VSTD::forward<_T2>(__u)))\n    -> decltype        (_VSTD::forward<_T1>(__t) > _VSTD::forward<_T2>(__u))\n        { return        _VSTD::forward<_T1>(__t) > _VSTD::forward<_T2>(__u); }\n    typedef void is_transparent;\n};\n#endif\n\n\n// less in <__functional_base>\n\n#if _LIBCPP_STD_VER > 11\ntemplate <class _Tp = void>\n#else\ntemplate <class _Tp>\n#endif\nstruct _LIBCPP_TEMPLATE_VIS greater_equal : binary_function<_Tp, _Tp, bool>\n{\n    _LIBCPP_CONSTEXPR_AFTER_CXX11 _LIBCPP_INLINE_VISIBILITY\n    bool operator()(const _Tp& __x, const _Tp& __y) const\n        {return __x >= __y;}\n};\n\n#if _LIBCPP_STD_VER > 11\ntemplate <>\nstruct _LIBCPP_TEMPLATE_VIS greater_equal<void>\n{\n    template <class _T1, class _T2>\n    _LIBCPP_CONSTEXPR_AFTER_CXX11 _LIBCPP_INLINE_VISIBILITY\n    auto operator()(_T1&& __t, _T2&& __u) const\n    _NOEXCEPT_(noexcept(_VSTD::forward<_T1>(__t) >= _VSTD::forward<_T2>(__u)))\n    -> decltype        (_VSTD::forward<_T1>(__t) >= _VSTD::forward<_T2>(__u))\n        { return        _VSTD::forward<_T1>(__t) >= _VSTD::forward<_T2>(__u); }\n    typedef void is_transparent;\n};\n#endif\n\n\n#if _LIBCPP_STD_VER > 11\ntemplate <class _Tp = void>\n#else\ntemplate <class _Tp>\n#endif\nstruct _LIBCPP_TEMPLATE_VIS less_equal : binary_function<_Tp, _Tp, bool>\n{\n    _LIBCPP_CONSTEXPR_AFTER_CXX11 _LIBCPP_INLINE_VISIBILITY\n    bool operator()(const _Tp& __x, const _Tp& __y) const\n        {return __x <= __y;}\n};\n\n#if _LIBCPP_STD_VER > 11\ntemplate <>\nstruct _LIBCPP_TEMPLATE_VIS less_equal<void>\n{\n    template <class _T1, class _T2>\n    _LIBCPP_CONSTEXPR_AFTER_CXX11 _LIBCPP_INLINE_VISIBILITY\n    auto operator()(_T1&& __t, _T2&& __u) const\n    _NOEXCEPT_(noexcept(_VSTD::forward<_T1>(__t) <= _VSTD::forward<_T2>(__u)))\n    -> decltype        (_VSTD::forward<_T1>(__t) <= _VSTD::forward<_T2>(__u))\n        { return        _VSTD::forward<_T1>(__t) <= _VSTD::forward<_T2>(__u); }\n    typedef void is_transparent;\n};\n#endif\n\n\n#if _LIBCPP_STD_VER > 11\ntemplate <class _Tp = void>\n#else\ntemplate <class _Tp>\n#endif\nstruct _LIBCPP_TEMPLATE_VIS logical_and : binary_function<_Tp, _Tp, bool>\n{\n    _LIBCPP_CONSTEXPR_AFTER_CXX11 _LIBCPP_INLINE_VISIBILITY\n    bool operator()(const _Tp& __x, const _Tp& __y) const\n        {return __x && __y;}\n};\n\n#if _LIBCPP_STD_VER > 11\ntemplate <>\nstruct _LIBCPP_TEMPLATE_VIS logical_and<void>\n{\n    template <class _T1, class _T2>\n    _LIBCPP_CONSTEXPR_AFTER_CXX11 _LIBCPP_INLINE_VISIBILITY\n    auto operator()(_T1&& __t, _T2&& __u) const\n    _NOEXCEPT_(noexcept(_VSTD::forward<_T1>(__t) && _VSTD::forward<_T2>(__u)))\n    -> decltype        (_VSTD::forward<_T1>(__t) && _VSTD::forward<_T2>(__u))\n        { return        _VSTD::forward<_T1>(__t) && _VSTD::forward<_T2>(__u); }\n    typedef void is_transparent;\n};\n#endif\n\n\n#if _LIBCPP_STD_VER > 11\ntemplate <class _Tp = void>\n#else\ntemplate <class _Tp>\n#endif\nstruct _LIBCPP_TEMPLATE_VIS logical_or : binary_function<_Tp, _Tp, bool>\n{\n    _LIBCPP_CONSTEXPR_AFTER_CXX11 _LIBCPP_INLINE_VISIBILITY\n    bool operator()(const _Tp& __x, const _Tp& __y) const\n        {return __x || __y;}\n};\n\n#if _LIBCPP_STD_VER > 11\ntemplate <>\nstruct _LIBCPP_TEMPLATE_VIS logical_or<void>\n{\n    template <class _T1, class _T2>\n    _LIBCPP_CONSTEXPR_AFTER_CXX11 _LIBCPP_INLINE_VISIBILITY\n    auto operator()(_T1&& __t, _T2&& __u) const\n    _NOEXCEPT_(noexcept(_VSTD::forward<_T1>(__t) || _VSTD::forward<_T2>(__u)))\n    -> decltype        (_VSTD::forward<_T1>(__t) || _VSTD::forward<_T2>(__u))\n        { return        _VSTD::forward<_T1>(__t) || _VSTD::forward<_T2>(__u); }\n    typedef void is_transparent;\n};\n#endif\n\n\n#if _LIBCPP_STD_VER > 11\ntemplate <class _Tp = void>\n#else\ntemplate <class _Tp>\n#endif\nstruct _LIBCPP_TEMPLATE_VIS logical_not : unary_function<_Tp, bool>\n{\n    _LIBCPP_CONSTEXPR_AFTER_CXX11 _LIBCPP_INLINE_VISIBILITY\n    bool operator()(const _Tp& __x) const\n        {return !__x;}\n};\n\n#if _LIBCPP_STD_VER > 11\ntemplate <>\nstruct _LIBCPP_TEMPLATE_VIS logical_not<void>\n{\n    template <class _Tp>\n    _LIBCPP_CONSTEXPR_AFTER_CXX11 _LIBCPP_INLINE_VISIBILITY\n    auto operator()(_Tp&& __x) const\n    _NOEXCEPT_(noexcept(!_VSTD::forward<_Tp>(__x)))\n    -> decltype        (!_VSTD::forward<_Tp>(__x))\n        { return        !_VSTD::forward<_Tp>(__x); }\n    typedef void is_transparent;\n};\n#endif\n\n\n#if _LIBCPP_STD_VER > 11\ntemplate <class _Tp = void>\n#else\ntemplate <class _Tp>\n#endif\nstruct _LIBCPP_TEMPLATE_VIS bit_and : binary_function<_Tp, _Tp, _Tp>\n{\n    _LIBCPP_CONSTEXPR_AFTER_CXX11 _LIBCPP_INLINE_VISIBILITY\n    _Tp operator()(const _Tp& __x, const _Tp& __y) const\n        {return __x & __y;}\n};\n\n#if _LIBCPP_STD_VER > 11\ntemplate <>\nstruct _LIBCPP_TEMPLATE_VIS bit_and<void>\n{\n    template <class _T1, class _T2>\n    _LIBCPP_CONSTEXPR_AFTER_CXX11 _LIBCPP_INLINE_VISIBILITY\n    auto operator()(_T1&& __t, _T2&& __u) const\n    _NOEXCEPT_(noexcept(_VSTD::forward<_T1>(__t) & _VSTD::forward<_T2>(__u)))\n    -> decltype        (_VSTD::forward<_T1>(__t) & _VSTD::forward<_T2>(__u))\n        { return        _VSTD::forward<_T1>(__t) & _VSTD::forward<_T2>(__u); }\n    typedef void is_transparent;\n};\n#endif\n\n\n#if _LIBCPP_STD_VER > 11\ntemplate <class _Tp = void>\n#else\ntemplate <class _Tp>\n#endif\nstruct _LIBCPP_TEMPLATE_VIS bit_or : binary_function<_Tp, _Tp, _Tp>\n{\n    _LIBCPP_CONSTEXPR_AFTER_CXX11 _LIBCPP_INLINE_VISIBILITY\n    _Tp operator()(const _Tp& __x, const _Tp& __y) const\n        {return __x | __y;}\n};\n\n#if _LIBCPP_STD_VER > 11\ntemplate <>\nstruct _LIBCPP_TEMPLATE_VIS bit_or<void>\n{\n    template <class _T1, class _T2>\n    _LIBCPP_CONSTEXPR_AFTER_CXX11 _LIBCPP_INLINE_VISIBILITY\n    auto operator()(_T1&& __t, _T2&& __u) const\n    _NOEXCEPT_(noexcept(_VSTD::forward<_T1>(__t) | _VSTD::forward<_T2>(__u)))\n    -> decltype        (_VSTD::forward<_T1>(__t) | _VSTD::forward<_T2>(__u))\n        { return        _VSTD::forward<_T1>(__t) | _VSTD::forward<_T2>(__u); }\n    typedef void is_transparent;\n};\n#endif\n\n\n#if _LIBCPP_STD_VER > 11\ntemplate <class _Tp = void>\n#else\ntemplate <class _Tp>\n#endif\nstruct _LIBCPP_TEMPLATE_VIS bit_xor : binary_function<_Tp, _Tp, _Tp>\n{\n    _LIBCPP_CONSTEXPR_AFTER_CXX11 _LIBCPP_INLINE_VISIBILITY\n    _Tp operator()(const _Tp& __x, const _Tp& __y) const\n        {return __x ^ __y;}\n};\n\n#if _LIBCPP_STD_VER > 11\ntemplate <>\nstruct _LIBCPP_TEMPLATE_VIS bit_xor<void>\n{\n    template <class _T1, class _T2>\n    _LIBCPP_CONSTEXPR_AFTER_CXX11 _LIBCPP_INLINE_VISIBILITY\n    auto operator()(_T1&& __t, _T2&& __u) const\n    _NOEXCEPT_(noexcept(_VSTD::forward<_T1>(__t) ^ _VSTD::forward<_T2>(__u)))\n    -> decltype        (_VSTD::forward<_T1>(__t) ^ _VSTD::forward<_T2>(__u))\n        { return        _VSTD::forward<_T1>(__t) ^ _VSTD::forward<_T2>(__u); }\n    typedef void is_transparent;\n};\n#endif\n\n\n#if _LIBCPP_STD_VER > 11\ntemplate <class _Tp = void>\nstruct _LIBCPP_TEMPLATE_VIS bit_not : unary_function<_Tp, _Tp>\n{\n    _LIBCPP_CONSTEXPR_AFTER_CXX11 _LIBCPP_INLINE_VISIBILITY\n    _Tp operator()(const _Tp& __x) const\n        {return ~__x;}\n};\n\ntemplate <>\nstruct _LIBCPP_TEMPLATE_VIS bit_not<void>\n{\n    template <class _Tp>\n    _LIBCPP_CONSTEXPR_AFTER_CXX11 _LIBCPP_INLINE_VISIBILITY\n    auto operator()(_Tp&& __x) const\n    _NOEXCEPT_(noexcept(~_VSTD::forward<_Tp>(__x)))\n    -> decltype        (~_VSTD::forward<_Tp>(__x))\n        { return        ~_VSTD::forward<_Tp>(__x); }\n    typedef void is_transparent;\n};\n#endif\n\ntemplate <class _Predicate>\nclass _LIBCPP_TEMPLATE_VIS unary_negate\n    : public unary_function<typename _Predicate::argument_type, bool>\n{\n    _Predicate __pred_;\npublic:\n    _LIBCPP_CONSTEXPR_AFTER_CXX11 _LIBCPP_INLINE_VISIBILITY\n    explicit unary_negate(const _Predicate& __pred)\n        : __pred_(__pred) {}\n    _LIBCPP_CONSTEXPR_AFTER_CXX11 _LIBCPP_INLINE_VISIBILITY\n    bool operator()(const typename _Predicate::argument_type& __x) const\n        {return !__pred_(__x);}\n};\n\ntemplate <class _Predicate>\ninline _LIBCPP_CONSTEXPR_AFTER_CXX11 _LIBCPP_INLINE_VISIBILITY\nunary_negate<_Predicate>\nnot1(const _Predicate& __pred) {return unary_negate<_Predicate>(__pred);}\n\ntemplate <class _Predicate>\nclass _LIBCPP_TEMPLATE_VIS binary_negate\n    : public binary_function<typename _Predicate::first_argument_type,\n                             typename _Predicate::second_argument_type,\n                             bool>\n{\n    _Predicate __pred_;\npublic:\n    _LIBCPP_INLINE_VISIBILITY explicit _LIBCPP_CONSTEXPR_AFTER_CXX11 \n    binary_negate(const _Predicate& __pred) : __pred_(__pred) {}\n\n    _LIBCPP_CONSTEXPR_AFTER_CXX11 _LIBCPP_INLINE_VISIBILITY\n    bool operator()(const typename _Predicate::first_argument_type& __x,\n                    const typename _Predicate::second_argument_type& __y) const\n        {return !__pred_(__x, __y);}\n};\n\ntemplate <class _Predicate>\ninline _LIBCPP_CONSTEXPR_AFTER_CXX11 _LIBCPP_INLINE_VISIBILITY\nbinary_negate<_Predicate>\nnot2(const _Predicate& __pred) {return binary_negate<_Predicate>(__pred);}\n\ntemplate <class __Operation>\nclass _LIBCPP_TEMPLATE_VIS binder1st\n    : public unary_function<typename __Operation::second_argument_type,\n                            typename __Operation::result_type>\n{\nprotected:\n    __Operation                               op;\n    typename __Operation::first_argument_type value;\npublic:\n    _LIBCPP_INLINE_VISIBILITY binder1st(const __Operation& __x,\n                               const typename __Operation::first_argument_type __y)\n        : op(__x), value(__y) {}\n    _LIBCPP_INLINE_VISIBILITY typename __Operation::result_type operator()\n        (typename __Operation::second_argument_type& __x) const\n            {return op(value, __x);}\n    _LIBCPP_INLINE_VISIBILITY typename __Operation::result_type operator()\n        (const typename __Operation::second_argument_type& __x) const\n            {return op(value, __x);}\n};\n\ntemplate <class __Operation, class _Tp>\ninline _LIBCPP_INLINE_VISIBILITY\nbinder1st<__Operation>\nbind1st(const __Operation& __op, const _Tp& __x)\n    {return binder1st<__Operation>(__op, __x);}\n\ntemplate <class __Operation>\nclass _LIBCPP_TEMPLATE_VIS binder2nd\n    : public unary_function<typename __Operation::first_argument_type,\n                            typename __Operation::result_type>\n{\nprotected:\n    __Operation                                op;\n    typename __Operation::second_argument_type value;\npublic:\n    _LIBCPP_INLINE_VISIBILITY\n    binder2nd(const __Operation& __x, const typename __Operation::second_argument_type __y)\n        : op(__x), value(__y) {}\n    _LIBCPP_INLINE_VISIBILITY typename __Operation::result_type operator()\n        (      typename __Operation::first_argument_type& __x) const\n            {return op(__x, value);}\n    _LIBCPP_INLINE_VISIBILITY typename __Operation::result_type operator()\n        (const typename __Operation::first_argument_type& __x) const\n            {return op(__x, value);}\n};\n\ntemplate <class __Operation, class _Tp>\ninline _LIBCPP_INLINE_VISIBILITY\nbinder2nd<__Operation>\nbind2nd(const __Operation& __op, const _Tp& __x)\n    {return binder2nd<__Operation>(__op, __x);}\n\ntemplate <class _Arg, class _Result>\nclass _LIBCPP_TEMPLATE_VIS pointer_to_unary_function\n    : public unary_function<_Arg, _Result>\n{\n    _Result (*__f_)(_Arg);\npublic:\n    _LIBCPP_INLINE_VISIBILITY explicit pointer_to_unary_function(_Result (*__f)(_Arg))\n        : __f_(__f) {}\n    _LIBCPP_INLINE_VISIBILITY _Result operator()(_Arg __x) const\n        {return __f_(__x);}\n};\n\ntemplate <class _Arg, class _Result>\ninline _LIBCPP_INLINE_VISIBILITY\npointer_to_unary_function<_Arg,_Result>\nptr_fun(_Result (*__f)(_Arg))\n    {return pointer_to_unary_function<_Arg,_Result>(__f);}\n\ntemplate <class _Arg1, class _Arg2, class _Result>\nclass _LIBCPP_TEMPLATE_VIS pointer_to_binary_function\n    : public binary_function<_Arg1, _Arg2, _Result>\n{\n    _Result (*__f_)(_Arg1, _Arg2);\npublic:\n    _LIBCPP_INLINE_VISIBILITY explicit pointer_to_binary_function(_Result (*__f)(_Arg1, _Arg2))\n        : __f_(__f) {}\n    _LIBCPP_INLINE_VISIBILITY _Result operator()(_Arg1 __x, _Arg2 __y) const\n        {return __f_(__x, __y);}\n};\n\ntemplate <class _Arg1, class _Arg2, class _Result>\ninline _LIBCPP_INLINE_VISIBILITY\npointer_to_binary_function<_Arg1,_Arg2,_Result>\nptr_fun(_Result (*__f)(_Arg1,_Arg2))\n    {return pointer_to_binary_function<_Arg1,_Arg2,_Result>(__f);}\n\ntemplate<class _Sp, class _Tp>\nclass _LIBCPP_TEMPLATE_VIS mem_fun_t : public unary_function<_Tp*, _Sp>\n{\n    _Sp (_Tp::*__p_)();\npublic:\n    _LIBCPP_INLINE_VISIBILITY explicit mem_fun_t(_Sp (_Tp::*__p)())\n        : __p_(__p) {}\n    _LIBCPP_INLINE_VISIBILITY _Sp operator()(_Tp* __p) const\n        {return (__p->*__p_)();}\n};\n\ntemplate<class _Sp, class _Tp, class _Ap>\nclass _LIBCPP_TEMPLATE_VIS mem_fun1_t : public binary_function<_Tp*, _Ap, _Sp>\n{\n    _Sp (_Tp::*__p_)(_Ap);\npublic:\n    _LIBCPP_INLINE_VISIBILITY explicit mem_fun1_t(_Sp (_Tp::*__p)(_Ap))\n        : __p_(__p) {}\n    _LIBCPP_INLINE_VISIBILITY _Sp operator()(_Tp* __p, _Ap __x) const\n        {return (__p->*__p_)(__x);}\n};\n\ntemplate<class _Sp, class _Tp>\ninline _LIBCPP_INLINE_VISIBILITY\nmem_fun_t<_Sp,_Tp>\nmem_fun(_Sp (_Tp::*__f)())\n    {return mem_fun_t<_Sp,_Tp>(__f);}\n\ntemplate<class _Sp, class _Tp, class _Ap>\ninline _LIBCPP_INLINE_VISIBILITY\nmem_fun1_t<_Sp,_Tp,_Ap>\nmem_fun(_Sp (_Tp::*__f)(_Ap))\n    {return mem_fun1_t<_Sp,_Tp,_Ap>(__f);}\n\ntemplate<class _Sp, class _Tp>\nclass _LIBCPP_TEMPLATE_VIS mem_fun_ref_t : public unary_function<_Tp, _Sp>\n{\n    _Sp (_Tp::*__p_)();\npublic:\n    _LIBCPP_INLINE_VISIBILITY explicit mem_fun_ref_t(_Sp (_Tp::*__p)())\n        : __p_(__p) {}\n    _LIBCPP_INLINE_VISIBILITY _Sp operator()(_Tp& __p) const\n        {return (__p.*__p_)();}\n};\n\ntemplate<class _Sp, class _Tp, class _Ap>\nclass _LIBCPP_TEMPLATE_VIS mem_fun1_ref_t : public binary_function<_Tp, _Ap, _Sp>\n{\n    _Sp (_Tp::*__p_)(_Ap);\npublic:\n    _LIBCPP_INLINE_VISIBILITY explicit mem_fun1_ref_t(_Sp (_Tp::*__p)(_Ap))\n        : __p_(__p) {}\n    _LIBCPP_INLINE_VISIBILITY _Sp operator()(_Tp& __p, _Ap __x) const\n        {return (__p.*__p_)(__x);}\n};\n\ntemplate<class _Sp, class _Tp>\ninline _LIBCPP_INLINE_VISIBILITY\nmem_fun_ref_t<_Sp,_Tp>\nmem_fun_ref(_Sp (_Tp::*__f)())\n    {return mem_fun_ref_t<_Sp,_Tp>(__f);}\n\ntemplate<class _Sp, class _Tp, class _Ap>\ninline _LIBCPP_INLINE_VISIBILITY\nmem_fun1_ref_t<_Sp,_Tp,_Ap>\nmem_fun_ref(_Sp (_Tp::*__f)(_Ap))\n    {return mem_fun1_ref_t<_Sp,_Tp,_Ap>(__f);}\n\ntemplate <class _Sp, class _Tp>\nclass _LIBCPP_TEMPLATE_VIS const_mem_fun_t : public unary_function<const _Tp*, _Sp>\n{\n    _Sp (_Tp::*__p_)() const;\npublic:\n    _LIBCPP_INLINE_VISIBILITY explicit const_mem_fun_t(_Sp (_Tp::*__p)() const)\n        : __p_(__p) {}\n    _LIBCPP_INLINE_VISIBILITY _Sp operator()(const _Tp* __p) const\n        {return (__p->*__p_)();}\n};\n\ntemplate <class _Sp, class _Tp, class _Ap>\nclass _LIBCPP_TEMPLATE_VIS const_mem_fun1_t : public binary_function<const _Tp*, _Ap, _Sp>\n{\n    _Sp (_Tp::*__p_)(_Ap) const;\npublic:\n    _LIBCPP_INLINE_VISIBILITY explicit const_mem_fun1_t(_Sp (_Tp::*__p)(_Ap) const)\n        : __p_(__p) {}\n    _LIBCPP_INLINE_VISIBILITY _Sp operator()(const _Tp* __p, _Ap __x) const\n        {return (__p->*__p_)(__x);}\n};\n\ntemplate <class _Sp, class _Tp>\ninline _LIBCPP_INLINE_VISIBILITY\nconst_mem_fun_t<_Sp,_Tp>\nmem_fun(_Sp (_Tp::*__f)() const)\n    {return const_mem_fun_t<_Sp,_Tp>(__f);}\n\ntemplate <class _Sp, class _Tp, class _Ap>\ninline _LIBCPP_INLINE_VISIBILITY\nconst_mem_fun1_t<_Sp,_Tp,_Ap>\nmem_fun(_Sp (_Tp::*__f)(_Ap) const)\n    {return const_mem_fun1_t<_Sp,_Tp,_Ap>(__f);}\n\ntemplate <class _Sp, class _Tp>\nclass _LIBCPP_TEMPLATE_VIS const_mem_fun_ref_t : public unary_function<_Tp, _Sp>\n{\n    _Sp (_Tp::*__p_)() const;\npublic:\n    _LIBCPP_INLINE_VISIBILITY explicit const_mem_fun_ref_t(_Sp (_Tp::*__p)() const)\n        : __p_(__p) {}\n    _LIBCPP_INLINE_VISIBILITY _Sp operator()(const _Tp& __p) const\n        {return (__p.*__p_)();}\n};\n\ntemplate <class _Sp, class _Tp, class _Ap>\nclass _LIBCPP_TEMPLATE_VIS const_mem_fun1_ref_t\n    : public binary_function<_Tp, _Ap, _Sp>\n{\n    _Sp (_Tp::*__p_)(_Ap) const;\npublic:\n    _LIBCPP_INLINE_VISIBILITY explicit const_mem_fun1_ref_t(_Sp (_Tp::*__p)(_Ap) const)\n        : __p_(__p) {}\n    _LIBCPP_INLINE_VISIBILITY _Sp operator()(const _Tp& __p, _Ap __x) const\n        {return (__p.*__p_)(__x);}\n};\n\ntemplate <class _Sp, class _Tp>\ninline _LIBCPP_INLINE_VISIBILITY\nconst_mem_fun_ref_t<_Sp,_Tp>\nmem_fun_ref(_Sp (_Tp::*__f)() const)\n    {return const_mem_fun_ref_t<_Sp,_Tp>(__f);}\n\ntemplate <class _Sp, class _Tp, class _Ap>\ninline _LIBCPP_INLINE_VISIBILITY\nconst_mem_fun1_ref_t<_Sp,_Tp,_Ap>\nmem_fun_ref(_Sp (_Tp::*__f)(_Ap) const)\n    {return const_mem_fun1_ref_t<_Sp,_Tp,_Ap>(__f);}\n\n////////////////////////////////////////////////////////////////////////////////\n//                                MEMFUN\n//==============================================================================\n\ntemplate <class _Tp>\nclass __mem_fn\n    : public __weak_result_type<_Tp>\n{\npublic:\n    // types\n    typedef _Tp type;\nprivate:\n    type __f_;\n\npublic:\n    _LIBCPP_INLINE_VISIBILITY __mem_fn(type __f) _NOEXCEPT : __f_(__f) {}\n\n#ifndef _LIBCPP_HAS_NO_VARIADICS\n    // invoke\n    template <class... _ArgTypes>\n    _LIBCPP_INLINE_VISIBILITY\n    typename __invoke_return<type, _ArgTypes...>::type\n    operator() (_ArgTypes&&... __args) const {\n        return __invoke(__f_, _VSTD::forward<_ArgTypes>(__args)...);\n    }\n#else\n\n    template <class _A0>\n    _LIBCPP_INLINE_VISIBILITY\n    typename __invoke_return0<type, _A0>::type\n    operator() (_A0& __a0) const {\n        return __invoke(__f_, __a0);\n    }\n\n    template <class _A0>\n    _LIBCPP_INLINE_VISIBILITY\n    typename __invoke_return0<type, _A0 const>::type\n    operator() (_A0 const& __a0) const {\n        return __invoke(__f_, __a0);\n    }\n\n    template <class _A0, class _A1>\n    _LIBCPP_INLINE_VISIBILITY\n    typename __invoke_return1<type, _A0, _A1>::type\n    operator() (_A0& __a0, _A1& __a1) const {\n        return __invoke(__f_, __a0, __a1);\n    }\n\n    template <class _A0, class _A1>\n    _LIBCPP_INLINE_VISIBILITY\n    typename __invoke_return1<type, _A0 const, _A1>::type\n    operator() (_A0 const& __a0, _A1& __a1) const {\n        return __invoke(__f_, __a0, __a1);\n    }\n\n    template <class _A0, class _A1>\n    _LIBCPP_INLINE_VISIBILITY\n    typename __invoke_return1<type, _A0, _A1 const>::type\n    operator() (_A0& __a0, _A1 const& __a1) const {\n        return __invoke(__f_, __a0, __a1);\n    }\n\n    template <class _A0, class _A1>\n    _LIBCPP_INLINE_VISIBILITY\n    typename __invoke_return1<type, _A0 const, _A1 const>::type\n    operator() (_A0 const& __a0, _A1 const& __a1) const {\n        return __invoke(__f_, __a0, __a1);\n    }\n\n    template <class _A0, class _A1, class _A2>\n    _LIBCPP_INLINE_VISIBILITY\n    typename __invoke_return2<type, _A0, _A1, _A2>::type\n    operator() (_A0& __a0, _A1& __a1, _A2& __a2) const {\n        return __invoke(__f_, __a0, __a1, __a2);\n    }\n\n    template <class _A0, class _A1, class _A2>\n    _LIBCPP_INLINE_VISIBILITY\n    typename __invoke_return2<type, _A0 const, _A1, _A2>::type\n    operator() (_A0 const& __a0, _A1& __a1, _A2& __a2) const {\n        return __invoke(__f_, __a0, __a1, __a2);\n    }\n\n    template <class _A0, class _A1, class _A2>\n    _LIBCPP_INLINE_VISIBILITY\n    typename __invoke_return2<type, _A0, _A1 const, _A2>::type\n    operator() (_A0& __a0, _A1 const& __a1, _A2& __a2) const {\n        return __invoke(__f_, __a0, __a1, __a2);\n    }\n\n    template <class _A0, class _A1, class _A2>\n    _LIBCPP_INLINE_VISIBILITY\n    typename __invoke_return2<type, _A0, _A1, _A2 const>::type\n    operator() (_A0& __a0, _A1& __a1, _A2 const& __a2) const {\n        return __invoke(__f_, __a0, __a1, __a2);\n    }\n\n    template <class _A0, class _A1, class _A2>\n    _LIBCPP_INLINE_VISIBILITY\n    typename __invoke_return2<type, _A0 const, _A1 const, _A2>::type\n    operator() (_A0 const& __a0, _A1 const& __a1, _A2& __a2) const {\n        return __invoke(__f_, __a0, __a1, __a2);\n    }\n\n    template <class _A0, class _A1, class _A2>\n    _LIBCPP_INLINE_VISIBILITY\n    typename __invoke_return2<type, _A0 const, _A1, _A2 const>::type\n    operator() (_A0 const& __a0, _A1& __a1, _A2 const& __a2) const {\n        return __invoke(__f_, __a0, __a1, __a2);\n    }\n\n    template <class _A0, class _A1, class _A2>\n    _LIBCPP_INLINE_VISIBILITY\n    typename __invoke_return2<type, _A0, _A1 const, _A2 const>::type\n    operator() (_A0& __a0, _A1 const& __a1, _A2 const& __a2) const {\n        return __invoke(__f_, __a0, __a1, __a2);\n    }\n\n    template <class _A0, class _A1, class _A2>\n    _LIBCPP_INLINE_VISIBILITY\n    typename __invoke_return2<type, _A0 const, _A1 const, _A2 const>::type\n    operator() (_A0 const& __a0, _A1 const& __a1, _A2 const& __a2) const {\n        return __invoke(__f_, __a0, __a1, __a2);\n    }\n#endif\n};\n\ntemplate<class _Rp, class _Tp>\ninline _LIBCPP_INLINE_VISIBILITY\n__mem_fn<_Rp _Tp::*>\nmem_fn(_Rp _Tp::* __pm) _NOEXCEPT\n{\n    return __mem_fn<_Rp _Tp::*>(__pm);\n}\n\n////////////////////////////////////////////////////////////////////////////////\n//                                FUNCTION\n//==============================================================================\n\n// bad_function_call\n\nclass _LIBCPP_EXCEPTION_ABI bad_function_call\n    : public exception\n{\n};\n\n_LIBCPP_NORETURN inline _LIBCPP_ALWAYS_INLINE\nvoid __throw_bad_function_call()\n{\n#ifndef _LIBCPP_NO_EXCEPTIONS\n    throw bad_function_call();\n#else\n\t_VSTD::abort();\n#endif\n}\n\ntemplate<class _Fp> class _LIBCPP_TEMPLATE_VIS function; // undefined\n\nnamespace __function\n{\n\ntemplate<class _Rp>\nstruct __maybe_derive_from_unary_function\n{\n};\n\ntemplate<class _Rp, class _A1>\nstruct __maybe_derive_from_unary_function<_Rp(_A1)>\n    : public unary_function<_A1, _Rp>\n{\n};\n\ntemplate<class _Rp>\nstruct __maybe_derive_from_binary_function\n{\n};\n\ntemplate<class _Rp, class _A1, class _A2>\nstruct __maybe_derive_from_binary_function<_Rp(_A1, _A2)>\n    : public binary_function<_A1, _A2, _Rp>\n{\n};\n\ntemplate <class _Fp>\n_LIBCPP_INLINE_VISIBILITY\nbool __not_null(_Fp const&) { return true; }\n\ntemplate <class _Fp>\n_LIBCPP_INLINE_VISIBILITY\nbool __not_null(_Fp* __ptr) { return __ptr; }\n\ntemplate <class _Ret, class _Class>\n_LIBCPP_INLINE_VISIBILITY\nbool __not_null(_Ret _Class::*__ptr) { return __ptr; }\n\ntemplate <class _Fp>\n_LIBCPP_INLINE_VISIBILITY\nbool __not_null(function<_Fp> const& __f) { return !!__f; }\n\n} // namespace __function\n\n#ifndef _LIBCPP_HAS_NO_VARIADICS\n\nnamespace __function {\n\ntemplate<class _Fp> class __base;\n\ntemplate<class _Rp, class ..._ArgTypes>\nclass __base<_Rp(_ArgTypes...)>\n{\n    __base(const __base&);\n    __base& operator=(const __base&);\npublic:\n    _LIBCPP_INLINE_VISIBILITY __base() {}\n    _LIBCPP_INLINE_VISIBILITY virtual ~__base() {}\n    virtual __base* __clone() const = 0;\n    virtual void __clone(__base*) const = 0;\n    virtual void destroy() _NOEXCEPT = 0;\n    virtual void destroy_deallocate() _NOEXCEPT = 0;\n    virtual _Rp operator()(_ArgTypes&& ...) = 0;\n#ifndef _LIBCPP_NO_RTTI\n    virtual const void* target(const type_info&) const _NOEXCEPT = 0;\n    virtual const std::type_info& target_type() const _NOEXCEPT = 0;\n#endif  // _LIBCPP_NO_RTTI\n};\n\ntemplate<class _FD, class _Alloc, class _FB> class __func;\n\ntemplate<class _Fp, class _Alloc, class _Rp, class ..._ArgTypes>\nclass __func<_Fp, _Alloc, _Rp(_ArgTypes...)>\n    : public  __base<_Rp(_ArgTypes...)>\n{\n    __compressed_pair<_Fp, _Alloc> __f_;\npublic:\n    _LIBCPP_INLINE_VISIBILITY\n    explicit __func(_Fp&& __f)\n        : __f_(piecewise_construct, _VSTD::forward_as_tuple(_VSTD::move(__f)),\n                                    _VSTD::forward_as_tuple()) {}\n    _LIBCPP_INLINE_VISIBILITY\n    explicit __func(const _Fp& __f, const _Alloc& __a)\n        : __f_(piecewise_construct, _VSTD::forward_as_tuple(__f),\n                                    _VSTD::forward_as_tuple(__a)) {}\n\n    _LIBCPP_INLINE_VISIBILITY\n    explicit __func(const _Fp& __f, _Alloc&& __a)\n        : __f_(piecewise_construct, _VSTD::forward_as_tuple(__f),\n                                    _VSTD::forward_as_tuple(_VSTD::move(__a))) {}\n\n    _LIBCPP_INLINE_VISIBILITY\n    explicit __func(_Fp&& __f, _Alloc&& __a)\n        : __f_(piecewise_construct, _VSTD::forward_as_tuple(_VSTD::move(__f)),\n                                    _VSTD::forward_as_tuple(_VSTD::move(__a))) {}\n    virtual __base<_Rp(_ArgTypes...)>* __clone() const;\n    virtual void __clone(__base<_Rp(_ArgTypes...)>*) const;\n    virtual void destroy() _NOEXCEPT;\n    virtual void destroy_deallocate() _NOEXCEPT;\n    virtual _Rp operator()(_ArgTypes&& ... __arg);\n#ifndef _LIBCPP_NO_RTTI\n    virtual const void* target(const type_info&) const _NOEXCEPT;\n    virtual const std::type_info& target_type() const _NOEXCEPT;\n#endif  // _LIBCPP_NO_RTTI\n};\n\ntemplate<class _Fp, class _Alloc, class _Rp, class ..._ArgTypes>\n__base<_Rp(_ArgTypes...)>*\n__func<_Fp, _Alloc, _Rp(_ArgTypes...)>::__clone() const\n{\n    typedef allocator_traits<_Alloc> __alloc_traits;\n    typedef typename __rebind_alloc_helper<__alloc_traits, __func>::type _Ap;\n    _Ap __a(__f_.second());\n    typedef __allocator_destructor<_Ap> _Dp;\n    unique_ptr<__func, _Dp> __hold(__a.allocate(1), _Dp(__a, 1));\n    ::new (__hold.get()) __func(__f_.first(), _Alloc(__a));\n    return __hold.release();\n}\n\ntemplate<class _Fp, class _Alloc, class _Rp, class ..._ArgTypes>\nvoid\n__func<_Fp, _Alloc, _Rp(_ArgTypes...)>::__clone(__base<_Rp(_ArgTypes...)>* __p) const\n{\n    ::new (__p) __func(__f_.first(), __f_.second());\n}\n\ntemplate<class _Fp, class _Alloc, class _Rp, class ..._ArgTypes>\nvoid\n__func<_Fp, _Alloc, _Rp(_ArgTypes...)>::destroy() _NOEXCEPT\n{\n    __f_.~__compressed_pair<_Fp, _Alloc>();\n}\n\ntemplate<class _Fp, class _Alloc, class _Rp, class ..._ArgTypes>\nvoid\n__func<_Fp, _Alloc, _Rp(_ArgTypes...)>::destroy_deallocate() _NOEXCEPT\n{\n    typedef allocator_traits<_Alloc> __alloc_traits;\n    typedef typename __rebind_alloc_helper<__alloc_traits, __func>::type _Ap;\n    _Ap __a(__f_.second());\n    __f_.~__compressed_pair<_Fp, _Alloc>();\n    __a.deallocate(this, 1);\n}\n\ntemplate<class _Fp, class _Alloc, class _Rp, class ..._ArgTypes>\n_Rp\n__func<_Fp, _Alloc, _Rp(_ArgTypes...)>::operator()(_ArgTypes&& ... __arg)\n{\n    typedef __invoke_void_return_wrapper<_Rp> _Invoker;\n    return _Invoker::__call(__f_.first(), _VSTD::forward<_ArgTypes>(__arg)...);\n}\n\n#ifndef _LIBCPP_NO_RTTI\n\ntemplate<class _Fp, class _Alloc, class _Rp, class ..._ArgTypes>\nconst void*\n__func<_Fp, _Alloc, _Rp(_ArgTypes...)>::target(const type_info& __ti) const _NOEXCEPT\n{\n    if (__ti == typeid(_Fp))\n        return &__f_.first();\n    return (const void*)0;\n}\n\ntemplate<class _Fp, class _Alloc, class _Rp, class ..._ArgTypes>\nconst std::type_info&\n__func<_Fp, _Alloc, _Rp(_ArgTypes...)>::target_type() const _NOEXCEPT\n{\n    return typeid(_Fp);\n}\n\n#endif  // _LIBCPP_NO_RTTI\n\n}  // __function\n\ntemplate<class _Rp, class ..._ArgTypes>\nclass _LIBCPP_TEMPLATE_VIS function<_Rp(_ArgTypes...)>\n    : public __function::__maybe_derive_from_unary_function<_Rp(_ArgTypes...)>,\n      public __function::__maybe_derive_from_binary_function<_Rp(_ArgTypes...)>\n{\n    typedef __function::__base<_Rp(_ArgTypes...)> __base;\n    typename aligned_storage<3*sizeof(void*)>::type __buf_;\n    __base* __f_;\n\n    _LIBCPP_NO_CFI static __base *__as_base(void *p) {\n      return reinterpret_cast<__base*>(p);\n    }\n\n    template <class _Fp, bool = !is_same<_Fp, function>::value &&\n                                __invokable<_Fp&, _ArgTypes...>::value>\n        struct __callable;\n    template <class _Fp>\n        struct __callable<_Fp, true>\n        {\n            static const bool value = is_same<void, _Rp>::value ||\n                is_convertible<typename __invoke_of<_Fp&, _ArgTypes...>::type,\n                               _Rp>::value;\n        };\n    template <class _Fp>\n        struct __callable<_Fp, false>\n        {\n            static const bool value = false;\n        };\npublic:\n    typedef _Rp result_type;\n\n    // construct/copy/destroy:\n    _LIBCPP_INLINE_VISIBILITY\n    function() _NOEXCEPT : __f_(0) {}\n    _LIBCPP_INLINE_VISIBILITY\n    function(nullptr_t) _NOEXCEPT : __f_(0) {}\n    function(const function&);\n    function(function&&) _NOEXCEPT;\n    template<class _Fp, class = typename enable_if<\n        __callable<_Fp>::value && !is_same<_Fp, function>::value\n    >::type>\n    function(_Fp);\n\n#if _LIBCPP_STD_VER <= 14\n    template<class _Alloc>\n      _LIBCPP_INLINE_VISIBILITY\n      function(allocator_arg_t, const _Alloc&) _NOEXCEPT : __f_(0) {}\n    template<class _Alloc>\n      _LIBCPP_INLINE_VISIBILITY\n      function(allocator_arg_t, const _Alloc&, nullptr_t) _NOEXCEPT : __f_(0) {}\n    template<class _Alloc>\n      function(allocator_arg_t, const _Alloc&, const function&);\n    template<class _Alloc>\n      function(allocator_arg_t, const _Alloc&, function&&);\n    template<class _Fp, class _Alloc, class = typename enable_if<__callable<_Fp>::value>::type>\n      function(allocator_arg_t, const _Alloc& __a, _Fp __f);\n#endif\n\n    function& operator=(const function&);\n    function& operator=(function&&) _NOEXCEPT;\n    function& operator=(nullptr_t) _NOEXCEPT;\n    template<class _Fp>\n      typename enable_if\n      <\n        __callable<typename decay<_Fp>::type>::value &&\n        !is_same<typename remove_reference<_Fp>::type, function>::value,\n        function&\n      >::type\n      operator=(_Fp&&);\n\n    ~function();\n\n    // function modifiers:\n    void swap(function&) _NOEXCEPT;\n\n#if _LIBCPP_STD_VER <= 14\n    template<class _Fp, class _Alloc>\n      _LIBCPP_INLINE_VISIBILITY\n      void assign(_Fp&& __f, const _Alloc& __a)\n        {function(allocator_arg, __a, _VSTD::forward<_Fp>(__f)).swap(*this);}\n#endif\n\n    // function capacity:\n    _LIBCPP_INLINE_VISIBILITY\n        _LIBCPP_EXPLICIT operator bool() const _NOEXCEPT {return __f_;}\n\n    // deleted overloads close possible hole in the type system\n    template<class _R2, class... _ArgTypes2>\n      bool operator==(const function<_R2(_ArgTypes2...)>&) const = delete;\n    template<class _R2, class... _ArgTypes2>\n      bool operator!=(const function<_R2(_ArgTypes2...)>&) const = delete;\npublic:\n    // function invocation:\n    _Rp operator()(_ArgTypes...) const;\n\n#ifndef _LIBCPP_NO_RTTI\n    // function target access:\n    const std::type_info& target_type() const _NOEXCEPT;\n    template <typename _Tp> _Tp* target() _NOEXCEPT;\n    template <typename _Tp> const _Tp* target() const _NOEXCEPT;\n#endif  // _LIBCPP_NO_RTTI\n};\n\ntemplate<class _Rp, class ..._ArgTypes>\nfunction<_Rp(_ArgTypes...)>::function(const function& __f)\n{\n    if (__f.__f_ == 0)\n        __f_ = 0;\n    else if ((void *)__f.__f_ == &__f.__buf_)\n    {\n        __f_ = __as_base(&__buf_);\n        __f.__f_->__clone(__f_);\n    }\n    else\n        __f_ = __f.__f_->__clone();\n}\n\n#if _LIBCPP_STD_VER <= 14\ntemplate<class _Rp, class ..._ArgTypes>\ntemplate <class _Alloc>\nfunction<_Rp(_ArgTypes...)>::function(allocator_arg_t, const _Alloc&,\n                                     const function& __f)\n{\n    if (__f.__f_ == 0)\n        __f_ = 0;\n    else if ((void *)__f.__f_ == &__f.__buf_)\n    {\n        __f_ = __as_base(&__buf_);\n        __f.__f_->__clone(__f_);\n    }\n    else\n        __f_ = __f.__f_->__clone();\n}\n#endif\n\ntemplate<class _Rp, class ..._ArgTypes>\nfunction<_Rp(_ArgTypes...)>::function(function&& __f) _NOEXCEPT\n{\n    if (__f.__f_ == 0)\n        __f_ = 0;\n    else if ((void *)__f.__f_ == &__f.__buf_)\n    {\n        __f_ = __as_base(&__buf_);\n        __f.__f_->__clone(__f_);\n    }\n    else\n    {\n        __f_ = __f.__f_;\n        __f.__f_ = 0;\n    }\n}\n\n#if _LIBCPP_STD_VER <= 14\ntemplate<class _Rp, class ..._ArgTypes>\ntemplate <class _Alloc>\nfunction<_Rp(_ArgTypes...)>::function(allocator_arg_t, const _Alloc&,\n                                     function&& __f)\n{\n    if (__f.__f_ == 0)\n        __f_ = 0;\n    else if ((void *)__f.__f_ == &__f.__buf_)\n    {\n        __f_ = __as_base(&__buf_);\n        __f.__f_->__clone(__f_);\n    }\n    else\n    {\n        __f_ = __f.__f_;\n        __f.__f_ = 0;\n    }\n}\n#endif\n\ntemplate<class _Rp, class ..._ArgTypes>\ntemplate <class _Fp, class>\nfunction<_Rp(_ArgTypes...)>::function(_Fp __f)\n    : __f_(0)\n{\n    if (__function::__not_null(__f))\n    {\n        typedef __function::__func<_Fp, allocator<_Fp>, _Rp(_ArgTypes...)> _FF;\n        if (sizeof(_FF) <= sizeof(__buf_) && is_nothrow_copy_constructible<_Fp>::value)\n        {\n            __f_ = ::new((void*)&__buf_) _FF(_VSTD::move(__f));\n        }\n        else\n        {\n            typedef allocator<_FF> _Ap;\n            _Ap __a;\n            typedef __allocator_destructor<_Ap> _Dp;\n            unique_ptr<__base, _Dp> __hold(__a.allocate(1), _Dp(__a, 1));\n            ::new (__hold.get()) _FF(_VSTD::move(__f), allocator<_Fp>(__a));\n            __f_ = __hold.release();\n        }\n    }\n}\n\n#if _LIBCPP_STD_VER <= 14\ntemplate<class _Rp, class ..._ArgTypes>\ntemplate <class _Fp, class _Alloc, class>\nfunction<_Rp(_ArgTypes...)>::function(allocator_arg_t, const _Alloc& __a0, _Fp __f)\n    : __f_(0)\n{\n    typedef allocator_traits<_Alloc> __alloc_traits;\n    if (__function::__not_null(__f))\n    {\n        typedef __function::__func<_Fp, _Alloc, _Rp(_ArgTypes...)> _FF;\n        typedef typename __rebind_alloc_helper<__alloc_traits, _FF>::type _Ap;\n        _Ap __a(__a0);\n        if (sizeof(_FF) <= sizeof(__buf_) && \n            is_nothrow_copy_constructible<_Fp>::value && is_nothrow_copy_constructible<_Ap>::value)\n        {\n            __f_ = ::new((void*)&__buf_) _FF(_VSTD::move(__f), _Alloc(__a));\n        }\n        else\n        {\n            typedef __allocator_destructor<_Ap> _Dp;\n            unique_ptr<__base, _Dp> __hold(__a.allocate(1), _Dp(__a, 1));\n            ::new (__hold.get()) _FF(_VSTD::move(__f), _Alloc(__a));\n            __f_ = __hold.release();\n        }\n    }\n}\n#endif\n\ntemplate<class _Rp, class ..._ArgTypes>\nfunction<_Rp(_ArgTypes...)>&\nfunction<_Rp(_ArgTypes...)>::operator=(const function& __f)\n{\n    function(__f).swap(*this);\n    return *this;\n}\n\ntemplate<class _Rp, class ..._ArgTypes>\nfunction<_Rp(_ArgTypes...)>&\nfunction<_Rp(_ArgTypes...)>::operator=(function&& __f) _NOEXCEPT\n{\n    if ((void *)__f_ == &__buf_)\n        __f_->destroy();\n    else if (__f_)\n        __f_->destroy_deallocate();\n    __f_ = 0;\n    if (__f.__f_ == 0)\n        __f_ = 0;\n    else if ((void *)__f.__f_ == &__f.__buf_)\n    {\n        __f_ = __as_base(&__buf_);\n        __f.__f_->__clone(__f_);\n    }\n    else\n    {\n        __f_ = __f.__f_;\n        __f.__f_ = 0;\n    }\n    return *this;\n}\n\ntemplate<class _Rp, class ..._ArgTypes>\nfunction<_Rp(_ArgTypes...)>&\nfunction<_Rp(_ArgTypes...)>::operator=(nullptr_t) _NOEXCEPT\n{\n    if ((void *)__f_ == &__buf_)\n        __f_->destroy();\n    else if (__f_)\n        __f_->destroy_deallocate();\n    __f_ = 0;\n    return *this;\n}\n\ntemplate<class _Rp, class ..._ArgTypes>\ntemplate <class _Fp>\ntypename enable_if\n<\n    function<_Rp(_ArgTypes...)>::template __callable<typename decay<_Fp>::type>::value &&\n    !is_same<typename remove_reference<_Fp>::type, function<_Rp(_ArgTypes...)>>::value,\n    function<_Rp(_ArgTypes...)>&\n>::type\nfunction<_Rp(_ArgTypes...)>::operator=(_Fp&& __f)\n{\n    function(_VSTD::forward<_Fp>(__f)).swap(*this);\n    return *this;\n}\n\ntemplate<class _Rp, class ..._ArgTypes>\nfunction<_Rp(_ArgTypes...)>::~function()\n{\n    if ((void *)__f_ == &__buf_)\n        __f_->destroy();\n    else if (__f_)\n        __f_->destroy_deallocate();\n}\n\ntemplate<class _Rp, class ..._ArgTypes>\nvoid\nfunction<_Rp(_ArgTypes...)>::swap(function& __f) _NOEXCEPT\n{\n    if (_VSTD::addressof(__f) == this)\n      return;\n    if ((void *)__f_ == &__buf_ && (void *)__f.__f_ == &__f.__buf_)\n    {\n        typename aligned_storage<sizeof(__buf_)>::type __tempbuf;\n        __base* __t = __as_base(&__tempbuf);\n        __f_->__clone(__t);\n        __f_->destroy();\n        __f_ = 0;\n        __f.__f_->__clone(__as_base(&__buf_));\n        __f.__f_->destroy();\n        __f.__f_ = 0;\n        __f_ = __as_base(&__buf_);\n        __t->__clone(__as_base(&__f.__buf_));\n        __t->destroy();\n        __f.__f_ = __as_base(&__f.__buf_);\n    }\n    else if ((void *)__f_ == &__buf_)\n    {\n        __f_->__clone(__as_base(&__f.__buf_));\n        __f_->destroy();\n        __f_ = __f.__f_;\n        __f.__f_ = __as_base(&__f.__buf_);\n    }\n    else if ((void *)__f.__f_ == &__f.__buf_)\n    {\n        __f.__f_->__clone(__as_base(&__buf_));\n        __f.__f_->destroy();\n        __f.__f_ = __f_;\n        __f_ = __as_base(&__buf_);\n    }\n    else\n        _VSTD::swap(__f_, __f.__f_);\n}\n\ntemplate<class _Rp, class ..._ArgTypes>\n_Rp\nfunction<_Rp(_ArgTypes...)>::operator()(_ArgTypes... __arg) const\n{\n    if (__f_ == 0)\n        __throw_bad_function_call();\n    return (*__f_)(_VSTD::forward<_ArgTypes>(__arg)...);\n}\n\n#ifndef _LIBCPP_NO_RTTI\n\ntemplate<class _Rp, class ..._ArgTypes>\nconst std::type_info&\nfunction<_Rp(_ArgTypes...)>::target_type() const _NOEXCEPT\n{\n    if (__f_ == 0)\n        return typeid(void);\n    return __f_->target_type();\n}\n\ntemplate<class _Rp, class ..._ArgTypes>\ntemplate <typename _Tp>\n_Tp*\nfunction<_Rp(_ArgTypes...)>::target() _NOEXCEPT\n{\n    if (__f_ == 0)\n        return (_Tp*)0;\n    return (_Tp*)__f_->target(typeid(_Tp));\n}\n\ntemplate<class _Rp, class ..._ArgTypes>\ntemplate <typename _Tp>\nconst _Tp*\nfunction<_Rp(_ArgTypes...)>::target() const _NOEXCEPT\n{\n    if (__f_ == 0)\n        return (const _Tp*)0;\n    return (const _Tp*)__f_->target(typeid(_Tp));\n}\n\n#endif  // _LIBCPP_NO_RTTI\n\ntemplate <class _Rp, class... _ArgTypes>\ninline _LIBCPP_INLINE_VISIBILITY\nbool\noperator==(const function<_Rp(_ArgTypes...)>& __f, nullptr_t) _NOEXCEPT {return !__f;}\n\ntemplate <class _Rp, class... _ArgTypes>\ninline _LIBCPP_INLINE_VISIBILITY\nbool\noperator==(nullptr_t, const function<_Rp(_ArgTypes...)>& __f) _NOEXCEPT {return !__f;}\n\ntemplate <class _Rp, class... _ArgTypes>\ninline _LIBCPP_INLINE_VISIBILITY\nbool\noperator!=(const function<_Rp(_ArgTypes...)>& __f, nullptr_t) _NOEXCEPT {return (bool)__f;}\n\ntemplate <class _Rp, class... _ArgTypes>\ninline _LIBCPP_INLINE_VISIBILITY\nbool\noperator!=(nullptr_t, const function<_Rp(_ArgTypes...)>& __f) _NOEXCEPT {return (bool)__f;}\n\ntemplate <class _Rp, class... _ArgTypes>\ninline _LIBCPP_INLINE_VISIBILITY\nvoid\nswap(function<_Rp(_ArgTypes...)>& __x, function<_Rp(_ArgTypes...)>& __y) _NOEXCEPT\n{return __x.swap(__y);}\n\n#else // _LIBCPP_HAS_NO_VARIADICS\n\n#include <__functional_03>\n\n#endif\n\n////////////////////////////////////////////////////////////////////////////////\n//                                  BIND\n//==============================================================================\n\ntemplate<class _Tp> struct __is_bind_expression : public false_type {};\ntemplate<class _Tp> struct _LIBCPP_TEMPLATE_VIS is_bind_expression\n    : public __is_bind_expression<typename remove_cv<_Tp>::type> {};\n\n#if _LIBCPP_STD_VER > 14\ntemplate <class _Tp>\nconstexpr size_t is_bind_expression_v = is_bind_expression<_Tp>::value;\n#endif\n\ntemplate<class _Tp> struct __is_placeholder : public integral_constant<int, 0> {};\ntemplate<class _Tp> struct _LIBCPP_TEMPLATE_VIS is_placeholder\n    : public __is_placeholder<typename remove_cv<_Tp>::type> {};\n\n#if _LIBCPP_STD_VER > 14\ntemplate <class _Tp>\nconstexpr size_t is_placeholder_v = is_placeholder<_Tp>::value;\n#endif\n\nnamespace placeholders\n{\n\ntemplate <int _Np> struct __ph {};\n\n#if defined(_LIBCPP_CXX03_LANG) || defined(_LIBCPP_BUILDING_BIND)\n_LIBCPP_FUNC_VIS extern const __ph<1>   _1;\n_LIBCPP_FUNC_VIS extern const __ph<2>   _2;\n_LIBCPP_FUNC_VIS extern const __ph<3>   _3;\n_LIBCPP_FUNC_VIS extern const __ph<4>   _4;\n_LIBCPP_FUNC_VIS extern const __ph<5>   _5;\n_LIBCPP_FUNC_VIS extern const __ph<6>   _6;\n_LIBCPP_FUNC_VIS extern const __ph<7>   _7;\n_LIBCPP_FUNC_VIS extern const __ph<8>   _8;\n_LIBCPP_FUNC_VIS extern const __ph<9>   _9;\n_LIBCPP_FUNC_VIS extern const __ph<10> _10;\n#else\nconstexpr __ph<1>   _1{};\nconstexpr __ph<2>   _2{};\nconstexpr __ph<3>   _3{};\nconstexpr __ph<4>   _4{};\nconstexpr __ph<5>   _5{};\nconstexpr __ph<6>   _6{};\nconstexpr __ph<7>   _7{};\nconstexpr __ph<8>   _8{};\nconstexpr __ph<9>   _9{};\nconstexpr __ph<10> _10{};\n#endif // defined(_LIBCPP_CXX03_LANG) || defined(_LIBCPP_BUILDING_BIND)\n\n}  // placeholders\n\ntemplate<int _Np>\nstruct __is_placeholder<placeholders::__ph<_Np> >\n    : public integral_constant<int, _Np> {};\n\n\n#ifndef _LIBCPP_HAS_NO_VARIADICS\n\ntemplate <class _Tp, class _Uj>\ninline _LIBCPP_INLINE_VISIBILITY\n_Tp&\n__mu(reference_wrapper<_Tp> __t, _Uj&)\n{\n    return __t.get();\n}\n\ntemplate <class _Ti, class ..._Uj, size_t ..._Indx>\ninline _LIBCPP_INLINE_VISIBILITY\ntypename __invoke_of<_Ti&, _Uj...>::type\n__mu_expand(_Ti& __ti, tuple<_Uj...>& __uj, __tuple_indices<_Indx...>)\n{\n    return __ti(_VSTD::forward<_Uj>(_VSTD::get<_Indx>(__uj))...);\n}\n\ntemplate <class _Ti, class ..._Uj>\ninline _LIBCPP_INLINE_VISIBILITY\ntypename __lazy_enable_if\n<\n    is_bind_expression<_Ti>::value,\n    __invoke_of<_Ti&, _Uj...>\n>::type\n__mu(_Ti& __ti, tuple<_Uj...>& __uj)\n{\n    typedef typename __make_tuple_indices<sizeof...(_Uj)>::type __indices;\n    return  __mu_expand(__ti, __uj, __indices());\n}\n\ntemplate <bool IsPh, class _Ti, class _Uj>\nstruct __mu_return2 {};\n\ntemplate <class _Ti, class _Uj>\nstruct __mu_return2<true, _Ti, _Uj>\n{\n    typedef typename tuple_element<is_placeholder<_Ti>::value - 1, _Uj>::type type;\n};\n\ntemplate <class _Ti, class _Uj>\ninline _LIBCPP_INLINE_VISIBILITY\ntypename enable_if\n<\n    0 < is_placeholder<_Ti>::value,\n    typename __mu_return2<0 < is_placeholder<_Ti>::value, _Ti, _Uj>::type\n>::type\n__mu(_Ti&, _Uj& __uj)\n{\n    const size_t _Indx = is_placeholder<_Ti>::value - 1;\n    return _VSTD::forward<typename tuple_element<_Indx, _Uj>::type>(_VSTD::get<_Indx>(__uj));\n}\n\ntemplate <class _Ti, class _Uj>\ninline _LIBCPP_INLINE_VISIBILITY\ntypename enable_if\n<\n    !is_bind_expression<_Ti>::value &&\n    is_placeholder<_Ti>::value == 0 &&\n    !__is_reference_wrapper<_Ti>::value,\n    _Ti&\n>::type\n__mu(_Ti& __ti, _Uj&)\n{\n    return __ti;\n}\n\ntemplate <class _Ti, bool IsReferenceWrapper, bool IsBindEx, bool IsPh,\n          class _TupleUj>\nstruct ____mu_return;\n\ntemplate <bool _Invokable, class _Ti, class ..._Uj>\nstruct ____mu_return_invokable  // false\n{\n    typedef __nat type;\n};\n\ntemplate <class _Ti, class ..._Uj>\nstruct ____mu_return_invokable<true, _Ti, _Uj...>\n{\n    typedef typename __invoke_of<_Ti&, _Uj...>::type type;\n};\n\ntemplate <class _Ti, class ..._Uj>\nstruct ____mu_return<_Ti, false, true, false, tuple<_Uj...> >\n    : public ____mu_return_invokable<__invokable<_Ti&, _Uj...>::value, _Ti, _Uj...>\n{\n};\n\ntemplate <class _Ti, class _TupleUj>\nstruct ____mu_return<_Ti, false, false, true, _TupleUj>\n{\n    typedef typename tuple_element<is_placeholder<_Ti>::value - 1,\n                                   _TupleUj>::type&& type;\n};\n\ntemplate <class _Ti, class _TupleUj>\nstruct ____mu_return<_Ti, true, false, false, _TupleUj>\n{\n    typedef typename _Ti::type& type;\n};\n\ntemplate <class _Ti, class _TupleUj>\nstruct ____mu_return<_Ti, false, false, false, _TupleUj>\n{\n    typedef _Ti& type;\n};\n\ntemplate <class _Ti, class _TupleUj>\nstruct __mu_return\n    : public ____mu_return<_Ti,\n                           __is_reference_wrapper<_Ti>::value,\n                           is_bind_expression<_Ti>::value,\n                           0 < is_placeholder<_Ti>::value &&\n                           is_placeholder<_Ti>::value <= tuple_size<_TupleUj>::value,\n                           _TupleUj>\n{\n};\n\ntemplate <class _Fp, class _BoundArgs, class _TupleUj>\nstruct __is_valid_bind_return\n{\n    static const bool value = false;\n};\n\ntemplate <class _Fp, class ..._BoundArgs, class _TupleUj>\nstruct __is_valid_bind_return<_Fp, tuple<_BoundArgs...>, _TupleUj>\n{\n    static const bool value = __invokable<_Fp,\n                    typename __mu_return<_BoundArgs, _TupleUj>::type...>::value;\n};\n\ntemplate <class _Fp, class ..._BoundArgs, class _TupleUj>\nstruct __is_valid_bind_return<_Fp, const tuple<_BoundArgs...>, _TupleUj>\n{\n    static const bool value = __invokable<_Fp,\n                    typename __mu_return<const _BoundArgs, _TupleUj>::type...>::value;\n};\n\ntemplate <class _Fp, class _BoundArgs, class _TupleUj,\n          bool = __is_valid_bind_return<_Fp, _BoundArgs, _TupleUj>::value>\nstruct __bind_return;\n\ntemplate <class _Fp, class ..._BoundArgs, class _TupleUj>\nstruct __bind_return<_Fp, tuple<_BoundArgs...>, _TupleUj, true>\n{\n    typedef typename __invoke_of\n    <\n        _Fp&,\n        typename __mu_return\n        <\n            _BoundArgs,\n            _TupleUj\n        >::type...\n    >::type type;\n};\n\ntemplate <class _Fp, class ..._BoundArgs, class _TupleUj>\nstruct __bind_return<_Fp, const tuple<_BoundArgs...>, _TupleUj, true>\n{\n    typedef typename __invoke_of\n    <\n        _Fp&,\n        typename __mu_return\n        <\n            const _BoundArgs,\n            _TupleUj\n        >::type...\n    >::type type;\n};\n\ntemplate <class _Fp, class _BoundArgs, size_t ..._Indx, class _Args>\ninline _LIBCPP_INLINE_VISIBILITY\ntypename __bind_return<_Fp, _BoundArgs, _Args>::type\n__apply_functor(_Fp& __f, _BoundArgs& __bound_args, __tuple_indices<_Indx...>,\n                _Args&& __args)\n{\n    return __invoke(__f, __mu(_VSTD::get<_Indx>(__bound_args), __args)...);\n}\n\ntemplate<class _Fp, class ..._BoundArgs>\nclass __bind\n    : public __weak_result_type<typename decay<_Fp>::type>\n{\nprotected:\n    typedef typename decay<_Fp>::type _Fd;\n    typedef tuple<typename decay<_BoundArgs>::type...> _Td;\nprivate:\n    _Fd __f_;\n    _Td __bound_args_;\n\n    typedef typename __make_tuple_indices<sizeof...(_BoundArgs)>::type __indices;\npublic:\n    template <class _Gp, class ..._BA,\n              class = typename enable_if\n                               <\n                                  is_constructible<_Fd, _Gp>::value &&\n                                  !is_same<typename remove_reference<_Gp>::type,\n                                           __bind>::value\n                               >::type>\n      _LIBCPP_INLINE_VISIBILITY\n      explicit __bind(_Gp&& __f, _BA&& ...__bound_args)\n        : __f_(_VSTD::forward<_Gp>(__f)),\n          __bound_args_(_VSTD::forward<_BA>(__bound_args)...) {}\n\n    template <class ..._Args>\n        _LIBCPP_INLINE_VISIBILITY\n        typename __bind_return<_Fd, _Td, tuple<_Args&&...> >::type\n        operator()(_Args&& ...__args)\n        {\n            return __apply_functor(__f_, __bound_args_, __indices(),\n                                  tuple<_Args&&...>(_VSTD::forward<_Args>(__args)...));\n        }\n\n    template <class ..._Args>\n        _LIBCPP_INLINE_VISIBILITY\n        typename __bind_return<const _Fd, const _Td, tuple<_Args&&...> >::type\n        operator()(_Args&& ...__args) const\n        {\n            return __apply_functor(__f_, __bound_args_, __indices(),\n                                   tuple<_Args&&...>(_VSTD::forward<_Args>(__args)...));\n        }\n};\n\ntemplate<class _Fp, class ..._BoundArgs>\nstruct __is_bind_expression<__bind<_Fp, _BoundArgs...> > : public true_type {};\n\ntemplate<class _Rp, class _Fp, class ..._BoundArgs>\nclass __bind_r\n    : public __bind<_Fp, _BoundArgs...>\n{\n    typedef __bind<_Fp, _BoundArgs...> base;\n    typedef typename base::_Fd _Fd;\n    typedef typename base::_Td _Td;\npublic:\n    typedef _Rp result_type;\n\n\n    template <class _Gp, class ..._BA,\n              class = typename enable_if\n                               <\n                                  is_constructible<_Fd, _Gp>::value &&\n                                  !is_same<typename remove_reference<_Gp>::type,\n                                           __bind_r>::value\n                               >::type>\n      _LIBCPP_INLINE_VISIBILITY\n      explicit __bind_r(_Gp&& __f, _BA&& ...__bound_args)\n        : base(_VSTD::forward<_Gp>(__f),\n               _VSTD::forward<_BA>(__bound_args)...) {}\n\n    template <class ..._Args>\n        _LIBCPP_INLINE_VISIBILITY\n        typename enable_if\n        <\n            is_convertible<typename __bind_return<_Fd, _Td, tuple<_Args&&...> >::type,\n                           result_type>::value || is_void<_Rp>::value,\n            result_type\n        >::type\n        operator()(_Args&& ...__args)\n        {\n            typedef __invoke_void_return_wrapper<_Rp> _Invoker;\n            return _Invoker::__call(static_cast<base&>(*this), _VSTD::forward<_Args>(__args)...);\n        }\n\n    template <class ..._Args>\n        _LIBCPP_INLINE_VISIBILITY\n        typename enable_if\n        <\n            is_convertible<typename __bind_return<const _Fd, const _Td, tuple<_Args&&...> >::type,\n                           result_type>::value || is_void<_Rp>::value,\n            result_type\n        >::type\n        operator()(_Args&& ...__args) const\n        {\n            typedef __invoke_void_return_wrapper<_Rp> _Invoker;\n            return _Invoker::__call(static_cast<base const&>(*this), _VSTD::forward<_Args>(__args)...);\n        }\n};\n\ntemplate<class _Rp, class _Fp, class ..._BoundArgs>\nstruct __is_bind_expression<__bind_r<_Rp, _Fp, _BoundArgs...> > : public true_type {};\n\ntemplate<class _Fp, class ..._BoundArgs>\ninline _LIBCPP_INLINE_VISIBILITY\n__bind<_Fp, _BoundArgs...>\nbind(_Fp&& __f, _BoundArgs&&... __bound_args)\n{\n    typedef __bind<_Fp, _BoundArgs...> type;\n    return type(_VSTD::forward<_Fp>(__f), _VSTD::forward<_BoundArgs>(__bound_args)...);\n}\n\ntemplate<class _Rp, class _Fp, class ..._BoundArgs>\ninline _LIBCPP_INLINE_VISIBILITY\n__bind_r<_Rp, _Fp, _BoundArgs...>\nbind(_Fp&& __f, _BoundArgs&&... __bound_args)\n{\n    typedef __bind_r<_Rp, _Fp, _BoundArgs...> type;\n    return type(_VSTD::forward<_Fp>(__f), _VSTD::forward<_BoundArgs>(__bound_args)...);\n}\n\n#endif  // _LIBCPP_HAS_NO_VARIADICS\n\ntemplate <>\nstruct _LIBCPP_TEMPLATE_VIS hash<bool>\n    : public unary_function<bool, size_t>\n{\n    _LIBCPP_INLINE_VISIBILITY\n    size_t operator()(bool __v) const _NOEXCEPT {return static_cast<size_t>(__v);}\n};\n\ntemplate <>\nstruct _LIBCPP_TEMPLATE_VIS hash<char>\n    : public unary_function<char, size_t>\n{\n    _LIBCPP_INLINE_VISIBILITY\n    size_t operator()(char __v) const _NOEXCEPT {return static_cast<size_t>(__v);}\n};\n\ntemplate <>\nstruct _LIBCPP_TEMPLATE_VIS hash<signed char>\n    : public unary_function<signed char, size_t>\n{\n    _LIBCPP_INLINE_VISIBILITY\n    size_t operator()(signed char __v) const _NOEXCEPT {return static_cast<size_t>(__v);}\n};\n\ntemplate <>\nstruct _LIBCPP_TEMPLATE_VIS hash<unsigned char>\n    : public unary_function<unsigned char, size_t>\n{\n    _LIBCPP_INLINE_VISIBILITY\n    size_t operator()(unsigned char __v) const _NOEXCEPT {return static_cast<size_t>(__v);}\n};\n\n#ifndef _LIBCPP_HAS_NO_UNICODE_CHARS\n\ntemplate <>\nstruct _LIBCPP_TEMPLATE_VIS hash<char16_t>\n    : public unary_function<char16_t, size_t>\n{\n    _LIBCPP_INLINE_VISIBILITY\n    size_t operator()(char16_t __v) const _NOEXCEPT {return static_cast<size_t>(__v);}\n};\n\ntemplate <>\nstruct _LIBCPP_TEMPLATE_VIS hash<char32_t>\n    : public unary_function<char32_t, size_t>\n{\n    _LIBCPP_INLINE_VISIBILITY\n    size_t operator()(char32_t __v) const _NOEXCEPT {return static_cast<size_t>(__v);}\n};\n\n#endif  // _LIBCPP_HAS_NO_UNICODE_CHARS\n\ntemplate <>\nstruct _LIBCPP_TEMPLATE_VIS hash<wchar_t>\n    : public unary_function<wchar_t, size_t>\n{\n    _LIBCPP_INLINE_VISIBILITY\n    size_t operator()(wchar_t __v) const _NOEXCEPT {return static_cast<size_t>(__v);}\n};\n\ntemplate <>\nstruct _LIBCPP_TEMPLATE_VIS hash<short>\n    : public unary_function<short, size_t>\n{\n    _LIBCPP_INLINE_VISIBILITY\n    size_t operator()(short __v) const _NOEXCEPT {return static_cast<size_t>(__v);}\n};\n\ntemplate <>\nstruct _LIBCPP_TEMPLATE_VIS hash<unsigned short>\n    : public unary_function<unsigned short, size_t>\n{\n    _LIBCPP_INLINE_VISIBILITY\n    size_t operator()(unsigned short __v) const _NOEXCEPT {return static_cast<size_t>(__v);}\n};\n\ntemplate <>\nstruct _LIBCPP_TEMPLATE_VIS hash<int>\n    : public unary_function<int, size_t>\n{\n    _LIBCPP_INLINE_VISIBILITY\n    size_t operator()(int __v) const _NOEXCEPT {return static_cast<size_t>(__v);}\n};\n\ntemplate <>\nstruct _LIBCPP_TEMPLATE_VIS hash<unsigned int>\n    : public unary_function<unsigned int, size_t>\n{\n    _LIBCPP_INLINE_VISIBILITY\n    size_t operator()(unsigned int __v) const _NOEXCEPT {return static_cast<size_t>(__v);}\n};\n\ntemplate <>\nstruct _LIBCPP_TEMPLATE_VIS hash<long>\n    : public unary_function<long, size_t>\n{\n    _LIBCPP_INLINE_VISIBILITY\n    size_t operator()(long __v) const _NOEXCEPT {return static_cast<size_t>(__v);}\n};\n\ntemplate <>\nstruct _LIBCPP_TEMPLATE_VIS hash<unsigned long>\n    : public unary_function<unsigned long, size_t>\n{\n    _LIBCPP_INLINE_VISIBILITY\n    size_t operator()(unsigned long __v) const _NOEXCEPT {return static_cast<size_t>(__v);}\n};\n\ntemplate <>\nstruct _LIBCPP_TEMPLATE_VIS hash<long long>\n    : public __scalar_hash<long long>\n{\n};\n\ntemplate <>\nstruct _LIBCPP_TEMPLATE_VIS hash<unsigned long long>\n    : public __scalar_hash<unsigned long long>\n{\n};\n\n#ifndef _LIBCPP_HAS_NO_INT128\n\ntemplate <>\nstruct _LIBCPP_TEMPLATE_VIS hash<__int128_t>\n    : public __scalar_hash<__int128_t>\n{\n};\n\ntemplate <>\nstruct _LIBCPP_TEMPLATE_VIS hash<__uint128_t>\n    : public __scalar_hash<__uint128_t>\n{\n};\n\n#endif\n\ntemplate <>\nstruct _LIBCPP_TEMPLATE_VIS hash<float>\n    : public __scalar_hash<float>\n{\n    _LIBCPP_INLINE_VISIBILITY\n    size_t operator()(float __v) const _NOEXCEPT\n    {\n        // -0.0 and 0.0 should return same hash\n       if (__v == 0)\n           return 0;\n        return __scalar_hash<float>::operator()(__v);\n    }\n};\n\ntemplate <>\nstruct _LIBCPP_TEMPLATE_VIS hash<double>\n    : public __scalar_hash<double>\n{\n    _LIBCPP_INLINE_VISIBILITY\n    size_t operator()(double __v) const _NOEXCEPT\n    {\n        // -0.0 and 0.0 should return same hash\n       if (__v == 0)\n           return 0;\n        return __scalar_hash<double>::operator()(__v);\n    }\n};\n\ntemplate <>\nstruct _LIBCPP_TEMPLATE_VIS hash<long double>\n    : public __scalar_hash<long double>\n{\n    _LIBCPP_INLINE_VISIBILITY\n    size_t operator()(long double __v) const _NOEXCEPT\n    {\n        // -0.0 and 0.0 should return same hash\n        if (__v == 0)\n            return 0;\n#if defined(__i386__)\n        // Zero out padding bits\n        union\n        {\n            long double __t;\n            struct\n            {\n                size_t __a;\n                size_t __b;\n                size_t __c;\n                size_t __d;\n            } __s;\n        } __u;\n        __u.__s.__a = 0;\n        __u.__s.__b = 0;\n        __u.__s.__c = 0;\n        __u.__s.__d = 0;\n        __u.__t = __v;\n        return __u.__s.__a ^ __u.__s.__b ^ __u.__s.__c ^ __u.__s.__d;\n#elif defined(__x86_64__)\n        // Zero out padding bits\n        union\n        {\n            long double __t;\n            struct\n            {\n                size_t __a;\n                size_t __b;\n            } __s;\n        } __u;\n        __u.__s.__a = 0;\n        __u.__s.__b = 0;\n        __u.__t = __v;\n        return __u.__s.__a ^ __u.__s.__b;\n#else\n        return __scalar_hash<long double>::operator()(__v);\n#endif\n    }\n};\n\n#if _LIBCPP_STD_VER > 11\n\ntemplate <class _Tp, bool = is_enum<_Tp>::value>\nstruct _LIBCPP_TEMPLATE_VIS __enum_hash\n    : public unary_function<_Tp, size_t>\n{\n    _LIBCPP_INLINE_VISIBILITY\n    size_t operator()(_Tp __v) const _NOEXCEPT\n    {\n        typedef typename underlying_type<_Tp>::type type;\n        return hash<type>{}(static_cast<type>(__v));\n    }\n};\ntemplate <class _Tp>\nstruct _LIBCPP_TEMPLATE_VIS __enum_hash<_Tp, false> {\n    __enum_hash() = delete;\n    __enum_hash(__enum_hash const&) = delete;\n    __enum_hash& operator=(__enum_hash const&) = delete;\n};\n\ntemplate <class _Tp>\nstruct _LIBCPP_TEMPLATE_VIS hash : public __enum_hash<_Tp>\n{\n};\n#endif\n\n\n#if _LIBCPP_STD_VER > 14\n\n#define __cpp_lib_invoke 201411\n\ntemplate <class _Fn, class ..._Args>\nresult_of_t<_Fn&&(_Args&&...)>\ninvoke(_Fn&& __f, _Args&&... __args)\n    noexcept(noexcept(_VSTD::__invoke(_VSTD::forward<_Fn>(__f), _VSTD::forward<_Args>(__args)...)))\n{\n    return _VSTD::__invoke(_VSTD::forward<_Fn>(__f), _VSTD::forward<_Args>(__args)...);\n}\n\ntemplate <class _DecayFunc>\nclass _LIBCPP_TEMPLATE_VIS __not_fn_imp {\n  _DecayFunc __fd;\n\npublic:\n    __not_fn_imp() = delete;\n\n    template <class ..._Args>\n    _LIBCPP_INLINE_VISIBILITY\n    auto operator()(_Args&& ...__args) &\n            noexcept(noexcept(!_VSTD::invoke(__fd, _VSTD::forward<_Args>(__args)...)))\n        -> decltype(          !_VSTD::invoke(__fd, _VSTD::forward<_Args>(__args)...))\n        { return              !_VSTD::invoke(__fd, _VSTD::forward<_Args>(__args)...); }\n\n    template <class ..._Args>\n    _LIBCPP_INLINE_VISIBILITY\n    auto operator()(_Args&& ...__args) &&\n            noexcept(noexcept(!_VSTD::invoke(_VSTD::move(__fd), _VSTD::forward<_Args>(__args)...)))\n        -> decltype(          !_VSTD::invoke(_VSTD::move(__fd), _VSTD::forward<_Args>(__args)...))\n        { return              !_VSTD::invoke(_VSTD::move(__fd), _VSTD::forward<_Args>(__args)...); }\n\n    template <class ..._Args>\n    _LIBCPP_INLINE_VISIBILITY\n    auto operator()(_Args&& ...__args) const&\n            noexcept(noexcept(!_VSTD::invoke(__fd, _VSTD::forward<_Args>(__args)...)))\n        -> decltype(          !_VSTD::invoke(__fd, _VSTD::forward<_Args>(__args)...))\n        { return              !_VSTD::invoke(__fd, _VSTD::forward<_Args>(__args)...); }\n\n\n    template <class ..._Args>\n    _LIBCPP_INLINE_VISIBILITY\n    auto operator()(_Args&& ...__args) const&&\n            noexcept(noexcept(!_VSTD::invoke(_VSTD::move(__fd), _VSTD::forward<_Args>(__args)...)))\n        -> decltype(          !_VSTD::invoke(_VSTD::move(__fd), _VSTD::forward<_Args>(__args)...))\n        { return              !_VSTD::invoke(_VSTD::move(__fd), _VSTD::forward<_Args>(__args)...); }\n\nprivate:\n    template <class _RawFunc,\n              class = enable_if_t<!is_same<decay_t<_RawFunc>, __not_fn_imp>::value>>\n    _LIBCPP_INLINE_VISIBILITY\n    explicit __not_fn_imp(_RawFunc&& __rf)\n        : __fd(_VSTD::forward<_RawFunc>(__rf)) {}\n\n    template <class _RawFunc>\n    friend inline _LIBCPP_INLINE_VISIBILITY\n    __not_fn_imp<decay_t<_RawFunc>> not_fn(_RawFunc&&);\n};\n\ntemplate <class _RawFunc>\ninline _LIBCPP_INLINE_VISIBILITY\n__not_fn_imp<decay_t<_RawFunc>> not_fn(_RawFunc&& __fn) {\n    return __not_fn_imp<decay_t<_RawFunc>>(_VSTD::forward<_RawFunc>(__fn));\n}\n\n#endif\n\n// struct hash<T*> in <memory>\n\n_LIBCPP_END_NAMESPACE_STD\n\n#endif  // _LIBCPP_FUNCTIONAL\n","// -*- C++ -*-\n//===----------------------------------------------------------------------===//\n//\n//                     The LLVM Compiler Infrastructure\n//\n// This file is dual licensed under the MIT and the University of Illinois Open\n// Source Licenses. See LICENSE.TXT for details.\n//\n//===----------------------------------------------------------------------===//\n\n#ifndef _LIBCPP__HASH_TABLE\n#define _LIBCPP__HASH_TABLE\n\n#include <__config>\n#include <initializer_list>\n#include <memory>\n#include <iterator>\n#include <algorithm>\n#include <cmath>\n#include <utility>\n\n#include <__undef_min_max>\n\n#include <__debug>\n\n#if !defined(_LIBCPP_HAS_NO_PRAGMA_SYSTEM_HEADER)\n#pragma GCC system_header\n#endif\n\n_LIBCPP_BEGIN_NAMESPACE_STD\n\n\n#ifndef _LIBCPP_CXX03_LANG\ntemplate <class _Key, class _Tp>\nunion __hash_value_type;\n#else\ntemplate <class _Key, class _Tp>\nstruct __hash_value_type;\n#endif\n\n#ifndef _LIBCPP_CXX03_LANG\ntemplate <class _Tp>\nstruct __is_hash_value_type_imp : false_type {};\n\ntemplate <class _Key, class _Value>\nstruct __is_hash_value_type_imp<__hash_value_type<_Key, _Value>> : true_type {};\n\ntemplate <class ..._Args>\nstruct __is_hash_value_type : false_type {};\n\ntemplate <class _One>\nstruct __is_hash_value_type<_One> : __is_hash_value_type_imp<typename __uncvref<_One>::type> {};\n#endif\n\n_LIBCPP_FUNC_VIS\nsize_t __next_prime(size_t __n);\n\ntemplate <class _NodePtr>\nstruct __hash_node_base\n{\n    typedef typename pointer_traits<_NodePtr>::element_type __node_type;\n    typedef __hash_node_base __first_node;\n    typedef typename __rebind_pointer<_NodePtr, __first_node>::type __node_base_pointer;\n    typedef _NodePtr __node_pointer;\n\n#if defined(_LIBCPP_ABI_FIX_UNORDERED_NODE_POINTER_UB)\n  typedef __node_base_pointer __next_pointer;\n#else\n  typedef typename conditional<\n      is_pointer<__node_pointer>::value,\n      __node_base_pointer,\n      __node_pointer>::type   __next_pointer;\n#endif\n\n    __next_pointer    __next_;\n\n    _LIBCPP_INLINE_VISIBILITY\n    __next_pointer __ptr() _NOEXCEPT {\n        return static_cast<__next_pointer>(\n            pointer_traits<__node_base_pointer>::pointer_to(*this));\n    }\n\n    _LIBCPP_INLINE_VISIBILITY\n    __node_pointer __upcast() _NOEXCEPT {\n        return static_cast<__node_pointer>(\n            pointer_traits<__node_base_pointer>::pointer_to(*this));\n    }\n\n    _LIBCPP_INLINE_VISIBILITY\n    size_t __hash() const _NOEXCEPT {\n        return static_cast<__node_type const&>(*this).__hash_;\n    }\n\n    _LIBCPP_INLINE_VISIBILITY __hash_node_base() _NOEXCEPT : __next_(nullptr) {}\n};\n\ntemplate <class _Tp, class _VoidPtr>\nstruct __hash_node\n    : public __hash_node_base\n             <\n                 typename __rebind_pointer<_VoidPtr, __hash_node<_Tp, _VoidPtr> >::type\n             >\n{\n    typedef _Tp __node_value_type;\n\n    size_t            __hash_;\n    __node_value_type __value_;\n};\n\ninline _LIBCPP_INLINE_VISIBILITY\nbool\n__is_hash_power2(size_t __bc)\n{\n    return __bc > 2 && !(__bc & (__bc - 1));\n}\n\ninline _LIBCPP_INLINE_VISIBILITY\nsize_t\n__constrain_hash(size_t __h, size_t __bc)\n{\n    return !(__bc & (__bc - 1)) ? __h & (__bc - 1) :\n        (__h < __bc ? __h : __h % __bc);\n}\n\ninline _LIBCPP_INLINE_VISIBILITY\nsize_t\n__next_hash_pow2(size_t __n)\n{\n    return size_t(1) << (std::numeric_limits<size_t>::digits - __clz(__n-1));\n}\n\n\ntemplate <class _Tp, class _Hash, class _Equal, class _Alloc> class __hash_table;\n\ntemplate <class _NodePtr>      class _LIBCPP_TEMPLATE_VIS __hash_iterator;\ntemplate <class _ConstNodePtr> class _LIBCPP_TEMPLATE_VIS __hash_const_iterator;\ntemplate <class _NodePtr>      class _LIBCPP_TEMPLATE_VIS __hash_local_iterator;\ntemplate <class _ConstNodePtr> class _LIBCPP_TEMPLATE_VIS __hash_const_local_iterator;\ntemplate <class _HashIterator> class _LIBCPP_TEMPLATE_VIS __hash_map_iterator;\ntemplate <class _HashIterator> class _LIBCPP_TEMPLATE_VIS __hash_map_const_iterator;\n\ntemplate <class _Tp>\nstruct __hash_key_value_types {\n  static_assert(!is_reference<_Tp>::value && !is_const<_Tp>::value, \"\");\n  typedef _Tp key_type;\n  typedef _Tp __node_value_type;\n  typedef _Tp __container_value_type;\n  static const bool __is_map = false;\n\n  _LIBCPP_INLINE_VISIBILITY\n  static key_type const& __get_key(_Tp const& __v) {\n    return __v;\n  }\n  _LIBCPP_INLINE_VISIBILITY\n  static __container_value_type const& __get_value(__node_value_type const& __v) {\n    return __v;\n  }\n  _LIBCPP_INLINE_VISIBILITY\n  static __container_value_type* __get_ptr(__node_value_type& __n) {\n    return _VSTD::addressof(__n);\n  }\n#ifndef _LIBCPP_CXX03_LANG\n  _LIBCPP_INLINE_VISIBILITY\n  static  __container_value_type&& __move(__node_value_type& __v) {\n    return _VSTD::move(__v);\n  }\n#endif\n};\n\ntemplate <class _Key, class _Tp>\nstruct __hash_key_value_types<__hash_value_type<_Key, _Tp> > {\n  typedef _Key                                         key_type;\n  typedef _Tp                                          mapped_type;\n  typedef __hash_value_type<_Key, _Tp>                 __node_value_type;\n  typedef pair<const _Key, _Tp>                        __container_value_type;\n  typedef pair<_Key, _Tp>                              __nc_value_type;\n  typedef __container_value_type                       __map_value_type;\n  static const bool __is_map = true;\n\n  _LIBCPP_INLINE_VISIBILITY\n  static key_type const& __get_key(__container_value_type const& __v) {\n    return __v.first;\n  }\n\n  template <class _Up>\n  _LIBCPP_INLINE_VISIBILITY\n  static typename enable_if<__is_same_uncvref<_Up, __node_value_type>::value,\n      __container_value_type const&>::type\n  __get_value(_Up& __t) {\n    return __t.__cc;\n  }\n\n  template <class _Up>\n  _LIBCPP_INLINE_VISIBILITY\n  static typename enable_if<__is_same_uncvref<_Up, __container_value_type>::value,\n      __container_value_type const&>::type\n  __get_value(_Up& __t) {\n    return __t;\n  }\n\n  _LIBCPP_INLINE_VISIBILITY\n  static __container_value_type* __get_ptr(__node_value_type& __n) {\n    return _VSTD::addressof(__n.__cc);\n  }\n#ifndef _LIBCPP_CXX03_LANG\n  _LIBCPP_INLINE_VISIBILITY\n  static __nc_value_type&& __move(__node_value_type& __v) {\n    return _VSTD::move(__v.__nc);\n  }\n#endif\n\n};\n\ntemplate <class _Tp, class _AllocPtr, class _KVTypes = __hash_key_value_types<_Tp>,\n          bool = _KVTypes::__is_map>\nstruct __hash_map_pointer_types {};\n\ntemplate <class _Tp, class _AllocPtr, class _KVTypes>\nstruct __hash_map_pointer_types<_Tp, _AllocPtr, _KVTypes, true> {\n  typedef typename _KVTypes::__map_value_type   _Mv;\n  typedef typename __rebind_pointer<_AllocPtr, _Mv>::type\n                                                       __map_value_type_pointer;\n  typedef typename __rebind_pointer<_AllocPtr, const _Mv>::type\n                                                 __const_map_value_type_pointer;\n};\n\ntemplate <class _NodePtr, class _NodeT = typename pointer_traits<_NodePtr>::element_type>\nstruct __hash_node_types;\n\ntemplate <class _NodePtr, class _Tp, class _VoidPtr>\nstruct __hash_node_types<_NodePtr, __hash_node<_Tp, _VoidPtr> >\n    : public __hash_key_value_types<_Tp>, __hash_map_pointer_types<_Tp, _VoidPtr>\n\n{\n  typedef __hash_key_value_types<_Tp>           __base;\n\npublic:\n  typedef ptrdiff_t difference_type;\n  typedef size_t size_type;\n\n  typedef typename __rebind_pointer<_NodePtr, void>::type       __void_pointer;\n\n  typedef typename pointer_traits<_NodePtr>::element_type       __node_type;\n  typedef _NodePtr                                              __node_pointer;\n\n  typedef __hash_node_base<__node_pointer>                      __node_base_type;\n  typedef typename __rebind_pointer<_NodePtr, __node_base_type>::type\n                                                             __node_base_pointer;\n\n  typedef typename __node_base_type::__next_pointer          __next_pointer;\n\n  typedef _Tp                                                 __node_value_type;\n  typedef typename __rebind_pointer<_VoidPtr, __node_value_type>::type\n                                                      __node_value_type_pointer;\n  typedef typename __rebind_pointer<_VoidPtr, const __node_value_type>::type\n                                                __const_node_value_type_pointer;\n\nprivate:\n    static_assert(!is_const<__node_type>::value,\n                \"_NodePtr should never be a pointer to const\");\n    static_assert((is_same<typename pointer_traits<_VoidPtr>::element_type, void>::value),\n                  \"_VoidPtr does not point to unqualified void type\");\n    static_assert((is_same<typename __rebind_pointer<_VoidPtr, __node_type>::type,\n                          _NodePtr>::value), \"_VoidPtr does not rebind to _NodePtr.\");\n};\n\ntemplate <class _HashIterator>\nstruct __hash_node_types_from_iterator;\ntemplate <class _NodePtr>\nstruct __hash_node_types_from_iterator<__hash_iterator<_NodePtr> > : __hash_node_types<_NodePtr> {};\ntemplate <class _NodePtr>\nstruct __hash_node_types_from_iterator<__hash_const_iterator<_NodePtr> > : __hash_node_types<_NodePtr> {};\ntemplate <class _NodePtr>\nstruct __hash_node_types_from_iterator<__hash_local_iterator<_NodePtr> > : __hash_node_types<_NodePtr> {};\ntemplate <class _NodePtr>\nstruct __hash_node_types_from_iterator<__hash_const_local_iterator<_NodePtr> > : __hash_node_types<_NodePtr> {};\n\n\ntemplate <class _NodeValueTp, class _VoidPtr>\nstruct __make_hash_node_types {\n  typedef __hash_node<_NodeValueTp, _VoidPtr> _NodeTp;\n  typedef typename __rebind_pointer<_VoidPtr, _NodeTp>::type _NodePtr;\n  typedef __hash_node_types<_NodePtr> type;\n};\n\ntemplate <class _NodePtr>\nclass _LIBCPP_TEMPLATE_VIS __hash_iterator\n{\n    typedef __hash_node_types<_NodePtr> _NodeTypes;\n    typedef _NodePtr                            __node_pointer;\n    typedef typename _NodeTypes::__next_pointer __next_pointer;\n\n    __next_pointer            __node_;\n\npublic:\n    typedef forward_iterator_tag                           iterator_category;\n    typedef typename _NodeTypes::__node_value_type         value_type;\n    typedef typename _NodeTypes::difference_type           difference_type;\n    typedef value_type&                                    reference;\n    typedef typename _NodeTypes::__node_value_type_pointer pointer;\n\n    _LIBCPP_INLINE_VISIBILITY __hash_iterator() _NOEXCEPT : __node_(nullptr) {\n        _LIBCPP_DEBUG_MODE(__get_db()->__insert_i(this));\n    }\n\n#if _LIBCPP_DEBUG_LEVEL >= 2\n    _LIBCPP_INLINE_VISIBILITY\n    __hash_iterator(const __hash_iterator& __i)\n        : __node_(__i.__node_)\n    {\n        __get_db()->__iterator_copy(this, &__i);\n    }\n\n    _LIBCPP_INLINE_VISIBILITY\n    ~__hash_iterator()\n    {\n        __get_db()->__erase_i(this);\n    }\n\n    _LIBCPP_INLINE_VISIBILITY\n    __hash_iterator& operator=(const __hash_iterator& __i)\n    {\n        if (this != &__i)\n        {\n            __get_db()->__iterator_copy(this, &__i);\n            __node_ = __i.__node_;\n        }\n        return *this;\n    }\n#endif  // _LIBCPP_DEBUG_LEVEL >= 2\n\n    _LIBCPP_INLINE_VISIBILITY\n    reference operator*() const {\n        _LIBCPP_DEBUG_ASSERT(__get_const_db()->__dereferenceable(this),\n                             \"Attempted to dereference a non-dereferenceable unordered container iterator\");\n        return __node_->__upcast()->__value_;\n    }\n\n    _LIBCPP_INLINE_VISIBILITY\n    pointer operator->() const {\n        _LIBCPP_DEBUG_ASSERT(__get_const_db()->__dereferenceable(this),\n                           \"Attempted to dereference a non-dereferenceable unordered container iterator\");\n        return pointer_traits<pointer>::pointer_to(__node_->__upcast()->__value_);\n    }\n\n    _LIBCPP_INLINE_VISIBILITY\n    __hash_iterator& operator++() {\n        _LIBCPP_DEBUG_ASSERT(__get_const_db()->__dereferenceable(this),\n                       \"Attempted to increment non-incrementable unordered container iterator\");\n        __node_ = __node_->__next_;\n        return *this;\n    }\n\n    _LIBCPP_INLINE_VISIBILITY\n    __hash_iterator operator++(int)\n    {\n        __hash_iterator __t(*this);\n        ++(*this);\n        return __t;\n    }\n\n    friend _LIBCPP_INLINE_VISIBILITY\n    bool operator==(const __hash_iterator& __x, const __hash_iterator& __y)\n    {\n        return __x.__node_ == __y.__node_;\n    }\n    friend _LIBCPP_INLINE_VISIBILITY\n    bool operator!=(const __hash_iterator& __x, const __hash_iterator& __y)\n        {return !(__x == __y);}\n\nprivate:\n#if _LIBCPP_DEBUG_LEVEL >= 2\n    _LIBCPP_INLINE_VISIBILITY\n    __hash_iterator(__next_pointer __node, const void* __c) _NOEXCEPT\n        : __node_(__node)\n        {\n            __get_db()->__insert_ic(this, __c);\n        }\n#else\n    _LIBCPP_INLINE_VISIBILITY\n    __hash_iterator(__next_pointer __node) _NOEXCEPT\n        : __node_(__node)\n        {}\n#endif\n    template <class, class, class, class> friend class __hash_table;\n    template <class> friend class _LIBCPP_TEMPLATE_VIS __hash_const_iterator;\n    template <class> friend class _LIBCPP_TEMPLATE_VIS __hash_map_iterator;\n    template <class, class, class, class, class> friend class _LIBCPP_TEMPLATE_VIS unordered_map;\n    template <class, class, class, class, class> friend class _LIBCPP_TEMPLATE_VIS unordered_multimap;\n};\n\ntemplate <class _NodePtr>\nclass _LIBCPP_TEMPLATE_VIS __hash_const_iterator\n{\n    static_assert(!is_const<typename pointer_traits<_NodePtr>::element_type>::value, \"\");\n    typedef __hash_node_types<_NodePtr> _NodeTypes;\n    typedef _NodePtr                            __node_pointer;\n    typedef typename _NodeTypes::__next_pointer __next_pointer;\n\n    __next_pointer __node_;\n\npublic:\n    typedef __hash_iterator<_NodePtr> __non_const_iterator;\n\n    typedef forward_iterator_tag                                 iterator_category;\n    typedef typename _NodeTypes::__node_value_type               value_type;\n    typedef typename _NodeTypes::difference_type                 difference_type;\n    typedef const value_type&                                    reference;\n    typedef typename _NodeTypes::__const_node_value_type_pointer pointer;\n\n\n    _LIBCPP_INLINE_VISIBILITY __hash_const_iterator() _NOEXCEPT : __node_(nullptr) {\n        _LIBCPP_DEBUG_MODE(__get_db()->__insert_i(this));\n    }\n\n    _LIBCPP_INLINE_VISIBILITY \n    __hash_const_iterator(const __non_const_iterator& __x) _NOEXCEPT\n        : __node_(__x.__node_)\n    {\n        _LIBCPP_DEBUG_MODE(__get_db()->__iterator_copy(this, &__x));\n    }\n\n#if _LIBCPP_DEBUG_LEVEL >= 2\n    _LIBCPP_INLINE_VISIBILITY\n    __hash_const_iterator(const __hash_const_iterator& __i)\n        : __node_(__i.__node_)\n    {\n        __get_db()->__iterator_copy(this, &__i);\n    }\n\n    _LIBCPP_INLINE_VISIBILITY\n    ~__hash_const_iterator()\n    {\n        __get_db()->__erase_i(this);\n    }\n\n    _LIBCPP_INLINE_VISIBILITY\n    __hash_const_iterator& operator=(const __hash_const_iterator& __i)\n    {\n        if (this != &__i)\n        {\n            __get_db()->__iterator_copy(this, &__i);\n            __node_ = __i.__node_;\n        }\n        return *this;\n    }\n#endif  // _LIBCPP_DEBUG_LEVEL >= 2\n\n    _LIBCPP_INLINE_VISIBILITY\n    reference operator*() const {\n        _LIBCPP_DEBUG_ASSERT(__get_const_db()->__dereferenceable(this),\n                           \"Attempted to dereference a non-dereferenceable unordered container const_iterator\");\n        return __node_->__upcast()->__value_;\n    }\n    _LIBCPP_INLINE_VISIBILITY\n    pointer operator->() const {\n        _LIBCPP_DEBUG_ASSERT(__get_const_db()->__dereferenceable(this),\n                           \"Attempted to dereference a non-dereferenceable unordered container const_iterator\");\n        return pointer_traits<pointer>::pointer_to(__node_->__upcast()->__value_);\n    }\n\n    _LIBCPP_INLINE_VISIBILITY\n    __hash_const_iterator& operator++() {\n        _LIBCPP_DEBUG_ASSERT(__get_const_db()->__dereferenceable(this),\n                             \"Attempted to increment non-incrementable unordered container const_iterator\");\n        __node_ = __node_->__next_;\n        return *this;\n    }\n\n    _LIBCPP_INLINE_VISIBILITY\n    __hash_const_iterator operator++(int)\n    {\n        __hash_const_iterator __t(*this);\n        ++(*this);\n        return __t;\n    }\n\n    friend _LIBCPP_INLINE_VISIBILITY\n    bool operator==(const __hash_const_iterator& __x, const __hash_const_iterator& __y)\n    {\n        return __x.__node_ == __y.__node_;\n    }\n    friend _LIBCPP_INLINE_VISIBILITY\n    bool operator!=(const __hash_const_iterator& __x, const __hash_const_iterator& __y)\n        {return !(__x == __y);}\n\nprivate:\n#if _LIBCPP_DEBUG_LEVEL >= 2\n    _LIBCPP_INLINE_VISIBILITY\n    __hash_const_iterator(__next_pointer __node, const void* __c) _NOEXCEPT\n        : __node_(__node)\n        {\n            __get_db()->__insert_ic(this, __c);\n        }\n#else\n    _LIBCPP_INLINE_VISIBILITY\n    __hash_const_iterator(__next_pointer __node) _NOEXCEPT\n        : __node_(__node)\n        {}\n#endif\n    template <class, class, class, class> friend class __hash_table;\n    template <class> friend class _LIBCPP_TEMPLATE_VIS __hash_map_const_iterator;\n    template <class, class, class, class, class> friend class _LIBCPP_TEMPLATE_VIS unordered_map;\n    template <class, class, class, class, class> friend class _LIBCPP_TEMPLATE_VIS unordered_multimap;\n};\n\ntemplate <class _NodePtr>\nclass _LIBCPP_TEMPLATE_VIS __hash_local_iterator\n{\n    typedef __hash_node_types<_NodePtr> _NodeTypes;\n    typedef _NodePtr                            __node_pointer;\n    typedef typename _NodeTypes::__next_pointer __next_pointer;\n\n    __next_pointer         __node_;\n    size_t                 __bucket_;\n    size_t                 __bucket_count_;\n\npublic:\n    typedef forward_iterator_tag                                iterator_category;\n    typedef typename _NodeTypes::__node_value_type              value_type;\n    typedef typename _NodeTypes::difference_type                difference_type;\n    typedef value_type&                                         reference;\n    typedef typename _NodeTypes::__node_value_type_pointer      pointer;\n\n    _LIBCPP_INLINE_VISIBILITY __hash_local_iterator() _NOEXCEPT : __node_(nullptr) {\n        _LIBCPP_DEBUG_MODE(__get_db()->__insert_i(this));\n    }\n\n#if _LIBCPP_DEBUG_LEVEL >= 2\n    _LIBCPP_INLINE_VISIBILITY\n    __hash_local_iterator(const __hash_local_iterator& __i)\n        : __node_(__i.__node_),\n          __bucket_(__i.__bucket_),\n          __bucket_count_(__i.__bucket_count_)\n    {\n        __get_db()->__iterator_copy(this, &__i);\n    }\n\n    _LIBCPP_INLINE_VISIBILITY\n    ~__hash_local_iterator()\n    {\n        __get_db()->__erase_i(this);\n    }\n\n    _LIBCPP_INLINE_VISIBILITY\n    __hash_local_iterator& operator=(const __hash_local_iterator& __i)\n    {\n        if (this != &__i)\n        {\n            __get_db()->__iterator_copy(this, &__i);\n            __node_ = __i.__node_;\n            __bucket_ = __i.__bucket_;\n            __bucket_count_ = __i.__bucket_count_;\n        }\n        return *this;\n    }\n#endif  // _LIBCPP_DEBUG_LEVEL >= 2\n\n    _LIBCPP_INLINE_VISIBILITY\n    reference operator*() const {\n        _LIBCPP_DEBUG_ASSERT(__get_const_db()->__dereferenceable(this),\n                           \"Attempted to dereference a non-dereferenceable unordered container local_iterator\");\n        return __node_->__upcast()->__value_;\n    }\n\n    _LIBCPP_INLINE_VISIBILITY\n    pointer operator->() const {\n        _LIBCPP_DEBUG_ASSERT(__get_const_db()->__dereferenceable(this),\n                             \"Attempted to dereference a non-dereferenceable unordered container local_iterator\");\n        return pointer_traits<pointer>::pointer_to(__node_->__upcast()->__value_);\n    }\n\n    _LIBCPP_INLINE_VISIBILITY\n    __hash_local_iterator& operator++() {\n        _LIBCPP_DEBUG_ASSERT(__get_const_db()->__dereferenceable(this),\n                       \"Attempted to increment non-incrementable unordered container local_iterator\");\n        __node_ = __node_->__next_;\n        if (__node_ != nullptr && __constrain_hash(__node_->__hash(), __bucket_count_) != __bucket_)\n            __node_ = nullptr;\n        return *this;\n    }\n\n    _LIBCPP_INLINE_VISIBILITY\n    __hash_local_iterator operator++(int)\n    {\n        __hash_local_iterator __t(*this);\n        ++(*this);\n        return __t;\n    }\n\n    friend _LIBCPP_INLINE_VISIBILITY\n    bool operator==(const __hash_local_iterator& __x, const __hash_local_iterator& __y)\n    {\n        return __x.__node_ == __y.__node_;\n    }\n    friend _LIBCPP_INLINE_VISIBILITY\n    bool operator!=(const __hash_local_iterator& __x, const __hash_local_iterator& __y)\n        {return !(__x == __y);}\n\nprivate:\n#if _LIBCPP_DEBUG_LEVEL >= 2\n    _LIBCPP_INLINE_VISIBILITY\n    __hash_local_iterator(__next_pointer __node, size_t __bucket,\n                          size_t __bucket_count, const void* __c) _NOEXCEPT\n        : __node_(__node),\n          __bucket_(__bucket),\n          __bucket_count_(__bucket_count)\n        {\n            __get_db()->__insert_ic(this, __c);\n            if (__node_ != nullptr)\n                __node_ = __node_->__next_;\n        }\n#else\n    _LIBCPP_INLINE_VISIBILITY\n    __hash_local_iterator(__next_pointer __node, size_t __bucket,\n                          size_t __bucket_count) _NOEXCEPT\n        : __node_(__node),\n          __bucket_(__bucket),\n          __bucket_count_(__bucket_count)\n        {\n            if (__node_ != nullptr)\n                __node_ = __node_->__next_;\n        }\n#endif\n    template <class, class, class, class> friend class __hash_table;\n    template <class> friend class _LIBCPP_TEMPLATE_VIS __hash_const_local_iterator;\n    template <class> friend class _LIBCPP_TEMPLATE_VIS __hash_map_iterator;\n};\n\ntemplate <class _ConstNodePtr>\nclass _LIBCPP_TEMPLATE_VIS __hash_const_local_iterator\n{\n    typedef __hash_node_types<_ConstNodePtr> _NodeTypes;\n    typedef _ConstNodePtr                       __node_pointer;\n    typedef typename _NodeTypes::__next_pointer __next_pointer;\n\n    __next_pointer         __node_;\n    size_t                 __bucket_;\n    size_t                 __bucket_count_;\n\n    typedef pointer_traits<__node_pointer>          __pointer_traits;\n    typedef typename __pointer_traits::element_type __node;\n    typedef typename remove_const<__node>::type     __non_const_node;\n    typedef typename __rebind_pointer<__node_pointer, __non_const_node>::type\n        __non_const_node_pointer;\npublic:\n    typedef __hash_local_iterator<__non_const_node_pointer>\n                                                    __non_const_iterator;\n\n    typedef forward_iterator_tag                                 iterator_category;\n    typedef typename _NodeTypes::__node_value_type               value_type;\n    typedef typename _NodeTypes::difference_type                 difference_type;\n    typedef const value_type&                                    reference;\n    typedef typename _NodeTypes::__const_node_value_type_pointer pointer;\n\n\n    _LIBCPP_INLINE_VISIBILITY __hash_const_local_iterator() _NOEXCEPT : __node_(nullptr) {\n        _LIBCPP_DEBUG_MODE(__get_db()->__insert_i(this));\n    }\n\n    _LIBCPP_INLINE_VISIBILITY\n    __hash_const_local_iterator(const __non_const_iterator& __x) _NOEXCEPT\n        : __node_(__x.__node_),\n          __bucket_(__x.__bucket_),\n          __bucket_count_(__x.__bucket_count_)\n    {\n        _LIBCPP_DEBUG_MODE(__get_db()->__iterator_copy(this, &__x));\n    }\n\n#if _LIBCPP_DEBUG_LEVEL >= 2\n    _LIBCPP_INLINE_VISIBILITY\n    __hash_const_local_iterator(const __hash_const_local_iterator& __i)\n        : __node_(__i.__node_),\n          __bucket_(__i.__bucket_),\n          __bucket_count_(__i.__bucket_count_)\n    {\n        __get_db()->__iterator_copy(this, &__i);\n    }\n\n    _LIBCPP_INLINE_VISIBILITY\n    ~__hash_const_local_iterator()\n    {\n        __get_db()->__erase_i(this);\n    }\n\n    _LIBCPP_INLINE_VISIBILITY\n    __hash_const_local_iterator& operator=(const __hash_const_local_iterator& __i)\n    {\n        if (this != &__i)\n        {\n            __get_db()->__iterator_copy(this, &__i);\n            __node_ = __i.__node_;\n            __bucket_ = __i.__bucket_;\n            __bucket_count_ = __i.__bucket_count_;\n        }\n        return *this;\n    }\n#endif  // _LIBCPP_DEBUG_LEVEL >= 2\n\n    _LIBCPP_INLINE_VISIBILITY\n    reference operator*() const {\n        _LIBCPP_DEBUG_ASSERT(__get_const_db()->__dereferenceable(this),\n                           \"Attempted to dereference a non-dereferenceable unordered container const_local_iterator\");\n        return __node_->__upcast()->__value_;\n    }\n\n    _LIBCPP_INLINE_VISIBILITY\n    pointer operator->() const {\n        _LIBCPP_DEBUG_ASSERT(__get_const_db()->__dereferenceable(this),\n                           \"Attempted to dereference a non-dereferenceable unordered container const_local_iterator\");\n        return pointer_traits<pointer>::pointer_to(__node_->__upcast()->__value_);\n    }\n\n    _LIBCPP_INLINE_VISIBILITY\n    __hash_const_local_iterator& operator++() {\n        _LIBCPP_DEBUG_ASSERT(__get_const_db()->__dereferenceable(this),\n                       \"Attempted to increment non-incrementable unordered container const_local_iterator\");\n        __node_ = __node_->__next_;\n        if (__node_ != nullptr && __constrain_hash(__node_->__hash(), __bucket_count_) != __bucket_)\n            __node_ = nullptr;\n        return *this;\n    }\n\n    _LIBCPP_INLINE_VISIBILITY\n    __hash_const_local_iterator operator++(int)\n    {\n        __hash_const_local_iterator __t(*this);\n        ++(*this);\n        return __t;\n    }\n\n    friend _LIBCPP_INLINE_VISIBILITY\n    bool operator==(const __hash_const_local_iterator& __x, const __hash_const_local_iterator& __y)\n    {\n        return __x.__node_ == __y.__node_;\n    }\n    friend _LIBCPP_INLINE_VISIBILITY\n    bool operator!=(const __hash_const_local_iterator& __x, const __hash_const_local_iterator& __y)\n        {return !(__x == __y);}\n\nprivate:\n#if _LIBCPP_DEBUG_LEVEL >= 2\n    _LIBCPP_INLINE_VISIBILITY\n    __hash_const_local_iterator(__next_pointer __node, size_t __bucket,\n                                size_t __bucket_count, const void* __c) _NOEXCEPT\n        : __node_(__node),\n          __bucket_(__bucket),\n          __bucket_count_(__bucket_count)\n        {\n            __get_db()->__insert_ic(this, __c);\n            if (__node_ != nullptr)\n                __node_ = __node_->__next_;\n        }\n#else\n    _LIBCPP_INLINE_VISIBILITY\n    __hash_const_local_iterator(__next_pointer __node, size_t __bucket,\n                                size_t __bucket_count) _NOEXCEPT\n        : __node_(__node),\n          __bucket_(__bucket),\n          __bucket_count_(__bucket_count)\n        {\n            if (__node_ != nullptr)\n                __node_ = __node_->__next_;\n        }\n#endif\n    template <class, class, class, class> friend class __hash_table;\n    template <class> friend class _LIBCPP_TEMPLATE_VIS __hash_map_const_iterator;\n};\n\ntemplate <class _Alloc>\nclass __bucket_list_deallocator\n{\n    typedef _Alloc                                          allocator_type;\n    typedef allocator_traits<allocator_type>                __alloc_traits;\n    typedef typename __alloc_traits::size_type              size_type;\n\n    __compressed_pair<size_type, allocator_type> __data_;\npublic:\n    typedef typename __alloc_traits::pointer pointer;\n\n    _LIBCPP_INLINE_VISIBILITY\n    __bucket_list_deallocator()\n        _NOEXCEPT_(is_nothrow_default_constructible<allocator_type>::value)\n        : __data_(0) {}\n\n    _LIBCPP_INLINE_VISIBILITY\n    __bucket_list_deallocator(const allocator_type& __a, size_type __size)\n        _NOEXCEPT_(is_nothrow_copy_constructible<allocator_type>::value)\n        : __data_(__size, __a) {}\n\n#ifndef _LIBCPP_HAS_NO_RVALUE_REFERENCES\n\n    _LIBCPP_INLINE_VISIBILITY\n    __bucket_list_deallocator(__bucket_list_deallocator&& __x)\n        _NOEXCEPT_(is_nothrow_move_constructible<allocator_type>::value)\n        : __data_(_VSTD::move(__x.__data_))\n    {\n        __x.size() = 0;\n    }\n\n#endif  // _LIBCPP_HAS_NO_RVALUE_REFERENCES\n\n    _LIBCPP_INLINE_VISIBILITY\n    size_type& size() _NOEXCEPT {return __data_.first();}\n    _LIBCPP_INLINE_VISIBILITY\n    size_type  size() const _NOEXCEPT {return __data_.first();}\n\n    _LIBCPP_INLINE_VISIBILITY\n    allocator_type& __alloc() _NOEXCEPT {return __data_.second();}\n    _LIBCPP_INLINE_VISIBILITY\n    const allocator_type& __alloc() const _NOEXCEPT {return __data_.second();}\n\n    _LIBCPP_INLINE_VISIBILITY\n    void operator()(pointer __p) _NOEXCEPT\n    {\n        __alloc_traits::deallocate(__alloc(), __p, size());\n    }\n};\n\ntemplate <class _Alloc> class __hash_map_node_destructor;\n\ntemplate <class _Alloc>\nclass __hash_node_destructor\n{\n    typedef _Alloc                                          allocator_type;\n    typedef allocator_traits<allocator_type>                __alloc_traits;\n\npublic:\n    typedef typename __alloc_traits::pointer                pointer;\nprivate:\n    typedef __hash_node_types<pointer> _NodeTypes;\n\n    allocator_type& __na_;\n\n    __hash_node_destructor& operator=(const __hash_node_destructor&);\n\npublic:\n    bool __value_constructed;\n\n    _LIBCPP_INLINE_VISIBILITY\n    explicit __hash_node_destructor(allocator_type& __na,\n                                    bool __constructed = false) _NOEXCEPT\n        : __na_(__na),\n          __value_constructed(__constructed)\n        {}\n\n    _LIBCPP_INLINE_VISIBILITY\n    void operator()(pointer __p) _NOEXCEPT\n    {\n        if (__value_constructed)\n            __alloc_traits::destroy(__na_, _NodeTypes::__get_ptr(__p->__value_));\n        if (__p)\n            __alloc_traits::deallocate(__na_, __p, 1);\n    }\n\n    template <class> friend class __hash_map_node_destructor;\n};\n\ntemplate <class _Tp, class _Hash, class _Equal, class _Alloc>\nclass __hash_table\n{\npublic:\n    typedef _Tp    value_type;\n    typedef _Hash  hasher;\n    typedef _Equal key_equal;\n    typedef _Alloc allocator_type;\n\nprivate:\n    typedef allocator_traits<allocator_type> __alloc_traits;\n    typedef typename\n      __make_hash_node_types<value_type, typename __alloc_traits::void_pointer>::type\n                                                                     _NodeTypes;\npublic:\n\n    typedef typename _NodeTypes::__node_value_type           __node_value_type;\n    typedef typename _NodeTypes::__container_value_type      __container_value_type;\n    typedef typename _NodeTypes::key_type                    key_type;\n    typedef value_type&                              reference;\n    typedef const value_type&                        const_reference;\n    typedef typename __alloc_traits::pointer         pointer;\n    typedef typename __alloc_traits::const_pointer   const_pointer;\n#ifndef _LIBCPP_ABI_FIX_UNORDERED_CONTAINER_SIZE_TYPE\n    typedef typename __alloc_traits::size_type       size_type;\n#else\n    typedef typename _NodeTypes::size_type           size_type;\n#endif\n    typedef typename _NodeTypes::difference_type     difference_type;\npublic:\n    // Create __node\n\n    typedef typename _NodeTypes::__node_type __node;\n    typedef typename __rebind_alloc_helper<__alloc_traits, __node>::type __node_allocator;\n    typedef allocator_traits<__node_allocator>       __node_traits;\n    typedef typename _NodeTypes::__void_pointer      __void_pointer;\n    typedef typename _NodeTypes::__node_pointer      __node_pointer;\n    typedef typename _NodeTypes::__node_pointer      __node_const_pointer;\n    typedef typename _NodeTypes::__node_base_type    __first_node;\n    typedef typename _NodeTypes::__node_base_pointer __node_base_pointer;\n    typedef typename _NodeTypes::__next_pointer      __next_pointer;\n\nprivate:\n    // check for sane allocator pointer rebinding semantics. Rebinding the\n    // allocator for a new pointer type should be exactly the same as rebinding\n    // the pointer using 'pointer_traits'.\n    static_assert((is_same<__node_pointer, typename __node_traits::pointer>::value),\n                  \"Allocator does not rebind pointers in a sane manner.\");\n    typedef typename __rebind_alloc_helper<__node_traits, __first_node>::type\n        __node_base_allocator;\n    typedef allocator_traits<__node_base_allocator> __node_base_traits;\n    static_assert((is_same<__node_base_pointer, typename __node_base_traits::pointer>::value),\n                 \"Allocator does not rebind pointers in a sane manner.\");\n\nprivate:\n\n    typedef typename __rebind_alloc_helper<__node_traits, __next_pointer>::type __pointer_allocator;\n    typedef __bucket_list_deallocator<__pointer_allocator> __bucket_list_deleter;\n    typedef unique_ptr<__next_pointer[], __bucket_list_deleter> __bucket_list;\n    typedef allocator_traits<__pointer_allocator>          __pointer_alloc_traits;\n    typedef typename __bucket_list_deleter::pointer       __node_pointer_pointer;\n\n    // --- Member data begin ---\n    __bucket_list                                         __bucket_list_;\n    __compressed_pair<__first_node, __node_allocator>     __p1_;\n    __compressed_pair<size_type, hasher>                  __p2_;\n    __compressed_pair<float, key_equal>                   __p3_;\n    // --- Member data end ---\n\n    _LIBCPP_INLINE_VISIBILITY\n    size_type& size() _NOEXCEPT {return __p2_.first();}\npublic:\n    _LIBCPP_INLINE_VISIBILITY\n    size_type  size() const _NOEXCEPT {return __p2_.first();}\n\n    _LIBCPP_INLINE_VISIBILITY\n    hasher& hash_function() _NOEXCEPT {return __p2_.second();}\n    _LIBCPP_INLINE_VISIBILITY\n    const hasher& hash_function() const _NOEXCEPT {return __p2_.second();}\n\n    _LIBCPP_INLINE_VISIBILITY\n    float& max_load_factor() _NOEXCEPT {return __p3_.first();}\n    _LIBCPP_INLINE_VISIBILITY\n    float  max_load_factor() const _NOEXCEPT {return __p3_.first();}\n\n    _LIBCPP_INLINE_VISIBILITY\n    key_equal& key_eq() _NOEXCEPT {return __p3_.second();}\n    _LIBCPP_INLINE_VISIBILITY\n    const key_equal& key_eq() const _NOEXCEPT {return __p3_.second();}\n\n    _LIBCPP_INLINE_VISIBILITY\n    __node_allocator& __node_alloc() _NOEXCEPT {return __p1_.second();}\n    _LIBCPP_INLINE_VISIBILITY\n    const __node_allocator& __node_alloc() const _NOEXCEPT\n        {return __p1_.second();}\n\npublic:\n    typedef __hash_iterator<__node_pointer>                   iterator;\n    typedef __hash_const_iterator<__node_pointer>             const_iterator;\n    typedef __hash_local_iterator<__node_pointer>             local_iterator;\n    typedef __hash_const_local_iterator<__node_pointer>       const_local_iterator;\n\n    _LIBCPP_INLINE_VISIBILITY\n    __hash_table()\n        _NOEXCEPT_(\n            is_nothrow_default_constructible<__bucket_list>::value &&\n            is_nothrow_default_constructible<__first_node>::value &&\n            is_nothrow_default_constructible<__node_allocator>::value &&\n            is_nothrow_default_constructible<hasher>::value &&\n            is_nothrow_default_constructible<key_equal>::value);\n    _LIBCPP_INLINE_VISIBILITY\n    __hash_table(const hasher& __hf, const key_equal& __eql);\n    __hash_table(const hasher& __hf, const key_equal& __eql,\n                 const allocator_type& __a);\n    explicit __hash_table(const allocator_type& __a);\n    __hash_table(const __hash_table& __u);\n    __hash_table(const __hash_table& __u, const allocator_type& __a);\n#ifndef _LIBCPP_CXX03_LANG\n    __hash_table(__hash_table&& __u)\n        _NOEXCEPT_(\n            is_nothrow_move_constructible<__bucket_list>::value &&\n            is_nothrow_move_constructible<__first_node>::value &&\n            is_nothrow_move_constructible<__node_allocator>::value &&\n            is_nothrow_move_constructible<hasher>::value &&\n            is_nothrow_move_constructible<key_equal>::value);\n    __hash_table(__hash_table&& __u, const allocator_type& __a);\n#endif  // _LIBCPP_CXX03_LANG\n    ~__hash_table();\n\n    __hash_table& operator=(const __hash_table& __u);\n#ifndef _LIBCPP_CXX03_LANG\n    _LIBCPP_INLINE_VISIBILITY\n    __hash_table& operator=(__hash_table&& __u)\n        _NOEXCEPT_(\n            __node_traits::propagate_on_container_move_assignment::value &&\n            is_nothrow_move_assignable<__node_allocator>::value &&\n            is_nothrow_move_assignable<hasher>::value &&\n            is_nothrow_move_assignable<key_equal>::value);\n#endif\n    template <class _InputIterator>\n        void __assign_unique(_InputIterator __first, _InputIterator __last);\n    template <class _InputIterator>\n        void __assign_multi(_InputIterator __first, _InputIterator __last);\n\n    _LIBCPP_INLINE_VISIBILITY\n    size_type max_size() const _NOEXCEPT\n    {\n        return std::min<size_type>(\n            __node_traits::max_size(__node_alloc()),\n            numeric_limits<difference_type >::max()\n        );\n    }\n\n    pair<iterator, bool> __node_insert_unique(__node_pointer __nd);\n    iterator             __node_insert_multi(__node_pointer __nd);\n    iterator             __node_insert_multi(const_iterator __p,\n                                             __node_pointer __nd);\n\n#ifndef _LIBCPP_CXX03_LANG\n    template <class _Key, class ..._Args>\n    _LIBCPP_INLINE_VISIBILITY\n    pair<iterator, bool> __emplace_unique_key_args(_Key const& __k, _Args&&... __args);\n\n    template <class... _Args>\n    _LIBCPP_INLINE_VISIBILITY\n    pair<iterator, bool> __emplace_unique_impl(_Args&&... __args);\n\n    template <class _Pp>\n    _LIBCPP_INLINE_VISIBILITY\n    pair<iterator, bool> __emplace_unique(_Pp&& __x) {\n      return __emplace_unique_extract_key(_VSTD::forward<_Pp>(__x),\n                                          __can_extract_key<_Pp, key_type>());\n    }\n\n    template <class _First, class _Second>\n    _LIBCPP_INLINE_VISIBILITY\n    typename enable_if<\n        __can_extract_map_key<_First, key_type, __container_value_type>::value,\n        pair<iterator, bool>\n    >::type __emplace_unique(_First&& __f, _Second&& __s) {\n        return __emplace_unique_key_args(__f, _VSTD::forward<_First>(__f),\n                                              _VSTD::forward<_Second>(__s));\n    }\n\n    template <class... _Args>\n    _LIBCPP_INLINE_VISIBILITY\n    pair<iterator, bool> __emplace_unique(_Args&&... __args) {\n      return __emplace_unique_impl(_VSTD::forward<_Args>(__args)...);\n    }\n\n    template <class _Pp>\n    _LIBCPP_INLINE_VISIBILITY\n    pair<iterator, bool>\n    __emplace_unique_extract_key(_Pp&& __x, __extract_key_fail_tag) {\n      return __emplace_unique_impl(_VSTD::forward<_Pp>(__x));\n    }\n    template <class _Pp>\n    _LIBCPP_INLINE_VISIBILITY\n    pair<iterator, bool>\n    __emplace_unique_extract_key(_Pp&& __x, __extract_key_self_tag) {\n      return __emplace_unique_key_args(__x, _VSTD::forward<_Pp>(__x));\n    }\n    template <class _Pp>\n    _LIBCPP_INLINE_VISIBILITY\n    pair<iterator, bool>\n    __emplace_unique_extract_key(_Pp&& __x, __extract_key_first_tag) {\n      return __emplace_unique_key_args(__x.first, _VSTD::forward<_Pp>(__x));\n    }\n\n    template <class... _Args>\n    _LIBCPP_INLINE_VISIBILITY\n    iterator __emplace_multi(_Args&&... __args);\n    template <class... _Args>\n    _LIBCPP_INLINE_VISIBILITY\n    iterator __emplace_hint_multi(const_iterator __p, _Args&&... __args);\n\n\n    _LIBCPP_INLINE_VISIBILITY\n    pair<iterator, bool>\n    __insert_unique(__container_value_type&& __x) {\n      return __emplace_unique_key_args(_NodeTypes::__get_key(__x), _VSTD::move(__x));\n    }\n\n    template <class _Pp, class = typename enable_if<\n            !__is_same_uncvref<_Pp, __container_value_type>::value\n        >::type>\n    _LIBCPP_INLINE_VISIBILITY\n    pair<iterator, bool> __insert_unique(_Pp&& __x) {\n      return __emplace_unique(_VSTD::forward<_Pp>(__x));\n    }\n\n    template <class _Pp>\n    _LIBCPP_INLINE_VISIBILITY\n    iterator __insert_multi(_Pp&& __x) {\n      return __emplace_multi(_VSTD::forward<_Pp>(__x));\n    }\n\n    template <class _Pp>\n    _LIBCPP_INLINE_VISIBILITY\n    iterator __insert_multi(const_iterator __p, _Pp&& __x) {\n        return __emplace_hint_multi(__p, _VSTD::forward<_Pp>(__x));\n    }\n\n#else  // !defined(_LIBCPP_CXX03_LANG)\n    template <class _Key, class _Args>\n    _LIBCPP_INLINE_VISIBILITY\n    pair<iterator, bool> __emplace_unique_key_args(_Key const&, _Args& __args);\n\n    iterator __insert_multi(const __container_value_type& __x);\n    iterator __insert_multi(const_iterator __p, const __container_value_type& __x);\n#endif\n\n    _LIBCPP_INLINE_VISIBILITY\n    pair<iterator, bool> __insert_unique(const __container_value_type& __x) {\n        return __emplace_unique_key_args(_NodeTypes::__get_key(__x), __x);\n    }\n\n    void clear() _NOEXCEPT;\n    void rehash(size_type __n);\n    _LIBCPP_INLINE_VISIBILITY void reserve(size_type __n)\n        {rehash(static_cast<size_type>(ceil(__n / max_load_factor())));}\n\n    _LIBCPP_INLINE_VISIBILITY\n    size_type bucket_count() const _NOEXCEPT\n    {\n        return __bucket_list_.get_deleter().size();\n    }\n\n    _LIBCPP_INLINE_VISIBILITY\n    iterator       begin() _NOEXCEPT;\n    _LIBCPP_INLINE_VISIBILITY\n    iterator       end() _NOEXCEPT;\n    _LIBCPP_INLINE_VISIBILITY\n    const_iterator begin() const _NOEXCEPT;\n    _LIBCPP_INLINE_VISIBILITY\n    const_iterator end() const _NOEXCEPT;\n\n    template <class _Key>\n        _LIBCPP_INLINE_VISIBILITY\n        size_type bucket(const _Key& __k) const\n        {\n            _LIBCPP_ASSERT(bucket_count() > 0,\n                \"unordered container::bucket(key) called when bucket_count() == 0\");\n            return __constrain_hash(hash_function()(__k), bucket_count());\n        }\n\n    template <class _Key>\n        iterator       find(const _Key& __x);\n    template <class _Key>\n        const_iterator find(const _Key& __x) const;\n\n    typedef __hash_node_destructor<__node_allocator> _Dp;\n    typedef unique_ptr<__node, _Dp> __node_holder;\n\n    iterator erase(const_iterator __p);\n    iterator erase(const_iterator __first, const_iterator __last);\n    template <class _Key>\n        size_type __erase_unique(const _Key& __k);\n    template <class _Key>\n        size_type __erase_multi(const _Key& __k);\n    __node_holder remove(const_iterator __p) _NOEXCEPT;\n\n    template <class _Key>\n        _LIBCPP_INLINE_VISIBILITY\n        size_type __count_unique(const _Key& __k) const;\n    template <class _Key>\n        size_type __count_multi(const _Key& __k) const;\n\n    template <class _Key>\n        pair<iterator, iterator>\n        __equal_range_unique(const _Key& __k);\n    template <class _Key>\n        pair<const_iterator, const_iterator>\n        __equal_range_unique(const _Key& __k) const;\n\n    template <class _Key>\n        pair<iterator, iterator>\n        __equal_range_multi(const _Key& __k);\n    template <class _Key>\n        pair<const_iterator, const_iterator>\n        __equal_range_multi(const _Key& __k) const;\n\n    void swap(__hash_table& __u)\n#if _LIBCPP_STD_VER <= 11\n        _NOEXCEPT_DEBUG_(\n            __is_nothrow_swappable<hasher>::value && __is_nothrow_swappable<key_equal>::value\n            && (!allocator_traits<__pointer_allocator>::propagate_on_container_swap::value\n                  || __is_nothrow_swappable<__pointer_allocator>::value)\n            && (!__node_traits::propagate_on_container_swap::value\n                  || __is_nothrow_swappable<__node_allocator>::value)\n            );\n#else\n     _NOEXCEPT_DEBUG_(__is_nothrow_swappable<hasher>::value && __is_nothrow_swappable<key_equal>::value);\n#endif\n\n    _LIBCPP_INLINE_VISIBILITY\n    size_type max_bucket_count() const _NOEXCEPT\n        {return max_size(); }\n    size_type bucket_size(size_type __n) const;\n    _LIBCPP_INLINE_VISIBILITY float load_factor() const _NOEXCEPT\n    {\n        size_type __bc = bucket_count();\n        return __bc != 0 ? (float)size() / __bc : 0.f;\n    }\n    _LIBCPP_INLINE_VISIBILITY void max_load_factor(float __mlf) _NOEXCEPT\n    {\n        _LIBCPP_ASSERT(__mlf > 0,\n            \"unordered container::max_load_factor(lf) called with lf <= 0\");\n        max_load_factor() = _VSTD::max(__mlf, load_factor());\n    }\n\n    _LIBCPP_INLINE_VISIBILITY\n    local_iterator\n    begin(size_type __n)\n    {\n        _LIBCPP_ASSERT(__n < bucket_count(),\n            \"unordered container::begin(n) called with n >= bucket_count()\");\n#if _LIBCPP_DEBUG_LEVEL >= 2\n        return local_iterator(__bucket_list_[__n], __n, bucket_count(), this);\n#else\n        return local_iterator(__bucket_list_[__n], __n, bucket_count());\n#endif\n    }\n\n    _LIBCPP_INLINE_VISIBILITY\n    local_iterator\n    end(size_type __n)\n    {\n        _LIBCPP_ASSERT(__n < bucket_count(),\n            \"unordered container::end(n) called with n >= bucket_count()\");\n#if _LIBCPP_DEBUG_LEVEL >= 2\n        return local_iterator(nullptr, __n, bucket_count(), this);\n#else\n        return local_iterator(nullptr, __n, bucket_count());\n#endif\n    }\n\n    _LIBCPP_INLINE_VISIBILITY\n    const_local_iterator\n    cbegin(size_type __n) const\n    {\n        _LIBCPP_ASSERT(__n < bucket_count(),\n            \"unordered container::cbegin(n) called with n >= bucket_count()\");\n#if _LIBCPP_DEBUG_LEVEL >= 2\n        return const_local_iterator(__bucket_list_[__n], __n, bucket_count(), this);\n#else\n        return const_local_iterator(__bucket_list_[__n], __n, bucket_count());\n#endif\n    }\n\n    _LIBCPP_INLINE_VISIBILITY\n    const_local_iterator\n    cend(size_type __n) const\n    {\n        _LIBCPP_ASSERT(__n < bucket_count(),\n            \"unordered container::cend(n) called with n >= bucket_count()\");\n#if _LIBCPP_DEBUG_LEVEL >= 2\n        return const_local_iterator(nullptr, __n, bucket_count(), this);\n#else\n        return const_local_iterator(nullptr, __n, bucket_count());\n#endif\n    }\n\n#if _LIBCPP_DEBUG_LEVEL >= 2\n\n    bool __dereferenceable(const const_iterator* __i) const;\n    bool __decrementable(const const_iterator* __i) const;\n    bool __addable(const const_iterator* __i, ptrdiff_t __n) const;\n    bool __subscriptable(const const_iterator* __i, ptrdiff_t __n) const;\n\n#endif  // _LIBCPP_DEBUG_LEVEL >= 2\n\nprivate:\n    void __rehash(size_type __n);\n\n#ifndef _LIBCPP_CXX03_LANG\n    template <class ..._Args>\n    __node_holder __construct_node(_Args&& ...__args);\n\n    template <class _First, class ..._Rest>\n    __node_holder __construct_node_hash(size_t __hash, _First&& __f, _Rest&&... __rest);\n#else // _LIBCPP_CXX03_LANG\n    __node_holder __construct_node(const __container_value_type& __v);\n    __node_holder __construct_node_hash(size_t __hash, const __container_value_type& __v);\n#endif\n\n\n    _LIBCPP_INLINE_VISIBILITY\n    void __copy_assign_alloc(const __hash_table& __u)\n        {__copy_assign_alloc(__u, integral_constant<bool,\n             __node_traits::propagate_on_container_copy_assignment::value>());}\n    void __copy_assign_alloc(const __hash_table& __u, true_type);\n    _LIBCPP_INLINE_VISIBILITY\n        void __copy_assign_alloc(const __hash_table&, false_type) {}\n\n#ifndef _LIBCPP_CXX03_LANG\n    void __move_assign(__hash_table& __u, false_type);\n    void __move_assign(__hash_table& __u, true_type)\n        _NOEXCEPT_(\n            is_nothrow_move_assignable<__node_allocator>::value &&\n            is_nothrow_move_assignable<hasher>::value &&\n            is_nothrow_move_assignable<key_equal>::value);\n    _LIBCPP_INLINE_VISIBILITY\n    void __move_assign_alloc(__hash_table& __u)\n        _NOEXCEPT_(\n            !__node_traits::propagate_on_container_move_assignment::value ||\n            (is_nothrow_move_assignable<__pointer_allocator>::value &&\n             is_nothrow_move_assignable<__node_allocator>::value))\n        {__move_assign_alloc(__u, integral_constant<bool,\n             __node_traits::propagate_on_container_move_assignment::value>());}\n    _LIBCPP_INLINE_VISIBILITY\n    void __move_assign_alloc(__hash_table& __u, true_type)\n        _NOEXCEPT_(\n            is_nothrow_move_assignable<__pointer_allocator>::value &&\n            is_nothrow_move_assignable<__node_allocator>::value)\n    {\n        __bucket_list_.get_deleter().__alloc() =\n                _VSTD::move(__u.__bucket_list_.get_deleter().__alloc());\n        __node_alloc() = _VSTD::move(__u.__node_alloc());\n    }\n    _LIBCPP_INLINE_VISIBILITY\n        void __move_assign_alloc(__hash_table&, false_type) _NOEXCEPT {}\n#endif // _LIBCPP_CXX03_LANG\n\n    void __deallocate_node(__next_pointer __np) _NOEXCEPT;\n    __next_pointer __detach() _NOEXCEPT;\n\n    template <class, class, class, class, class> friend class _LIBCPP_TEMPLATE_VIS unordered_map;\n    template <class, class, class, class, class> friend class _LIBCPP_TEMPLATE_VIS unordered_multimap;\n};\n\ntemplate <class _Tp, class _Hash, class _Equal, class _Alloc>\ninline\n__hash_table<_Tp, _Hash, _Equal, _Alloc>::__hash_table()\n    _NOEXCEPT_(\n        is_nothrow_default_constructible<__bucket_list>::value &&\n        is_nothrow_default_constructible<__first_node>::value &&\n        is_nothrow_default_constructible<__node_allocator>::value &&\n        is_nothrow_default_constructible<hasher>::value &&\n        is_nothrow_default_constructible<key_equal>::value)\n    : __p2_(0),\n      __p3_(1.0f)\n{\n}\n\ntemplate <class _Tp, class _Hash, class _Equal, class _Alloc>\ninline\n__hash_table<_Tp, _Hash, _Equal, _Alloc>::__hash_table(const hasher& __hf,\n                                                       const key_equal& __eql)\n    : __bucket_list_(nullptr, __bucket_list_deleter()),\n      __p1_(),\n      __p2_(0, __hf),\n      __p3_(1.0f, __eql)\n{\n}\n\ntemplate <class _Tp, class _Hash, class _Equal, class _Alloc>\n__hash_table<_Tp, _Hash, _Equal, _Alloc>::__hash_table(const hasher& __hf,\n                                                       const key_equal& __eql,\n                                                       const allocator_type& __a)\n    : __bucket_list_(nullptr, __bucket_list_deleter(__pointer_allocator(__a), 0)),\n      __p1_(__node_allocator(__a)),\n      __p2_(0, __hf),\n      __p3_(1.0f, __eql)\n{\n}\n\ntemplate <class _Tp, class _Hash, class _Equal, class _Alloc>\n__hash_table<_Tp, _Hash, _Equal, _Alloc>::__hash_table(const allocator_type& __a)\n    : __bucket_list_(nullptr, __bucket_list_deleter(__pointer_allocator(__a), 0)),\n      __p1_(__node_allocator(__a)),\n      __p2_(0),\n      __p3_(1.0f)\n{\n}\n\ntemplate <class _Tp, class _Hash, class _Equal, class _Alloc>\n__hash_table<_Tp, _Hash, _Equal, _Alloc>::__hash_table(const __hash_table& __u)\n    : __bucket_list_(nullptr,\n          __bucket_list_deleter(allocator_traits<__pointer_allocator>::\n              select_on_container_copy_construction(\n                  __u.__bucket_list_.get_deleter().__alloc()), 0)),\n      __p1_(allocator_traits<__node_allocator>::\n          select_on_container_copy_construction(__u.__node_alloc())),\n      __p2_(0, __u.hash_function()),\n      __p3_(__u.__p3_)\n{\n}\n\ntemplate <class _Tp, class _Hash, class _Equal, class _Alloc>\n__hash_table<_Tp, _Hash, _Equal, _Alloc>::__hash_table(const __hash_table& __u,\n                                                       const allocator_type& __a)\n    : __bucket_list_(nullptr, __bucket_list_deleter(__pointer_allocator(__a), 0)),\n      __p1_(__node_allocator(__a)),\n      __p2_(0, __u.hash_function()),\n      __p3_(__u.__p3_)\n{\n}\n\n#ifndef _LIBCPP_CXX03_LANG\n\ntemplate <class _Tp, class _Hash, class _Equal, class _Alloc>\n__hash_table<_Tp, _Hash, _Equal, _Alloc>::__hash_table(__hash_table&& __u)\n        _NOEXCEPT_(\n            is_nothrow_move_constructible<__bucket_list>::value &&\n            is_nothrow_move_constructible<__first_node>::value &&\n            is_nothrow_move_constructible<__node_allocator>::value &&\n            is_nothrow_move_constructible<hasher>::value &&\n            is_nothrow_move_constructible<key_equal>::value)\n    : __bucket_list_(_VSTD::move(__u.__bucket_list_)),\n      __p1_(_VSTD::move(__u.__p1_)),\n      __p2_(_VSTD::move(__u.__p2_)),\n      __p3_(_VSTD::move(__u.__p3_))\n{\n    if (size() > 0)\n    {\n        __bucket_list_[__constrain_hash(__p1_.first().__next_->__hash(), bucket_count())] =\n            __p1_.first().__ptr();\n        __u.__p1_.first().__next_ = nullptr;\n        __u.size() = 0;\n    }\n}\n\ntemplate <class _Tp, class _Hash, class _Equal, class _Alloc>\n__hash_table<_Tp, _Hash, _Equal, _Alloc>::__hash_table(__hash_table&& __u,\n                                                       const allocator_type& __a)\n    : __bucket_list_(nullptr, __bucket_list_deleter(__pointer_allocator(__a), 0)),\n      __p1_(__node_allocator(__a)),\n      __p2_(0, _VSTD::move(__u.hash_function())),\n      __p3_(_VSTD::move(__u.__p3_))\n{\n    if (__a == allocator_type(__u.__node_alloc()))\n    {\n        __bucket_list_.reset(__u.__bucket_list_.release());\n        __bucket_list_.get_deleter().size() = __u.__bucket_list_.get_deleter().size();\n        __u.__bucket_list_.get_deleter().size() = 0;\n        if (__u.size() > 0)\n        {\n            __p1_.first().__next_ = __u.__p1_.first().__next_;\n            __u.__p1_.first().__next_ = nullptr;\n            __bucket_list_[__constrain_hash(__p1_.first().__next_->__hash(), bucket_count())] =\n                __p1_.first().__ptr();\n            size() = __u.size();\n            __u.size() = 0;\n        }\n    }\n}\n\n#endif  // _LIBCPP_CXX03_LANG\n\ntemplate <class _Tp, class _Hash, class _Equal, class _Alloc>\n__hash_table<_Tp, _Hash, _Equal, _Alloc>::~__hash_table()\n{\n    static_assert((is_copy_constructible<key_equal>::value),\n                 \"Predicate must be copy-constructible.\");\n    static_assert((is_copy_constructible<hasher>::value),\n                 \"Hasher must be copy-constructible.\");\n    __deallocate_node(__p1_.first().__next_);\n#if _LIBCPP_DEBUG_LEVEL >= 2\n    __get_db()->__erase_c(this);\n#endif\n}\n\ntemplate <class _Tp, class _Hash, class _Equal, class _Alloc>\nvoid\n__hash_table<_Tp, _Hash, _Equal, _Alloc>::__copy_assign_alloc(\n        const __hash_table& __u, true_type)\n{\n    if (__node_alloc() != __u.__node_alloc())\n    {\n        clear();\n        __bucket_list_.reset();\n        __bucket_list_.get_deleter().size() = 0;\n    }\n    __bucket_list_.get_deleter().__alloc() = __u.__bucket_list_.get_deleter().__alloc();\n    __node_alloc() = __u.__node_alloc();\n}\n\ntemplate <class _Tp, class _Hash, class _Equal, class _Alloc>\n__hash_table<_Tp, _Hash, _Equal, _Alloc>&\n__hash_table<_Tp, _Hash, _Equal, _Alloc>::operator=(const __hash_table& __u)\n{\n    if (this != &__u)\n    {\n        __copy_assign_alloc(__u);\n        hash_function() = __u.hash_function();\n        key_eq() = __u.key_eq();\n        max_load_factor() = __u.max_load_factor();\n        __assign_multi(__u.begin(), __u.end());\n    }\n    return *this;\n}\n\ntemplate <class _Tp, class _Hash, class _Equal, class _Alloc>\nvoid\n__hash_table<_Tp, _Hash, _Equal, _Alloc>::__deallocate_node(__next_pointer __np)\n    _NOEXCEPT\n{\n    __node_allocator& __na = __node_alloc();\n    while (__np != nullptr)\n    {\n        __next_pointer __next = __np->__next_;\n#if _LIBCPP_DEBUG_LEVEL >= 2\n        __c_node* __c = __get_db()->__find_c_and_lock(this);\n        for (__i_node** __p = __c->end_; __p != __c->beg_; )\n        {\n            --__p;\n            iterator* __i = static_cast<iterator*>((*__p)->__i_);\n            if (__i->__node_ == __np)\n            {\n                (*__p)->__c_ = nullptr;\n                if (--__c->end_ != __p)\n                    memmove(__p, __p+1, (__c->end_ - __p)*sizeof(__i_node*));\n            }\n        }\n        __get_db()->unlock();\n#endif\n        __node_pointer __real_np = __np->__upcast();\n        __node_traits::destroy(__na, _NodeTypes::__get_ptr(__real_np->__value_));\n        __node_traits::deallocate(__na, __real_np, 1);\n        __np = __next;\n    }\n}\n\ntemplate <class _Tp, class _Hash, class _Equal, class _Alloc>\ntypename __hash_table<_Tp, _Hash, _Equal, _Alloc>::__next_pointer\n__hash_table<_Tp, _Hash, _Equal, _Alloc>::__detach() _NOEXCEPT\n{\n    size_type __bc = bucket_count();\n    for (size_type __i = 0; __i < __bc; ++__i)\n        __bucket_list_[__i] = nullptr;\n    size() = 0;\n    __next_pointer __cache = __p1_.first().__next_;\n    __p1_.first().__next_ = nullptr;\n    return __cache;\n}\n\n#ifndef _LIBCPP_CXX03_LANG\n\ntemplate <class _Tp, class _Hash, class _Equal, class _Alloc>\nvoid\n__hash_table<_Tp, _Hash, _Equal, _Alloc>::__move_assign(\n        __hash_table& __u, true_type)\n    _NOEXCEPT_(\n        is_nothrow_move_assignable<__node_allocator>::value &&\n        is_nothrow_move_assignable<hasher>::value &&\n        is_nothrow_move_assignable<key_equal>::value)\n{\n    clear();\n    __bucket_list_.reset(__u.__bucket_list_.release());\n    __bucket_list_.get_deleter().size() = __u.__bucket_list_.get_deleter().size();\n    __u.__bucket_list_.get_deleter().size() = 0;\n    __move_assign_alloc(__u);\n    size() = __u.size();\n    hash_function() = _VSTD::move(__u.hash_function());\n    max_load_factor() = __u.max_load_factor();\n    key_eq() = _VSTD::move(__u.key_eq());\n    __p1_.first().__next_ = __u.__p1_.first().__next_;\n    if (size() > 0)\n    {\n        __bucket_list_[__constrain_hash(__p1_.first().__next_->__hash(), bucket_count())] =\n            __p1_.first().__ptr();\n        __u.__p1_.first().__next_ = nullptr;\n        __u.size() = 0;\n    }\n#if _LIBCPP_DEBUG_LEVEL >= 2\n    __get_db()->swap(this, &__u);\n#endif\n}\n\ntemplate <class _Tp, class _Hash, class _Equal, class _Alloc>\nvoid\n__hash_table<_Tp, _Hash, _Equal, _Alloc>::__move_assign(\n        __hash_table& __u, false_type)\n{\n    if (__node_alloc() == __u.__node_alloc())\n        __move_assign(__u, true_type());\n    else\n    {\n        hash_function() = _VSTD::move(__u.hash_function());\n        key_eq() = _VSTD::move(__u.key_eq());\n        max_load_factor() = __u.max_load_factor();\n        if (bucket_count() != 0)\n        {\n            __next_pointer __cache = __detach();\n#ifndef _LIBCPP_NO_EXCEPTIONS\n            try\n            {\n#endif  // _LIBCPP_NO_EXCEPTIONS\n                const_iterator __i = __u.begin();\n                while (__cache != nullptr && __u.size() != 0)\n                {\n                    __cache->__upcast()->__value_ =\n                        _VSTD::move(__u.remove(__i++)->__value_);\n                    __next_pointer __next = __cache->__next_;\n                    __node_insert_multi(__cache->__upcast());\n                    __cache = __next;\n                }\n#ifndef _LIBCPP_NO_EXCEPTIONS\n            }\n            catch (...)\n            {\n                __deallocate_node(__cache);\n                throw;\n            }\n#endif  // _LIBCPP_NO_EXCEPTIONS\n            __deallocate_node(__cache);\n        }\n        const_iterator __i = __u.begin();\n        while (__u.size() != 0)\n        {\n            __node_holder __h = __construct_node(_NodeTypes::__move(__u.remove(__i++)->__value_));\n            __node_insert_multi(__h.get());\n            __h.release();\n        }\n    }\n}\n\ntemplate <class _Tp, class _Hash, class _Equal, class _Alloc>\ninline\n__hash_table<_Tp, _Hash, _Equal, _Alloc>&\n__hash_table<_Tp, _Hash, _Equal, _Alloc>::operator=(__hash_table&& __u)\n    _NOEXCEPT_(\n        __node_traits::propagate_on_container_move_assignment::value &&\n        is_nothrow_move_assignable<__node_allocator>::value &&\n        is_nothrow_move_assignable<hasher>::value &&\n        is_nothrow_move_assignable<key_equal>::value)\n{\n    __move_assign(__u, integral_constant<bool,\n                  __node_traits::propagate_on_container_move_assignment::value>());\n    return *this;\n}\n\n#endif  // _LIBCPP_CXX03_LANG\n\ntemplate <class _Tp, class _Hash, class _Equal, class _Alloc>\ntemplate <class _InputIterator>\nvoid\n__hash_table<_Tp, _Hash, _Equal, _Alloc>::__assign_unique(_InputIterator __first,\n                                                          _InputIterator __last)\n{\n    typedef iterator_traits<_InputIterator> _ITraits;\n    typedef typename _ITraits::value_type _ItValueType;\n    static_assert((is_same<_ItValueType, __container_value_type>::value),\n                  \"__assign_unique may only be called with the containers value type\");\n\n    if (bucket_count() != 0)\n    {\n        __next_pointer __cache = __detach();\n#ifndef _LIBCPP_NO_EXCEPTIONS\n        try\n        {\n#endif  // _LIBCPP_NO_EXCEPTIONS\n            for (; __cache != nullptr && __first != __last; ++__first)\n            {\n                __cache->__upcast()->__value_ = *__first;\n                __next_pointer __next = __cache->__next_;\n                __node_insert_unique(__cache->__upcast());\n                __cache = __next;\n            }\n#ifndef _LIBCPP_NO_EXCEPTIONS\n        }\n        catch (...)\n        {\n            __deallocate_node(__cache);\n            throw;\n        }\n#endif  // _LIBCPP_NO_EXCEPTIONS\n        __deallocate_node(__cache);\n    }\n    for (; __first != __last; ++__first)\n        __insert_unique(*__first);\n}\n\ntemplate <class _Tp, class _Hash, class _Equal, class _Alloc>\ntemplate <class _InputIterator>\nvoid\n__hash_table<_Tp, _Hash, _Equal, _Alloc>::__assign_multi(_InputIterator __first,\n                                                         _InputIterator __last)\n{\n    typedef iterator_traits<_InputIterator> _ITraits;\n    typedef typename _ITraits::value_type _ItValueType;\n    static_assert((is_same<_ItValueType, __container_value_type>::value ||\n                  is_same<_ItValueType, __node_value_type>::value),\n                  \"__assign_multi may only be called with the containers value type\"\n                  \" or the nodes value type\");\n    if (bucket_count() != 0)\n    {\n        __next_pointer __cache = __detach();\n#ifndef _LIBCPP_NO_EXCEPTIONS\n        try\n        {\n#endif  // _LIBCPP_NO_EXCEPTIONS\n            for (; __cache != nullptr && __first != __last; ++__first)\n            {\n                __cache->__upcast()->__value_ = *__first;\n                __next_pointer __next = __cache->__next_;\n                __node_insert_multi(__cache->__upcast());\n                __cache = __next;\n            }\n#ifndef _LIBCPP_NO_EXCEPTIONS\n        }\n        catch (...)\n        {\n            __deallocate_node(__cache);\n            throw;\n        }\n#endif  // _LIBCPP_NO_EXCEPTIONS\n        __deallocate_node(__cache);\n    }\n    for (; __first != __last; ++__first)\n        __insert_multi(_NodeTypes::__get_value(*__first));\n}\n\ntemplate <class _Tp, class _Hash, class _Equal, class _Alloc>\ninline\ntypename __hash_table<_Tp, _Hash, _Equal, _Alloc>::iterator\n__hash_table<_Tp, _Hash, _Equal, _Alloc>::begin() _NOEXCEPT\n{\n#if _LIBCPP_DEBUG_LEVEL >= 2\n    return iterator(__p1_.first().__next_, this);\n#else\n    return iterator(__p1_.first().__next_);\n#endif\n}\n\ntemplate <class _Tp, class _Hash, class _Equal, class _Alloc>\ninline\ntypename __hash_table<_Tp, _Hash, _Equal, _Alloc>::iterator\n__hash_table<_Tp, _Hash, _Equal, _Alloc>::end() _NOEXCEPT\n{\n#if _LIBCPP_DEBUG_LEVEL >= 2\n    return iterator(nullptr, this);\n#else\n    return iterator(nullptr);\n#endif\n}\n\ntemplate <class _Tp, class _Hash, class _Equal, class _Alloc>\ninline\ntypename __hash_table<_Tp, _Hash, _Equal, _Alloc>::const_iterator\n__hash_table<_Tp, _Hash, _Equal, _Alloc>::begin() const _NOEXCEPT\n{\n#if _LIBCPP_DEBUG_LEVEL >= 2\n    return const_iterator(__p1_.first().__next_, this);\n#else\n    return const_iterator(__p1_.first().__next_);\n#endif\n}\n\ntemplate <class _Tp, class _Hash, class _Equal, class _Alloc>\ninline\ntypename __hash_table<_Tp, _Hash, _Equal, _Alloc>::const_iterator\n__hash_table<_Tp, _Hash, _Equal, _Alloc>::end() const _NOEXCEPT\n{\n#if _LIBCPP_DEBUG_LEVEL >= 2\n    return const_iterator(nullptr, this);\n#else\n    return const_iterator(nullptr);\n#endif\n}\n\ntemplate <class _Tp, class _Hash, class _Equal, class _Alloc>\nvoid\n__hash_table<_Tp, _Hash, _Equal, _Alloc>::clear() _NOEXCEPT\n{\n    if (size() > 0)\n    {\n        __deallocate_node(__p1_.first().__next_);\n        __p1_.first().__next_ = nullptr;\n        size_type __bc = bucket_count();\n        for (size_type __i = 0; __i < __bc; ++__i)\n            __bucket_list_[__i] = nullptr;\n        size() = 0;\n    }\n}\n\ntemplate <class _Tp, class _Hash, class _Equal, class _Alloc>\npair<typename __hash_table<_Tp, _Hash, _Equal, _Alloc>::iterator, bool>\n__hash_table<_Tp, _Hash, _Equal, _Alloc>::__node_insert_unique(__node_pointer __nd)\n{\n    __nd->__hash_ = hash_function()(__nd->__value_);\n    size_type __bc = bucket_count();\n    bool __inserted = false;\n    __next_pointer __ndptr;\n    size_t __chash;\n    if (__bc != 0)\n    {\n        __chash = __constrain_hash(__nd->__hash_, __bc);\n        __ndptr = __bucket_list_[__chash];\n        if (__ndptr != nullptr)\n        {\n            for (__ndptr = __ndptr->__next_; __ndptr != nullptr &&\n                                             __constrain_hash(__ndptr->__hash(), __bc) == __chash;\n                                                     __ndptr = __ndptr->__next_)\n            {\n                if (key_eq()(__ndptr->__upcast()->__value_, __nd->__value_))\n                    goto __done;\n            }\n        }\n    }\n    {\n        if (size()+1 > __bc * max_load_factor() || __bc == 0)\n        {\n            rehash(_VSTD::max<size_type>(2 * __bc + !__is_hash_power2(__bc),\n                           size_type(ceil(float(size() + 1) / max_load_factor()))));\n            __bc = bucket_count();\n            __chash = __constrain_hash(__nd->__hash_, __bc);\n        }\n        // insert_after __bucket_list_[__chash], or __first_node if bucket is null\n        __next_pointer __pn = __bucket_list_[__chash];\n        if (__pn == nullptr)\n        {\n            __pn =__p1_.first().__ptr();\n            __nd->__next_ = __pn->__next_;\n            __pn->__next_ = __nd->__ptr();\n            // fix up __bucket_list_\n            __bucket_list_[__chash] = __pn;\n            if (__nd->__next_ != nullptr)\n                __bucket_list_[__constrain_hash(__nd->__next_->__hash(), __bc)] = __nd->__ptr();\n        }\n        else\n        {\n            __nd->__next_ = __pn->__next_;\n            __pn->__next_ = __nd->__ptr();\n        }\n        __ndptr = __nd->__ptr();\n        // increment size\n        ++size();\n        __inserted = true;\n    }\n__done:\n#if _LIBCPP_DEBUG_LEVEL >= 2\n    return pair<iterator, bool>(iterator(__ndptr, this), __inserted);\n#else\n    return pair<iterator, bool>(iterator(__ndptr), __inserted);\n#endif\n}\n\ntemplate <class _Tp, class _Hash, class _Equal, class _Alloc>\ntypename __hash_table<_Tp, _Hash, _Equal, _Alloc>::iterator\n__hash_table<_Tp, _Hash, _Equal, _Alloc>::__node_insert_multi(__node_pointer __cp)\n{\n    __cp->__hash_ = hash_function()(__cp->__value_);\n    size_type __bc = bucket_count();\n    if (size()+1 > __bc * max_load_factor() || __bc == 0)\n    {\n        rehash(_VSTD::max<size_type>(2 * __bc + !__is_hash_power2(__bc),\n                       size_type(ceil(float(size() + 1) / max_load_factor()))));\n        __bc = bucket_count();\n    }\n    size_t __chash = __constrain_hash(__cp->__hash_, __bc);\n    __next_pointer __pn = __bucket_list_[__chash];\n    if (__pn == nullptr)\n    {\n        __pn =__p1_.first().__ptr();\n        __cp->__next_ = __pn->__next_;\n        __pn->__next_ = __cp->__ptr();\n        // fix up __bucket_list_\n        __bucket_list_[__chash] = __pn;\n        if (__cp->__next_ != nullptr)\n            __bucket_list_[__constrain_hash(__cp->__next_->__hash(), __bc)]\n                = __cp->__ptr();\n    }\n    else\n    {\n        for (bool __found = false; __pn->__next_ != nullptr &&\n                                   __constrain_hash(__pn->__next_->__hash(), __bc) == __chash;\n                                                           __pn = __pn->__next_)\n        {\n            //      __found    key_eq()     action\n            //      false       false       loop\n            //      true        true        loop\n            //      false       true        set __found to true\n            //      true        false       break\n            if (__found != (__pn->__next_->__hash() == __cp->__hash_ &&\n                            key_eq()(__pn->__next_->__upcast()->__value_, __cp->__value_)))\n            {\n                if (!__found)\n                    __found = true;\n                else\n                    break;\n            }\n        }\n        __cp->__next_ = __pn->__next_;\n        __pn->__next_ = __cp->__ptr();\n        if (__cp->__next_ != nullptr)\n        {\n            size_t __nhash = __constrain_hash(__cp->__next_->__hash(), __bc);\n            if (__nhash != __chash)\n                __bucket_list_[__nhash] = __cp->__ptr();\n        }\n    }\n    ++size();\n#if _LIBCPP_DEBUG_LEVEL >= 2\n    return iterator(__cp->__ptr(), this);\n#else\n    return iterator(__cp->__ptr());\n#endif\n}\n\ntemplate <class _Tp, class _Hash, class _Equal, class _Alloc>\ntypename __hash_table<_Tp, _Hash, _Equal, _Alloc>::iterator\n__hash_table<_Tp, _Hash, _Equal, _Alloc>::__node_insert_multi(\n        const_iterator __p, __node_pointer __cp)\n{\n#if _LIBCPP_DEBUG_LEVEL >= 2\n    _LIBCPP_ASSERT(__get_const_db()->__find_c_from_i(&__p) == this,\n        \"unordered container::emplace_hint(const_iterator, args...) called with an iterator not\"\n        \" referring to this unordered container\");\n#endif\n    if (__p != end() && key_eq()(*__p, __cp->__value_))\n    {\n        __next_pointer __np = __p.__node_;\n        __cp->__hash_ = __np->__hash();\n        size_type __bc = bucket_count();\n        if (size()+1 > __bc * max_load_factor() || __bc == 0)\n        {\n            rehash(_VSTD::max<size_type>(2 * __bc + !__is_hash_power2(__bc),\n                           size_type(ceil(float(size() + 1) / max_load_factor()))));\n            __bc = bucket_count();\n        }\n        size_t __chash = __constrain_hash(__cp->__hash_, __bc);\n        __next_pointer __pp = __bucket_list_[__chash];\n        while (__pp->__next_ != __np)\n            __pp = __pp->__next_;\n        __cp->__next_ = __np;\n        __pp->__next_ = static_cast<__next_pointer>(__cp);\n        ++size();\n#if _LIBCPP_DEBUG_LEVEL >= 2\n        return iterator(static_cast<__next_pointer>(__cp), this);\n#else\n        return iterator(static_cast<__next_pointer>(__cp));\n#endif\n    }\n    return __node_insert_multi(__cp);\n}\n\n\n\n#ifndef _LIBCPP_CXX03_LANG\ntemplate <class _Tp, class _Hash, class _Equal, class _Alloc>\ntemplate <class _Key, class ..._Args>\npair<typename __hash_table<_Tp, _Hash, _Equal, _Alloc>::iterator, bool>\n__hash_table<_Tp, _Hash, _Equal, _Alloc>::__emplace_unique_key_args(_Key const& __k, _Args&&... __args)\n#else\ntemplate <class _Tp, class _Hash, class _Equal, class _Alloc>\ntemplate <class _Key, class _Args>\npair<typename __hash_table<_Tp, _Hash, _Equal, _Alloc>::iterator, bool>\n__hash_table<_Tp, _Hash, _Equal, _Alloc>::__emplace_unique_key_args(_Key const& __k, _Args& __args)\n#endif\n{\n\n    size_t __hash = hash_function()(__k);\n    size_type __bc = bucket_count();\n    bool __inserted = false;\n    __next_pointer __nd;\n    size_t __chash;\n    if (__bc != 0)\n    {\n        __chash = __constrain_hash(__hash, __bc);\n        __nd = __bucket_list_[__chash];\n        if (__nd != nullptr)\n        {\n            for (__nd = __nd->__next_; __nd != nullptr &&\n                (__nd->__hash() == __hash || __constrain_hash(__nd->__hash(), __bc) == __chash);\n                                                           __nd = __nd->__next_)\n            {\n                if (key_eq()(__nd->__upcast()->__value_, __k))\n                    goto __done;\n            }\n        }\n    }\n    {\n#ifndef _LIBCPP_CXX03_LANG\n        __node_holder __h = __construct_node_hash(__hash, _VSTD::forward<_Args>(__args)...);\n#else\n        __node_holder __h = __construct_node_hash(__hash, __args);\n#endif\n        if (size()+1 > __bc * max_load_factor() || __bc == 0)\n        {\n            rehash(_VSTD::max<size_type>(2 * __bc + !__is_hash_power2(__bc),\n                           size_type(ceil(float(size() + 1) / max_load_factor()))));\n            __bc = bucket_count();\n            __chash = __constrain_hash(__hash, __bc);\n        }\n        // insert_after __bucket_list_[__chash], or __first_node if bucket is null\n        __next_pointer __pn = __bucket_list_[__chash];\n        if (__pn == nullptr)\n        {\n            __pn = __p1_.first().__ptr();\n            __h->__next_ = __pn->__next_;\n            __pn->__next_ = __h.get()->__ptr();\n            // fix up __bucket_list_\n            __bucket_list_[__chash] = __pn;\n            if (__h->__next_ != nullptr)\n                __bucket_list_[__constrain_hash(__h->__next_->__hash(), __bc)]\n                    = __h.get()->__ptr();\n        }\n        else\n        {\n            __h->__next_ = __pn->__next_;\n            __pn->__next_ = static_cast<__next_pointer>(__h.get());\n        }\n        __nd = static_cast<__next_pointer>(__h.release());\n        // increment size\n        ++size();\n        __inserted = true;\n    }\n__done:\n#if _LIBCPP_DEBUG_LEVEL >= 2\n    return pair<iterator, bool>(iterator(__nd, this), __inserted);\n#else\n    return pair<iterator, bool>(iterator(__nd), __inserted);\n#endif\n}\n\n#ifndef _LIBCPP_CXX03_LANG\n\ntemplate <class _Tp, class _Hash, class _Equal, class _Alloc>\ntemplate <class... _Args>\npair<typename __hash_table<_Tp, _Hash, _Equal, _Alloc>::iterator, bool>\n__hash_table<_Tp, _Hash, _Equal, _Alloc>::__emplace_unique_impl(_Args&&... __args)\n{\n    __node_holder __h = __construct_node(_VSTD::forward<_Args>(__args)...);\n    pair<iterator, bool> __r = __node_insert_unique(__h.get());\n    if (__r.second)\n        __h.release();\n    return __r;\n}\n\ntemplate <class _Tp, class _Hash, class _Equal, class _Alloc>\ntemplate <class... _Args>\ntypename __hash_table<_Tp, _Hash, _Equal, _Alloc>::iterator\n__hash_table<_Tp, _Hash, _Equal, _Alloc>::__emplace_multi(_Args&&... __args)\n{\n    __node_holder __h = __construct_node(_VSTD::forward<_Args>(__args)...);\n    iterator __r = __node_insert_multi(__h.get());\n    __h.release();\n    return __r;\n}\n\ntemplate <class _Tp, class _Hash, class _Equal, class _Alloc>\ntemplate <class... _Args>\ntypename __hash_table<_Tp, _Hash, _Equal, _Alloc>::iterator\n__hash_table<_Tp, _Hash, _Equal, _Alloc>::__emplace_hint_multi(\n        const_iterator __p, _Args&&... __args)\n{\n#if _LIBCPP_DEBUG_LEVEL >= 2\n    _LIBCPP_ASSERT(__get_const_db()->__find_c_from_i(&__p) == this,\n        \"unordered container::emplace_hint(const_iterator, args...) called with an iterator not\"\n        \" referring to this unordered container\");\n#endif\n    __node_holder __h = __construct_node(_VSTD::forward<_Args>(__args)...);\n    iterator __r = __node_insert_multi(__p, __h.get());\n    __h.release();\n    return __r;\n}\n\n#else // _LIBCPP_CXX03_LANG\n\ntemplate <class _Tp, class _Hash, class _Equal, class _Alloc>\ntypename __hash_table<_Tp, _Hash, _Equal, _Alloc>::iterator\n__hash_table<_Tp, _Hash, _Equal, _Alloc>::__insert_multi(const __container_value_type& __x)\n{\n    __node_holder __h = __construct_node(__x);\n    iterator __r = __node_insert_multi(__h.get());\n    __h.release();\n    return __r;\n}\n\ntemplate <class _Tp, class _Hash, class _Equal, class _Alloc>\ntypename __hash_table<_Tp, _Hash, _Equal, _Alloc>::iterator\n__hash_table<_Tp, _Hash, _Equal, _Alloc>::__insert_multi(const_iterator __p,\n                                                         const __container_value_type& __x)\n{\n#if _LIBCPP_DEBUG_LEVEL >= 2\n    _LIBCPP_ASSERT(__get_const_db()->__find_c_from_i(&__p) == this,\n        \"unordered container::insert(const_iterator, lvalue) called with an iterator not\"\n        \" referring to this unordered container\");\n#endif\n    __node_holder __h = __construct_node(__x);\n    iterator __r = __node_insert_multi(__p, __h.get());\n    __h.release();\n    return __r;\n}\n\n#endif  // _LIBCPP_CXX03_LANG\n\ntemplate <class _Tp, class _Hash, class _Equal, class _Alloc>\nvoid\n__hash_table<_Tp, _Hash, _Equal, _Alloc>::rehash(size_type __n)\n{\n    if (__n == 1)\n        __n = 2;\n    else if (__n & (__n - 1))\n        __n = __next_prime(__n);\n    size_type __bc = bucket_count();\n    if (__n > __bc)\n        __rehash(__n);\n    else if (__n < __bc)\n    {\n        __n = _VSTD::max<size_type>\n              (\n                  __n,\n                  __is_hash_power2(__bc) ? __next_hash_pow2(size_t(ceil(float(size()) / max_load_factor()))) :\n                                           __next_prime(size_t(ceil(float(size()) / max_load_factor())))\n              );\n        if (__n < __bc)\n            __rehash(__n);\n    }\n}\n\ntemplate <class _Tp, class _Hash, class _Equal, class _Alloc>\nvoid\n__hash_table<_Tp, _Hash, _Equal, _Alloc>::__rehash(size_type __nbc)\n{\n#if _LIBCPP_DEBUG_LEVEL >= 2\n    __get_db()->__invalidate_all(this);\n#endif  // _LIBCPP_DEBUG_LEVEL >= 2\n    __pointer_allocator& __npa = __bucket_list_.get_deleter().__alloc();\n    __bucket_list_.reset(__nbc > 0 ?\n                      __pointer_alloc_traits::allocate(__npa, __nbc) : nullptr);\n    __bucket_list_.get_deleter().size() = __nbc;\n    if (__nbc > 0)\n    {\n        for (size_type __i = 0; __i < __nbc; ++__i)\n            __bucket_list_[__i] = nullptr;\n        __next_pointer __pp = __p1_.first().__ptr();\n        __next_pointer __cp = __pp->__next_;\n        if (__cp != nullptr)\n        {\n            size_type __chash = __constrain_hash(__cp->__hash(), __nbc);\n            __bucket_list_[__chash] = __pp;\n            size_type __phash = __chash;\n            for (__pp = __cp, __cp = __cp->__next_; __cp != nullptr;\n                                                           __cp = __pp->__next_)\n            {\n                __chash = __constrain_hash(__cp->__hash(), __nbc);\n                if (__chash == __phash)\n                    __pp = __cp;\n                else\n                {\n                    if (__bucket_list_[__chash] == nullptr)\n                    {\n                        __bucket_list_[__chash] = __pp;\n                        __pp = __cp;\n                        __phash = __chash;\n                    }\n                    else\n                    {\n                        __next_pointer __np = __cp;\n                        for (; __np->__next_ != nullptr &&\n                               key_eq()(__cp->__upcast()->__value_,\n                                        __np->__next_->__upcast()->__value_);\n                                                           __np = __np->__next_)\n                            ;\n                        __pp->__next_ = __np->__next_;\n                        __np->__next_ = __bucket_list_[__chash]->__next_;\n                        __bucket_list_[__chash]->__next_ = __cp;\n\n                    }\n                }\n            }\n        }\n    }\n}\n\ntemplate <class _Tp, class _Hash, class _Equal, class _Alloc>\ntemplate <class _Key>\ntypename __hash_table<_Tp, _Hash, _Equal, _Alloc>::iterator\n__hash_table<_Tp, _Hash, _Equal, _Alloc>::find(const _Key& __k)\n{\n    size_t __hash = hash_function()(__k);\n    size_type __bc = bucket_count();\n    if (__bc != 0)\n    {\n        size_t __chash = __constrain_hash(__hash, __bc);\n        __next_pointer __nd = __bucket_list_[__chash];\n        if (__nd != nullptr)\n        {\n            for (__nd = __nd->__next_; __nd != nullptr &&\n                (__nd->__hash() == __hash\n                  || __constrain_hash(__nd->__hash(), __bc) == __chash);\n                                                           __nd = __nd->__next_)\n            {\n                if ((__nd->__hash() == __hash)\n                    && key_eq()(__nd->__upcast()->__value_, __k))\n#if _LIBCPP_DEBUG_LEVEL >= 2\n                    return iterator(__nd, this);\n#else\n                    return iterator(__nd);\n#endif\n            }\n        }\n    }\n    return end();\n}\n\ntemplate <class _Tp, class _Hash, class _Equal, class _Alloc>\ntemplate <class _Key>\ntypename __hash_table<_Tp, _Hash, _Equal, _Alloc>::const_iterator\n__hash_table<_Tp, _Hash, _Equal, _Alloc>::find(const _Key& __k) const\n{\n    size_t __hash = hash_function()(__k);\n    size_type __bc = bucket_count();\n    if (__bc != 0)\n    {\n        size_t __chash = __constrain_hash(__hash, __bc);\n        __next_pointer __nd = __bucket_list_[__chash];\n        if (__nd != nullptr)\n        {\n            for (__nd = __nd->__next_; __nd != nullptr &&\n                (__hash == __nd->__hash()\n                    || __constrain_hash(__nd->__hash(), __bc) == __chash);\n                                                           __nd = __nd->__next_)\n            {\n                if ((__nd->__hash() == __hash)\n                    && key_eq()(__nd->__upcast()->__value_, __k))\n#if _LIBCPP_DEBUG_LEVEL >= 2\n                    return const_iterator(__nd, this);\n#else\n                    return const_iterator(__nd);\n#endif\n            }\n        }\n\n    }\n    return end();\n}\n\n#ifndef _LIBCPP_CXX03_LANG\n\ntemplate <class _Tp, class _Hash, class _Equal, class _Alloc>\ntemplate <class ..._Args>\ntypename __hash_table<_Tp, _Hash, _Equal, _Alloc>::__node_holder\n__hash_table<_Tp, _Hash, _Equal, _Alloc>::__construct_node(_Args&& ...__args)\n{\n    static_assert(!__is_hash_value_type<_Args...>::value,\n                  \"Construct cannot be called with a hash value type\");\n    __node_allocator& __na = __node_alloc();\n    __node_holder __h(__node_traits::allocate(__na, 1), _Dp(__na));\n    __node_traits::construct(__na, _NodeTypes::__get_ptr(__h->__value_), _VSTD::forward<_Args>(__args)...);\n    __h.get_deleter().__value_constructed = true;\n    __h->__hash_ = hash_function()(__h->__value_);\n    __h->__next_ = nullptr;\n    return __h;\n}\n\ntemplate <class _Tp, class _Hash, class _Equal, class _Alloc>\ntemplate <class _First, class ..._Rest>\ntypename __hash_table<_Tp, _Hash, _Equal, _Alloc>::__node_holder\n__hash_table<_Tp, _Hash, _Equal, _Alloc>::__construct_node_hash(\n    size_t __hash, _First&& __f, _Rest&& ...__rest)\n{\n    static_assert(!__is_hash_value_type<_First, _Rest...>::value,\n                  \"Construct cannot be called with a hash value type\");\n    __node_allocator& __na = __node_alloc();\n    __node_holder __h(__node_traits::allocate(__na, 1), _Dp(__na));\n    __node_traits::construct(__na, _NodeTypes::__get_ptr(__h->__value_),\n                             _VSTD::forward<_First>(__f),\n                             _VSTD::forward<_Rest>(__rest)...);\n    __h.get_deleter().__value_constructed = true;\n    __h->__hash_ = __hash;\n    __h->__next_ = nullptr;\n    return __h;\n}\n\n#else  // _LIBCPP_CXX03_LANG\n\ntemplate <class _Tp, class _Hash, class _Equal, class _Alloc>\ntypename __hash_table<_Tp, _Hash, _Equal, _Alloc>::__node_holder\n__hash_table<_Tp, _Hash, _Equal, _Alloc>::__construct_node(const __container_value_type& __v)\n{\n    __node_allocator& __na = __node_alloc();\n    __node_holder __h(__node_traits::allocate(__na, 1), _Dp(__na));\n    __node_traits::construct(__na, _NodeTypes::__get_ptr(__h->__value_), __v);\n    __h.get_deleter().__value_constructed = true;\n    __h->__hash_ = hash_function()(__h->__value_);\n    __h->__next_ = nullptr;\n    return _LIBCPP_EXPLICIT_MOVE(__h);  // explicitly moved for C++03\n}\n\ntemplate <class _Tp, class _Hash, class _Equal, class _Alloc>\ntypename __hash_table<_Tp, _Hash, _Equal, _Alloc>::__node_holder\n__hash_table<_Tp, _Hash, _Equal, _Alloc>::__construct_node_hash(size_t __hash,\n                                                                const __container_value_type& __v)\n{\n    __node_allocator& __na = __node_alloc();\n    __node_holder __h(__node_traits::allocate(__na, 1), _Dp(__na));\n    __node_traits::construct(__na, _NodeTypes::__get_ptr(__h->__value_), __v);\n    __h.get_deleter().__value_constructed = true;\n    __h->__hash_ = __hash;\n    __h->__next_ = nullptr;\n    return _LIBCPP_EXPLICIT_MOVE(__h);  // explicitly moved for C++03\n}\n\n#endif  // _LIBCPP_CXX03_LANG\n\ntemplate <class _Tp, class _Hash, class _Equal, class _Alloc>\ntypename __hash_table<_Tp, _Hash, _Equal, _Alloc>::iterator\n__hash_table<_Tp, _Hash, _Equal, _Alloc>::erase(const_iterator __p)\n{\n    __next_pointer __np = __p.__node_;\n#if _LIBCPP_DEBUG_LEVEL >= 2\n    _LIBCPP_ASSERT(__get_const_db()->__find_c_from_i(&__p) == this,\n        \"unordered container erase(iterator) called with an iterator not\"\n        \" referring to this container\");\n    _LIBCPP_ASSERT(__p != end(),\n        \"unordered container erase(iterator) called with a non-dereferenceable iterator\");\n    iterator __r(__np, this);\n#else\n    iterator __r(__np);\n#endif\n    ++__r;\n    remove(__p);\n    return __r;\n}\n\ntemplate <class _Tp, class _Hash, class _Equal, class _Alloc>\ntypename __hash_table<_Tp, _Hash, _Equal, _Alloc>::iterator\n__hash_table<_Tp, _Hash, _Equal, _Alloc>::erase(const_iterator __first,\n                                                const_iterator __last)\n{\n#if _LIBCPP_DEBUG_LEVEL >= 2\n    _LIBCPP_ASSERT(__get_const_db()->__find_c_from_i(&__first) == this,\n        \"unodered container::erase(iterator, iterator) called with an iterator not\"\n        \" referring to this unodered container\");\n    _LIBCPP_ASSERT(__get_const_db()->__find_c_from_i(&__last) == this,\n        \"unodered container::erase(iterator, iterator) called with an iterator not\"\n        \" referring to this unodered container\");\n#endif\n    for (const_iterator __p = __first; __first != __last; __p = __first)\n    {\n        ++__first;\n        erase(__p);\n    }\n    __next_pointer __np = __last.__node_;\n#if _LIBCPP_DEBUG_LEVEL >= 2\n    return iterator (__np, this);\n#else\n    return iterator (__np);\n#endif\n}\n\ntemplate <class _Tp, class _Hash, class _Equal, class _Alloc>\ntemplate <class _Key>\ntypename __hash_table<_Tp, _Hash, _Equal, _Alloc>::size_type\n__hash_table<_Tp, _Hash, _Equal, _Alloc>::__erase_unique(const _Key& __k)\n{\n    iterator __i = find(__k);\n    if (__i == end())\n        return 0;\n    erase(__i);\n    return 1;\n}\n\ntemplate <class _Tp, class _Hash, class _Equal, class _Alloc>\ntemplate <class _Key>\ntypename __hash_table<_Tp, _Hash, _Equal, _Alloc>::size_type\n__hash_table<_Tp, _Hash, _Equal, _Alloc>::__erase_multi(const _Key& __k)\n{\n    size_type __r = 0;\n    iterator __i = find(__k);\n    if (__i != end())\n    {\n        iterator __e = end();\n        do\n        {\n            erase(__i++);\n            ++__r;\n        } while (__i != __e && key_eq()(*__i, __k));\n    }\n    return __r;\n}\n\ntemplate <class _Tp, class _Hash, class _Equal, class _Alloc>\ntypename __hash_table<_Tp, _Hash, _Equal, _Alloc>::__node_holder\n__hash_table<_Tp, _Hash, _Equal, _Alloc>::remove(const_iterator __p) _NOEXCEPT\n{\n    // current node\n    __next_pointer __cn = __p.__node_;\n    size_type __bc = bucket_count();\n    size_t __chash = __constrain_hash(__cn->__hash(), __bc);\n    // find previous node\n    __next_pointer __pn = __bucket_list_[__chash];\n    for (; __pn->__next_ != __cn; __pn = __pn->__next_)\n        ;\n    // Fix up __bucket_list_\n        // if __pn is not in same bucket (before begin is not in same bucket) &&\n        //    if __cn->__next_ is not in same bucket (nullptr is not in same bucket)\n    if (__pn == __p1_.first().__ptr()\n            || __constrain_hash(__pn->__hash(), __bc) != __chash)\n    {\n        if (__cn->__next_ == nullptr\n            || __constrain_hash(__cn->__next_->__hash(), __bc) != __chash)\n            __bucket_list_[__chash] = nullptr;\n    }\n        // if __cn->__next_ is not in same bucket (nullptr is in same bucket)\n    if (__cn->__next_ != nullptr)\n    {\n        size_t __nhash = __constrain_hash(__cn->__next_->__hash(), __bc);\n        if (__nhash != __chash)\n            __bucket_list_[__nhash] = __pn;\n    }\n    // remove __cn\n    __pn->__next_ = __cn->__next_;\n    __cn->__next_ = nullptr;\n    --size();\n#if _LIBCPP_DEBUG_LEVEL >= 2\n    __c_node* __c = __get_db()->__find_c_and_lock(this);\n    for (__i_node** __dp = __c->end_; __dp != __c->beg_; )\n    {\n        --__dp;\n        iterator* __i = static_cast<iterator*>((*__dp)->__i_);\n        if (__i->__node_ == __cn)\n        {\n            (*__dp)->__c_ = nullptr;\n            if (--__c->end_ != __dp)\n                memmove(__dp, __dp+1, (__c->end_ - __dp)*sizeof(__i_node*));\n        }\n    }\n    __get_db()->unlock();\n#endif\n    return __node_holder(__cn->__upcast(), _Dp(__node_alloc(), true));\n}\n\ntemplate <class _Tp, class _Hash, class _Equal, class _Alloc>\ntemplate <class _Key>\ninline\ntypename __hash_table<_Tp, _Hash, _Equal, _Alloc>::size_type\n__hash_table<_Tp, _Hash, _Equal, _Alloc>::__count_unique(const _Key& __k) const\n{\n    return static_cast<size_type>(find(__k) != end());\n}\n\ntemplate <class _Tp, class _Hash, class _Equal, class _Alloc>\ntemplate <class _Key>\ntypename __hash_table<_Tp, _Hash, _Equal, _Alloc>::size_type\n__hash_table<_Tp, _Hash, _Equal, _Alloc>::__count_multi(const _Key& __k) const\n{\n    size_type __r = 0;\n    const_iterator __i = find(__k);\n    if (__i != end())\n    {\n        const_iterator __e = end();\n        do\n        {\n            ++__i;\n            ++__r;\n        } while (__i != __e && key_eq()(*__i, __k));\n    }\n    return __r;\n}\n\ntemplate <class _Tp, class _Hash, class _Equal, class _Alloc>\ntemplate <class _Key>\npair<typename __hash_table<_Tp, _Hash, _Equal, _Alloc>::iterator,\n     typename __hash_table<_Tp, _Hash, _Equal, _Alloc>::iterator>\n__hash_table<_Tp, _Hash, _Equal, _Alloc>::__equal_range_unique(\n        const _Key& __k)\n{\n    iterator __i = find(__k);\n    iterator __j = __i;\n    if (__i != end())\n        ++__j;\n    return pair<iterator, iterator>(__i, __j);\n}\n\ntemplate <class _Tp, class _Hash, class _Equal, class _Alloc>\ntemplate <class _Key>\npair<typename __hash_table<_Tp, _Hash, _Equal, _Alloc>::const_iterator,\n     typename __hash_table<_Tp, _Hash, _Equal, _Alloc>::const_iterator>\n__hash_table<_Tp, _Hash, _Equal, _Alloc>::__equal_range_unique(\n        const _Key& __k) const\n{\n    const_iterator __i = find(__k);\n    const_iterator __j = __i;\n    if (__i != end())\n        ++__j;\n    return pair<const_iterator, const_iterator>(__i, __j);\n}\n\ntemplate <class _Tp, class _Hash, class _Equal, class _Alloc>\ntemplate <class _Key>\npair<typename __hash_table<_Tp, _Hash, _Equal, _Alloc>::iterator,\n     typename __hash_table<_Tp, _Hash, _Equal, _Alloc>::iterator>\n__hash_table<_Tp, _Hash, _Equal, _Alloc>::__equal_range_multi(\n        const _Key& __k)\n{\n    iterator __i = find(__k);\n    iterator __j = __i;\n    if (__i != end())\n    {\n        iterator __e = end();\n        do\n        {\n            ++__j;\n        } while (__j != __e && key_eq()(*__j, __k));\n    }\n    return pair<iterator, iterator>(__i, __j);\n}\n\ntemplate <class _Tp, class _Hash, class _Equal, class _Alloc>\ntemplate <class _Key>\npair<typename __hash_table<_Tp, _Hash, _Equal, _Alloc>::const_iterator,\n     typename __hash_table<_Tp, _Hash, _Equal, _Alloc>::const_iterator>\n__hash_table<_Tp, _Hash, _Equal, _Alloc>::__equal_range_multi(\n        const _Key& __k) const\n{\n    const_iterator __i = find(__k);\n    const_iterator __j = __i;\n    if (__i != end())\n    {\n        const_iterator __e = end();\n        do\n        {\n            ++__j;\n        } while (__j != __e && key_eq()(*__j, __k));\n    }\n    return pair<const_iterator, const_iterator>(__i, __j);\n}\n\ntemplate <class _Tp, class _Hash, class _Equal, class _Alloc>\nvoid\n__hash_table<_Tp, _Hash, _Equal, _Alloc>::swap(__hash_table& __u)\n#if _LIBCPP_STD_VER <= 11\n    _NOEXCEPT_DEBUG_(\n        __is_nothrow_swappable<hasher>::value && __is_nothrow_swappable<key_equal>::value\n        && (!allocator_traits<__pointer_allocator>::propagate_on_container_swap::value\n              || __is_nothrow_swappable<__pointer_allocator>::value)\n        && (!__node_traits::propagate_on_container_swap::value\n              || __is_nothrow_swappable<__node_allocator>::value)\n            )\n#else\n  _NOEXCEPT_DEBUG_(__is_nothrow_swappable<hasher>::value && __is_nothrow_swappable<key_equal>::value)\n#endif\n{\n    _LIBCPP_ASSERT(__node_traits::propagate_on_container_swap::value ||\n                   this->__node_alloc() == __u.__node_alloc(),\n                   \"list::swap: Either propagate_on_container_swap must be true\"\n                   \" or the allocators must compare equal\");\n    {\n    __node_pointer_pointer __npp = __bucket_list_.release();\n    __bucket_list_.reset(__u.__bucket_list_.release());\n    __u.__bucket_list_.reset(__npp);\n    }\n    _VSTD::swap(__bucket_list_.get_deleter().size(), __u.__bucket_list_.get_deleter().size());\n    __swap_allocator(__bucket_list_.get_deleter().__alloc(),\n             __u.__bucket_list_.get_deleter().__alloc());\n    __swap_allocator(__node_alloc(), __u.__node_alloc());\n    _VSTD::swap(__p1_.first().__next_, __u.__p1_.first().__next_);\n    __p2_.swap(__u.__p2_);\n    __p3_.swap(__u.__p3_);\n    if (size() > 0)\n        __bucket_list_[__constrain_hash(__p1_.first().__next_->__hash(), bucket_count())] =\n            __p1_.first().__ptr();\n    if (__u.size() > 0)\n        __u.__bucket_list_[__constrain_hash(__u.__p1_.first().__next_->__hash(), __u.bucket_count())] =\n            __u.__p1_.first().__ptr();\n#if _LIBCPP_DEBUG_LEVEL >= 2\n    __get_db()->swap(this, &__u);\n#endif\n}\n\ntemplate <class _Tp, class _Hash, class _Equal, class _Alloc>\ntypename __hash_table<_Tp, _Hash, _Equal, _Alloc>::size_type\n__hash_table<_Tp, _Hash, _Equal, _Alloc>::bucket_size(size_type __n) const\n{\n    _LIBCPP_ASSERT(__n < bucket_count(),\n        \"unordered container::bucket_size(n) called with n >= bucket_count()\");\n    __next_pointer __np = __bucket_list_[__n];\n    size_type __bc = bucket_count();\n    size_type __r = 0;\n    if (__np != nullptr)\n    {\n        for (__np = __np->__next_; __np != nullptr &&\n                                   __constrain_hash(__np->__hash(), __bc) == __n;\n                                                    __np = __np->__next_, ++__r)\n            ;\n    }\n    return __r;\n}\n\ntemplate <class _Tp, class _Hash, class _Equal, class _Alloc>\ninline _LIBCPP_INLINE_VISIBILITY\nvoid\nswap(__hash_table<_Tp, _Hash, _Equal, _Alloc>& __x,\n     __hash_table<_Tp, _Hash, _Equal, _Alloc>& __y)\n    _NOEXCEPT_(_NOEXCEPT_(__x.swap(__y)))\n{\n    __x.swap(__y);\n}\n\n#if _LIBCPP_DEBUG_LEVEL >= 2\n\ntemplate <class _Tp, class _Hash, class _Equal, class _Alloc>\nbool\n__hash_table<_Tp, _Hash, _Equal, _Alloc>::__dereferenceable(const const_iterator* __i) const\n{\n    return __i->__node_ != nullptr;\n}\n\ntemplate <class _Tp, class _Hash, class _Equal, class _Alloc>\nbool\n__hash_table<_Tp, _Hash, _Equal, _Alloc>::__decrementable(const const_iterator*) const\n{\n    return false;\n}\n\ntemplate <class _Tp, class _Hash, class _Equal, class _Alloc>\nbool\n__hash_table<_Tp, _Hash, _Equal, _Alloc>::__addable(const const_iterator*, ptrdiff_t) const\n{\n    return false;\n}\n\ntemplate <class _Tp, class _Hash, class _Equal, class _Alloc>\nbool\n__hash_table<_Tp, _Hash, _Equal, _Alloc>::__subscriptable(const const_iterator*, ptrdiff_t) const\n{\n    return false;\n}\n\n#endif  // _LIBCPP_DEBUG_LEVEL >= 2\n_LIBCPP_END_NAMESPACE_STD\n\n#endif  // _LIBCPP__HASH_TABLE\n","// -*- C++ -*-\n//===------------------------------ variant -------------------------------===//\n//\n//                     The LLVM Compiler Infrastructure\n//\n// This file is dual licensed under the MIT and the University of Illinois Open\n// Source Licenses. See LICENSE.TXT for details.\n//\n//===----------------------------------------------------------------------===//\n\n#ifndef _LIBCPP_VARIANT\n#define _LIBCPP_VARIANT\n\n/*\n   variant synopsis\n\nnamespace std {\n\n  // 20.7.2, class template variant\n  template <class... Types>\n  class variant {\n  public:\n\n    // 20.7.2.1, constructors\n    constexpr variant() noexcept(see below);\n    variant(const variant&);\n    variant(variant&&) noexcept(see below);\n\n    template <class T> constexpr variant(T&&) noexcept(see below);\n\n    template <class T, class... Args>\n    constexpr explicit variant(in_place_type_t<T>, Args&&...);\n\n    template <class T, class U, class... Args>\n    constexpr explicit variant(\n        in_place_type_t<T>, initializer_list<U>, Args&&...);\n\n    template <size_t I, class... Args>\n    constexpr explicit variant(in_place_index_t<I>, Args&&...);\n\n    template <size_t I, class U, class... Args>\n    constexpr explicit variant(\n        in_place_index_t<I>, initializer_list<U>, Args&&...);\n\n    // 20.7.2.2, destructor\n    ~variant();\n\n    // 20.7.2.3, assignment\n    variant& operator=(const variant&);\n    variant& operator=(variant&&) noexcept(see below);\n\n    template <class T> variant& operator=(T&&) noexcept(see below);\n\n    // 20.7.2.4, modifiers\n    template <class T, class... Args>\n    void emplace(Args&&...);\n\n    template <class T, class U, class... Args>\n    void emplace(initializer_list<U>, Args&&...);\n\n    template <size_t I, class... Args>\n    void emplace(Args&&...);\n\n    template <size_t I, class U, class...  Args>\n    void emplace(initializer_list<U>, Args&&...);\n\n    // 20.7.2.5, value status\n    constexpr bool valueless_by_exception() const noexcept;\n    constexpr size_t index() const noexcept;\n\n    // 20.7.2.6, swap\n    void swap(variant&) noexcept(see below);\n  };\n\n  // 20.7.3, variant helper classes\n  template <class T> struct variant_size; // undefined\n\n  template <class T>\n  constexpr size_t variant_size_v = variant_size<T>::value;\n\n  template <class T> struct variant_size<const T>;\n  template <class T> struct variant_size<volatile T>;\n  template <class T> struct variant_size<const volatile T>;\n\n  template <class... Types>\n  struct variant_size<variant<Types...>>;\n\n  template <size_t I, class T> struct variant_alternative; // undefined\n\n  template <size_t I, class T>\n  using variant_alternative_t = typename variant_alternative<I, T>::type;\n\n  template <size_t I, class T> struct variant_alternative<I, const T>;\n  template <size_t I, class T> struct variant_alternative<I, volatile T>;\n  template <size_t I, class T> struct variant_alternative<I, const volatile T>;\n\n  template <size_t I, class... Types>\n  struct variant_alternative<I, variant<Types...>>;\n\n  constexpr size_t variant_npos = -1;\n\n  // 20.7.4, value access\n  template <class T, class... Types>\n  constexpr bool holds_alternative(const variant<Types...>&) noexcept;\n\n  template <size_t I, class... Types>\n  constexpr variant_alternative_t<I, variant<Types...>>&\n  get(variant<Types...>&);\n\n  template <size_t I, class... Types>\n  constexpr variant_alternative_t<I, variant<Types...>>&&\n  get(variant<Types...>&&);\n\n  template <size_t I, class... Types>\n  constexpr variant_alternative_t<I, variant<Types...>> const&\n  get(const variant<Types...>&);\n\n  template <size_t I, class... Types>\n  constexpr variant_alternative_t<I, variant<Types...>> const&&\n  get(const variant<Types...>&&);\n\n  template <class T, class...  Types>\n  constexpr T& get(variant<Types...>&);\n\n  template <class T, class... Types>\n  constexpr T&& get(variant<Types...>&&);\n\n  template <class T, class... Types>\n  constexpr const T& get(const variant<Types...>&);\n\n  template <class T, class... Types>\n  constexpr const T&& get(const variant<Types...>&&);\n\n  template <size_t I, class... Types>\n  constexpr add_pointer_t<variant_alternative_t<I, variant<Types...>>>\n  get_if(variant<Types...>*) noexcept;\n\n  template <size_t I, class... Types>\n  constexpr add_pointer_t<const variant_alternative_t<I, variant<Types...>>>\n  get_if(const variant<Types...>*) noexcept;\n\n  template <class T, class... Types>\n  constexpr add_pointer_t<T>\n  get_if(variant<Types...>*) noexcept;\n\n  template <class T, class... Types>\n  constexpr add_pointer_t<const T>\n  get_if(const variant<Types...>*) noexcept;\n\n  // 20.7.5, relational operators\n  template <class... Types>\n  constexpr bool operator==(const variant<Types...>&, const variant<Types...>&);\n\n  template <class... Types>\n  constexpr bool operator!=(const variant<Types...>&, const variant<Types...>&);\n\n  template <class... Types>\n  constexpr bool operator<(const variant<Types...>&, const variant<Types...>&);\n\n  template <class... Types>\n  constexpr bool operator>(const variant<Types...>&, const variant<Types...>&);\n\n  template <class... Types>\n  constexpr bool operator<=(const variant<Types...>&, const variant<Types...>&);\n\n  template <class... Types>\n  constexpr bool operator>=(const variant<Types...>&, const variant<Types...>&);\n\n  // 20.7.6, visitation\n  template <class Visitor, class... Variants>\n  constexpr see below visit(Visitor&&, Variants&&...);\n\n  // 20.7.7, class monostate\n  struct monostate;\n\n  // 20.7.8, monostate relational operators\n  constexpr bool operator<(monostate, monostate) noexcept;\n  constexpr bool operator>(monostate, monostate) noexcept;\n  constexpr bool operator<=(monostate, monostate) noexcept;\n  constexpr bool operator>=(monostate, monostate) noexcept;\n  constexpr bool operator==(monostate, monostate) noexcept;\n  constexpr bool operator!=(monostate, monostate) noexcept;\n\n  // 20.7.9, specialized algorithms\n  template <class... Types>\n  void swap(variant<Types...>&, variant<Types...>&) noexcept(see below);\n\n  // 20.7.10, class bad_variant_access\n  class bad_variant_access;\n\n  // 20.7.11, hash support\n  template <class T> struct hash;\n  template <class... Types> struct hash<variant<Types...>>;\n  template <> struct hash<monostate>;\n\n} // namespace std\n\n*/\n\n#include <__config>\n#include <__tuple>\n#include <array>\n#include <exception>\n#include <functional>\n#include <initializer_list>\n#include <new>\n#include <tuple>\n#include <type_traits>\n#include <utility>\n\n#if !defined(_LIBCPP_HAS_NO_PRAGMA_SYSTEM_HEADER)\n#pragma GCC system_header\n#endif\n\nnamespace std { // explicitly not using versioning namespace\n\nclass _LIBCPP_EXCEPTION_ABI bad_variant_access : public exception {\npublic:\n  virtual const char* what() const _NOEXCEPT;\n};\n\n} // namespace std\n\n_LIBCPP_BEGIN_NAMESPACE_STD\n\n#if _LIBCPP_STD_VER > 14\n\n_LIBCPP_NORETURN\ninline _LIBCPP_INLINE_VISIBILITY\nvoid __throw_bad_variant_access() {\n#ifndef _LIBCPP_NO_EXCEPTIONS\n        throw bad_variant_access();\n#else\n        _VSTD::abort();\n#endif\n}\n\ntemplate <class... _Types>\nclass _LIBCPP_TEMPLATE_VIS variant;\n\ntemplate <class _Tp>\nstruct _LIBCPP_TEMPLATE_VIS variant_size;\n\ntemplate <class _Tp>\nconstexpr size_t variant_size_v = variant_size<_Tp>::value;\n\ntemplate <class _Tp>\nstruct _LIBCPP_TEMPLATE_VIS variant_size<const _Tp> : variant_size<_Tp> {};\n\ntemplate <class _Tp>\nstruct _LIBCPP_TEMPLATE_VIS variant_size<volatile _Tp> : variant_size<_Tp> {};\n\ntemplate <class _Tp>\nstruct _LIBCPP_TEMPLATE_VIS variant_size<const volatile _Tp>\n    : variant_size<_Tp> {};\n\ntemplate <class... _Types>\nstruct _LIBCPP_TEMPLATE_VIS variant_size<variant<_Types...>>\n    : integral_constant<size_t, sizeof...(_Types)> {};\n\ntemplate <size_t _Ip, class _Tp>\nstruct _LIBCPP_TEMPLATE_VIS variant_alternative;\n\ntemplate <size_t _Ip, class _Tp>\nusing variant_alternative_t = typename variant_alternative<_Ip, _Tp>::type;\n\ntemplate <size_t _Ip, class _Tp>\nstruct _LIBCPP_TEMPLATE_VIS variant_alternative<_Ip, const _Tp>\n    : add_const<variant_alternative_t<_Ip, _Tp>> {};\n\ntemplate <size_t _Ip, class _Tp>\nstruct _LIBCPP_TEMPLATE_VIS variant_alternative<_Ip, volatile _Tp>\n    : add_volatile<variant_alternative_t<_Ip, _Tp>> {};\n\ntemplate <size_t _Ip, class _Tp>\nstruct _LIBCPP_TEMPLATE_VIS variant_alternative<_Ip, const volatile _Tp>\n    : add_cv<variant_alternative_t<_Ip, _Tp>> {};\n\ntemplate <size_t _Ip, class... _Types>\nstruct _LIBCPP_TEMPLATE_VIS variant_alternative<_Ip, variant<_Types...>> {\n  static_assert(_Ip < sizeof...(_Types));\n  using type = __type_pack_element<_Ip, _Types...>;\n};\n\nconstexpr size_t variant_npos = static_cast<size_t>(-1);\nconstexpr unsigned int __variant_npos = static_cast<unsigned int>(-1);\n\nnamespace __find_detail {\n\ntemplate <class _Tp, class... _Types>\ninline _LIBCPP_INLINE_VISIBILITY\nconstexpr size_t __find_index() {\n  constexpr bool __matches[] = {is_same_v<_Tp, _Types>...};\n  size_t __result = __not_found;\n  for (size_t __i = 0; __i < sizeof...(_Types); ++__i) {\n    if (__matches[__i]) {\n      if (__result != __not_found) {\n        return __ambiguous;\n      }\n      __result = __i;\n    }\n  }\n  return __result;\n}\n\ntemplate <size_t _Index>\nstruct __find_unambiguous_index_sfinae_impl\n    : integral_constant<size_t, _Index> {};\n\ntemplate <>\nstruct __find_unambiguous_index_sfinae_impl<__not_found> {};\n\ntemplate <>\nstruct __find_unambiguous_index_sfinae_impl<__ambiguous> {};\n\ntemplate <class _Tp, class... _Types>\nstruct __find_unambiguous_index_sfinae\n    : __find_unambiguous_index_sfinae_impl<__find_index<_Tp, _Types...>()> {};\n\n} // namespace __find_detail\n\nnamespace __variant_detail {\n\nstruct __valueless_t {};\n\nenum class _Trait { _TriviallyAvailable, _Available, _Unavailable };\n\ntemplate <typename _Tp,\n          template <typename> class _IsTriviallyAvailable,\n          template <typename> class _IsAvailable>\nconstexpr _Trait __trait =\n    _IsTriviallyAvailable<_Tp>::value\n        ? _Trait::_TriviallyAvailable\n        : _IsAvailable<_Tp>::value ? _Trait::_Available : _Trait::_Unavailable;\n\ninline _LIBCPP_INLINE_VISIBILITY\nconstexpr _Trait __common_trait(initializer_list<_Trait> __traits) {\n  _Trait __result = _Trait::_TriviallyAvailable;\n  for (_Trait __t : __traits) {\n    if (static_cast<int>(__t) > static_cast<int>(__result)) {\n      __result = __t;\n    }\n  }\n  return __result;\n}\n\ntemplate <typename... _Types>\nstruct __traits {\n  static constexpr _Trait __copy_constructible_trait =\n      __common_trait({__trait<_Types,\n                              is_trivially_copy_constructible,\n                              is_copy_constructible>...});\n\n  static constexpr _Trait __move_constructible_trait =\n      __common_trait({__trait<_Types,\n                              is_trivially_move_constructible,\n                              is_move_constructible>...});\n\n  static constexpr _Trait __copy_assignable_trait = __common_trait(\n      {__copy_constructible_trait,\n       __move_constructible_trait,\n       __trait<_Types, is_trivially_copy_assignable, is_copy_assignable>...});\n\n  static constexpr _Trait __move_assignable_trait = __common_trait(\n      {__move_constructible_trait,\n       __trait<_Types, is_trivially_move_assignable, is_move_assignable>...});\n\n  static constexpr _Trait __destructible_trait = __common_trait(\n      {__trait<_Types, is_trivially_destructible, is_destructible>...});\n};\n\nnamespace __access {\n\nstruct __union {\n  template <class _Vp>\n  inline _LIBCPP_INLINE_VISIBILITY\n  static constexpr auto&& __get_alt(_Vp&& __v, in_place_index_t<0>) {\n    return _VSTD::forward<_Vp>(__v).__head;\n  }\n\n  template <class _Vp, size_t _Ip>\n  inline _LIBCPP_INLINE_VISIBILITY\n  static constexpr auto&& __get_alt(_Vp&& __v, in_place_index_t<_Ip>) {\n    return __get_alt(_VSTD::forward<_Vp>(__v).__tail, in_place_index<_Ip - 1>);\n  }\n};\n\nstruct __base {\n  template <size_t _Ip, class _Vp>\n  inline _LIBCPP_INLINE_VISIBILITY\n  static constexpr auto&& __get_alt(_Vp&& __v) {\n    return __union::__get_alt(_VSTD::forward<_Vp>(__v).__data,\n                              in_place_index<_Ip>);\n  }\n};\n\nstruct __variant {\n  template <size_t _Ip, class _Vp>\n  inline _LIBCPP_INLINE_VISIBILITY\n  static constexpr auto&& __get_alt(_Vp&& __v) {\n    return __base::__get_alt<_Ip>(_VSTD::forward<_Vp>(__v).__impl);\n  }\n};\n\n} // namespace __access\n\nnamespace __visitation {\n\nstruct __base {\n  template <class _Visitor, class... _Vs>\n  inline _LIBCPP_INLINE_VISIBILITY\n  static constexpr decltype(auto)\n  __visit_alt_at(size_t __index, _Visitor&& __visitor, _Vs&&... __vs) {\n    constexpr auto __fdiagonal =\n        __make_fdiagonal<_Visitor&&,\n                         decltype(_VSTD::forward<_Vs>(__vs).__as_base())...>();\n    return __fdiagonal[__index](_VSTD::forward<_Visitor>(__visitor),\n                                _VSTD::forward<_Vs>(__vs).__as_base()...);\n  }\n\n  template <class _Visitor, class... _Vs>\n  inline _LIBCPP_INLINE_VISIBILITY\n  static constexpr decltype(auto) __visit_alt(_Visitor&& __visitor,\n                                              _Vs&&... __vs) {\n    constexpr auto __fmatrix =\n        __make_fmatrix<_Visitor&&,\n                       decltype(_VSTD::forward<_Vs>(__vs).__as_base())...>();\n    const size_t __indices[] = {__vs.index()...};\n    return __at(__fmatrix, __indices)(_VSTD::forward<_Visitor>(__visitor),\n                                      _VSTD::forward<_Vs>(__vs).__as_base()...);\n  }\n\nprivate:\n  template <class _Tp>\n  inline _LIBCPP_INLINE_VISIBILITY\n  static constexpr const _Tp& __at_impl(const _Tp& __elem, const size_t*) {\n    return __elem;\n  }\n\n  template <class _Tp, size_t _Np>\n  inline _LIBCPP_INLINE_VISIBILITY\n  static constexpr auto&& __at_impl(const array<_Tp, _Np>& __elems,\n                                    const size_t* __index) {\n    return __at_impl(__elems[*__index], __index + 1);\n  }\n\n  template <class _Tp, size_t _Np, size_t _Ip>\n  inline _LIBCPP_INLINE_VISIBILITY\n  static constexpr auto&& __at(const array<_Tp, _Np>& __elems,\n                               const size_t (&__indices)[_Ip]) {\n    return __at_impl(__elems, begin(__indices));\n  }\n\n  template <class _Fp, class... _Fs>\n  static constexpr void __std_visit_visitor_return_type_check() {\n    static_assert(\n        __all<is_same_v<_Fp, _Fs>...>::value,\n        \"`std::visit` requires the visitor to have a single return type.\");\n  }\n\n  template <class... _Fs>\n  inline _LIBCPP_INLINE_VISIBILITY\n  static constexpr auto __make_farray(_Fs&&... __fs) {\n    __std_visit_visitor_return_type_check<decay_t<_Fs>...>();\n    using __result = array<common_type_t<decay_t<_Fs>...>, sizeof...(_Fs)>;\n    return __result{{_VSTD::forward<_Fs>(__fs)...}};\n  }\n\n  template <class _Fp, class... _Vs, size_t... _Is>\n  inline _LIBCPP_INLINE_VISIBILITY\n  static constexpr auto __make_dispatch(index_sequence<_Is...>) {\n    struct __dispatcher {\n      static constexpr decltype(auto) __dispatch(_Fp __f, _Vs... __vs) {\n        return __invoke_constexpr(\n            static_cast<_Fp>(__f),\n            __access::__base::__get_alt<_Is>(static_cast<_Vs>(__vs))...);\n      }\n    };\n    return _VSTD::addressof(__dispatcher::__dispatch);\n  }\n\n  template <size_t _Ip, class _Fp, class... _Vs>\n  inline _LIBCPP_INLINE_VISIBILITY\n  static constexpr auto __make_fdiagonal_impl() {\n    return __make_dispatch<_Fp, _Vs...>(\n        index_sequence<(__identity<_Vs>{}, _Ip)...>{});\n  }\n\n  template <class _Fp, class... _Vs, size_t... _Is>\n  inline _LIBCPP_INLINE_VISIBILITY\n  static constexpr auto __make_fdiagonal_impl(index_sequence<_Is...>) {\n    return __base::__make_farray(__make_fdiagonal_impl<_Is, _Fp, _Vs...>()...);\n  }\n\n  template <class _Fp, class _Vp, class... _Vs>\n  inline _LIBCPP_INLINE_VISIBILITY\n  static constexpr auto __make_fdiagonal() {\n    constexpr size_t _Np = decay_t<_Vp>::__size();\n    static_assert(__all<(_Np == decay_t<_Vs>::__size())...>::value);\n    return __make_fdiagonal_impl<_Fp, _Vp, _Vs...>(make_index_sequence<_Np>{});\n  }\n\n  template <class _Fp, class... _Vs, size_t... _Is>\n  inline _LIBCPP_INLINE_VISIBILITY\n  static constexpr auto __make_fmatrix_impl(index_sequence<_Is...> __is) {\n    return __make_dispatch<_Fp, _Vs...>(__is);\n  }\n\n  template <class _Fp, class... _Vs, size_t... _Is, size_t... _Js, class... _Ls>\n  inline _LIBCPP_INLINE_VISIBILITY\n  static constexpr auto __make_fmatrix_impl(index_sequence<_Is...>,\n                                            index_sequence<_Js...>,\n                                            _Ls... __ls) {\n    return __base::__make_farray(__make_fmatrix_impl<_Fp, _Vs...>(\n        index_sequence<_Is..., _Js>{}, __ls...)...);\n  }\n\n  template <class _Fp, class... _Vs>\n  inline _LIBCPP_INLINE_VISIBILITY\n  static constexpr auto __make_fmatrix() {\n    return __make_fmatrix_impl<_Fp, _Vs...>(\n        index_sequence<>{}, make_index_sequence<decay_t<_Vs>::__size()>{}...);\n  }\n};\n\nstruct __variant {\n  template <class _Visitor, class... _Vs>\n  inline _LIBCPP_INLINE_VISIBILITY\n  static constexpr decltype(auto)\n  __visit_alt_at(size_t __index, _Visitor&& __visitor, _Vs&&... __vs) {\n    return __base::__visit_alt_at(__index,\n                                  _VSTD::forward<_Visitor>(__visitor),\n                                  _VSTD::forward<_Vs>(__vs).__impl...);\n  }\n\n  template <class _Visitor, class... _Vs>\n  inline _LIBCPP_INLINE_VISIBILITY\n  static constexpr decltype(auto) __visit_alt(_Visitor&& __visitor,\n                                              _Vs&&... __vs) {\n    return __base::__visit_alt(_VSTD::forward<_Visitor>(__visitor),\n                               _VSTD::forward<_Vs>(__vs).__impl...);\n  }\n\n  template <class _Visitor, class... _Vs>\n  inline _LIBCPP_INLINE_VISIBILITY\n  static constexpr decltype(auto)\n  __visit_value_at(size_t __index, _Visitor&& __visitor, _Vs&&... __vs) {\n    return __visit_alt_at(\n        __index,\n        __make_value_visitor(_VSTD::forward<_Visitor>(__visitor)),\n        _VSTD::forward<_Vs>(__vs)...);\n  }\n\n  template <class _Visitor, class... _Vs>\n  inline _LIBCPP_INLINE_VISIBILITY\n  static constexpr decltype(auto) __visit_value(_Visitor&& __visitor,\n                                                _Vs&&... __vs) {\n    return __visit_alt(\n        __make_value_visitor(_VSTD::forward<_Visitor>(__visitor)),\n        _VSTD::forward<_Vs>(__vs)...);\n  }\n\nprivate:\n  template <class _Visitor, class... _Values>\n  static constexpr void __std_visit_exhaustive_visitor_check() {\n    static_assert(is_callable_v<_Visitor(_Values...)>,\n                  \"`std::visit` requires the visitor to be exhaustive.\");\n  }\n\n  template <class _Visitor>\n  struct __value_visitor {\n    template <class... _Alts>\n    inline _LIBCPP_INLINE_VISIBILITY\n    constexpr decltype(auto) operator()(_Alts&&... __alts) const {\n      __std_visit_exhaustive_visitor_check<\n          _Visitor,\n          decltype((_VSTD::forward<_Alts>(__alts).__value))...>();\n      return __invoke_constexpr(_VSTD::forward<_Visitor>(__visitor),\n                                _VSTD::forward<_Alts>(__alts).__value...);\n    }\n    _Visitor&& __visitor;\n  };\n\n  template <class _Visitor>\n  inline _LIBCPP_INLINE_VISIBILITY\n  static constexpr auto __make_value_visitor(_Visitor&& __visitor) {\n    return __value_visitor<_Visitor>{_VSTD::forward<_Visitor>(__visitor)};\n  }\n};\n\n} // namespace __visitation\n\ntemplate <size_t _Index, class _Tp>\nstruct _LIBCPP_TEMPLATE_VIS __alt {\n  using __value_type = _Tp;\n\n  template <class... _Args>\n  inline _LIBCPP_INLINE_VISIBILITY\n  explicit constexpr __alt(in_place_t, _Args&&... __args)\n      : __value(_VSTD::forward<_Args>(__args)...) {}\n\n  __value_type __value;\n};\n\ntemplate <_Trait _DestructibleTrait, size_t _Index, class... _Types>\nunion _LIBCPP_TEMPLATE_VIS __union;\n\ntemplate <_Trait _DestructibleTrait, size_t _Index>\nunion _LIBCPP_TEMPLATE_VIS __union<_DestructibleTrait, _Index> {};\n\n#define _LIBCPP_VARIANT_UNION(destructible_trait, destructor)                  \\\n  template <size_t _Index, class _Tp, class... _Types>                         \\\n  union _LIBCPP_TEMPLATE_VIS __union<destructible_trait,                      \\\n                                      _Index,                                  \\\n                                      _Tp,                                     \\\n                                      _Types...> {                             \\\n  public:                                                                      \\\n    inline _LIBCPP_INLINE_VISIBILITY                                           \\\n    explicit constexpr __union(__valueless_t) noexcept : __dummy{} {}          \\\n                                                                               \\\n    template <class... _Args>                                                  \\\n    inline _LIBCPP_INLINE_VISIBILITY                                           \\\n    explicit constexpr __union(in_place_index_t<0>, _Args&&... __args)         \\\n        : __head(in_place, _VSTD::forward<_Args>(__args)...) {}                \\\n                                                                               \\\n    template <size_t _Ip, class... _Args>                                      \\\n    inline _LIBCPP_INLINE_VISIBILITY                                           \\\n    explicit constexpr __union(in_place_index_t<_Ip>, _Args&&... __args)       \\\n        : __tail(in_place_index<_Ip - 1>, _VSTD::forward<_Args>(__args)...) {} \\\n                                                                               \\\n    __union(const __union&) = default;                                         \\\n    __union(__union&&) = default;                                              \\\n                                                                               \\\n    destructor                                                                 \\\n                                                                               \\\n    __union& operator=(const __union&) = default;                              \\\n    __union& operator=(__union&&) = default;                                   \\\n                                                                               \\\n  private:                                                                     \\\n    char __dummy;                                                              \\\n    __alt<_Index, _Tp> __head;                                                 \\\n    __union<destructible_trait, _Index + 1, _Types...> __tail;                 \\\n                                                                               \\\n    friend struct __access::__union;                                           \\\n  }\n\n_LIBCPP_VARIANT_UNION(_Trait::_TriviallyAvailable, ~__union() = default;);\n_LIBCPP_VARIANT_UNION(_Trait::_Available, ~__union() {});\n_LIBCPP_VARIANT_UNION(_Trait::_Unavailable, ~__union() = delete;);\n\n#undef _LIBCPP_VARIANT_UNION\n\ntemplate <_Trait _DestructibleTrait, class... _Types>\nclass _LIBCPP_TEMPLATE_VIS __base {\npublic:\n  inline _LIBCPP_INLINE_VISIBILITY\n  explicit constexpr __base(__valueless_t tag) noexcept\n      : __data(tag), __index(__variant_npos) {}\n\n  template <size_t _Ip, class... _Args>\n  inline _LIBCPP_INLINE_VISIBILITY\n  explicit constexpr __base(in_place_index_t<_Ip>, _Args&&... __args)\n      :\n        __data(in_place_index<_Ip>, _VSTD::forward<_Args>(__args)...),\n        __index(_Ip) {}\n\n  inline _LIBCPP_INLINE_VISIBILITY\n  constexpr bool valueless_by_exception() const noexcept {\n    return index() == variant_npos;\n  }\n\n  inline _LIBCPP_INLINE_VISIBILITY\n  constexpr size_t index() const noexcept {\n    return __index == __variant_npos ? variant_npos : __index;\n  }\n\nprotected:\n  inline _LIBCPP_INLINE_VISIBILITY\n  constexpr auto&& __as_base() & { return *this; }\n\n  inline _LIBCPP_INLINE_VISIBILITY\n  constexpr auto&& __as_base() && { return _VSTD::move(*this); }\n\n  inline _LIBCPP_INLINE_VISIBILITY\n  constexpr auto&& __as_base() const & { return *this; }\n\n  inline _LIBCPP_INLINE_VISIBILITY\n  constexpr auto&& __as_base() const && { return _VSTD::move(*this); }\n\n  inline _LIBCPP_INLINE_VISIBILITY\n  static constexpr size_t __size() { return sizeof...(_Types); }\n\n  __union<_DestructibleTrait, 0, _Types...> __data;\n  unsigned int __index;\n\n  friend struct __access::__base;\n  friend struct __visitation::__base;\n};\n\ntemplate <class _Traits, _Trait = _Traits::__destructible_trait>\nclass _LIBCPP_TEMPLATE_VIS __destructor;\n\n#define _LIBCPP_VARIANT_DESTRUCTOR(destructible_trait, destructor, destroy)    \\\n  template <class... _Types>                                                   \\\n  class _LIBCPP_TEMPLATE_VIS __destructor<__traits<_Types...>,                \\\n                                           destructible_trait>                 \\\n      : public __base<destructible_trait, _Types...> {                         \\\n    using __base_type = __base<destructible_trait, _Types...>;                 \\\n                                                                               \\\n  public:                                                                      \\\n    using __base_type::__base_type;                                            \\\n    using __base_type::operator=;                                              \\\n                                                                               \\\n    __destructor(const __destructor&) = default;                               \\\n    __destructor(__destructor&&) = default;                                    \\\n    destructor                                                                 \\\n    __destructor& operator=(const __destructor&) = default;                    \\\n    __destructor& operator=(__destructor&&) = default;                         \\\n                                                                               \\\n  protected:                                                                   \\\n    inline _LIBCPP_INLINE_VISIBILITY                                           \\\n    destroy                                                                    \\\n  }\n\n_LIBCPP_VARIANT_DESTRUCTOR(\n    _Trait::_TriviallyAvailable,\n    ~__destructor() = default;,\n    void __destroy() noexcept { this->__index = __variant_npos; });\n\n_LIBCPP_VARIANT_DESTRUCTOR(\n    _Trait::_Available,\n    ~__destructor() { __destroy(); },\n    void __destroy() noexcept {\n      if (!this->valueless_by_exception()) {\n        __visitation::__base::__visit_alt(\n            [](auto& __alt) noexcept {\n              using __alt_type = decay_t<decltype(__alt)>;\n              __alt.~__alt_type();\n            },\n            *this);\n      }\n      this->__index = __variant_npos;\n    });\n\n_LIBCPP_VARIANT_DESTRUCTOR(\n    _Trait::_Unavailable,\n    ~__destructor() = delete;,\n    void __destroy() noexcept = delete;);\n\n#undef _LIBCPP_VARIANT_DESTRUCTOR\n\ntemplate <class _Traits>\nclass _LIBCPP_TEMPLATE_VIS __constructor : public __destructor<_Traits> {\n  using __base_type = __destructor<_Traits>;\n\npublic:\n  using __base_type::__base_type;\n  using __base_type::operator=;\n\nprotected:\n  template <size_t _Ip, class _Tp, class... _Args>\n  inline _LIBCPP_INLINE_VISIBILITY\n  static void __construct_alt(__alt<_Ip, _Tp>& __a, _Args&&... __args) {\n    ::new (_VSTD::addressof(__a))\n        __alt<_Ip, _Tp>(in_place, _VSTD::forward<_Args>(__args)...);\n  }\n\n  template <class _Rhs>\n  inline _LIBCPP_INLINE_VISIBILITY\n  static void __generic_construct(__constructor& __lhs, _Rhs&& __rhs) {\n    __lhs.__destroy();\n    if (!__rhs.valueless_by_exception()) {\n      __visitation::__base::__visit_alt_at(\n          __rhs.index(),\n          [](auto& __lhs_alt, auto&& __rhs_alt) {\n            __construct_alt(\n                __lhs_alt,\n                _VSTD::forward<decltype(__rhs_alt)>(__rhs_alt).__value);\n          },\n          __lhs, _VSTD::forward<_Rhs>(__rhs));\n      __lhs.__index = __rhs.index();\n    }\n  }\n};\n\ntemplate <class _Traits, _Trait = _Traits::__move_constructible_trait>\nclass _LIBCPP_TEMPLATE_VIS __move_constructor;\n\n#define _LIBCPP_VARIANT_MOVE_CONSTRUCTOR(move_constructible_trait,             \\\n                                         move_constructor)                     \\\n  template <class... _Types>                                                   \\\n  class _LIBCPP_TEMPLATE_VIS __move_constructor<__traits<_Types...>,          \\\n                                                 move_constructible_trait>     \\\n      : public __constructor<__traits<_Types...>> {                            \\\n    using __base_type = __constructor<__traits<_Types...>>;                    \\\n                                                                               \\\n  public:                                                                      \\\n    using __base_type::__base_type;                                            \\\n    using __base_type::operator=;                                              \\\n                                                                               \\\n    __move_constructor(const __move_constructor&) = default;                   \\\n    move_constructor                                                           \\\n    ~__move_constructor() = default;                                           \\\n    __move_constructor& operator=(const __move_constructor&) = default;        \\\n    __move_constructor& operator=(__move_constructor&&) = default;             \\\n  }\n\n_LIBCPP_VARIANT_MOVE_CONSTRUCTOR(\n    _Trait::_TriviallyAvailable,\n    __move_constructor(__move_constructor&& __that) = default;);\n\n_LIBCPP_VARIANT_MOVE_CONSTRUCTOR(\n    _Trait::_Available,\n    __move_constructor(__move_constructor&& __that) noexcept(\n        __all<is_nothrow_move_constructible_v<_Types>...>::value)\n        : __move_constructor(__valueless_t{}) {\n      this->__generic_construct(*this, _VSTD::move(__that));\n    });\n\n_LIBCPP_VARIANT_MOVE_CONSTRUCTOR(\n    _Trait::_Unavailable,\n    __move_constructor(__move_constructor&&) = delete;);\n\n#undef _LIBCPP_VARIANT_MOVE_CONSTRUCTOR\n\ntemplate <class _Traits, _Trait = _Traits::__copy_constructible_trait>\nclass _LIBCPP_TEMPLATE_VIS __copy_constructor;\n\n#define _LIBCPP_VARIANT_COPY_CONSTRUCTOR(copy_constructible_trait,             \\\n                                         copy_constructor)                     \\\n  template <class... _Types>                                                   \\\n  class _LIBCPP_TEMPLATE_VIS __copy_constructor<__traits<_Types...>,          \\\n                                                 copy_constructible_trait>     \\\n      : public __move_constructor<__traits<_Types...>> {                       \\\n    using __base_type = __move_constructor<__traits<_Types...>>;               \\\n                                                                               \\\n  public:                                                                      \\\n    using __base_type::__base_type;                                            \\\n    using __base_type::operator=;                                              \\\n                                                                               \\\n    copy_constructor                                                           \\\n    __copy_constructor(__copy_constructor&&) = default;                        \\\n    ~__copy_constructor() = default;                                           \\\n    __copy_constructor& operator=(const __copy_constructor&) = default;        \\\n    __copy_constructor& operator=(__copy_constructor&&) = default;             \\\n  }\n\n_LIBCPP_VARIANT_COPY_CONSTRUCTOR(\n    _Trait::_TriviallyAvailable,\n    __copy_constructor(const __copy_constructor& __that) = default;);\n\n_LIBCPP_VARIANT_COPY_CONSTRUCTOR(\n    _Trait::_Available,\n    __copy_constructor(const __copy_constructor& __that)\n        : __copy_constructor(__valueless_t{}) {\n      this->__generic_construct(*this, __that);\n    });\n\n_LIBCPP_VARIANT_COPY_CONSTRUCTOR(\n    _Trait::_Unavailable,\n    __copy_constructor(const __copy_constructor&) = delete;);\n\n#undef _LIBCPP_VARIANT_COPY_CONSTRUCTOR\n\ntemplate <class _Traits>\nclass _LIBCPP_TEMPLATE_VIS __assignment : public __copy_constructor<_Traits> {\n  using __base_type = __copy_constructor<_Traits>;\n\npublic:\n  using __base_type::__base_type;\n  using __base_type::operator=;\n\n  template <size_t _Ip, class... _Args>\n  inline _LIBCPP_INLINE_VISIBILITY\n  void __emplace(_Args&&... __args) {\n    this->__destroy();\n    this->__construct_alt(__access::__base::__get_alt<_Ip>(*this),\n                          _VSTD::forward<_Args>(__args)...);\n    this->__index = _Ip;\n  }\n\nprotected:\n  template <bool _CopyAssign, size_t _Ip, class _Tp, class _Arg>\n  inline _LIBCPP_INLINE_VISIBILITY\n  void __assign_alt(__alt<_Ip, _Tp>& __a,\n                    _Arg&& __arg,\n                    bool_constant<_CopyAssign> __tag) {\n    if (this->index() == _Ip) {\n      __a.__value = _VSTD::forward<_Arg>(__arg);\n    } else {\n      struct {\n        void operator()(true_type) const {\n          __this->__emplace<_Ip>(_Tp(_VSTD::forward<_Arg>(__arg)));\n        }\n        void operator()(false_type) const {\n          __this->__emplace<_Ip>(_VSTD::forward<_Arg>(__arg));\n        }\n        __assignment* __this;\n        _Arg&& __arg;\n      } __impl{this, _VSTD::forward<_Arg>(__arg)};\n      __impl(__tag);\n    }\n  }\n\n  template <class _That>\n  inline _LIBCPP_INLINE_VISIBILITY\n  void __generic_assign(_That&& __that) {\n    if (this->valueless_by_exception() && __that.valueless_by_exception()) {\n      // do nothing.\n    } else if (__that.valueless_by_exception()) {\n      this->__destroy();\n    } else {\n      __visitation::__base::__visit_alt_at(\n          __that.index(),\n          [this](auto& __this_alt, auto&& __that_alt) {\n            this->__assign_alt(\n                __this_alt,\n                _VSTD::forward<decltype(__that_alt)>(__that_alt).__value,\n                is_lvalue_reference<_That>{});\n          },\n          *this, _VSTD::forward<_That>(__that));\n    }\n  }\n};\n\ntemplate <class _Traits, _Trait = _Traits::__move_assignable_trait>\nclass _LIBCPP_TEMPLATE_VIS __move_assignment;\n\n#define _LIBCPP_VARIANT_MOVE_ASSIGNMENT(move_assignable_trait,                 \\\n                                        move_assignment)                       \\\n  template <class... _Types>                                                   \\\n  class _LIBCPP_TEMPLATE_VIS __move_assignment<__traits<_Types...>,           \\\n                                                move_assignable_trait>         \\\n      : public __assignment<__traits<_Types...>> {                             \\\n    using __base_type = __assignment<__traits<_Types...>>;                     \\\n                                                                               \\\n  public:                                                                      \\\n    using __base_type::__base_type;                                            \\\n    using __base_type::operator=;                                              \\\n                                                                               \\\n    __move_assignment(const __move_assignment&) = default;                     \\\n    __move_assignment(__move_assignment&&) = default;                          \\\n    ~__move_assignment() = default;                                            \\\n    __move_assignment& operator=(const __move_assignment&) = default;          \\\n    move_assignment                                                            \\\n  }\n\n_LIBCPP_VARIANT_MOVE_ASSIGNMENT(\n    _Trait::_TriviallyAvailable,\n    __move_assignment& operator=(__move_assignment&& __that) = default;);\n\n_LIBCPP_VARIANT_MOVE_ASSIGNMENT(\n    _Trait::_Available,\n    __move_assignment& operator=(__move_assignment&& __that) noexcept(\n        __all<(is_nothrow_move_constructible_v<_Types> &&\n               is_nothrow_move_assignable_v<_Types>)...>::value) {\n      this->__generic_assign(_VSTD::move(__that));\n      return *this;\n    });\n\n_LIBCPP_VARIANT_MOVE_ASSIGNMENT(\n    _Trait::_Unavailable,\n    __move_assignment& operator=(__move_assignment&&) = delete;);\n\n#undef _LIBCPP_VARIANT_MOVE_ASSIGNMENT\n\ntemplate <class _Traits, _Trait = _Traits::__copy_assignable_trait>\nclass _LIBCPP_TEMPLATE_VIS __copy_assignment;\n\n#define _LIBCPP_VARIANT_COPY_ASSIGNMENT(copy_assignable_trait,                 \\\n                                        copy_assignment)                       \\\n  template <class... _Types>                                                   \\\n  class _LIBCPP_TEMPLATE_VIS __copy_assignment<__traits<_Types...>,           \\\n                                                copy_assignable_trait>         \\\n      : public __move_assignment<__traits<_Types...>> {                        \\\n    using __base_type = __move_assignment<__traits<_Types...>>;                \\\n                                                                               \\\n  public:                                                                      \\\n    using __base_type::__base_type;                                            \\\n    using __base_type::operator=;                                              \\\n                                                                               \\\n    __copy_assignment(const __copy_assignment&) = default;                     \\\n    __copy_assignment(__copy_assignment&&) = default;                          \\\n    ~__copy_assignment() = default;                                            \\\n    copy_assignment                                                            \\\n    __copy_assignment& operator=(__copy_assignment&&) = default;               \\\n  }\n\n_LIBCPP_VARIANT_COPY_ASSIGNMENT(\n    _Trait::_TriviallyAvailable,\n    __copy_assignment& operator=(const __copy_assignment& __that) = default;);\n\n_LIBCPP_VARIANT_COPY_ASSIGNMENT(\n    _Trait::_Available,\n    __copy_assignment& operator=(const __copy_assignment& __that) {\n      this->__generic_assign(__that);\n      return *this;\n    });\n\n_LIBCPP_VARIANT_COPY_ASSIGNMENT(\n    _Trait::_Unavailable,\n    __copy_assignment& operator=(const __copy_assignment&) = delete;);\n\n#undef _LIBCPP_VARIANT_COPY_ASSIGNMENT\n\ntemplate <class... _Types>\nclass _LIBCPP_TEMPLATE_VIS __impl\n    : public __copy_assignment<__traits<_Types...>> {\n  using __base_type = __copy_assignment<__traits<_Types...>>;\n\npublic:\n  using __base_type::__base_type;\n  using __base_type::operator=;\n\n  template <size_t _Ip, class _Arg>\n  inline _LIBCPP_INLINE_VISIBILITY\n  void __assign(_Arg&& __arg) {\n    this->__assign_alt(__access::__base::__get_alt<_Ip>(*this),\n                       _VSTD::forward<_Arg>(__arg),\n                       false_type{});\n  }\n\n  inline _LIBCPP_INLINE_VISIBILITY\n  void __swap(__impl& __that)  {\n    if (this->valueless_by_exception() && __that.valueless_by_exception()) {\n      // do nothing.\n    } else if (this->index() == __that.index()) {\n      __visitation::__base::__visit_alt_at(\n          this->index(),\n          [](auto& __this_alt, auto& __that_alt) {\n            using _VSTD::swap;\n            swap(__this_alt.__value, __that_alt.__value);\n          },\n          *this,\n          __that);\n    } else {\n      __impl* __lhs = this;\n      __impl* __rhs = _VSTD::addressof(__that);\n      if (__lhs->__move_nothrow() && !__rhs->__move_nothrow()) {\n        _VSTD::swap(__lhs, __rhs);\n      }\n      __impl __tmp(_VSTD::move(*__rhs));\n#ifndef _LIBCPP_NO_EXCEPTIONS\n      // EXTENSION: When the move construction of `__lhs` into `__rhs` throws\n      // and `__tmp` is nothrow move constructible then we move `__tmp` back\n      // into `__rhs` and provide the strong exception safety guarentee.\n      try {\n        this->__generic_construct(*__rhs, _VSTD::move(*__lhs));\n      } catch (...) {\n        if (__tmp.__move_nothrow()) {\n          this->__generic_construct(*__rhs, _VSTD::move(__tmp));\n        }\n        throw;\n      }\n#else\n      this->__generic_construct(*__rhs, _VSTD::move(*__lhs));\n#endif\n      this->__generic_construct(*__lhs, _VSTD::move(__tmp));\n    }\n  }\n\nprivate:\n  inline _LIBCPP_INLINE_VISIBILITY\n  bool __move_nothrow() const {\n    constexpr bool __results[] = {is_nothrow_move_constructible_v<_Types>...};\n    return this->valueless_by_exception() || __results[this->index()];\n  }\n};\n\ntemplate <class... _Types>\nstruct __overload;\n\ntemplate <>\nstruct __overload<> { void operator()() const; };\n\ntemplate <class _Tp, class... _Types>\nstruct __overload<_Tp, _Types...> : __overload<_Types...> {\n  using __overload<_Types...>::operator();\n  __identity<_Tp> operator()(_Tp) const;\n};\n\ntemplate <class _Tp, class... _Types>\nusing __best_match_t = typename result_of_t<__overload<_Types...>(_Tp&&)>::type;\n\n} // __variant_detail\n\ntemplate <class... _Types>\nclass _LIBCPP_TEMPLATE_VIS variant\n    : private __sfinae_ctor_base<\n          __all<is_copy_constructible_v<_Types>...>::value,\n          __all<is_move_constructible_v<_Types>...>::value>,\n      private __sfinae_assign_base<\n          __all<(is_copy_constructible_v<_Types> &&\n                 is_move_constructible_v<_Types> &&\n                 is_copy_assignable_v<_Types>)...>::value,\n          __all<(is_move_constructible_v<_Types> &&\n                 is_move_assignable_v<_Types>)...>::value> {\n  static_assert(0 < sizeof...(_Types),\n                \"variant must consist of at least one alternative.\");\n\n  static_assert(__all<!is_array_v<_Types>...>::value,\n                \"variant can not have an array type as an alternative.\");\n\n  static_assert(__all<!is_reference_v<_Types>...>::value,\n                \"variant can not have a reference type as an alternative.\");\n\n  static_assert(__all<!is_void_v<_Types>...>::value,\n                \"variant can not have a void type as an alternative.\");\n\n  using __first_type = variant_alternative_t<0, variant>;\n\npublic:\n  template <bool _Dummy = true,\n            enable_if_t<__dependent_type<is_default_constructible<__first_type>,\n                                         _Dummy>::value,\n                        int> = 0>\n  inline _LIBCPP_INLINE_VISIBILITY\n  constexpr variant() noexcept(is_nothrow_default_constructible_v<__first_type>)\n      : __impl(in_place_index<0>) {}\n\n  variant(const variant&) = default;\n  variant(variant&&) = default;\n\n  template <\n      class _Arg,\n      enable_if_t<!is_same_v<decay_t<_Arg>, variant>, int> = 0,\n      class _Tp = __variant_detail::__best_match_t<_Arg, _Types...>,\n      size_t _Ip =\n          __find_detail::__find_unambiguous_index_sfinae<_Tp, _Types...>::value,\n      enable_if_t<is_constructible_v<_Tp, _Arg>, int> = 0>\n  inline _LIBCPP_INLINE_VISIBILITY\n  constexpr variant(_Arg&& __arg) noexcept(\n      is_nothrow_constructible_v<_Tp, _Arg>)\n      : __impl(in_place_index<_Ip>, _VSTD::forward<_Arg>(__arg)) {}\n\n  template <size_t _Ip, class... _Args,\n            enable_if_t<(_Ip < sizeof...(_Types)), int> = 0,\n            class _Tp = variant_alternative_t<_Ip, variant<_Types...>>,\n            enable_if_t<is_constructible_v<_Tp, _Args...>, int> = 0>\n  inline _LIBCPP_INLINE_VISIBILITY\n  explicit constexpr variant(\n      in_place_index_t<_Ip>,\n      _Args&&... __args) noexcept(is_nothrow_constructible_v<_Tp, _Args...>)\n      : __impl(in_place_index<_Ip>, _VSTD::forward<_Args>(__args)...) {}\n\n  template <\n      size_t _Ip,\n      class _Up,\n      class... _Args,\n      enable_if_t<(_Ip < sizeof...(_Types)), int> = 0,\n      class _Tp = variant_alternative_t<_Ip, variant<_Types...>>,\n      enable_if_t<is_constructible_v<_Tp, initializer_list<_Up>&, _Args...>,\n                  int> = 0>\n  inline _LIBCPP_INLINE_VISIBILITY\n  explicit constexpr variant(\n      in_place_index_t<_Ip>,\n      initializer_list<_Up> __il,\n      _Args&&... __args) noexcept(\n      is_nothrow_constructible_v<_Tp, initializer_list<_Up>&, _Args...>)\n      : __impl(in_place_index<_Ip>, __il, _VSTD::forward<_Args>(__args)...) {}\n\n  template <\n      class _Tp,\n      class... _Args,\n      size_t _Ip =\n          __find_detail::__find_unambiguous_index_sfinae<_Tp, _Types...>::value,\n      enable_if_t<is_constructible_v<_Tp, _Args...>, int> = 0>\n  inline _LIBCPP_INLINE_VISIBILITY\n  explicit constexpr variant(in_place_type_t<_Tp>, _Args&&... __args) noexcept(\n      is_nothrow_constructible_v<_Tp, _Args...>)\n      : __impl(in_place_index<_Ip>, _VSTD::forward<_Args>(__args)...) {}\n\n  template <\n      class _Tp,\n      class _Up,\n      class... _Args,\n      size_t _Ip =\n          __find_detail::__find_unambiguous_index_sfinae<_Tp, _Types...>::value,\n      enable_if_t<is_constructible_v<_Tp, initializer_list<_Up>&, _Args...>,\n                  int> = 0>\n  inline _LIBCPP_INLINE_VISIBILITY\n  explicit constexpr variant(\n      in_place_type_t<_Tp>,\n      initializer_list<_Up> __il,\n      _Args&&... __args) noexcept(\n      is_nothrow_constructible_v<_Tp, initializer_list< _Up>&, _Args...>)\n      : __impl(in_place_index<_Ip>, __il, _VSTD::forward<_Args>(__args)...) {}\n\n  ~variant() = default;\n\n  variant& operator=(const variant&) = default;\n  variant& operator=(variant&&) = default;\n\n  template <\n      class _Arg,\n      enable_if_t<!is_same_v<decay_t<_Arg>, variant>, int> = 0,\n      class _Tp = __variant_detail::__best_match_t<_Arg, _Types...>,\n      size_t _Ip =\n          __find_detail::__find_unambiguous_index_sfinae<_Tp, _Types...>::value,\n      enable_if_t<is_assignable_v<_Tp&, _Arg> && is_constructible_v<_Tp, _Arg>,\n                  int> = 0>\n  inline _LIBCPP_INLINE_VISIBILITY\n  variant& operator=(_Arg&& __arg) noexcept(\n      is_nothrow_assignable_v<_Tp&, _Arg> &&\n      is_nothrow_constructible_v<_Tp, _Arg>) {\n    __impl.template __assign<_Ip>(_VSTD::forward<_Arg>(__arg));\n    return *this;\n  }\n\n  template <\n      size_t _Ip,\n      class... _Args,\n      enable_if_t<(_Ip < sizeof...(_Types)), int> = 0,\n      class _Tp = variant_alternative_t<_Ip, variant<_Types...>>,\n      enable_if_t<is_constructible_v<_Tp, _Args...>, int> = 0>\n  inline _LIBCPP_INLINE_VISIBILITY\n  void emplace(_Args&&... __args) {\n    __impl.template __emplace<_Ip>(_VSTD::forward<_Args>(__args)...);\n  }\n\n  template <\n      size_t _Ip,\n      class _Up,\n      class... _Args,\n      enable_if_t<(_Ip < sizeof...(_Types)), int> = 0,\n      class _Tp = variant_alternative_t<_Ip, variant<_Types...>>,\n      enable_if_t<is_constructible_v<_Tp, initializer_list<_Up>&, _Args...>,\n                  int> = 0>\n  inline _LIBCPP_INLINE_VISIBILITY\n  void emplace(initializer_list<_Up> __il, _Args&&... __args) {\n    __impl.template __emplace<_Ip>(__il, _VSTD::forward<_Args>(__args)...);\n  }\n\n  template <\n      class _Tp,\n      class... _Args,\n      size_t _Ip =\n          __find_detail::__find_unambiguous_index_sfinae<_Tp, _Types...>::value,\n      enable_if_t<is_constructible_v<_Tp, _Args...>, int> = 0>\n  inline _LIBCPP_INLINE_VISIBILITY\n  void emplace(_Args&&... __args) {\n    __impl.template __emplace<_Ip>(_VSTD::forward<_Args>(__args)...);\n  }\n\n  template <\n      class _Tp,\n      class _Up,\n      class... _Args,\n      size_t _Ip =\n          __find_detail::__find_unambiguous_index_sfinae<_Tp, _Types...>::value,\n      enable_if_t<is_constructible_v<_Tp, initializer_list<_Up>&, _Args...>,\n                  int> = 0>\n  inline _LIBCPP_INLINE_VISIBILITY\n  void emplace(initializer_list<_Up> __il, _Args&&... __args) {\n    __impl.template __emplace<_Ip>(__il, _VSTD::forward<_Args>(__args)...);\n  }\n\n  inline _LIBCPP_INLINE_VISIBILITY\n  constexpr bool valueless_by_exception() const noexcept {\n    return __impl.valueless_by_exception();\n  }\n\n  inline _LIBCPP_INLINE_VISIBILITY\n  constexpr size_t index() const noexcept { return __impl.index(); }\n\n  template <\n      bool _Dummy = true,\n      enable_if_t<\n          __all<(\n              __dependent_type<is_move_constructible<_Types>, _Dummy>::value &&\n              __dependent_type<is_swappable<_Types>, _Dummy>::value)...>::value,\n          int> = 0>\n  inline _LIBCPP_INLINE_VISIBILITY\n  void swap(variant& __that) noexcept(\n      __all<(is_nothrow_move_constructible_v<_Types> &&\n             is_nothrow_swappable_v<_Types>)...>::value) {\n    __impl.__swap(__that.__impl);\n  }\n\nprivate:\n  __variant_detail::__impl<_Types...> __impl;\n\n  friend struct __variant_detail::__access::__variant;\n  friend struct __variant_detail::__visitation::__variant;\n};\n\ntemplate <size_t _Ip, class... _Types>\ninline _LIBCPP_INLINE_VISIBILITY\nconstexpr bool __holds_alternative(const variant<_Types...>& __v) noexcept {\n  return __v.index() == _Ip;\n}\n\ntemplate <class _Tp, class... _Types>\ninline _LIBCPP_INLINE_VISIBILITY\nconstexpr bool holds_alternative(const variant<_Types...>& __v) noexcept {\n  return __holds_alternative<__find_exactly_one_t<_Tp, _Types...>::value>(__v);\n}\n\ntemplate <size_t _Ip, class _Vp>\ninline _LIBCPP_INLINE_VISIBILITY\nstatic constexpr auto&& __generic_get(_Vp&& __v) {\n  using __variant_detail::__access::__variant;\n  if (!__holds_alternative<_Ip>(__v)) {\n    __throw_bad_variant_access();\n  }\n  return __variant::__get_alt<_Ip>(_VSTD::forward<_Vp>(__v)).__value;\n}\n\ntemplate <size_t _Ip, class... _Types>\ninline _LIBCPP_INLINE_VISIBILITY\nconstexpr variant_alternative_t<_Ip, variant<_Types...>>& get(\n    variant<_Types...>& __v) {\n  static_assert(_Ip < sizeof...(_Types));\n  static_assert(!is_void_v<variant_alternative_t<_Ip, variant<_Types...>>>);\n  return __generic_get<_Ip>(__v);\n}\n\ntemplate <size_t _Ip, class... _Types>\ninline _LIBCPP_INLINE_VISIBILITY\nconstexpr variant_alternative_t<_Ip, variant<_Types...>>&& get(\n    variant<_Types...>&& __v) {\n  static_assert(_Ip < sizeof...(_Types));\n  static_assert(!is_void_v<variant_alternative_t<_Ip, variant<_Types...>>>);\n  return __generic_get<_Ip>(_VSTD::move(__v));\n}\n\ntemplate <size_t _Ip, class... _Types>\ninline _LIBCPP_INLINE_VISIBILITY\nconstexpr const variant_alternative_t<_Ip, variant<_Types...>>& get(\n    const variant<_Types...>& __v) {\n  static_assert(_Ip < sizeof...(_Types));\n  static_assert(!is_void_v<variant_alternative_t<_Ip, variant<_Types...>>>);\n  return __generic_get<_Ip>(__v);\n}\n\ntemplate <size_t _Ip, class... _Types>\ninline _LIBCPP_INLINE_VISIBILITY\nconstexpr const variant_alternative_t<_Ip, variant<_Types...>>&& get(\n    const variant<_Types...>&& __v) {\n  static_assert(_Ip < sizeof...(_Types));\n  static_assert(!is_void_v<variant_alternative_t<_Ip, variant<_Types...>>>);\n  return __generic_get<_Ip>(_VSTD::move(__v));\n}\n\ntemplate <class _Tp, class... _Types>\ninline _LIBCPP_INLINE_VISIBILITY\nconstexpr _Tp& get(variant<_Types...>& __v) {\n  static_assert(!is_void_v<_Tp>);\n  return _VSTD::get<__find_exactly_one_t<_Tp, _Types...>::value>(__v);\n}\n\ntemplate <class _Tp, class... _Types>\ninline _LIBCPP_INLINE_VISIBILITY\nconstexpr _Tp&& get(variant<_Types...>&& __v) {\n  static_assert(!is_void_v<_Tp>);\n  return _VSTD::get<__find_exactly_one_t<_Tp, _Types...>::value>(\n      _VSTD::move(__v));\n}\n\ntemplate <class _Tp, class... _Types>\ninline _LIBCPP_INLINE_VISIBILITY\nconstexpr const _Tp& get(const variant<_Types...>& __v) {\n  static_assert(!is_void_v<_Tp>);\n  return _VSTD::get<__find_exactly_one_t<_Tp, _Types...>::value>(__v);\n}\n\ntemplate <class _Tp, class... _Types>\ninline _LIBCPP_INLINE_VISIBILITY\nconstexpr const _Tp&& get(const variant<_Types...>&& __v) {\n  static_assert(!is_void_v<_Tp>);\n  return _VSTD::get<__find_exactly_one_t<_Tp, _Types...>::value>(\n      _VSTD::move(__v));\n}\n\ntemplate <size_t _Ip, class _Vp>\ninline _LIBCPP_INLINE_VISIBILITY\nconstexpr auto* __generic_get_if(_Vp* __v) noexcept {\n  using __variant_detail::__access::__variant;\n  return __v && __holds_alternative<_Ip>(*__v)\n             ? _VSTD::addressof(__variant::__get_alt<_Ip>(*__v).__value)\n             : nullptr;\n}\n\ntemplate <size_t _Ip, class... _Types>\ninline _LIBCPP_INLINE_VISIBILITY\nconstexpr add_pointer_t<variant_alternative_t<_Ip, variant<_Types...>>>\nget_if(variant<_Types...>* __v) noexcept {\n  static_assert(_Ip < sizeof...(_Types));\n  static_assert(!is_void_v<variant_alternative_t<_Ip, variant<_Types...>>>);\n  return __generic_get_if<_Ip>(__v);\n}\n\ntemplate <size_t _Ip, class... _Types>\ninline _LIBCPP_INLINE_VISIBILITY\nconstexpr add_pointer_t<const variant_alternative_t<_Ip, variant<_Types...>>>\nget_if(const variant<_Types...>* __v) noexcept {\n  static_assert(_Ip < sizeof...(_Types));\n  static_assert(!is_void_v<variant_alternative_t<_Ip, variant<_Types...>>>);\n  return __generic_get_if<_Ip>(__v);\n}\n\ntemplate <class _Tp, class... _Types>\ninline _LIBCPP_INLINE_VISIBILITY\nconstexpr add_pointer_t<_Tp>\nget_if(variant<_Types...>* __v) noexcept {\n  static_assert(!is_void_v<_Tp>);\n  return _VSTD::get_if<__find_exactly_one_t<_Tp, _Types...>::value>(__v);\n}\n\ntemplate <class _Tp, class... _Types>\ninline _LIBCPP_INLINE_VISIBILITY\nconstexpr add_pointer_t<const _Tp>\nget_if(const variant<_Types...>* __v) noexcept {\n  static_assert(!is_void_v<_Tp>);\n  return _VSTD::get_if<__find_exactly_one_t<_Tp, _Types...>::value>(__v);\n}\n\ntemplate <class... _Types>\ninline _LIBCPP_INLINE_VISIBILITY\nconstexpr bool operator==(const variant<_Types...>& __lhs,\n                          const variant<_Types...>& __rhs) {\n  using __variant_detail::__visitation::__variant;\n  if (__lhs.index() != __rhs.index()) return false;\n  if (__lhs.valueless_by_exception()) return true;\n  return __variant::__visit_value_at(__lhs.index(), equal_to<>{}, __lhs, __rhs);\n}\n\ntemplate <class... _Types>\ninline _LIBCPP_INLINE_VISIBILITY\nconstexpr bool operator!=(const variant<_Types...>& __lhs,\n                          const variant<_Types...>& __rhs) {\n  using __variant_detail::__visitation::__variant;\n  if (__lhs.index() != __rhs.index()) return true;\n  if (__lhs.valueless_by_exception()) return false;\n  return __variant::__visit_value_at(\n      __lhs.index(), not_equal_to<>{}, __lhs, __rhs);\n}\n\ntemplate <class... _Types>\ninline _LIBCPP_INLINE_VISIBILITY\nconstexpr bool operator<(const variant<_Types...>& __lhs,\n                         const variant<_Types...>& __rhs) {\n  using __variant_detail::__visitation::__variant;\n  if (__rhs.valueless_by_exception()) return false;\n  if (__lhs.valueless_by_exception()) return true;\n  if (__lhs.index() < __rhs.index()) return true;\n  if (__lhs.index() > __rhs.index()) return false;\n  return __variant::__visit_value_at(__lhs.index(), less<>{}, __lhs, __rhs);\n}\n\ntemplate <class... _Types>\ninline _LIBCPP_INLINE_VISIBILITY\nconstexpr bool operator>(const variant<_Types...>& __lhs,\n                         const variant<_Types...>& __rhs) {\n  using __variant_detail::__visitation::__variant;\n  if (__lhs.valueless_by_exception()) return false;\n  if (__rhs.valueless_by_exception()) return true;\n  if (__lhs.index() > __rhs.index()) return true;\n  if (__lhs.index() < __rhs.index()) return false;\n  return __variant::__visit_value_at(__lhs.index(), greater<>{}, __lhs, __rhs);\n}\n\ntemplate <class... _Types>\ninline _LIBCPP_INLINE_VISIBILITY\nconstexpr bool operator<=(const variant<_Types...>& __lhs,\n                          const variant<_Types...>& __rhs) {\n  using __variant_detail::__visitation::__variant;\n  if (__lhs.valueless_by_exception()) return true;\n  if (__rhs.valueless_by_exception()) return false;\n  if (__lhs.index() < __rhs.index()) return true;\n  if (__lhs.index() > __rhs.index()) return false;\n  return __variant::__visit_value_at(\n      __lhs.index(), less_equal<>{}, __lhs, __rhs);\n}\n\ntemplate <class... _Types>\ninline _LIBCPP_INLINE_VISIBILITY\nconstexpr bool operator>=(const variant<_Types...>& __lhs,\n                          const variant<_Types...>& __rhs) {\n  using __variant_detail::__visitation::__variant;\n  if (__rhs.valueless_by_exception()) return true;\n  if (__lhs.valueless_by_exception()) return false;\n  if (__lhs.index() > __rhs.index()) return true;\n  if (__lhs.index() < __rhs.index()) return false;\n  return __variant::__visit_value_at(\n      __lhs.index(), greater_equal<>{}, __lhs, __rhs);\n}\n\ntemplate <class _Visitor, class... _Vs>\ninline _LIBCPP_INLINE_VISIBILITY\nconstexpr decltype(auto) visit(_Visitor&& __visitor, _Vs&&... __vs) {\n  using __variant_detail::__visitation::__variant;\n  bool __results[] = {__vs.valueless_by_exception()...};\n  for (bool __result : __results) {\n    if (__result) {\n      __throw_bad_variant_access();\n    }\n  }\n  return __variant::__visit_value(_VSTD::forward<_Visitor>(__visitor),\n                                  _VSTD::forward<_Vs>(__vs)...);\n}\n\nstruct _LIBCPP_TEMPLATE_VIS monostate {};\n\ninline _LIBCPP_INLINE_VISIBILITY\nconstexpr bool operator<(monostate, monostate) noexcept { return false; }\n\ninline _LIBCPP_INLINE_VISIBILITY\nconstexpr bool operator>(monostate, monostate) noexcept { return false; }\n\ninline _LIBCPP_INLINE_VISIBILITY\nconstexpr bool operator<=(monostate, monostate) noexcept { return true; }\n\ninline _LIBCPP_INLINE_VISIBILITY\nconstexpr bool operator>=(monostate, monostate) noexcept { return true; }\n\ninline _LIBCPP_INLINE_VISIBILITY\nconstexpr bool operator==(monostate, monostate) noexcept { return true; }\n\ninline _LIBCPP_INLINE_VISIBILITY\nconstexpr bool operator!=(monostate, monostate) noexcept { return false; }\n\ntemplate <class... _Types>\ninline _LIBCPP_INLINE_VISIBILITY\nauto swap(variant<_Types...>& __lhs,\n          variant<_Types...>& __rhs) noexcept(noexcept(__lhs.swap(__rhs)))\n    -> decltype(__lhs.swap(__rhs)) {\n  __lhs.swap(__rhs);\n}\n\ntemplate <class... _Types>\nstruct _LIBCPP_TEMPLATE_VIS hash<variant<_Types...>> {\n  using argument_type = variant<_Types...>;\n  using result_type = size_t;\n\n  inline _LIBCPP_INLINE_VISIBILITY\n  result_type operator()(const argument_type& __v) const {\n    using __variant_detail::__visitation::__variant;\n    size_t __res =\n        __v.valueless_by_exception()\n               ? 299792458 // Random value chosen by the universe upon creation\n               : __variant::__visit_alt(\n                     [](const auto& __alt) {\n                       using __alt_type = decay_t<decltype(__alt)>;\n                       using __value_type = typename __alt_type::__value_type;\n                       return hash<__value_type>{}(__alt.__value);\n                     },\n                     __v);\n    return __hash_combine(__res, hash<size_t>{}(__v.index()));\n  }\n};\n\ntemplate <>\nstruct _LIBCPP_TEMPLATE_VIS hash<monostate> {\n  using argument_type = monostate;\n  using result_type = size_t;\n\n  inline _LIBCPP_INLINE_VISIBILITY\n  result_type operator()(const argument_type&) const {\n    return 66740831; // return a fundamentally attractive random value.\n  }\n};\n\n#endif  // _LIBCPP_STD_VER > 14\n\n_LIBCPP_END_NAMESPACE_STD\n\n#endif  // _LIBCPP_VARIANT\n","// -*- C++ -*-\n//===-------------------------- typeinfo ----------------------------------===//\n//\n//                     The LLVM Compiler Infrastructure\n//\n// This file is dual licensed under the MIT and the University of Illinois Open\n// Source Licenses. See LICENSE.TXT for details.\n//\n//===----------------------------------------------------------------------===//\n\n#ifndef __LIBCPP_TYPEINFO\n#define __LIBCPP_TYPEINFO\n\n/*\n\n    typeinfo synopsis\n\nnamespace std {\n\nclass type_info\n{\npublic:\n    virtual ~type_info();\n\n    bool operator==(const type_info& rhs) const noexcept;\n    bool operator!=(const type_info& rhs) const noexcept;\n\n    bool before(const type_info& rhs) const noexcept;\n    size_t hash_code() const noexcept;\n    const char* name() const noexcept;\n\n    type_info(const type_info& rhs) = delete;\n    type_info& operator=(const type_info& rhs) = delete;\n};\n\nclass bad_cast\n    : public exception\n{\npublic:\n    bad_cast() noexcept;\n    bad_cast(const bad_cast&) noexcept;\n    bad_cast& operator=(const bad_cast&) noexcept;\n    virtual const char* what() const noexcept;\n};\n\nclass bad_typeid\n    : public exception\n{\npublic:\n    bad_typeid() noexcept;\n    bad_typeid(const bad_typeid&) noexcept;\n    bad_typeid& operator=(const bad_typeid&) noexcept;\n    virtual const char* what() const noexcept;\n};\n\n}  // std\n\n*/\n\n#include <__config>\n#include <exception>\n#include <cstddef>\n#include <cstdint>\n#ifdef _LIBCPP_NO_EXCEPTIONS\n#include <cstdlib>\n#endif\n\n#if !defined(_LIBCPP_HAS_NO_PRAGMA_SYSTEM_HEADER)\n#pragma GCC system_header\n#endif\n\n#if defined(_LIBCPP_NONUNIQUE_RTTI_BIT)\n#define _LIBCPP_HAS_NONUNIQUE_TYPEINFO\n#else\n#define _LIBCPP_HAS_UNIQUE_TYPEINFO\n#endif\n\nnamespace std  // purposefully not using versioning namespace\n{\n\nclass _LIBCPP_EXCEPTION_ABI type_info\n{\n    type_info& operator=(const type_info&);\n    type_info(const type_info&);\n\n#if defined(_LIBCPP_HAS_NONUNIQUE_TYPEINFO)\n    _LIBCPP_INLINE_VISIBILITY\n    int __compare_nonunique_names(const type_info &__arg) const _NOEXCEPT\n    { return __builtin_strcmp(name(), __arg.name()); }\n#endif\n\nprotected:\n#if defined(_LIBCPP_HAS_NONUNIQUE_TYPEINFO)\n    // A const char* with the non-unique RTTI bit possibly set.\n    uintptr_t __type_name;\n\n    _LIBCPP_INLINE_VISIBILITY\n    explicit type_info(const char* __n)\n      : __type_name(reinterpret_cast<uintptr_t>(__n)) {}\n#else\n    const char *__type_name;\n\n    _LIBCPP_INLINE_VISIBILITY\n    explicit type_info(const char* __n) : __type_name(__n) {}\n#endif\n\npublic:\n    virtual ~type_info();\n\n#if defined(_LIBCPP_HAS_NONUNIQUE_TYPEINFO)\n    _LIBCPP_INLINE_VISIBILITY\n    const char* name() const _NOEXCEPT\n    {\n      return reinterpret_cast<const char*>(__type_name &\n                                           ~_LIBCPP_NONUNIQUE_RTTI_BIT);\n    }\n\n    _LIBCPP_INLINE_VISIBILITY\n    bool before(const type_info& __arg) const _NOEXCEPT\n    {\n      if (!((__type_name & __arg.__type_name) & _LIBCPP_NONUNIQUE_RTTI_BIT))\n        return __type_name < __arg.__type_name;\n      return __compare_nonunique_names(__arg) < 0;\n    }\n\n    _LIBCPP_INLINE_VISIBILITY\n    size_t hash_code() const _NOEXCEPT\n    {\n      if (!(__type_name & _LIBCPP_NONUNIQUE_RTTI_BIT))\n        return __type_name;\n\n      const char* __ptr = name();\n      size_t __hash = 5381;\n      while (unsigned char __c = static_cast<unsigned char>(*__ptr++))\n        __hash = (__hash * 33) ^ __c;\n      return __hash;\n    }\n\n    _LIBCPP_INLINE_VISIBILITY\n    bool operator==(const type_info& __arg) const _NOEXCEPT\n    {\n      if (__type_name == __arg.__type_name)\n        return true;\n\n      if (!((__type_name & __arg.__type_name) & _LIBCPP_NONUNIQUE_RTTI_BIT))\n        return false;\n      return __compare_nonunique_names(__arg) == 0;\n    }\n#else\n    _LIBCPP_INLINE_VISIBILITY\n    const char* name() const _NOEXCEPT\n    { return __type_name; }\n\n    _LIBCPP_INLINE_VISIBILITY\n    bool before(const type_info& __arg) const _NOEXCEPT\n    { return __type_name < __arg.__type_name; }\n\n    _LIBCPP_INLINE_VISIBILITY\n    size_t hash_code() const _NOEXCEPT\n    { return reinterpret_cast<size_t>(__type_name); }\n\n    _LIBCPP_INLINE_VISIBILITY\n    bool operator==(const type_info& __arg) const _NOEXCEPT\n    { return __type_name == __arg.__type_name; }\n#endif\n\n    _LIBCPP_INLINE_VISIBILITY\n    bool operator!=(const type_info& __arg) const _NOEXCEPT\n    { return !operator==(__arg); }\n};\n\nclass _LIBCPP_EXCEPTION_ABI bad_cast\n    : public exception\n{\npublic:\n    bad_cast() _NOEXCEPT;\n    virtual ~bad_cast() _NOEXCEPT;\n    virtual const char* what() const _NOEXCEPT;\n};\n\nclass _LIBCPP_EXCEPTION_ABI bad_typeid\n    : public exception\n{\npublic:\n    bad_typeid() _NOEXCEPT;\n    virtual ~bad_typeid() _NOEXCEPT;\n    virtual const char* what() const _NOEXCEPT;\n};\n\n}  // std\n\n_LIBCPP_BEGIN_NAMESPACE_STD\n_LIBCPP_NORETURN inline _LIBCPP_ALWAYS_INLINE\nvoid __throw_bad_cast()\n{\n#ifndef _LIBCPP_NO_EXCEPTIONS\n    throw bad_cast();\n#else\n\t_VSTD::abort();\n#endif\n}\n_LIBCPP_END_NAMESPACE_STD\n\n#endif  // __LIBCPP_TYPEINFO\n","#pragma once\n#include <vector>\n#include <unordered_map>\n#include \"ParserTypes.h\"\n#include \"Stack.h\"\n\n//in PredefinedFunctions.h\nclass PredefinedFunctions;\n\n//in FFI.h\nclass FFI;\n\nstruct FunctionDefinition {\n\tstd::string functionName;\n\tCHARM_LIST_TYPE functionBody;\n\tCharmFunctionDefinitionInfo definitionInfo;\n};\n\nstruct Reference {\n\tCharmFunction key;\n\tCharmFunction value;\n};\n\nextern \"C\"\nclass Runner {\nprivate:\n\t//handle the functions that we don't know about\n\t//and / or handle built in functions\n\tvoid handleDefinedFunctions(CharmFunction f, RunnerContext* context);\n\t//this is the name of the current stack that we\n\t//are working with. by default, this is stack 0\n\tCharmFunction currentStackName;\n\t//and here is the list of all of our stacks\n\tstd::vector<Stack> stacks;\n\t//and the list of all of our references\n\tstd::vector<Reference> references;\npublic:\n\tRunner();\n\t//and this is how you add them\n\tvoid addFunctionDefinition(FunctionDefinition fD);\n\n\t//all of our instances containing any sort of functions are right here:\n\tPredefinedFunctions* pF;\n\tFFI* ffi;\n\tstd::unordered_map<std::string, FunctionDefinition> functionDefinitions;\n\n\tconst unsigned int MAX_STACK = 20000;\n\tbool doesStackExist(CharmFunction name);\n\tStack* getCurrentStack();\n\tvoid switchCurrentStack(CharmFunction name);\n\tvoid createStack(unsigned long long length, CharmFunction name);\n\n\tCharmFunction getReference(CharmFunction key);\n\tvoid setReference(CharmFunction key, CharmFunction value);\n\n\tvoid addNamespacePrefix(CharmFunction& f, std::string ns);\n\tvoid runWithContext(CHARM_LIST_TYPE parsedProgram, RunnerContext* context, std::string ns = \"\");\n\tvoid run(std::pair<CHARM_LIST_TYPE, FunctionAnalyzer*> parsedProgramWithAnalyzer, std::string ns = \"\");\n};\n","#include <vector>\n\n#include \"Runner.h\"\n#include \"ParserTypes.h\"\n#include \"PredefinedFunctions.h\"\n#include \"Error.h\"\n#include \"Debug.h\"\n#include \"FFI.h\"\n\nvoid Runner::addFunctionDefinition(FunctionDefinition fD) {\n\t//first, check and make sure there's no other definition with\n\t//the same name. if there is, overwrite it. if not, just push_back\n\t//this definition.\n\tif (functionDefinitions.find(fD.functionName) == functionDefinitions.end()) {\n\t\tfunctionDefinitions[fD.functionName] = fD;\n\t}\n}\n\nRunner::Runner() {\n\t//initialize the stacks\n\tCharmFunction zero = Stack::zeroF();\n\tcurrentStackName = zero;\n\tstacks.push_back(Stack(MAX_STACK, zero));\n\tpF = new PredefinedFunctions();\n\tffi = new FFI();\n}\n\nbool Runner::doesStackExist(CharmFunction name) {\n\tfor (Stack stack : stacks) {\n\t\tif (stack.isNameEqualTo(name)) {\n\t\t\treturn true;\n\t\t}\n\t}\n\treturn false;\n}\nStack* Runner::getCurrentStack() {\n\tfor (unsigned int s = 0; s < stacks.size(); s++) {\n\t\tif (stacks[s].isNameEqualTo(Runner::currentStackName)) {\n\t\t\treturn &(stacks[s]);\n\t\t}\n\t}\n\treturn &(stacks[0]);\n}\n\nvoid Runner::switchCurrentStack(CharmFunction name) {\n\tif (Runner::doesStackExist(name)) {\n\t\tRunner::currentStackName = name;\n\t} else {\n\t\truntime_die(\"Tried to switch to stack which does not exist.\");\n\t}\n}\n\nvoid Runner::createStack(unsigned long long length, CharmFunction name) {\n\tif (Runner::doesStackExist(name)) {\n\t\truntime_die(\"Tried to create stack that already exists.\");\n\t} else {\n\t\tstacks.push_back(Stack(length, name));\n\t}\n}\n\nCharmFunction Runner::getReference(CharmFunction key) {\n\tfor (Reference r : references) {\n\t\tif (r.key == key) {\n\t\t\treturn r.value;\n\t\t}\n\t}\n\treturn Stack::zeroF();\n}\n\nvoid Runner::setReference(CharmFunction key, CharmFunction value) {\n\tReference newRef;\n\tnewRef.key = key;\n\tnewRef.value = value;\n\tfor (unsigned long long n = 0; n < references.size(); n++) {\n\t\tif (references[n].key == key) {\n\t\t\t//if the ref was previously defined\n\t\t\treferences[n] = newRef;\n\t\t\treturn;\n\t\t}\n\t}\n\t//if it wasn't previously defined then\n\treferences.push_back(newRef);\n}\n\nvoid Runner::handleDefinedFunctions(CharmFunction f, RunnerContext* context) {\n\t//PredefinedFunctions.h holds all the functions written in C++\n\t//other than that, if these functions aren't built in, they are run through\n\t//the functionDefinitions table.\n\n\t//first, make sure that the function we're trying to run exists in the PredefinedFunctions\n\t//table. if it doesn't - assume it's defined in Charm and run through the\n\t//functionDefinitions table.\n\tif (DEBUGMODE) {\n\t\tputs(\"ALL PREDEFINED FUNCTIONS: \");\n\t\tfor (auto f : pF->cppFunctionNames) {\n\t\t\tprintf(\"%s \", f.first.c_str());\n\t\t}\n\t\tputs(\"\");\n\t}\n\tbool isPredefinedFunction = (pF->cppFunctionNames.find(f.functionName) != pF->cppFunctionNames.end());\n\tbool isFFIFunction = (ffi->mutateFFIFuncs.find(f.functionName) != ffi->mutateFFIFuncs.end());\n\tONLYDEBUG printf(\"isPredefinedFunction? %s. isFFIFunction? %s\\n\", isPredefinedFunction ? \"Yes\" : \"No\", isFFIFunction ? \"Yes\" : \"No\");\n\tif (isPredefinedFunction) {\n\t\t//run the predefined function!\n\t\t//(note: the function context AKA the definition we are running code from\n\t\t//is passed in for tail call optimization in PredefinedFunctions.cpp::ifthen())\n\t\tpF->functionLookup(f.functionName, this, context);\n\t} else if (isFFIFunction) {\n\t\tffi->runFFI(f.functionName, this);\n\t} else {\n\t\t//alright, now we get down and dirty\n\t\t//look through the functionDefinitions table for a function with\n\t\t//a matching name, and run that. if there are no functions - throw\n\t\t//an error.\n\t\tif (DEBUGMODE) {\n\t\t\tputs(\"ALL DEFINED FUNCTIONS: \");\n\t\t\tfor (auto f : functionDefinitions) {\n\t\t\t\tprintf(\"%s \", f.first.c_str());\n\t\t\t}\n\t\t\tputs(\"\");\n\t\t}\n\t\tauto possibleFunction = functionDefinitions.find(f.functionName);\n\t\tif (possibleFunction != functionDefinitions.end()) {\n\t\t\tauto fD = possibleFunction->second;\n\t\t\t//wait! before we run it, check and make sure this function isn't tail recursive\n\t\t\tif (fD.definitionInfo.tailCallRecursive) {\n\t\t\t\t//if it is, drop the last call to itself and just run it in a loop\n\t\t\t\t//TODO: exiting a tail-call loop?\n\t\t\t\tCHARM_LIST_TYPE functionBodyCopy = fD.functionBody;\n\t\t\t\tfunctionBodyCopy.pop_back();\n\t\t\t\twhile (1) {\n\t\t\t\t\tRunner::run(std::pair<CHARM_LIST_TYPE, FunctionAnalyzer*>(functionBodyCopy, context->fA));\n\t\t\t\t}\n\t\t\t}\n\t\t\t//ooh. the only time we use this call!\n\t\t\tcontext->fD = &fD;\n\t\t\tRunner::runWithContext(fD.functionBody, context);\n\t\t} else {\n\t\t\truntime_die(\"Unknown function `\" + f.functionName + \"`.\");\n\t\t}\n\t}\n}\n\nvoid Runner::addNamespacePrefix(CharmFunction& f, std::string ns) {\n\tif (ns == \"\") {\n\t\treturn;\n\t}\n\tif (f.functionType == NUMBER_FUNCTION) {\n\t\treturn;\n\t} else if (f.functionType == STRING_FUNCTION) {\n\t\treturn;\n\t} else if (f.functionType == LIST_FUNCTION) {\n\t\tfor (CharmFunction& currentFunction : f.literalFunctions) {\n\t\t\taddNamespacePrefix(currentFunction, ns);\n\t\t}\n\t\treturn;\n\t} else if (f.functionType == FUNCTION_DEFINITION) {\n\t\tf.functionName = ns + f.functionName;\n\t\tfor (CharmFunction& currentFunction : f.literalFunctions) {\n\t\t\taddNamespacePrefix(currentFunction, ns);\n\t\t}\n\t\treturn;\n\t} else if (f.functionType == DEFINED_FUNCTION) {\n\t\tbool isAlreadyDefined = (functionDefinitions.find(f.functionName) != functionDefinitions.end());\n\t\tbool isPredefinedFunction = (pF->cppFunctionNames.find(f.functionName) != pF->cppFunctionNames.end());\n\t\tbool isFFIFunction = (ffi->mutateFFIFuncs.find(f.functionName) != ffi->mutateFFIFuncs.end());\n\t\tONLYDEBUG printf(\"isAlreadyDefined: %s, isPredefinedFunction: %s, isFFIFunction: %s\\n\", isAlreadyDefined ? \"Yes\" : \"No\", isPredefinedFunction ? \"Yes\" : \"No\", isFFIFunction ? \"Yes\" : \"No\");\n\t\tif (isPredefinedFunction || isFFIFunction || isAlreadyDefined) {\n\t\t\t//don't rename the function if it was defined globally outside of this file\n\t\t\t//or it was already defined (aka: in the prelude)\n\t\t\t//note: adding the \"if already defined\" clause ensures that functions from its own file don't trip the system,\n\t\t\t//as those functions were already transformed and had their namespace prepended.\n\t\t} else {\n\t\t\tf.functionName = ns + f.functionName;\n\t\t}\n\t}\n}\n\nvoid Runner::runWithContext(CHARM_LIST_TYPE parsedProgram, RunnerContext* context, std::string ns) {\n\tfor (CharmFunction currentFunction : parsedProgram) {\n\t\tif (ns != \"\") {\n\t\t\tONLYDEBUG printf(\"ADDING NAMESPACE %s\\n\", ns.c_str());\n\t\t\tRunner::addNamespacePrefix(currentFunction, ns);\n\t\t}\n\t\t//alright, now we get into the running portion\n\t\tif (currentFunction.functionType == NUMBER_FUNCTION) {\n\t\t\tONLYDEBUG puts(\"RUNNING AS NUMBER_FUNCTION\");\n\t\t\t//first, let's do the numbers\n\t\t\tRunner::getCurrentStack()->push(currentFunction);\n\t\t\t//easy, right? let's do more\n\t\t} else if (currentFunction.functionType == STRING_FUNCTION) {\n\t\t\tONLYDEBUG puts(\"RUNNING AS STRING_FUNCTION\");\n\t\t\t//now we push strings onto the stack\n\t\t\tRunner::getCurrentStack()->push(currentFunction);\n\t\t\t//still p easy ye\n\t\t} else if (currentFunction.functionType == LIST_FUNCTION) {\n\t\t\tONLYDEBUG puts(\"RUNNING AS LIST_FUNCTION\");\n\t\t\t//now we push on the lists\n\t\t\tRunner::getCurrentStack()->push(currentFunction);\n\t\t\t//wow this is easy right? now get ready baby\n\t\t} else if (currentFunction.functionType == FUNCTION_DEFINITION) {\n\t\t\tONLYDEBUG puts(\"RUNNING AS FUNCTION_DEFINTION\");\n\t\t\t//lets define some functions bruh\n\t\t\tFunctionDefinition tempFunction;\n\t\t\ttempFunction.functionName = currentFunction.functionName;\n\t\t\ttempFunction.functionBody = currentFunction.literalFunctions;\n\t\t\ttempFunction.definitionInfo = currentFunction.definitionInfo;\n\t\t\tRunner::addFunctionDefinition(tempFunction);\n\t\t\tONLYDEBUG printf(\"ADDED FUNCTION DEFINITION FOR %s\\n\", tempFunction.functionName.c_str());\n\t\t\t//that was easy too! oh no...\n\t\t} else if (currentFunction.functionType == DEFINED_FUNCTION) {\n\t\t\tONLYDEBUG puts(\"RUNNING AS DEFINED_FUNCTION\");\n\t\t\t//let's do these defined functions now\n\t\t\tRunner::handleDefinedFunctions(currentFunction, context);\n\t\t\t//lol you thought i'd do it here\n\t\t}\n\t}\n\tONLYDEBUG puts(\"EXITING RUNNER::RUN\");\n}\n\nvoid Runner::run(std::pair<CHARM_LIST_TYPE, FunctionAnalyzer*> parsedProgramWithAnalyzer, std::string ns) {\n\tRunnerContext rC;\n\trC.fA = parsedProgramWithAnalyzer.second;\n\trC.fD = nullptr;\n\tRunner::runWithContext(parsedProgramWithAnalyzer.first, &rC, ns);\n}\n","// -*- C++ -*-\n//===-------------------------- iterator ----------------------------------===//\n//\n//                     The LLVM Compiler Infrastructure\n//\n// This file is dual licensed under the MIT and the University of Illinois Open\n// Source Licenses. See LICENSE.TXT for details.\n//\n//===----------------------------------------------------------------------===//\n\n#ifndef _LIBCPP_ITERATOR\n#define _LIBCPP_ITERATOR\n\n/*\n    iterator synopsis\n\nnamespace std\n{\n\ntemplate<class Iterator>\nstruct iterator_traits\n{\n    typedef typename Iterator::difference_type difference_type;\n    typedef typename Iterator::value_type value_type;\n    typedef typename Iterator::pointer pointer;\n    typedef typename Iterator::reference reference;\n    typedef typename Iterator::iterator_category iterator_category;\n};\n\ntemplate<class T>\nstruct iterator_traits<T*>\n{\n    typedef ptrdiff_t difference_type;\n    typedef T value_type;\n    typedef T* pointer;\n    typedef T& reference;\n    typedef random_access_iterator_tag iterator_category;\n};\n\ntemplate<class T>\nstruct iterator_traits<const T*>\n{\n    typedef ptrdiff_t difference_type;\n    typedef T value_type;\n    typedef const T* pointer;\n    typedef const T& reference;\n    typedef random_access_iterator_tag iterator_category;\n};\n\ntemplate<class Category, class T, class Distance = ptrdiff_t,\n         class Pointer = T*, class Reference = T&>\nstruct iterator\n{\n    typedef T         value_type;\n    typedef Distance  difference_type;\n    typedef Pointer   pointer;\n    typedef Reference reference;\n    typedef Category  iterator_category;\n};\n\nstruct input_iterator_tag  {};\nstruct output_iterator_tag {};\nstruct forward_iterator_tag       : public input_iterator_tag         {};\nstruct bidirectional_iterator_tag : public forward_iterator_tag       {};\nstruct random_access_iterator_tag : public bidirectional_iterator_tag {};\n\n// extension: second argument not conforming to C++03\ntemplate <class InputIterator>\nvoid advance(InputIterator& i,\n             typename iterator_traits<InputIterator>::difference_type n);\n\ntemplate <class InputIterator>\ntypename iterator_traits<InputIterator>::difference_type\ndistance(InputIterator first, InputIterator last);\n\ntemplate <class Iterator>\nclass reverse_iterator\n    : public iterator<typename iterator_traits<Iterator>::iterator_category,\n                      typename iterator_traits<Iterator>::value_type,\n                      typename iterator_traits<Iterator>::difference_type,\n                      typename iterator_traits<Iterator>::pointer,\n                      typename iterator_traits<Iterator>::reference>\n{\nprotected:\n    Iterator current;\npublic:\n    typedef Iterator                                            iterator_type;\n    typedef typename iterator_traits<Iterator>::difference_type difference_type;\n    typedef typename iterator_traits<Iterator>::reference       reference;\n    typedef typename iterator_traits<Iterator>::pointer         pointer;\n\n    constexpr reverse_iterator();\n    constexpr explicit reverse_iterator(Iterator x);\n    template <class U> constexpr reverse_iterator(const reverse_iterator<U>& u);\n    template <class U> constexpr reverse_iterator& operator=(const reverse_iterator<U>& u);\n    constexpr Iterator base() const;\n    constexpr reference operator*() const;\n    constexpr pointer   operator->() const;\n    constexpr reverse_iterator& operator++();\n    constexpr reverse_iterator  operator++(int);\n    constexpr reverse_iterator& operator--();\n    constexpr reverse_iterator  operator--(int);\n    constexpr reverse_iterator  operator+ (difference_type n) const;\n    constexpr reverse_iterator& operator+=(difference_type n);\n    constexpr reverse_iterator  operator- (difference_type n) const;\n    constexpr reverse_iterator& operator-=(difference_type n);\n    constexpr reference         operator[](difference_type n) const;\n};\n\ntemplate <class Iterator1, class Iterator2>\nconstexpr bool                          // constexpr in C++17\noperator==(const reverse_iterator<Iterator1>& x, const reverse_iterator<Iterator2>& y);\n\ntemplate <class Iterator1, class Iterator2>\nconstexpr bool                          // constexpr in C++17\noperator<(const reverse_iterator<Iterator1>& x, const reverse_iterator<Iterator2>& y);\n\ntemplate <class Iterator1, class Iterator2>\nconstexpr bool                          // constexpr in C++17\noperator!=(const reverse_iterator<Iterator1>& x, const reverse_iterator<Iterator2>& y);\n\ntemplate <class Iterator1, class Iterator2>\nconstexpr bool                          // constexpr in C++17\noperator>(const reverse_iterator<Iterator1>& x, const reverse_iterator<Iterator2>& y);\n\ntemplate <class Iterator1, class Iterator2>\nconstexpr bool                          // constexpr in C++17\noperator>=(const reverse_iterator<Iterator1>& x, const reverse_iterator<Iterator2>& y);\n\ntemplate <class Iterator1, class Iterator2>\nconstexpr bool                          // constexpr in C++17\noperator<=(const reverse_iterator<Iterator1>& x, const reverse_iterator<Iterator2>& y);\n\ntemplate <class Iterator1, class Iterator2>\nconstexpr auto\noperator-(const reverse_iterator<Iterator1>& x, const reverse_iterator<Iterator2>& y)\n-> decltype(__y.base() - __x.base());   // constexpr in C++17\n\ntemplate <class Iterator>\nconstexpr reverse_iterator<Iterator>\noperator+(typename reverse_iterator<Iterator>::difference_type n, \n          const reverse_iterator<Iterator>& x);   // constexpr in C++17\n\ntemplate <class Iterator>\nconstexpr reverse_iterator<Iterator> make_reverse_iterator(Iterator i); // C++14, constexpr in C++17\n\ntemplate <class Container>\nclass back_insert_iterator\n{\nprotected:\n    Container* container;\npublic:\n    typedef Container                   container_type;\n    typedef void                        value_type;\n    typedef void                        difference_type;\n    typedef void                        reference;\n    typedef void                        pointer;\n\n    explicit back_insert_iterator(Container& x);\n    back_insert_iterator& operator=(const typename Container::value_type& value);\n    back_insert_iterator& operator*();\n    back_insert_iterator& operator++();\n    back_insert_iterator  operator++(int);\n};\n\ntemplate <class Container> back_insert_iterator<Container> back_inserter(Container& x);\n\ntemplate <class Container>\nclass front_insert_iterator\n{\nprotected:\n    Container* container;\npublic:\n    typedef Container                    container_type;\n    typedef void                         value_type;\n    typedef void                         difference_type;\n    typedef void                         reference;\n    typedef void                         pointer;\n\n    explicit front_insert_iterator(Container& x);\n    front_insert_iterator& operator=(const typename Container::value_type& value);\n    front_insert_iterator& operator*();\n    front_insert_iterator& operator++();\n    front_insert_iterator  operator++(int);\n};\n\ntemplate <class Container> front_insert_iterator<Container> front_inserter(Container& x);\n\ntemplate <class Container>\nclass insert_iterator\n{\nprotected:\n    Container* container;\n    typename Container::iterator iter;\npublic:\n    typedef Container              container_type;\n    typedef void                   value_type;\n    typedef void                   difference_type;\n    typedef void                   reference;\n    typedef void                   pointer;\n\n    insert_iterator(Container& x, typename Container::iterator i);\n    insert_iterator& operator=(const typename Container::value_type& value);\n    insert_iterator& operator*();\n    insert_iterator& operator++();\n    insert_iterator& operator++(int);\n};\n\ntemplate <class Container, class Iterator>\ninsert_iterator<Container> inserter(Container& x, Iterator i);\n\ntemplate <class Iterator>\nclass move_iterator {\npublic:\n    typedef Iterator                                              iterator_type;\n    typedef typename iterator_traits<Iterator>::difference_type   difference_type;\n    typedef Iterator                                              pointer;\n    typedef typename iterator_traits<Iterator>::value_type        value_type;\n    typedef typename iterator_traits<Iterator>::iterator_category iterator_category;\n    typedef value_type&&                                          reference;\n \n    constexpr move_iterator();  // all the constexprs are in C++17\n    constexpr explicit move_iterator(Iterator i);\n    template <class U>\n      constexpr move_iterator(const move_iterator<U>& u);\n    template <class U>\n      constexpr move_iterator& operator=(const move_iterator<U>& u);\n    constexpr iterator_type base() const;\n    constexpr reference operator*() const;\n    constexpr pointer operator->() const;\n    constexpr move_iterator& operator++();\n    constexpr move_iterator operator++(int);\n    constexpr move_iterator& operator--();\n    constexpr move_iterator operator--(int);\n    constexpr move_iterator operator+(difference_type n) const; \n    constexpr move_iterator& operator+=(difference_type n); \n    constexpr move_iterator operator-(difference_type n) const; \n    constexpr move_iterator& operator-=(difference_type n); \n    constexpr unspecified operator[](difference_type n) const;\nprivate:\n    Iterator current; // exposition only\n};\n\ntemplate <class Iterator1, class Iterator2>\nconstexpr bool   // constexpr in C++17\noperator==(const move_iterator<Iterator1>& x, const move_iterator<Iterator2>& y);\n\ntemplate <class Iterator1, class Iterator2>\nconstexpr bool   // constexpr in C++17\noperator!=(const move_iterator<Iterator1>& x, const move_iterator<Iterator2>& y);\n\ntemplate <class Iterator1, class Iterator2>\nconstexpr bool   // constexpr in C++17\noperator<(const move_iterator<Iterator1>& x, const move_iterator<Iterator2>& y);\n\ntemplate <class Iterator1, class Iterator2>\nconstexpr bool   // constexpr in C++17\noperator<=(const move_iterator<Iterator1>& x, const move_iterator<Iterator2>& y);\n\ntemplate <class Iterator1, class Iterator2>\nconstexpr bool   // constexpr in C++17\noperator>(const move_iterator<Iterator1>& x, const move_iterator<Iterator2>& y);\n\ntemplate <class Iterator1, class Iterator2>\nconstexpr bool   // constexpr in C++17\noperator>=(const move_iterator<Iterator1>& x, const move_iterator<Iterator2>& y);\n\ntemplate <class Iterator1, class Iterator2>\nconstexpr auto   // constexpr in C++17\noperator-(const move_iterator<Iterator1>& x,\n          const move_iterator<Iterator2>& y) -> decltype(x.base() - y.base());\n\ntemplate <class Iterator>\nconstexpr move_iterator<Iterator> operator+(   // constexpr in C++17\n            typename move_iterator<Iterator>::difference_type n, \n            const move_iterator<Iterator>& x);\n\ntemplate <class Iterator>   // constexpr in C++17\nconstexpr  move_iterator<Iterator> make_move_iterator(const Iterator& i);\n\n\ntemplate <class T, class charT = char, class traits = char_traits<charT>, class Distance = ptrdiff_t>\nclass istream_iterator\n    : public iterator<input_iterator_tag, T, Distance, const T*, const T&>\n{\npublic:\n    typedef charT char_type;\n    typedef traits traits_type;\n    typedef basic_istream<charT,traits> istream_type;\n\n    constexpr istream_iterator();\n    istream_iterator(istream_type& s);\n    istream_iterator(const istream_iterator& x);\n    ~istream_iterator();\n\n    const T& operator*() const;\n    const T* operator->() const;\n    istream_iterator& operator++();\n    istream_iterator  operator++(int);\n};\n\ntemplate <class T, class charT, class traits, class Distance>\nbool operator==(const istream_iterator<T,charT,traits,Distance>& x,\n                const istream_iterator<T,charT,traits,Distance>& y);\ntemplate <class T, class charT, class traits, class Distance>\nbool operator!=(const istream_iterator<T,charT,traits,Distance>& x,\n                const istream_iterator<T,charT,traits,Distance>& y);\n\ntemplate <class T, class charT = char, class traits = char_traits<charT> >\nclass ostream_iterator\n    : public iterator<output_iterator_tag, void, void, void ,void>\n{\npublic:\n    typedef charT char_type;\n    typedef traits traits_type;\n    typedef basic_ostream<charT,traits> ostream_type;\n\n    ostream_iterator(ostream_type& s);\n    ostream_iterator(ostream_type& s, const charT* delimiter);\n    ostream_iterator(const ostream_iterator& x);\n    ~ostream_iterator();\n    ostream_iterator& operator=(const T& value);\n\n    ostream_iterator& operator*();\n    ostream_iterator& operator++();\n    ostream_iterator& operator++(int);\n};\n\ntemplate<class charT, class traits = char_traits<charT> >\nclass istreambuf_iterator\n    : public iterator<input_iterator_tag, charT,\n                      typename traits::off_type, unspecified,\n                      charT>\n{\npublic:\n    typedef charT                         char_type;\n    typedef traits                        traits_type;\n    typedef typename traits::int_type     int_type;\n    typedef basic_streambuf<charT,traits> streambuf_type;\n    typedef basic_istream<charT,traits>   istream_type;\n\n    istreambuf_iterator() noexcept;\n    istreambuf_iterator(istream_type& s) noexcept;\n    istreambuf_iterator(streambuf_type* s) noexcept;\n    istreambuf_iterator(a-private-type) noexcept;\n\n    charT                operator*() const;\n    pointer operator->() const;\n    istreambuf_iterator& operator++();\n    a-private-type       operator++(int);\n\n    bool equal(const istreambuf_iterator& b) const;\n};\n\ntemplate <class charT, class traits>\nbool operator==(const istreambuf_iterator<charT,traits>& a,\n                const istreambuf_iterator<charT,traits>& b);\ntemplate <class charT, class traits>\nbool operator!=(const istreambuf_iterator<charT,traits>& a,\n                const istreambuf_iterator<charT,traits>& b);\n\ntemplate <class charT, class traits = char_traits<charT> >\nclass ostreambuf_iterator\n    : public iterator<output_iterator_tag, void, void, void, void>\n{\npublic:\n    typedef charT                         char_type;\n    typedef traits                        traits_type;\n    typedef basic_streambuf<charT,traits> streambuf_type;\n    typedef basic_ostream<charT,traits>   ostream_type;\n\n    ostreambuf_iterator(ostream_type& s) noexcept;\n    ostreambuf_iterator(streambuf_type* s) noexcept;\n    ostreambuf_iterator& operator=(charT c);\n    ostreambuf_iterator& operator*();\n    ostreambuf_iterator& operator++();\n    ostreambuf_iterator& operator++(int);\n    bool failed() const noexcept;\n};\n\ntemplate <class C> constexpr auto begin(C& c) -> decltype(c.begin());\ntemplate <class C> constexpr auto begin(const C& c) -> decltype(c.begin());\ntemplate <class C> constexpr auto end(C& c) -> decltype(c.end());\ntemplate <class C> constexpr auto end(const C& c) -> decltype(c.end());\ntemplate <class T, size_t N> constexpr T* begin(T (&array)[N]);\ntemplate <class T, size_t N> constexpr T* end(T (&array)[N]);\n\ntemplate <class C> auto constexpr cbegin(const C& c) -> decltype(std::begin(c));        // C++14\ntemplate <class C> auto constexpr cend(const C& c) -> decltype(std::end(c));            // C++14\ntemplate <class C> auto constexpr rbegin(C& c) -> decltype(c.rbegin());                 // C++14\ntemplate <class C> auto constexpr rbegin(const C& c) -> decltype(c.rbegin());           // C++14\ntemplate <class C> auto constexpr rend(C& c) -> decltype(c.rend());                     // C++14\ntemplate <class C> constexpr auto rend(const C& c) -> decltype(c.rend());               // C++14\ntemplate <class E> reverse_iterator<const E*> constexpr rbegin(initializer_list<E> il); // C++14\ntemplate <class E> reverse_iterator<const E*> constexpr rend(initializer_list<E> il);   // C++14\ntemplate <class T, size_t N> reverse_iterator<T*> constexpr rbegin(T (&array)[N]);      // C++14\ntemplate <class T, size_t N> reverse_iterator<T*> constexpr rend(T (&array)[N]);        // C++14\ntemplate <class C> constexpr auto crbegin(const C& c) -> decltype(std::rbegin(c));      // C++14\ntemplate <class C> constexpr auto crend(const C& c) -> decltype(std::rend(c));          // C++14\n\n// 24.8, container access:\ntemplate <class C> constexpr auto size(const C& c) -> decltype(c.size());         // C++17\ntemplate <class T, size_t N> constexpr size_t size(const T (&array)[N]) noexcept; // C++17\ntemplate <class C> constexpr auto empty(const C& c) -> decltype(c.empty());       // C++17\ntemplate <class T, size_t N> constexpr bool empty(const T (&array)[N]) noexcept;  // C++17\ntemplate <class E> constexpr bool empty(initializer_list<E> il) noexcept;         // C++17\ntemplate <class C> constexpr auto data(C& c) -> decltype(c.data());               // C++17\ntemplate <class C> constexpr auto data(const C& c) -> decltype(c.data());         // C++17\ntemplate <class T, size_t N> constexpr T* data(T (&array)[N]) noexcept;           // C++17\ntemplate <class E> constexpr const E* data(initializer_list<E> il) noexcept;      // C++17\n\n}  // std\n\n*/\n\n#include <__config>\n#include <iosfwd> // for forward declarations of vector and string.\n#include <__functional_base>\n#include <type_traits>\n#include <cstddef>\n#include <initializer_list>\n#ifdef __APPLE__\n#include <Availability.h>\n#endif\n\n#include <__debug>\n\n#if !defined(_LIBCPP_HAS_NO_PRAGMA_SYSTEM_HEADER)\n#pragma GCC system_header\n#endif\n\n_LIBCPP_BEGIN_NAMESPACE_STD\n\nstruct _LIBCPP_TEMPLATE_VIS input_iterator_tag {};\nstruct _LIBCPP_TEMPLATE_VIS output_iterator_tag {};\nstruct _LIBCPP_TEMPLATE_VIS forward_iterator_tag       : public input_iterator_tag {};\nstruct _LIBCPP_TEMPLATE_VIS bidirectional_iterator_tag : public forward_iterator_tag {};\nstruct _LIBCPP_TEMPLATE_VIS random_access_iterator_tag : public bidirectional_iterator_tag {};\n\ntemplate <class _Tp>\nstruct __has_iterator_category\n{\nprivate:\n    struct __two {char __lx; char __lxx;};\n    template <class _Up> static __two __test(...);\n    template <class _Up> static char __test(typename _Up::iterator_category* = 0);\npublic:\n    static const bool value = sizeof(__test<_Tp>(0)) == 1;\n};\n\ntemplate <class _Iter, bool> struct __iterator_traits_impl {};\n\ntemplate <class _Iter>\nstruct __iterator_traits_impl<_Iter, true>\n{\n    typedef typename _Iter::difference_type   difference_type;\n    typedef typename _Iter::value_type        value_type;\n    typedef typename _Iter::pointer           pointer;\n    typedef typename _Iter::reference         reference;\n    typedef typename _Iter::iterator_category iterator_category;\n};\n\ntemplate <class _Iter, bool> struct __iterator_traits {};\n\ntemplate <class _Iter>\nstruct __iterator_traits<_Iter, true>\n    :  __iterator_traits_impl\n      <\n        _Iter,\n        is_convertible<typename _Iter::iterator_category, input_iterator_tag>::value ||\n        is_convertible<typename _Iter::iterator_category, output_iterator_tag>::value\n      >\n{};\n\n// iterator_traits<Iterator> will only have the nested types if Iterator::iterator_category\n//    exists.  Else iterator_traits<Iterator> will be an empty class.  This is a\n//    conforming extension which allows some programs to compile and behave as\n//    the client expects instead of failing at compile time.\n\ntemplate <class _Iter>\nstruct _LIBCPP_TEMPLATE_VIS iterator_traits\n    : __iterator_traits<_Iter, __has_iterator_category<_Iter>::value> {};\n\ntemplate<class _Tp>\nstruct _LIBCPP_TEMPLATE_VIS iterator_traits<_Tp*>\n{\n    typedef ptrdiff_t difference_type;\n    typedef typename remove_const<_Tp>::type value_type;\n    typedef _Tp* pointer;\n    typedef _Tp& reference;\n    typedef random_access_iterator_tag iterator_category;\n};\n\ntemplate <class _Tp, class _Up, bool = __has_iterator_category<iterator_traits<_Tp> >::value>\nstruct __has_iterator_category_convertible_to\n    : public integral_constant<bool, is_convertible<typename iterator_traits<_Tp>::iterator_category, _Up>::value>\n{};\n\ntemplate <class _Tp, class _Up>\nstruct __has_iterator_category_convertible_to<_Tp, _Up, false> : public false_type {};\n\ntemplate <class _Tp>\nstruct __is_input_iterator : public __has_iterator_category_convertible_to<_Tp, input_iterator_tag> {};\n\ntemplate <class _Tp>\nstruct __is_forward_iterator : public __has_iterator_category_convertible_to<_Tp, forward_iterator_tag> {};\n\ntemplate <class _Tp>\nstruct __is_bidirectional_iterator : public __has_iterator_category_convertible_to<_Tp, bidirectional_iterator_tag> {};\n\ntemplate <class _Tp>\nstruct __is_random_access_iterator : public __has_iterator_category_convertible_to<_Tp, random_access_iterator_tag> {};\n\ntemplate <class _Tp>\nstruct __is_exactly_input_iterator\n    : public integral_constant<bool, \n         __has_iterator_category_convertible_to<_Tp, input_iterator_tag>::value && \n        !__has_iterator_category_convertible_to<_Tp, forward_iterator_tag>::value> {};\n\ntemplate<class _Category, class _Tp, class _Distance = ptrdiff_t,\n         class _Pointer = _Tp*, class _Reference = _Tp&>\nstruct _LIBCPP_TEMPLATE_VIS iterator\n{\n    typedef _Tp        value_type;\n    typedef _Distance  difference_type;\n    typedef _Pointer   pointer;\n    typedef _Reference reference;\n    typedef _Category  iterator_category;\n};\n\ntemplate <class _InputIter>\ninline _LIBCPP_INLINE_VISIBILITY\nvoid __advance(_InputIter& __i,\n             typename iterator_traits<_InputIter>::difference_type __n, input_iterator_tag)\n{\n    for (; __n > 0; --__n)\n        ++__i;\n}\n\ntemplate <class _BiDirIter>\ninline _LIBCPP_INLINE_VISIBILITY\nvoid __advance(_BiDirIter& __i,\n             typename iterator_traits<_BiDirIter>::difference_type __n, bidirectional_iterator_tag)\n{\n    if (__n >= 0)\n        for (; __n > 0; --__n)\n            ++__i;\n    else\n        for (; __n < 0; ++__n)\n            --__i;\n}\n\ntemplate <class _RandIter>\ninline _LIBCPP_INLINE_VISIBILITY\nvoid __advance(_RandIter& __i,\n             typename iterator_traits<_RandIter>::difference_type __n, random_access_iterator_tag)\n{\n   __i += __n;\n}\n\ntemplate <class _InputIter>\ninline _LIBCPP_INLINE_VISIBILITY\nvoid advance(_InputIter& __i,\n             typename iterator_traits<_InputIter>::difference_type __n)\n{\n    __advance(__i, __n, typename iterator_traits<_InputIter>::iterator_category());\n}\n\ntemplate <class _InputIter>\ninline _LIBCPP_INLINE_VISIBILITY\ntypename iterator_traits<_InputIter>::difference_type\n__distance(_InputIter __first, _InputIter __last, input_iterator_tag)\n{\n    typename iterator_traits<_InputIter>::difference_type __r(0);\n    for (; __first != __last; ++__first)\n        ++__r;\n    return __r;\n}\n\ntemplate <class _RandIter>\ninline _LIBCPP_INLINE_VISIBILITY\ntypename iterator_traits<_RandIter>::difference_type\n__distance(_RandIter __first, _RandIter __last, random_access_iterator_tag)\n{\n    return __last - __first;\n}\n\ntemplate <class _InputIter>\ninline _LIBCPP_INLINE_VISIBILITY\ntypename iterator_traits<_InputIter>::difference_type\ndistance(_InputIter __first, _InputIter __last)\n{\n    return __distance(__first, __last, typename iterator_traits<_InputIter>::iterator_category());\n}\n\ntemplate <class _InputIter>\ninline _LIBCPP_INLINE_VISIBILITY\n_InputIter\nnext(_InputIter __x,\n     typename iterator_traits<_InputIter>::difference_type __n = 1,\n     typename enable_if<__is_input_iterator<_InputIter>::value>::type* = 0)\n{\n    _VSTD::advance(__x, __n);\n    return __x;\n}\n\ntemplate <class _BidiretionalIter>\ninline _LIBCPP_INLINE_VISIBILITY\n_BidiretionalIter\nprev(_BidiretionalIter __x,\n     typename iterator_traits<_BidiretionalIter>::difference_type __n = 1,\n     typename enable_if<__is_bidirectional_iterator<_BidiretionalIter>::value>::type* = 0)\n{\n    _VSTD::advance(__x, -__n);\n    return __x;\n}\n\ntemplate <class _Iter>\nclass _LIBCPP_TEMPLATE_VIS reverse_iterator\n    : public iterator<typename iterator_traits<_Iter>::iterator_category,\n                      typename iterator_traits<_Iter>::value_type,\n                      typename iterator_traits<_Iter>::difference_type,\n                      typename iterator_traits<_Iter>::pointer,\n                      typename iterator_traits<_Iter>::reference>\n{\nprivate:\n    /*mutable*/ _Iter __t;  // no longer used as of LWG #2360, not removed due to ABI break\nprotected:\n    _Iter current;\npublic:\n    typedef _Iter                                            iterator_type;\n    typedef typename iterator_traits<_Iter>::difference_type difference_type;\n    typedef typename iterator_traits<_Iter>::reference       reference;\n    typedef typename iterator_traits<_Iter>::pointer         pointer;\n\n    _LIBCPP_INLINE_VISIBILITY _LIBCPP_CONSTEXPR_AFTER_CXX14\n    reverse_iterator() : __t(), current() {}\n    _LIBCPP_INLINE_VISIBILITY _LIBCPP_CONSTEXPR_AFTER_CXX14\n    explicit reverse_iterator(_Iter __x) : __t(__x), current(__x) {}\n    template <class _Up>\n        _LIBCPP_INLINE_VISIBILITY _LIBCPP_CONSTEXPR_AFTER_CXX14\n        reverse_iterator(const reverse_iterator<_Up>& __u) : __t(__u.base()), current(__u.base()) {}\n    template <class _Up>\n        _LIBCPP_INLINE_VISIBILITY _LIBCPP_CONSTEXPR_AFTER_CXX14\n        reverse_iterator& operator=(const reverse_iterator<_Up>& __u)\n            { __t = current = __u.base(); return *this; }\n    _LIBCPP_INLINE_VISIBILITY _LIBCPP_CONSTEXPR_AFTER_CXX14\n    _Iter base() const {return current;}\n    _LIBCPP_INLINE_VISIBILITY _LIBCPP_CONSTEXPR_AFTER_CXX14\n    reference operator*() const {_Iter __tmp = current; return *--__tmp;}\n    _LIBCPP_INLINE_VISIBILITY _LIBCPP_CONSTEXPR_AFTER_CXX14\n    pointer  operator->() const {return _VSTD::addressof(operator*());}\n    _LIBCPP_INLINE_VISIBILITY _LIBCPP_CONSTEXPR_AFTER_CXX14\n    reverse_iterator& operator++() {--current; return *this;}\n    _LIBCPP_INLINE_VISIBILITY _LIBCPP_CONSTEXPR_AFTER_CXX14\n    reverse_iterator  operator++(int) {reverse_iterator __tmp(*this); --current; return __tmp;}\n    _LIBCPP_INLINE_VISIBILITY _LIBCPP_CONSTEXPR_AFTER_CXX14\n    reverse_iterator& operator--() {++current; return *this;}\n    _LIBCPP_INLINE_VISIBILITY _LIBCPP_CONSTEXPR_AFTER_CXX14\n    reverse_iterator  operator--(int) {reverse_iterator __tmp(*this); ++current; return __tmp;}\n    _LIBCPP_INLINE_VISIBILITY _LIBCPP_CONSTEXPR_AFTER_CXX14\n    reverse_iterator  operator+ (difference_type __n) const {return reverse_iterator(current - __n);}\n    _LIBCPP_INLINE_VISIBILITY _LIBCPP_CONSTEXPR_AFTER_CXX14\n    reverse_iterator& operator+=(difference_type __n) {current -= __n; return *this;}\n    _LIBCPP_INLINE_VISIBILITY _LIBCPP_CONSTEXPR_AFTER_CXX14\n    reverse_iterator  operator- (difference_type __n) const {return reverse_iterator(current + __n);}\n    _LIBCPP_INLINE_VISIBILITY _LIBCPP_CONSTEXPR_AFTER_CXX14\n    reverse_iterator& operator-=(difference_type __n) {current += __n; return *this;}\n    _LIBCPP_INLINE_VISIBILITY _LIBCPP_CONSTEXPR_AFTER_CXX14\n    reference         operator[](difference_type __n) const {return *(*this + __n);}\n};\n\ntemplate <class _Iter1, class _Iter2>\ninline _LIBCPP_INLINE_VISIBILITY _LIBCPP_CONSTEXPR_AFTER_CXX14\nbool\noperator==(const reverse_iterator<_Iter1>& __x, const reverse_iterator<_Iter2>& __y)\n{\n    return __x.base() == __y.base();\n}\n\ntemplate <class _Iter1, class _Iter2>\ninline _LIBCPP_INLINE_VISIBILITY _LIBCPP_CONSTEXPR_AFTER_CXX14\nbool\noperator<(const reverse_iterator<_Iter1>& __x, const reverse_iterator<_Iter2>& __y)\n{\n    return __x.base() > __y.base();\n}\n\ntemplate <class _Iter1, class _Iter2>\ninline _LIBCPP_INLINE_VISIBILITY _LIBCPP_CONSTEXPR_AFTER_CXX14\nbool\noperator!=(const reverse_iterator<_Iter1>& __x, const reverse_iterator<_Iter2>& __y)\n{\n    return __x.base() != __y.base();\n}\n\ntemplate <class _Iter1, class _Iter2>\ninline _LIBCPP_INLINE_VISIBILITY _LIBCPP_CONSTEXPR_AFTER_CXX14\nbool\noperator>(const reverse_iterator<_Iter1>& __x, const reverse_iterator<_Iter2>& __y)\n{\n    return __x.base() < __y.base();\n}\n\ntemplate <class _Iter1, class _Iter2>\ninline _LIBCPP_INLINE_VISIBILITY _LIBCPP_CONSTEXPR_AFTER_CXX14\nbool\noperator>=(const reverse_iterator<_Iter1>& __x, const reverse_iterator<_Iter2>& __y)\n{\n    return __x.base() <= __y.base();\n}\n\ntemplate <class _Iter1, class _Iter2>\ninline _LIBCPP_INLINE_VISIBILITY _LIBCPP_CONSTEXPR_AFTER_CXX14\nbool\noperator<=(const reverse_iterator<_Iter1>& __x, const reverse_iterator<_Iter2>& __y)\n{\n    return __x.base() >= __y.base();\n}\n\n#ifndef _LIBCPP_CXX03_LANG\ntemplate <class _Iter1, class _Iter2>\ninline _LIBCPP_INLINE_VISIBILITY _LIBCPP_CONSTEXPR_AFTER_CXX14\nauto\noperator-(const reverse_iterator<_Iter1>& __x, const reverse_iterator<_Iter2>& __y)\n-> decltype(__y.base() - __x.base())\n{\n    return __y.base() - __x.base();\n}\n#else\ntemplate <class _Iter1, class _Iter2>\ninline _LIBCPP_INLINE_VISIBILITY\ntypename reverse_iterator<_Iter1>::difference_type\noperator-(const reverse_iterator<_Iter1>& __x, const reverse_iterator<_Iter2>& __y)\n{\n    return __y.base() - __x.base();\n}\n#endif\n\ntemplate <class _Iter>\ninline _LIBCPP_INLINE_VISIBILITY _LIBCPP_CONSTEXPR_AFTER_CXX14\nreverse_iterator<_Iter>\noperator+(typename reverse_iterator<_Iter>::difference_type __n, const reverse_iterator<_Iter>& __x)\n{\n    return reverse_iterator<_Iter>(__x.base() - __n);\n}\n\n#if _LIBCPP_STD_VER > 11\ntemplate <class _Iter>\ninline _LIBCPP_INLINE_VISIBILITY _LIBCPP_CONSTEXPR_AFTER_CXX14\nreverse_iterator<_Iter> make_reverse_iterator(_Iter __i)\n{\n    return reverse_iterator<_Iter>(__i);\n}\n#endif\n\ntemplate <class _Container>\nclass _LIBCPP_TEMPLATE_VIS back_insert_iterator\n    : public iterator<output_iterator_tag,\n                      void,\n                      void,\n                      void,\n                      void>\n{\nprotected:\n    _Container* container;\npublic:\n    typedef _Container container_type;\n\n    _LIBCPP_INLINE_VISIBILITY explicit back_insert_iterator(_Container& __x) : container(_VSTD::addressof(__x)) {}\n    _LIBCPP_INLINE_VISIBILITY back_insert_iterator& operator=(const typename _Container::value_type& __value_)\n        {container->push_back(__value_); return *this;}\n#ifndef _LIBCPP_HAS_NO_RVALUE_REFERENCES\n    _LIBCPP_INLINE_VISIBILITY back_insert_iterator& operator=(typename _Container::value_type&& __value_)\n        {container->push_back(_VSTD::move(__value_)); return *this;}\n#endif  // _LIBCPP_HAS_NO_RVALUE_REFERENCES\n    _LIBCPP_INLINE_VISIBILITY back_insert_iterator& operator*()     {return *this;}\n    _LIBCPP_INLINE_VISIBILITY back_insert_iterator& operator++()    {return *this;}\n    _LIBCPP_INLINE_VISIBILITY back_insert_iterator  operator++(int) {return *this;}\n};\n\ntemplate <class _Container>\ninline _LIBCPP_INLINE_VISIBILITY\nback_insert_iterator<_Container>\nback_inserter(_Container& __x)\n{\n    return back_insert_iterator<_Container>(__x);\n}\n\ntemplate <class _Container>\nclass _LIBCPP_TEMPLATE_VIS front_insert_iterator\n    : public iterator<output_iterator_tag,\n                      void,\n                      void,\n                      void,\n                      void>\n{\nprotected:\n    _Container* container;\npublic:\n    typedef _Container container_type;\n\n    _LIBCPP_INLINE_VISIBILITY explicit front_insert_iterator(_Container& __x) : container(_VSTD::addressof(__x)) {}\n    _LIBCPP_INLINE_VISIBILITY front_insert_iterator& operator=(const typename _Container::value_type& __value_)\n        {container->push_front(__value_); return *this;}\n#ifndef _LIBCPP_HAS_NO_RVALUE_REFERENCES\n    _LIBCPP_INLINE_VISIBILITY front_insert_iterator& operator=(typename _Container::value_type&& __value_)\n        {container->push_front(_VSTD::move(__value_)); return *this;}\n#endif  // _LIBCPP_HAS_NO_RVALUE_REFERENCES\n    _LIBCPP_INLINE_VISIBILITY front_insert_iterator& operator*()     {return *this;}\n    _LIBCPP_INLINE_VISIBILITY front_insert_iterator& operator++()    {return *this;}\n    _LIBCPP_INLINE_VISIBILITY front_insert_iterator  operator++(int) {return *this;}\n};\n\ntemplate <class _Container>\ninline _LIBCPP_INLINE_VISIBILITY\nfront_insert_iterator<_Container>\nfront_inserter(_Container& __x)\n{\n    return front_insert_iterator<_Container>(__x);\n}\n\ntemplate <class _Container>\nclass _LIBCPP_TEMPLATE_VIS insert_iterator\n    : public iterator<output_iterator_tag,\n                      void,\n                      void,\n                      void,\n                      void>\n{\nprotected:\n    _Container* container;\n    typename _Container::iterator iter;\npublic:\n    typedef _Container container_type;\n\n    _LIBCPP_INLINE_VISIBILITY insert_iterator(_Container& __x, typename _Container::iterator __i)\n        : container(_VSTD::addressof(__x)), iter(__i) {}\n    _LIBCPP_INLINE_VISIBILITY insert_iterator& operator=(const typename _Container::value_type& __value_)\n        {iter = container->insert(iter, __value_); ++iter; return *this;}\n#ifndef _LIBCPP_HAS_NO_RVALUE_REFERENCES\n    _LIBCPP_INLINE_VISIBILITY insert_iterator& operator=(typename _Container::value_type&& __value_)\n        {iter = container->insert(iter, _VSTD::move(__value_)); ++iter; return *this;}\n#endif  // _LIBCPP_HAS_NO_RVALUE_REFERENCES\n    _LIBCPP_INLINE_VISIBILITY insert_iterator& operator*()        {return *this;}\n    _LIBCPP_INLINE_VISIBILITY insert_iterator& operator++()       {return *this;}\n    _LIBCPP_INLINE_VISIBILITY insert_iterator& operator++(int)    {return *this;}\n};\n\ntemplate <class _Container>\ninline _LIBCPP_INLINE_VISIBILITY\ninsert_iterator<_Container>\ninserter(_Container& __x, typename _Container::iterator __i)\n{\n    return insert_iterator<_Container>(__x, __i);\n}\n\ntemplate <class _Tp, class _CharT = char,\n          class _Traits = char_traits<_CharT>, class _Distance = ptrdiff_t>\nclass _LIBCPP_TEMPLATE_VIS istream_iterator\n    : public iterator<input_iterator_tag, _Tp, _Distance, const _Tp*, const _Tp&>\n{\npublic:\n    typedef _CharT char_type;\n    typedef _Traits traits_type;\n    typedef basic_istream<_CharT,_Traits> istream_type;\nprivate:\n    istream_type* __in_stream_;\n    _Tp __value_;\npublic:\n    _LIBCPP_INLINE_VISIBILITY _LIBCPP_CONSTEXPR istream_iterator() : __in_stream_(0), __value_() {}\n    _LIBCPP_INLINE_VISIBILITY istream_iterator(istream_type& __s) : __in_stream_(_VSTD::addressof(__s))\n        {\n            if (!(*__in_stream_ >> __value_))\n                __in_stream_ = 0;\n        }\n\n    _LIBCPP_INLINE_VISIBILITY const _Tp& operator*() const {return __value_;}\n    _LIBCPP_INLINE_VISIBILITY const _Tp* operator->() const {return _VSTD::addressof((operator*()));}\n    _LIBCPP_INLINE_VISIBILITY istream_iterator& operator++()\n        {\n            if (!(*__in_stream_ >> __value_))\n                __in_stream_ = 0;\n            return *this;\n        }\n    _LIBCPP_INLINE_VISIBILITY istream_iterator  operator++(int)\n        {istream_iterator __t(*this); ++(*this); return __t;}\n\n    friend _LIBCPP_INLINE_VISIBILITY\n    bool operator==(const istream_iterator& __x, const istream_iterator& __y)\n        {return __x.__in_stream_ == __y.__in_stream_;}\n\n    friend _LIBCPP_INLINE_VISIBILITY\n    bool operator!=(const istream_iterator& __x, const istream_iterator& __y)\n        {return !(__x == __y);}\n};\n\ntemplate <class _Tp, class _CharT = char, class _Traits = char_traits<_CharT> >\nclass _LIBCPP_TEMPLATE_VIS ostream_iterator\n    : public iterator<output_iterator_tag, void, void, void, void>\n{\npublic:\n    typedef _CharT char_type;\n    typedef _Traits traits_type;\n    typedef basic_ostream<_CharT,_Traits> ostream_type;\nprivate:\n    ostream_type* __out_stream_;\n    const char_type* __delim_;\npublic:\n    _LIBCPP_INLINE_VISIBILITY ostream_iterator(ostream_type& __s) _NOEXCEPT\n        : __out_stream_(_VSTD::addressof(__s)), __delim_(0) {}\n    _LIBCPP_INLINE_VISIBILITY ostream_iterator(ostream_type& __s, const _CharT* __delimiter) _NOEXCEPT\n        : __out_stream_(_VSTD::addressof(__s)), __delim_(__delimiter) {}\n    _LIBCPP_INLINE_VISIBILITY ostream_iterator& operator=(const _Tp& __value_)\n        {\n            *__out_stream_ << __value_;\n            if (__delim_)\n                *__out_stream_ << __delim_;\n            return *this;\n        }\n\n    _LIBCPP_INLINE_VISIBILITY ostream_iterator& operator*()     {return *this;}\n    _LIBCPP_INLINE_VISIBILITY ostream_iterator& operator++()    {return *this;}\n    _LIBCPP_INLINE_VISIBILITY ostream_iterator& operator++(int) {return *this;}\n};\n\ntemplate<class _CharT, class _Traits>\nclass _LIBCPP_TEMPLATE_VIS istreambuf_iterator\n    : public iterator<input_iterator_tag, _CharT,\n                      typename _Traits::off_type, _CharT*,\n                      _CharT>\n{\npublic:\n    typedef _CharT                          char_type;\n    typedef _Traits                         traits_type;\n    typedef typename _Traits::int_type      int_type;\n    typedef basic_streambuf<_CharT,_Traits> streambuf_type;\n    typedef basic_istream<_CharT,_Traits>   istream_type;\nprivate:\n    mutable streambuf_type* __sbuf_;\n\n    class __proxy\n    {\n        char_type __keep_;\n        streambuf_type* __sbuf_;\n        _LIBCPP_INLINE_VISIBILITY __proxy(char_type __c, streambuf_type* __s)\n            : __keep_(__c), __sbuf_(__s) {}\n        friend class istreambuf_iterator;\n    public:\n        _LIBCPP_INLINE_VISIBILITY char_type operator*() const {return __keep_;}\n    };\n\n    _LIBCPP_INLINE_VISIBILITY\n    bool __test_for_eof() const\n    {\n        if (__sbuf_ && traits_type::eq_int_type(__sbuf_->sgetc(), traits_type::eof()))\n            __sbuf_ = 0;\n        return __sbuf_ == 0;\n    }\npublic:\n    _LIBCPP_INLINE_VISIBILITY _LIBCPP_CONSTEXPR istreambuf_iterator() _NOEXCEPT : __sbuf_(0) {}\n    _LIBCPP_INLINE_VISIBILITY istreambuf_iterator(istream_type& __s) _NOEXCEPT\n        : __sbuf_(__s.rdbuf()) {}\n    _LIBCPP_INLINE_VISIBILITY istreambuf_iterator(streambuf_type* __s) _NOEXCEPT\n        : __sbuf_(__s) {}\n    _LIBCPP_INLINE_VISIBILITY istreambuf_iterator(const __proxy& __p) _NOEXCEPT\n        : __sbuf_(__p.__sbuf_) {}\n\n    _LIBCPP_INLINE_VISIBILITY char_type  operator*() const\n        {return static_cast<char_type>(__sbuf_->sgetc());}\n    _LIBCPP_INLINE_VISIBILITY char_type* operator->() const {return nullptr;}\n    _LIBCPP_INLINE_VISIBILITY istreambuf_iterator& operator++()\n        {\n            __sbuf_->sbumpc();\n            return *this;\n        }\n    _LIBCPP_INLINE_VISIBILITY __proxy              operator++(int)\n        {\n            return __proxy(__sbuf_->sbumpc(), __sbuf_);\n        }\n\n    _LIBCPP_INLINE_VISIBILITY bool equal(const istreambuf_iterator& __b) const\n        {return __test_for_eof() == __b.__test_for_eof();}\n};\n\ntemplate <class _CharT, class _Traits>\ninline _LIBCPP_INLINE_VISIBILITY\nbool operator==(const istreambuf_iterator<_CharT,_Traits>& __a,\n                const istreambuf_iterator<_CharT,_Traits>& __b)\n                {return __a.equal(__b);}\n\ntemplate <class _CharT, class _Traits>\ninline _LIBCPP_INLINE_VISIBILITY\nbool operator!=(const istreambuf_iterator<_CharT,_Traits>& __a,\n                const istreambuf_iterator<_CharT,_Traits>& __b)\n                {return !__a.equal(__b);}\n\ntemplate <class _CharT, class _Traits>\nclass _LIBCPP_TEMPLATE_VIS ostreambuf_iterator\n    : public iterator<output_iterator_tag, void, void, void, void>\n{\npublic:\n    typedef _CharT                          char_type;\n    typedef _Traits                         traits_type;\n    typedef basic_streambuf<_CharT,_Traits> streambuf_type;\n    typedef basic_ostream<_CharT,_Traits>   ostream_type;\nprivate:\n    streambuf_type* __sbuf_;\npublic:\n    _LIBCPP_INLINE_VISIBILITY ostreambuf_iterator(ostream_type& __s) _NOEXCEPT\n        : __sbuf_(__s.rdbuf()) {}\n    _LIBCPP_INLINE_VISIBILITY ostreambuf_iterator(streambuf_type* __s) _NOEXCEPT\n        : __sbuf_(__s) {}\n    _LIBCPP_INLINE_VISIBILITY ostreambuf_iterator& operator=(_CharT __c)\n        {\n            if (__sbuf_ && traits_type::eq_int_type(__sbuf_->sputc(__c), traits_type::eof()))\n                __sbuf_ = 0;\n            return *this;\n        }\n    _LIBCPP_INLINE_VISIBILITY ostreambuf_iterator& operator*()     {return *this;}\n    _LIBCPP_INLINE_VISIBILITY ostreambuf_iterator& operator++()    {return *this;}\n    _LIBCPP_INLINE_VISIBILITY ostreambuf_iterator& operator++(int) {return *this;}\n    _LIBCPP_INLINE_VISIBILITY bool failed() const _NOEXCEPT {return __sbuf_ == 0;}\n\n#if !defined(__APPLE__) || \\\n    (defined(__MAC_OS_X_VERSION_MIN_REQUIRED) && __MAC_OS_X_VERSION_MIN_REQUIRED > __MAC_10_8) || \\\n    (defined(__IPHONE_OS_VERSION_MIN_REQUIRED) && __IPHONE_OS_VERSION_MIN_REQUIRED > __IPHONE_6_0)\n\n    template <class _Ch, class _Tr>\n    friend\n    _LIBCPP_HIDDEN\n    ostreambuf_iterator<_Ch, _Tr>\n    __pad_and_output(ostreambuf_iterator<_Ch, _Tr> __s,\n                     const _Ch* __ob, const _Ch* __op, const _Ch* __oe,\n                     ios_base& __iob, _Ch __fl);\n#endif\n};\n\ntemplate <class _Iter>\nclass _LIBCPP_TEMPLATE_VIS move_iterator\n{\nprivate:\n    _Iter __i;\npublic:\n    typedef _Iter                                            iterator_type;\n    typedef typename iterator_traits<iterator_type>::iterator_category iterator_category;\n    typedef typename iterator_traits<iterator_type>::value_type value_type;\n    typedef typename iterator_traits<iterator_type>::difference_type difference_type;\n    typedef iterator_type pointer;\n#ifndef _LIBCPP_HAS_NO_RVALUE_REFERENCES\n    typedef typename iterator_traits<iterator_type>::reference __reference;\n    typedef typename conditional<\n            is_reference<__reference>::value,\n            typename remove_reference<__reference>::type&&,\n            __reference\n        >::type reference;\n#else\n    typedef typename iterator_traits<iterator_type>::reference reference;\n#endif\n\n    _LIBCPP_INLINE_VISIBILITY _LIBCPP_CONSTEXPR_AFTER_CXX14\n    move_iterator() : __i() {}\n    _LIBCPP_INLINE_VISIBILITY _LIBCPP_CONSTEXPR_AFTER_CXX14\n    explicit move_iterator(_Iter __x) : __i(__x) {}\n    template <class _Up>\n      _LIBCPP_INLINE_VISIBILITY _LIBCPP_CONSTEXPR_AFTER_CXX14\n      move_iterator(const move_iterator<_Up>& __u) : __i(__u.base()) {}\n    _LIBCPP_INLINE_VISIBILITY _LIBCPP_CONSTEXPR_AFTER_CXX14 _Iter base() const {return __i;}\n    _LIBCPP_INLINE_VISIBILITY _LIBCPP_CONSTEXPR_AFTER_CXX14 \n    reference operator*() const { return static_cast<reference>(*__i); }\n    _LIBCPP_INLINE_VISIBILITY _LIBCPP_CONSTEXPR_AFTER_CXX14\n    pointer  operator->() const { return __i;}\n    _LIBCPP_INLINE_VISIBILITY _LIBCPP_CONSTEXPR_AFTER_CXX14\n    move_iterator& operator++() {++__i; return *this;}\n    _LIBCPP_INLINE_VISIBILITY _LIBCPP_CONSTEXPR_AFTER_CXX14\n    move_iterator  operator++(int) {move_iterator __tmp(*this); ++__i; return __tmp;}\n    _LIBCPP_INLINE_VISIBILITY _LIBCPP_CONSTEXPR_AFTER_CXX14\n    move_iterator& operator--() {--__i; return *this;}\n    _LIBCPP_INLINE_VISIBILITY _LIBCPP_CONSTEXPR_AFTER_CXX14\n    move_iterator  operator--(int) {move_iterator __tmp(*this); --__i; return __tmp;}\n    _LIBCPP_INLINE_VISIBILITY _LIBCPP_CONSTEXPR_AFTER_CXX14\n    move_iterator  operator+ (difference_type __n) const {return move_iterator(__i + __n);}\n    _LIBCPP_INLINE_VISIBILITY _LIBCPP_CONSTEXPR_AFTER_CXX14\n    move_iterator& operator+=(difference_type __n) {__i += __n; return *this;}\n    _LIBCPP_INLINE_VISIBILITY _LIBCPP_CONSTEXPR_AFTER_CXX14\n    move_iterator  operator- (difference_type __n) const {return move_iterator(__i - __n);}\n    _LIBCPP_INLINE_VISIBILITY _LIBCPP_CONSTEXPR_AFTER_CXX14\n    move_iterator& operator-=(difference_type __n) {__i -= __n; return *this;}\n    _LIBCPP_INLINE_VISIBILITY _LIBCPP_CONSTEXPR_AFTER_CXX14\n    reference operator[](difference_type __n) const { return static_cast<reference>(__i[__n]); }\n};\n\ntemplate <class _Iter1, class _Iter2>\ninline _LIBCPP_INLINE_VISIBILITY _LIBCPP_CONSTEXPR_AFTER_CXX14\nbool\noperator==(const move_iterator<_Iter1>& __x, const move_iterator<_Iter2>& __y)\n{\n    return __x.base() == __y.base();\n}\n\ntemplate <class _Iter1, class _Iter2>\ninline _LIBCPP_INLINE_VISIBILITY _LIBCPP_CONSTEXPR_AFTER_CXX14\nbool\noperator<(const move_iterator<_Iter1>& __x, const move_iterator<_Iter2>& __y)\n{\n    return __x.base() < __y.base();\n}\n\ntemplate <class _Iter1, class _Iter2>\ninline _LIBCPP_INLINE_VISIBILITY _LIBCPP_CONSTEXPR_AFTER_CXX14\nbool\noperator!=(const move_iterator<_Iter1>& __x, const move_iterator<_Iter2>& __y)\n{\n    return __x.base() != __y.base();\n}\n\ntemplate <class _Iter1, class _Iter2>\ninline _LIBCPP_INLINE_VISIBILITY _LIBCPP_CONSTEXPR_AFTER_CXX14\nbool\noperator>(const move_iterator<_Iter1>& __x, const move_iterator<_Iter2>& __y)\n{\n    return __x.base() > __y.base();\n}\n\ntemplate <class _Iter1, class _Iter2>\ninline _LIBCPP_INLINE_VISIBILITY _LIBCPP_CONSTEXPR_AFTER_CXX14\nbool\noperator>=(const move_iterator<_Iter1>& __x, const move_iterator<_Iter2>& __y)\n{\n    return __x.base() >= __y.base();\n}\n\ntemplate <class _Iter1, class _Iter2>\ninline _LIBCPP_INLINE_VISIBILITY _LIBCPP_CONSTEXPR_AFTER_CXX14\nbool\noperator<=(const move_iterator<_Iter1>& __x, const move_iterator<_Iter2>& __y)\n{\n    return __x.base() <= __y.base();\n}\n\n#ifndef _LIBCPP_CXX03_LANG\ntemplate <class _Iter1, class _Iter2>\ninline _LIBCPP_INLINE_VISIBILITY _LIBCPP_CONSTEXPR_AFTER_CXX14\nauto\noperator-(const move_iterator<_Iter1>& __x, const move_iterator<_Iter2>& __y)\n-> decltype(__x.base() - __y.base())\n{\n    return __x.base() - __y.base();\n}\n#else\ntemplate <class _Iter1, class _Iter2>\ninline _LIBCPP_INLINE_VISIBILITY\ntypename move_iterator<_Iter1>::difference_type\noperator-(const move_iterator<_Iter1>& __x, const move_iterator<_Iter2>& __y)\n{\n    return __x.base() - __y.base();\n}\n#endif\n\ntemplate <class _Iter>\ninline _LIBCPP_INLINE_VISIBILITY _LIBCPP_CONSTEXPR_AFTER_CXX14\nmove_iterator<_Iter>\noperator+(typename move_iterator<_Iter>::difference_type __n, const move_iterator<_Iter>& __x)\n{\n    return move_iterator<_Iter>(__x.base() + __n);\n}\n\ntemplate <class _Iter>\ninline _LIBCPP_INLINE_VISIBILITY _LIBCPP_CONSTEXPR_AFTER_CXX14\nmove_iterator<_Iter>\nmake_move_iterator(_Iter __i)\n{\n    return move_iterator<_Iter>(__i);\n}\n\n// __wrap_iter\n\ntemplate <class _Iter> class __wrap_iter;\n\ntemplate <class _Iter1, class _Iter2>\n_LIBCPP_INLINE_VISIBILITY\nbool\noperator==(const __wrap_iter<_Iter1>&, const __wrap_iter<_Iter2>&) _NOEXCEPT_DEBUG;\n\ntemplate <class _Iter1, class _Iter2>\n_LIBCPP_INLINE_VISIBILITY\nbool\noperator<(const __wrap_iter<_Iter1>&, const __wrap_iter<_Iter2>&) _NOEXCEPT_DEBUG;\n\ntemplate <class _Iter1, class _Iter2>\n_LIBCPP_INLINE_VISIBILITY\nbool\noperator!=(const __wrap_iter<_Iter1>&, const __wrap_iter<_Iter2>&) _NOEXCEPT_DEBUG;\n\ntemplate <class _Iter1, class _Iter2>\n_LIBCPP_INLINE_VISIBILITY\nbool\noperator>(const __wrap_iter<_Iter1>&, const __wrap_iter<_Iter2>&) _NOEXCEPT_DEBUG;\n\ntemplate <class _Iter1, class _Iter2>\n_LIBCPP_INLINE_VISIBILITY\nbool\noperator>=(const __wrap_iter<_Iter1>&, const __wrap_iter<_Iter2>&) _NOEXCEPT_DEBUG;\n\ntemplate <class _Iter1, class _Iter2>\n_LIBCPP_INLINE_VISIBILITY\nbool\noperator<=(const __wrap_iter<_Iter1>&, const __wrap_iter<_Iter2>&) _NOEXCEPT_DEBUG;\n\n#ifndef _LIBCPP_CXX03_LANG\ntemplate <class _Iter1, class _Iter2>\n_LIBCPP_INLINE_VISIBILITY\nauto\noperator-(const __wrap_iter<_Iter1>& __x, const __wrap_iter<_Iter2>& __y) _NOEXCEPT_DEBUG\n-> decltype(__x.base() - __y.base());\n#else\ntemplate <class _Iter1, class _Iter2>\n_LIBCPP_INLINE_VISIBILITY\ntypename __wrap_iter<_Iter1>::difference_type\noperator-(const __wrap_iter<_Iter1>&, const __wrap_iter<_Iter2>&) _NOEXCEPT_DEBUG;\n#endif\n\ntemplate <class _Iter>\n_LIBCPP_INLINE_VISIBILITY\n__wrap_iter<_Iter>\noperator+(typename __wrap_iter<_Iter>::difference_type, __wrap_iter<_Iter>) _NOEXCEPT_DEBUG;\n\ntemplate <class _Ip, class _Op> _Op _LIBCPP_INLINE_VISIBILITY copy(_Ip, _Ip, _Op);\ntemplate <class _B1, class _B2> _B2 _LIBCPP_INLINE_VISIBILITY copy_backward(_B1, _B1, _B2);\ntemplate <class _Ip, class _Op> _Op _LIBCPP_INLINE_VISIBILITY move(_Ip, _Ip, _Op);\ntemplate <class _B1, class _B2> _B2 _LIBCPP_INLINE_VISIBILITY move_backward(_B1, _B1, _B2);\n\n#if _LIBCPP_DEBUG_LEVEL < 2\n\ntemplate <class _Tp>\n_LIBCPP_INLINE_VISIBILITY\ntypename enable_if\n<\n    is_trivially_copy_assignable<_Tp>::value,\n    _Tp*\n>::type\n__unwrap_iter(__wrap_iter<_Tp*>);\n\n#else\n\ntemplate <class _Tp>\ninline _LIBCPP_INLINE_VISIBILITY\ntypename enable_if\n<\n    is_trivially_copy_assignable<_Tp>::value,\n    __wrap_iter<_Tp*>\n>::type\n__unwrap_iter(__wrap_iter<_Tp*> __i);\n\n#endif\n\ntemplate <class _Iter>\nclass __wrap_iter\n{\npublic:\n    typedef _Iter                                                      iterator_type;\n    typedef typename iterator_traits<iterator_type>::iterator_category iterator_category;\n    typedef typename iterator_traits<iterator_type>::value_type        value_type;\n    typedef typename iterator_traits<iterator_type>::difference_type   difference_type;\n    typedef typename iterator_traits<iterator_type>::pointer           pointer;\n    typedef typename iterator_traits<iterator_type>::reference         reference;\nprivate:\n    iterator_type __i;\npublic:\n    _LIBCPP_INLINE_VISIBILITY __wrap_iter() _NOEXCEPT_DEBUG\n#if _LIBCPP_STD_VER > 11\n                : __i{}\n#endif\n    {\n#if _LIBCPP_DEBUG_LEVEL >= 2\n        __get_db()->__insert_i(this);\n#endif\n    }\n    template <class _Up> _LIBCPP_INLINE_VISIBILITY __wrap_iter(const __wrap_iter<_Up>& __u,\n        typename enable_if<is_convertible<_Up, iterator_type>::value>::type* = 0) _NOEXCEPT_DEBUG\n        : __i(__u.base())\n    {\n#if _LIBCPP_DEBUG_LEVEL >= 2\n        __get_db()->__iterator_copy(this, &__u);\n#endif\n    }\n#if _LIBCPP_DEBUG_LEVEL >= 2\n    _LIBCPP_INLINE_VISIBILITY\n    __wrap_iter(const __wrap_iter& __x)\n        : __i(__x.base())\n    {\n        __get_db()->__iterator_copy(this, &__x);\n    }\n    _LIBCPP_INLINE_VISIBILITY\n    __wrap_iter& operator=(const __wrap_iter& __x)\n    {\n        if (this != &__x)\n        {\n            __get_db()->__iterator_copy(this, &__x);\n            __i = __x.__i;\n        }\n        return *this;\n    }\n    _LIBCPP_INLINE_VISIBILITY\n    ~__wrap_iter()\n    {\n        __get_db()->__erase_i(this);\n    }\n#endif\n    _LIBCPP_INLINE_VISIBILITY reference operator*() const _NOEXCEPT_DEBUG\n    {\n#if _LIBCPP_DEBUG_LEVEL >= 2\n        _LIBCPP_ASSERT(__get_const_db()->__dereferenceable(this),\n                       \"Attempted to dereference a non-dereferenceable iterator\");\n#endif\n        return *__i;\n    }\n    _LIBCPP_INLINE_VISIBILITY pointer  operator->() const _NOEXCEPT_DEBUG\n    {\n#if _LIBCPP_DEBUG_LEVEL >= 2\n        _LIBCPP_ASSERT(__get_const_db()->__dereferenceable(this),\n                       \"Attempted to dereference a non-dereferenceable iterator\");\n#endif\n        return (pointer)_VSTD::addressof(*__i);\n    }\n    _LIBCPP_INLINE_VISIBILITY __wrap_iter& operator++() _NOEXCEPT_DEBUG\n    {\n#if _LIBCPP_DEBUG_LEVEL >= 2\n        _LIBCPP_ASSERT(__get_const_db()->__dereferenceable(this),\n                       \"Attempted to increment non-incrementable iterator\");\n#endif\n        ++__i;\n        return *this;\n    }\n    _LIBCPP_INLINE_VISIBILITY __wrap_iter  operator++(int) _NOEXCEPT_DEBUG\n        {__wrap_iter __tmp(*this); ++(*this); return __tmp;}\n    _LIBCPP_INLINE_VISIBILITY __wrap_iter& operator--() _NOEXCEPT_DEBUG\n    {\n#if _LIBCPP_DEBUG_LEVEL >= 2\n        _LIBCPP_ASSERT(__get_const_db()->__decrementable(this),\n                       \"Attempted to decrement non-decrementable iterator\");\n#endif\n        --__i;\n        return *this;\n    }\n    _LIBCPP_INLINE_VISIBILITY __wrap_iter  operator--(int) _NOEXCEPT_DEBUG\n        {__wrap_iter __tmp(*this); --(*this); return __tmp;}\n    _LIBCPP_INLINE_VISIBILITY __wrap_iter  operator+ (difference_type __n) const _NOEXCEPT_DEBUG\n        {__wrap_iter __w(*this); __w += __n; return __w;}\n    _LIBCPP_INLINE_VISIBILITY __wrap_iter& operator+=(difference_type __n) _NOEXCEPT_DEBUG\n    {\n#if _LIBCPP_DEBUG_LEVEL >= 2\n        _LIBCPP_ASSERT(__get_const_db()->__addable(this, __n),\n                   \"Attempted to add/subtract iterator outside of valid range\");\n#endif\n        __i += __n;\n        return *this;\n    }\n    _LIBCPP_INLINE_VISIBILITY __wrap_iter  operator- (difference_type __n) const _NOEXCEPT_DEBUG\n        {return *this + (-__n);}\n    _LIBCPP_INLINE_VISIBILITY __wrap_iter& operator-=(difference_type __n) _NOEXCEPT_DEBUG\n        {*this += -__n; return *this;}\n    _LIBCPP_INLINE_VISIBILITY reference        operator[](difference_type __n) const _NOEXCEPT_DEBUG\n    {\n#if _LIBCPP_DEBUG_LEVEL >= 2\n        _LIBCPP_ASSERT(__get_const_db()->__subscriptable(this, __n),\n                   \"Attempted to subscript iterator outside of valid range\");\n#endif\n        return __i[__n];\n    }\n\n    _LIBCPP_INLINE_VISIBILITY iterator_type base() const _NOEXCEPT_DEBUG {return __i;}\n\nprivate:\n#if _LIBCPP_DEBUG_LEVEL >= 2\n    _LIBCPP_INLINE_VISIBILITY __wrap_iter(const void* __p, iterator_type __x) : __i(__x)\n    {\n        __get_db()->__insert_ic(this, __p);\n    }\n#else\n    _LIBCPP_INLINE_VISIBILITY __wrap_iter(iterator_type __x) _NOEXCEPT_DEBUG : __i(__x) {}\n#endif\n\n    template <class _Up> friend class __wrap_iter;\n    template <class _CharT, class _Traits, class _Alloc> friend class basic_string;\n    template <class _Tp, class _Alloc> friend class _LIBCPP_TEMPLATE_VIS vector;\n\n    template <class _Iter1, class _Iter2>\n    friend\n    bool\n    operator==(const __wrap_iter<_Iter1>&, const __wrap_iter<_Iter2>&) _NOEXCEPT_DEBUG;\n\n    template <class _Iter1, class _Iter2>\n    friend\n    bool\n    operator<(const __wrap_iter<_Iter1>&, const __wrap_iter<_Iter2>&) _NOEXCEPT_DEBUG;\n\n    template <class _Iter1, class _Iter2>\n    friend\n    bool\n    operator!=(const __wrap_iter<_Iter1>&, const __wrap_iter<_Iter2>&) _NOEXCEPT_DEBUG;\n\n    template <class _Iter1, class _Iter2>\n    friend\n    bool\n    operator>(const __wrap_iter<_Iter1>&, const __wrap_iter<_Iter2>&) _NOEXCEPT_DEBUG;\n\n    template <class _Iter1, class _Iter2>\n    friend\n    bool\n    operator>=(const __wrap_iter<_Iter1>&, const __wrap_iter<_Iter2>&) _NOEXCEPT_DEBUG;\n\n    template <class _Iter1, class _Iter2>\n    friend\n    bool\n    operator<=(const __wrap_iter<_Iter1>&, const __wrap_iter<_Iter2>&) _NOEXCEPT_DEBUG;\n\n#ifndef _LIBCPP_CXX03_LANG\n    template <class _Iter1, class _Iter2>\n    friend\n    auto\n    operator-(const __wrap_iter<_Iter1>& __x, const __wrap_iter<_Iter2>& __y) _NOEXCEPT_DEBUG\n    -> decltype(__x.base() - __y.base());\n#else\n    template <class _Iter1, class _Iter2>\n    friend\n    typename __wrap_iter<_Iter1>::difference_type\n    operator-(const __wrap_iter<_Iter1>&, const __wrap_iter<_Iter2>&) _NOEXCEPT_DEBUG;\n#endif\n\n    template <class _Iter1>\n    friend\n    __wrap_iter<_Iter1>\n    operator+(typename __wrap_iter<_Iter1>::difference_type, __wrap_iter<_Iter1>) _NOEXCEPT_DEBUG;\n\n    template <class _Ip, class _Op> friend _Op copy(_Ip, _Ip, _Op);\n    template <class _B1, class _B2> friend _B2 copy_backward(_B1, _B1, _B2);\n    template <class _Ip, class _Op> friend _Op move(_Ip, _Ip, _Op);\n    template <class _B1, class _B2> friend _B2 move_backward(_B1, _B1, _B2);\n\n#if _LIBCPP_DEBUG_LEVEL < 2\n    template <class _Tp>\n    friend\n    typename enable_if\n    <\n        is_trivially_copy_assignable<_Tp>::value,\n        _Tp*\n    >::type\n    __unwrap_iter(__wrap_iter<_Tp*>);\n#else\n  template <class _Tp>\n  inline _LIBCPP_INLINE_VISIBILITY\n  typename enable_if\n  <\n      is_trivially_copy_assignable<_Tp>::value,\n      __wrap_iter<_Tp*>\n  >::type\n  __unwrap_iter(__wrap_iter<_Tp*> __i);\n#endif\n};\n\ntemplate <class _Iter1, class _Iter2>\ninline _LIBCPP_INLINE_VISIBILITY\nbool\noperator==(const __wrap_iter<_Iter1>& __x, const __wrap_iter<_Iter2>& __y) _NOEXCEPT_DEBUG\n{\n    return __x.base() == __y.base();\n}\n\ntemplate <class _Iter1, class _Iter2>\ninline _LIBCPP_INLINE_VISIBILITY\nbool\noperator<(const __wrap_iter<_Iter1>& __x, const __wrap_iter<_Iter2>& __y) _NOEXCEPT_DEBUG\n{\n#if _LIBCPP_DEBUG_LEVEL >= 2\n    _LIBCPP_ASSERT(__get_const_db()->__less_than_comparable(&__x, &__y),\n                   \"Attempted to compare incomparable iterators\");\n#endif\n    return __x.base() < __y.base();\n}\n\ntemplate <class _Iter1, class _Iter2>\ninline _LIBCPP_INLINE_VISIBILITY\nbool\noperator!=(const __wrap_iter<_Iter1>& __x, const __wrap_iter<_Iter2>& __y) _NOEXCEPT_DEBUG\n{\n    return !(__x == __y);\n}\n\ntemplate <class _Iter1, class _Iter2>\ninline _LIBCPP_INLINE_VISIBILITY\nbool\noperator>(const __wrap_iter<_Iter1>& __x, const __wrap_iter<_Iter2>& __y) _NOEXCEPT_DEBUG\n{\n    return __y < __x;\n}\n\ntemplate <class _Iter1, class _Iter2>\ninline _LIBCPP_INLINE_VISIBILITY\nbool\noperator>=(const __wrap_iter<_Iter1>& __x, const __wrap_iter<_Iter2>& __y) _NOEXCEPT_DEBUG\n{\n    return !(__x < __y);\n}\n\ntemplate <class _Iter1, class _Iter2>\ninline _LIBCPP_INLINE_VISIBILITY\nbool\noperator<=(const __wrap_iter<_Iter1>& __x, const __wrap_iter<_Iter2>& __y) _NOEXCEPT_DEBUG\n{\n    return !(__y < __x);\n}\n\ntemplate <class _Iter1>\ninline _LIBCPP_INLINE_VISIBILITY\nbool\noperator!=(const __wrap_iter<_Iter1>& __x, const __wrap_iter<_Iter1>& __y) _NOEXCEPT_DEBUG\n{\n    return !(__x == __y);\n}\n\ntemplate <class _Iter1>\ninline _LIBCPP_INLINE_VISIBILITY\nbool\noperator>(const __wrap_iter<_Iter1>& __x, const __wrap_iter<_Iter1>& __y) _NOEXCEPT_DEBUG\n{\n    return __y < __x;\n}\n\ntemplate <class _Iter1>\ninline _LIBCPP_INLINE_VISIBILITY\nbool\noperator>=(const __wrap_iter<_Iter1>& __x, const __wrap_iter<_Iter1>& __y) _NOEXCEPT_DEBUG\n{\n    return !(__x < __y);\n}\n\ntemplate <class _Iter1>\ninline _LIBCPP_INLINE_VISIBILITY\nbool\noperator<=(const __wrap_iter<_Iter1>& __x, const __wrap_iter<_Iter1>& __y) _NOEXCEPT_DEBUG\n{\n    return !(__y < __x);\n}\n\n#ifndef _LIBCPP_CXX03_LANG\ntemplate <class _Iter1, class _Iter2>\ninline _LIBCPP_INLINE_VISIBILITY\nauto\noperator-(const __wrap_iter<_Iter1>& __x, const __wrap_iter<_Iter2>& __y) _NOEXCEPT_DEBUG\n-> decltype(__x.base() - __y.base())\n{\n#if _LIBCPP_DEBUG_LEVEL >= 2\n    _LIBCPP_ASSERT(__get_const_db()->__less_than_comparable(&__x, &__y),\n                   \"Attempted to subtract incompatible iterators\");\n#endif\n    return __x.base() - __y.base();\n}\n#else\ntemplate <class _Iter1, class _Iter2>\ninline _LIBCPP_INLINE_VISIBILITY\ntypename __wrap_iter<_Iter1>::difference_type\noperator-(const __wrap_iter<_Iter1>& __x, const __wrap_iter<_Iter2>& __y) _NOEXCEPT_DEBUG\n{\n#if _LIBCPP_DEBUG_LEVEL >= 2\n    _LIBCPP_ASSERT(__get_const_db()->__less_than_comparable(&__x, &__y),\n                   \"Attempted to subtract incompatible iterators\");\n#endif\n    return __x.base() - __y.base();\n}\n#endif\n\ntemplate <class _Iter>\ninline _LIBCPP_INLINE_VISIBILITY\n__wrap_iter<_Iter>\noperator+(typename __wrap_iter<_Iter>::difference_type __n,\n          __wrap_iter<_Iter> __x) _NOEXCEPT_DEBUG\n{\n    __x += __n;\n    return __x;\n}\n\ntemplate <class _Iter>\nstruct __libcpp_is_trivial_iterator\n    : public _LIBCPP_BOOL_CONSTANT(is_pointer<_Iter>::value) {};\n    \ntemplate <class _Iter>\nstruct __libcpp_is_trivial_iterator<move_iterator<_Iter> >\n    : public _LIBCPP_BOOL_CONSTANT(__libcpp_is_trivial_iterator<_Iter>::value) {};\n\ntemplate <class _Iter>\nstruct __libcpp_is_trivial_iterator<reverse_iterator<_Iter> >\n    : public _LIBCPP_BOOL_CONSTANT(__libcpp_is_trivial_iterator<_Iter>::value) {};\n\ntemplate <class _Iter>\nstruct __libcpp_is_trivial_iterator<__wrap_iter<_Iter> >\n    : public _LIBCPP_BOOL_CONSTANT(__libcpp_is_trivial_iterator<_Iter>::value) {};\n\n\ntemplate <class _Tp, size_t _Np>\ninline _LIBCPP_INLINE_VISIBILITY _LIBCPP_CONSTEXPR_AFTER_CXX11\n_Tp*\nbegin(_Tp (&__array)[_Np])\n{\n    return __array;\n}\n\ntemplate <class _Tp, size_t _Np>\ninline _LIBCPP_INLINE_VISIBILITY _LIBCPP_CONSTEXPR_AFTER_CXX11\n_Tp*\nend(_Tp (&__array)[_Np])\n{\n    return __array + _Np;\n}\n\n#if !defined(_LIBCPP_CXX03_LANG)\n\ntemplate <class _Cp>\ninline _LIBCPP_INLINE_VISIBILITY _LIBCPP_CONSTEXPR_AFTER_CXX14\nauto\nbegin(_Cp& __c) -> decltype(__c.begin())\n{\n    return __c.begin();\n}\n\ntemplate <class _Cp>\ninline _LIBCPP_INLINE_VISIBILITY _LIBCPP_CONSTEXPR_AFTER_CXX14\nauto\nbegin(const _Cp& __c) -> decltype(__c.begin())\n{\n    return __c.begin();\n}\n\ntemplate <class _Cp>\ninline _LIBCPP_INLINE_VISIBILITY _LIBCPP_CONSTEXPR_AFTER_CXX14\nauto\nend(_Cp& __c) -> decltype(__c.end())\n{\n    return __c.end();\n}\n\ntemplate <class _Cp>\ninline _LIBCPP_INLINE_VISIBILITY _LIBCPP_CONSTEXPR_AFTER_CXX14\nauto\nend(const _Cp& __c) -> decltype(__c.end())\n{\n    return __c.end();\n}\n\n#if _LIBCPP_STD_VER > 11\n\ntemplate <class _Tp, size_t _Np>\ninline _LIBCPP_INLINE_VISIBILITY _LIBCPP_CONSTEXPR_AFTER_CXX14\nreverse_iterator<_Tp*> rbegin(_Tp (&__array)[_Np])\n{\n    return reverse_iterator<_Tp*>(__array + _Np);\n}\n\ntemplate <class _Tp, size_t _Np>\ninline _LIBCPP_INLINE_VISIBILITY _LIBCPP_CONSTEXPR_AFTER_CXX14\nreverse_iterator<_Tp*> rend(_Tp (&__array)[_Np])\n{\n    return reverse_iterator<_Tp*>(__array);\n}\n\ntemplate <class _Ep>\ninline _LIBCPP_INLINE_VISIBILITY _LIBCPP_CONSTEXPR_AFTER_CXX14\nreverse_iterator<const _Ep*> rbegin(initializer_list<_Ep> __il)\n{\n    return reverse_iterator<const _Ep*>(__il.end());\n}\n\ntemplate <class _Ep>\ninline _LIBCPP_INLINE_VISIBILITY _LIBCPP_CONSTEXPR_AFTER_CXX14\nreverse_iterator<const _Ep*> rend(initializer_list<_Ep> __il)\n{\n    return reverse_iterator<const _Ep*>(__il.begin());\n}\n\ntemplate <class _Cp>\ninline _LIBCPP_INLINE_VISIBILITY _LIBCPP_CONSTEXPR_AFTER_CXX11\nauto cbegin(const _Cp& __c) -> decltype(_VSTD::begin(__c))\n{\n    return _VSTD::begin(__c);\n}\n\ntemplate <class _Cp>\ninline _LIBCPP_INLINE_VISIBILITY _LIBCPP_CONSTEXPR_AFTER_CXX11\nauto cend(const _Cp& __c) -> decltype(_VSTD::end(__c))\n{\n    return _VSTD::end(__c);\n}\n\ntemplate <class _Cp>\ninline _LIBCPP_INLINE_VISIBILITY _LIBCPP_CONSTEXPR_AFTER_CXX14\nauto rbegin(_Cp& __c) -> decltype(__c.rbegin())\n{\n    return __c.rbegin();\n}\n\ntemplate <class _Cp>\ninline _LIBCPP_INLINE_VISIBILITY _LIBCPP_CONSTEXPR_AFTER_CXX14\nauto rbegin(const _Cp& __c) -> decltype(__c.rbegin())\n{\n    return __c.rbegin();\n}\n\ntemplate <class _Cp>\ninline _LIBCPP_INLINE_VISIBILITY _LIBCPP_CONSTEXPR_AFTER_CXX14\nauto rend(_Cp& __c) -> decltype(__c.rend())\n{\n    return __c.rend();\n}\n\ntemplate <class _Cp>\ninline _LIBCPP_INLINE_VISIBILITY _LIBCPP_CONSTEXPR_AFTER_CXX14\nauto rend(const _Cp& __c) -> decltype(__c.rend())\n{\n    return __c.rend();\n}\n\ntemplate <class _Cp>\ninline _LIBCPP_INLINE_VISIBILITY _LIBCPP_CONSTEXPR_AFTER_CXX14\nauto crbegin(const _Cp& __c) -> decltype(_VSTD::rbegin(__c))\n{\n    return _VSTD::rbegin(__c);\n}\n\ntemplate <class _Cp>\ninline _LIBCPP_INLINE_VISIBILITY _LIBCPP_CONSTEXPR_AFTER_CXX14\nauto crend(const _Cp& __c) -> decltype(_VSTD::rend(__c))\n{\n    return _VSTD::rend(__c);\n}\n\n#endif\n\n\n#else  // defined(_LIBCPP_CXX03_LANG)\n\ntemplate <class _Cp>\ninline _LIBCPP_INLINE_VISIBILITY\ntypename _Cp::iterator\nbegin(_Cp& __c)\n{\n    return __c.begin();\n}\n\ntemplate <class _Cp>\ninline _LIBCPP_INLINE_VISIBILITY\ntypename _Cp::const_iterator\nbegin(const _Cp& __c)\n{\n    return __c.begin();\n}\n\ntemplate <class _Cp>\ninline _LIBCPP_INLINE_VISIBILITY\ntypename _Cp::iterator\nend(_Cp& __c)\n{\n    return __c.end();\n}\n\ntemplate <class _Cp>\ninline _LIBCPP_INLINE_VISIBILITY\ntypename _Cp::const_iterator\nend(const _Cp& __c)\n{\n    return __c.end();\n}\n\n#endif  // !defined(_LIBCPP_CXX03_LANG)\n\n#if _LIBCPP_STD_VER > 14\ntemplate <class _Cont>\nconstexpr auto size(const _Cont& __c) -> decltype(__c.size()) { return __c.size(); }\n\ntemplate <class _Tp, size_t _Sz>\nconstexpr size_t size(const _Tp (&)[_Sz]) noexcept { return _Sz; }\n\ntemplate <class _Cont>\nconstexpr auto empty(const _Cont& __c) -> decltype(__c.empty()) { return __c.empty(); }\n\ntemplate <class _Tp, size_t _Sz>\nconstexpr bool empty(const _Tp (&)[_Sz]) noexcept { return false; }\n\ntemplate <class _Ep>\nconstexpr bool empty(initializer_list<_Ep> __il) noexcept { return __il.size() == 0; }\n\ntemplate <class _Cont> constexpr\nauto data(_Cont& __c) -> decltype(__c.data()) { return __c.data(); }\n\ntemplate <class _Cont> constexpr\nauto data(const _Cont& __c) -> decltype(__c.data()) { return __c.data(); }\n\ntemplate <class _Tp, size_t _Sz>\nconstexpr _Tp* data(_Tp (&__array)[_Sz]) noexcept { return __array; }\n\ntemplate <class _Ep>\nconstexpr const _Ep* data(initializer_list<_Ep> __il) noexcept { return __il.begin(); }\n#endif\n\n\n_LIBCPP_END_NAMESPACE_STD\n\n#endif  // _LIBCPP_ITERATOR\n","// -*- C++ -*-\n//===-------------------------- unordered_map -----------------------------===//\n//\n//                     The LLVM Compiler Infrastructure\n//\n// This file is dual licensed under the MIT and the University of Illinois Open\n// Source Licenses. See LICENSE.TXT for details.\n//\n//===----------------------------------------------------------------------===//\n\n#ifndef _LIBCPP_UNORDERED_MAP\n#define _LIBCPP_UNORDERED_MAP\n\n/*\n\n    unordered_map synopsis\n\n#include <initializer_list>\n\nnamespace std\n{\n\ntemplate <class Key, class T, class Hash = hash<Key>, class Pred = equal_to<Key>,\n          class Alloc = allocator<pair<const Key, T>>>\nclass unordered_map\n{\npublic:\n    // types\n    typedef Key                                                        key_type;\n    typedef T                                                          mapped_type;\n    typedef Hash                                                       hasher;\n    typedef Pred                                                       key_equal;\n    typedef Alloc                                                      allocator_type;\n    typedef pair<const key_type, mapped_type>                          value_type;\n    typedef value_type&                                                reference;\n    typedef const value_type&                                          const_reference;\n    typedef typename allocator_traits<allocator_type>::pointer         pointer;\n    typedef typename allocator_traits<allocator_type>::const_pointer   const_pointer;\n    typedef typename allocator_traits<allocator_type>::size_type       size_type;\n    typedef typename allocator_traits<allocator_type>::difference_type difference_type;\n\n    typedef /unspecified/ iterator;\n    typedef /unspecified/ const_iterator;\n    typedef /unspecified/ local_iterator;\n    typedef /unspecified/ const_local_iterator;\n\n    unordered_map()\n        noexcept(\n            is_nothrow_default_constructible<hasher>::value &&\n            is_nothrow_default_constructible<key_equal>::value &&\n            is_nothrow_default_constructible<allocator_type>::value);\n    explicit unordered_map(size_type n, const hasher& hf = hasher(),\n                           const key_equal& eql = key_equal(),\n                           const allocator_type& a = allocator_type());\n    template <class InputIterator>\n        unordered_map(InputIterator f, InputIterator l,\n                      size_type n = 0, const hasher& hf = hasher(),\n                      const key_equal& eql = key_equal(),\n                      const allocator_type& a = allocator_type());\n    explicit unordered_map(const allocator_type&);\n    unordered_map(const unordered_map&);\n    unordered_map(const unordered_map&, const Allocator&);\n    unordered_map(unordered_map&&)\n        noexcept(\n            is_nothrow_move_constructible<hasher>::value &&\n            is_nothrow_move_constructible<key_equal>::value &&\n            is_nothrow_move_constructible<allocator_type>::value);\n    unordered_map(unordered_map&&, const Allocator&);\n    unordered_map(initializer_list<value_type>, size_type n = 0,\n                  const hasher& hf = hasher(), const key_equal& eql = key_equal(),\n                  const allocator_type& a = allocator_type());\n    unordered_map(size_type n, const allocator_type& a)\n      : unordered_map(n, hasher(), key_equal(), a) {}  // C++14\n    unordered_map(size_type n, const hasher& hf, const allocator_type& a)\n      : unordered_map(n, hf, key_equal(), a) {}  // C++14\n    template <class InputIterator>\n      unordered_map(InputIterator f, InputIterator l, size_type n, const allocator_type& a)\n      : unordered_map(f, l, n, hasher(), key_equal(), a) {}  // C++14\n    template <class InputIterator>\n      unordered_map(InputIterator f, InputIterator l, size_type n, const hasher& hf, \n        const allocator_type& a)\n      : unordered_map(f, l, n, hf, key_equal(), a) {}  // C++14\n    unordered_map(initializer_list<value_type> il, size_type n, const allocator_type& a)\n      : unordered_map(il, n, hasher(), key_equal(), a) {}  // C++14\n    unordered_map(initializer_list<value_type> il, size_type n, const hasher& hf, \n      const allocator_type& a)\n      : unordered_map(il, n, hf, key_equal(), a) {}  // C++14\n    ~unordered_map();\n    unordered_map& operator=(const unordered_map&);\n    unordered_map& operator=(unordered_map&&)\n        noexcept(\n            allocator_type::propagate_on_container_move_assignment::value &&\n            is_nothrow_move_assignable<allocator_type>::value &&\n            is_nothrow_move_assignable<hasher>::value &&\n            is_nothrow_move_assignable<key_equal>::value);\n    unordered_map& operator=(initializer_list<value_type>);\n\n    allocator_type get_allocator() const noexcept;\n\n    bool      empty() const noexcept;\n    size_type size() const noexcept;\n    size_type max_size() const noexcept;\n\n    iterator       begin() noexcept;\n    iterator       end() noexcept;\n    const_iterator begin()  const noexcept;\n    const_iterator end()    const noexcept;\n    const_iterator cbegin() const noexcept;\n    const_iterator cend()   const noexcept;\n\n    template <class... Args>\n        pair<iterator, bool> emplace(Args&&... args);\n    template <class... Args>\n        iterator emplace_hint(const_iterator position, Args&&... args);\n    pair<iterator, bool> insert(const value_type& obj);\n    template <class P>\n        pair<iterator, bool> insert(P&& obj);\n    iterator insert(const_iterator hint, const value_type& obj);\n    template <class P>\n        iterator insert(const_iterator hint, P&& obj);\n    template <class InputIterator>\n        void insert(InputIterator first, InputIterator last);\n    void insert(initializer_list<value_type>);\n\n    template <class... Args>\n        pair<iterator, bool> try_emplace(const key_type& k, Args&&... args);          // C++17\n    template <class... Args>\n        pair<iterator, bool> try_emplace(key_type&& k, Args&&... args);               // C++17\n    template <class... Args>\n        iterator try_emplace(const_iterator hint, const key_type& k, Args&&... args); // C++17\n    template <class... Args>\n        iterator try_emplace(const_iterator hint, key_type&& k, Args&&... args);      // C++17\n    template <class M>\n        pair<iterator, bool> insert_or_assign(const key_type& k, M&& obj);            // C++17\n    template <class M>\n        pair<iterator, bool> insert_or_assign(key_type&& k, M&& obj);                 // C++17\n    template <class M>\n        iterator insert_or_assign(const_iterator hint, const key_type& k, M&& obj);   // C++17\n    template <class M>\n        iterator insert_or_assign(const_iterator hint, key_type&& k, M&& obj);        // C++17\n\n    iterator erase(const_iterator position);\n    iterator erase(iterator position);  // C++14\n    size_type erase(const key_type& k);\n    iterator erase(const_iterator first, const_iterator last);\n    void clear() noexcept;\n\n    void swap(unordered_map&)\n        noexcept(\n            (!allocator_type::propagate_on_container_swap::value ||\n             __is_nothrow_swappable<allocator_type>::value) &&\n            __is_nothrow_swappable<hasher>::value &&\n            __is_nothrow_swappable<key_equal>::value);\n\n    hasher hash_function() const;\n    key_equal key_eq() const;\n\n    iterator       find(const key_type& k);\n    const_iterator find(const key_type& k) const;\n    size_type count(const key_type& k) const;\n    pair<iterator, iterator>             equal_range(const key_type& k);\n    pair<const_iterator, const_iterator> equal_range(const key_type& k) const;\n\n    mapped_type& operator[](const key_type& k);\n    mapped_type& operator[](key_type&& k);\n\n    mapped_type&       at(const key_type& k);\n    const mapped_type& at(const key_type& k) const;\n\n    size_type bucket_count() const noexcept;\n    size_type max_bucket_count() const noexcept;\n\n    size_type bucket_size(size_type n) const;\n    size_type bucket(const key_type& k) const;\n\n    local_iterator       begin(size_type n);\n    local_iterator       end(size_type n);\n    const_local_iterator begin(size_type n) const;\n    const_local_iterator end(size_type n) const;\n    const_local_iterator cbegin(size_type n) const;\n    const_local_iterator cend(size_type n) const;\n\n    float load_factor() const noexcept;\n    float max_load_factor() const noexcept;\n    void max_load_factor(float z);\n    void rehash(size_type n);\n    void reserve(size_type n);\n};\n\ntemplate <class Key, class T, class Hash, class Pred, class Alloc>\n    void swap(unordered_map<Key, T, Hash, Pred, Alloc>& x,\n              unordered_map<Key, T, Hash, Pred, Alloc>& y)\n              noexcept(noexcept(x.swap(y)));\n\ntemplate <class Key, class T, class Hash, class Pred, class Alloc>\n    bool\n    operator==(const unordered_map<Key, T, Hash, Pred, Alloc>& x,\n               const unordered_map<Key, T, Hash, Pred, Alloc>& y);\n\ntemplate <class Key, class T, class Hash, class Pred, class Alloc>\n    bool\n    operator!=(const unordered_map<Key, T, Hash, Pred, Alloc>& x,\n               const unordered_map<Key, T, Hash, Pred, Alloc>& y);\n\ntemplate <class Key, class T, class Hash = hash<Key>, class Pred = equal_to<Key>,\n          class Alloc = allocator<pair<const Key, T>>>\nclass unordered_multimap\n{\npublic:\n    // types\n    typedef Key                                                        key_type;\n    typedef T                                                          mapped_type;\n    typedef Hash                                                       hasher;\n    typedef Pred                                                       key_equal;\n    typedef Alloc                                                      allocator_type;\n    typedef pair<const key_type, mapped_type>                          value_type;\n    typedef value_type&                                                reference;\n    typedef const value_type&                                          const_reference;\n    typedef typename allocator_traits<allocator_type>::pointer         pointer;\n    typedef typename allocator_traits<allocator_type>::const_pointer   const_pointer;\n    typedef typename allocator_traits<allocator_type>::size_type       size_type;\n    typedef typename allocator_traits<allocator_type>::difference_type difference_type;\n\n    typedef /unspecified/ iterator;\n    typedef /unspecified/ const_iterator;\n    typedef /unspecified/ local_iterator;\n    typedef /unspecified/ const_local_iterator;\n\n    unordered_multimap()\n        noexcept(\n            is_nothrow_default_constructible<hasher>::value &&\n            is_nothrow_default_constructible<key_equal>::value &&\n            is_nothrow_default_constructible<allocator_type>::value);\n    explicit unordered_multimap(size_type n, const hasher& hf = hasher(),\n                           const key_equal& eql = key_equal(),\n                           const allocator_type& a = allocator_type());\n    template <class InputIterator>\n        unordered_multimap(InputIterator f, InputIterator l,\n                      size_type n = 0, const hasher& hf = hasher(),\n                      const key_equal& eql = key_equal(),\n                      const allocator_type& a = allocator_type());\n    explicit unordered_multimap(const allocator_type&);\n    unordered_multimap(const unordered_multimap&);\n    unordered_multimap(const unordered_multimap&, const Allocator&);\n    unordered_multimap(unordered_multimap&&)\n        noexcept(\n            is_nothrow_move_constructible<hasher>::value &&\n            is_nothrow_move_constructible<key_equal>::value &&\n            is_nothrow_move_constructible<allocator_type>::value);\n    unordered_multimap(unordered_multimap&&, const Allocator&);\n    unordered_multimap(initializer_list<value_type>, size_type n = 0,\n                  const hasher& hf = hasher(), const key_equal& eql = key_equal(),\n                  const allocator_type& a = allocator_type());\n    unordered_multimap(size_type n, const allocator_type& a)\n      : unordered_multimap(n, hasher(), key_equal(), a) {}  // C++14\n    unordered_multimap(size_type n, const hasher& hf, const allocator_type& a)\n      : unordered_multimap(n, hf, key_equal(), a) {}  // C++14\n    template <class InputIterator>\n      unordered_multimap(InputIterator f, InputIterator l, size_type n, const allocator_type& a)\n      : unordered_multimap(f, l, n, hasher(), key_equal(), a) {}  // C++14\n    template <class InputIterator>\n      unordered_multimap(InputIterator f, InputIterator l, size_type n, const hasher& hf, \n        const allocator_type& a)\n      : unordered_multimap(f, l, n, hf, key_equal(), a) {}  // C++14\n    unordered_multimap(initializer_list<value_type> il, size_type n, const allocator_type& a)\n      : unordered_multimap(il, n, hasher(), key_equal(), a) {}  // C++14\n    unordered_multimap(initializer_list<value_type> il, size_type n, const hasher& hf, \n      const allocator_type& a)\n      : unordered_multimap(il, n, hf, key_equal(), a) {}  // C++14\n    ~unordered_multimap();\n    unordered_multimap& operator=(const unordered_multimap&);\n    unordered_multimap& operator=(unordered_multimap&&)\n        noexcept(\n            allocator_type::propagate_on_container_move_assignment::value &&\n            is_nothrow_move_assignable<allocator_type>::value &&\n            is_nothrow_move_assignable<hasher>::value &&\n            is_nothrow_move_assignable<key_equal>::value);\n    unordered_multimap& operator=(initializer_list<value_type>);\n\n    allocator_type get_allocator() const noexcept;\n\n    bool      empty() const noexcept;\n    size_type size() const noexcept;\n    size_type max_size() const noexcept;\n\n    iterator       begin() noexcept;\n    iterator       end() noexcept;\n    const_iterator begin()  const noexcept;\n    const_iterator end()    const noexcept;\n    const_iterator cbegin() const noexcept;\n    const_iterator cend()   const noexcept;\n\n    template <class... Args>\n        iterator emplace(Args&&... args);\n    template <class... Args>\n        iterator emplace_hint(const_iterator position, Args&&... args);\n    iterator insert(const value_type& obj);\n    template <class P>\n        iterator insert(P&& obj);\n    iterator insert(const_iterator hint, const value_type& obj);\n    template <class P>\n        iterator insert(const_iterator hint, P&& obj);\n    template <class InputIterator>\n        void insert(InputIterator first, InputIterator last);\n    void insert(initializer_list<value_type>);\n\n    iterator erase(const_iterator position);\n    iterator erase(iterator position);  // C++14\n    size_type erase(const key_type& k);\n    iterator erase(const_iterator first, const_iterator last);\n    void clear() noexcept;\n\n    void swap(unordered_multimap&)\n        noexcept(\n            (!allocator_type::propagate_on_container_swap::value ||\n             __is_nothrow_swappable<allocator_type>::value) &&\n            __is_nothrow_swappable<hasher>::value &&\n            __is_nothrow_swappable<key_equal>::value);\n\n    hasher hash_function() const;\n    key_equal key_eq() const;\n\n    iterator       find(const key_type& k);\n    const_iterator find(const key_type& k) const;\n    size_type count(const key_type& k) const;\n    pair<iterator, iterator>             equal_range(const key_type& k);\n    pair<const_iterator, const_iterator> equal_range(const key_type& k) const;\n\n    size_type bucket_count() const noexcept;\n    size_type max_bucket_count() const noexcept;\n\n    size_type bucket_size(size_type n) const;\n    size_type bucket(const key_type& k) const;\n\n    local_iterator       begin(size_type n);\n    local_iterator       end(size_type n);\n    const_local_iterator begin(size_type n) const;\n    const_local_iterator end(size_type n) const;\n    const_local_iterator cbegin(size_type n) const;\n    const_local_iterator cend(size_type n) const;\n\n    float load_factor() const noexcept;\n    float max_load_factor() const noexcept;\n    void max_load_factor(float z);\n    void rehash(size_type n);\n    void reserve(size_type n);\n};\n\ntemplate <class Key, class T, class Hash, class Pred, class Alloc>\n    void swap(unordered_multimap<Key, T, Hash, Pred, Alloc>& x,\n              unordered_multimap<Key, T, Hash, Pred, Alloc>& y)\n              noexcept(noexcept(x.swap(y)));\n\ntemplate <class Key, class T, class Hash, class Pred, class Alloc>\n    bool\n    operator==(const unordered_multimap<Key, T, Hash, Pred, Alloc>& x,\n               const unordered_multimap<Key, T, Hash, Pred, Alloc>& y);\n\ntemplate <class Key, class T, class Hash, class Pred, class Alloc>\n    bool\n    operator!=(const unordered_multimap<Key, T, Hash, Pred, Alloc>& x,\n               const unordered_multimap<Key, T, Hash, Pred, Alloc>& y);\n\n}  // std\n\n*/\n\n#include <__config>\n#include <__hash_table>\n#include <functional>\n#include <stdexcept>\n#include <tuple>\n\n#include <__debug>\n\n#if !defined(_LIBCPP_HAS_NO_PRAGMA_SYSTEM_HEADER)\n#pragma GCC system_header\n#endif\n\n_LIBCPP_BEGIN_NAMESPACE_STD\n\ntemplate <class _Key, class _Cp, class _Hash,\n          bool = is_empty<_Hash>::value && !__libcpp_is_final<_Hash>::value\n         >\nclass __unordered_map_hasher\n    : private _Hash\n{\npublic:\n    _LIBCPP_INLINE_VISIBILITY\n    __unordered_map_hasher()\n        _NOEXCEPT_(is_nothrow_default_constructible<_Hash>::value)\n        : _Hash() {}\n    _LIBCPP_INLINE_VISIBILITY\n    __unordered_map_hasher(const _Hash& __h)\n        _NOEXCEPT_(is_nothrow_copy_constructible<_Hash>::value)\n        : _Hash(__h) {}\n    _LIBCPP_INLINE_VISIBILITY\n    const _Hash& hash_function() const _NOEXCEPT {return *this;}\n    _LIBCPP_INLINE_VISIBILITY\n    size_t operator()(const _Cp& __x) const\n        {return static_cast<const _Hash&>(*this)(__x.__cc.first);}\n    _LIBCPP_INLINE_VISIBILITY\n    size_t operator()(const _Key& __x) const\n        {return static_cast<const _Hash&>(*this)(__x);}\n    void swap(__unordered_map_hasher&__y)\n        _NOEXCEPT_(__is_nothrow_swappable<_Hash>::value)\n    {\n        using _VSTD::swap;\n        swap(static_cast<const _Hash&>(*this), static_cast<const _Hash&>(__y));\n    }\n};\n\ntemplate <class _Key, class _Cp, class _Hash>\nclass __unordered_map_hasher<_Key, _Cp, _Hash, false>\n{\n    _Hash __hash_;\npublic:\n    _LIBCPP_INLINE_VISIBILITY\n    __unordered_map_hasher()\n        _NOEXCEPT_(is_nothrow_default_constructible<_Hash>::value)\n        : __hash_() {}\n    _LIBCPP_INLINE_VISIBILITY\n    __unordered_map_hasher(const _Hash& __h)\n        _NOEXCEPT_(is_nothrow_copy_constructible<_Hash>::value)\n        : __hash_(__h) {}\n    _LIBCPP_INLINE_VISIBILITY\n    const _Hash& hash_function() const _NOEXCEPT {return __hash_;}\n    _LIBCPP_INLINE_VISIBILITY\n    size_t operator()(const _Cp& __x) const\n        {return __hash_(__x.__cc.first);}\n    _LIBCPP_INLINE_VISIBILITY\n    size_t operator()(const _Key& __x) const\n        {return __hash_(__x);}\n    void swap(__unordered_map_hasher&__y)\n        _NOEXCEPT_(__is_nothrow_swappable<_Hash>::value)\n    {\n        using _VSTD::swap;\n        swap(__hash_, __y.__hash_);\n    }\n};\n\ntemplate <class _Key, class _Cp, class _Hash, bool __b>\ninline _LIBCPP_INLINE_VISIBILITY\nvoid\nswap(__unordered_map_hasher<_Key, _Cp, _Hash, __b>& __x,\n     __unordered_map_hasher<_Key, _Cp, _Hash, __b>& __y)\n    _NOEXCEPT_(_NOEXCEPT_(__x.swap(__y)))\n{\n    __x.swap(__y);\n}\n\ntemplate <class _Key, class _Cp, class _Pred,\n          bool = is_empty<_Pred>::value && !__libcpp_is_final<_Pred>::value\n         >\nclass __unordered_map_equal\n    : private _Pred\n{\npublic:\n    _LIBCPP_INLINE_VISIBILITY\n    __unordered_map_equal()\n        _NOEXCEPT_(is_nothrow_default_constructible<_Pred>::value)\n        : _Pred() {}\n    _LIBCPP_INLINE_VISIBILITY\n    __unordered_map_equal(const _Pred& __p)\n        _NOEXCEPT_(is_nothrow_copy_constructible<_Pred>::value)\n        : _Pred(__p) {}\n    _LIBCPP_INLINE_VISIBILITY\n    const _Pred& key_eq() const _NOEXCEPT {return *this;}\n    _LIBCPP_INLINE_VISIBILITY\n    bool operator()(const _Cp& __x, const _Cp& __y) const\n        {return static_cast<const _Pred&>(*this)(__x.__cc.first, __y.__cc.first);}\n    _LIBCPP_INLINE_VISIBILITY\n    bool operator()(const _Cp& __x, const _Key& __y) const\n        {return static_cast<const _Pred&>(*this)(__x.__cc.first, __y);}\n    _LIBCPP_INLINE_VISIBILITY\n    bool operator()(const _Key& __x, const _Cp& __y) const\n        {return static_cast<const _Pred&>(*this)(__x, __y.__cc.first);}\n    void swap(__unordered_map_equal&__y)\n        _NOEXCEPT_(__is_nothrow_swappable<_Pred>::value)\n    {\n        using _VSTD::swap;\n        swap(static_cast<const _Pred&>(*this), static_cast<const _Pred&>(__y));\n    }\n};\n\ntemplate <class _Key, class _Cp, class _Pred>\nclass __unordered_map_equal<_Key, _Cp, _Pred, false>\n{\n    _Pred __pred_;\npublic:\n    _LIBCPP_INLINE_VISIBILITY\n    __unordered_map_equal()\n        _NOEXCEPT_(is_nothrow_default_constructible<_Pred>::value)\n        : __pred_() {}\n    _LIBCPP_INLINE_VISIBILITY\n    __unordered_map_equal(const _Pred& __p)\n        _NOEXCEPT_(is_nothrow_copy_constructible<_Pred>::value)\n        : __pred_(__p) {}\n    _LIBCPP_INLINE_VISIBILITY\n    const _Pred& key_eq() const _NOEXCEPT {return __pred_;}\n    _LIBCPP_INLINE_VISIBILITY\n    bool operator()(const _Cp& __x, const _Cp& __y) const\n        {return __pred_(__x.__cc.first, __y.__cc.first);}\n    _LIBCPP_INLINE_VISIBILITY\n    bool operator()(const _Cp& __x, const _Key& __y) const\n        {return __pred_(__x.__cc.first, __y);}\n    _LIBCPP_INLINE_VISIBILITY\n    bool operator()(const _Key& __x, const _Cp& __y) const\n        {return __pred_(__x, __y.__cc.first);}\n    void swap(__unordered_map_equal&__y)\n        _NOEXCEPT_(__is_nothrow_swappable<_Pred>::value)\n    {\n        using _VSTD::swap;\n        swap(__pred_, __y.__pred_);\n    }\n};\n\ntemplate <class _Key, class _Cp, class _Pred, bool __b>\ninline _LIBCPP_INLINE_VISIBILITY\nvoid\nswap(__unordered_map_equal<_Key, _Cp, _Pred, __b>& __x,\n     __unordered_map_equal<_Key, _Cp, _Pred, __b>& __y)\n    _NOEXCEPT_(_NOEXCEPT_(__x.swap(__y)))\n{\n    __x.swap(__y);\n}\n\ntemplate <class _Alloc>\nclass __hash_map_node_destructor\n{\n    typedef _Alloc                              allocator_type;\n    typedef allocator_traits<allocator_type>    __alloc_traits;\n\npublic:\n\n    typedef typename __alloc_traits::pointer       pointer;\nprivate:\n\n    allocator_type& __na_;\n\n    __hash_map_node_destructor& operator=(const __hash_map_node_destructor&);\n\npublic:\n    bool __first_constructed;\n    bool __second_constructed;\n\n    _LIBCPP_INLINE_VISIBILITY\n    explicit __hash_map_node_destructor(allocator_type& __na) _NOEXCEPT\n        : __na_(__na),\n          __first_constructed(false),\n          __second_constructed(false)\n        {}\n\n#ifndef _LIBCPP_HAS_NO_RVALUE_REFERENCES\n    _LIBCPP_INLINE_VISIBILITY\n    __hash_map_node_destructor(__hash_node_destructor<allocator_type>&& __x)\n        _NOEXCEPT\n        : __na_(__x.__na_),\n          __first_constructed(__x.__value_constructed),\n          __second_constructed(__x.__value_constructed)\n        {\n            __x.__value_constructed = false;\n        }\n#else  // _LIBCPP_HAS_NO_RVALUE_REFERENCES\n    _LIBCPP_INLINE_VISIBILITY\n    __hash_map_node_destructor(const __hash_node_destructor<allocator_type>& __x)\n        : __na_(__x.__na_),\n          __first_constructed(__x.__value_constructed),\n          __second_constructed(__x.__value_constructed)\n        {\n            const_cast<bool&>(__x.__value_constructed) = false;\n        }\n#endif  // _LIBCPP_HAS_NO_RVALUE_REFERENCES\n\n    _LIBCPP_INLINE_VISIBILITY\n    void operator()(pointer __p) _NOEXCEPT\n    {\n        if (__second_constructed)\n            __alloc_traits::destroy(__na_, _VSTD::addressof(__p->__value_.__cc.second));\n        if (__first_constructed)\n            __alloc_traits::destroy(__na_, _VSTD::addressof(__p->__value_.__cc.first));\n        if (__p)\n            __alloc_traits::deallocate(__na_, __p, 1);\n    }\n};\n\n#ifndef _LIBCPP_CXX03_LANG\ntemplate <class _Key, class _Tp>\nunion __hash_value_type\n{\n    typedef _Key                                     key_type;\n    typedef _Tp                                      mapped_type;\n    typedef pair<const key_type, mapped_type>        value_type;\n    typedef pair<key_type, mapped_type>              __nc_value_type;\n\n    value_type __cc;\n    __nc_value_type __nc;\n\n    _LIBCPP_INLINE_VISIBILITY\n    __hash_value_type& operator=(const __hash_value_type& __v)\n        {__nc = __v.__cc; return *this;}\n\n    _LIBCPP_INLINE_VISIBILITY\n    __hash_value_type& operator=(__hash_value_type&& __v)\n        {__nc = _VSTD::move(__v.__nc); return *this;}\n\n    template <class _ValueTp,\n              class = typename enable_if<\n                    __is_same_uncvref<_ValueTp, value_type>::value\n                 >::type\n             >\n    _LIBCPP_INLINE_VISIBILITY\n    __hash_value_type& operator=(_ValueTp&& __v) {\n        __nc = _VSTD::forward<_ValueTp>(__v); return *this;\n    }\n\nprivate:\n    __hash_value_type(const __hash_value_type& __v) = delete;\n    __hash_value_type(__hash_value_type&& __v) = delete;\n    template <class ..._Args>\n    explicit __hash_value_type(_Args&& ...__args) = delete;\n\n    ~__hash_value_type() = delete;\n};\n\n#else\n\ntemplate <class _Key, class _Tp>\nstruct __hash_value_type\n{\n    typedef _Key                                     key_type;\n    typedef _Tp                                      mapped_type;\n    typedef pair<const key_type, mapped_type>        value_type;\n\n    value_type __cc;\n\nprivate:\n   ~__hash_value_type();\n};\n\n#endif\n\ntemplate <class _HashIterator>\nclass _LIBCPP_TEMPLATE_VIS __hash_map_iterator\n{\n    _HashIterator __i_;\n\n    typedef  __hash_node_types_from_iterator<_HashIterator> _NodeTypes;\n\npublic:\n    typedef forward_iterator_tag                                 iterator_category;\n    typedef typename _NodeTypes::__map_value_type                value_type;\n    typedef typename _NodeTypes::difference_type                 difference_type;\n    typedef value_type&                                          reference;\n    typedef typename _NodeTypes::__map_value_type_pointer       pointer;\n\n    _LIBCPP_INLINE_VISIBILITY\n    __hash_map_iterator() _NOEXCEPT {}\n\n    _LIBCPP_INLINE_VISIBILITY\n    __hash_map_iterator(_HashIterator __i) _NOEXCEPT : __i_(__i) {}\n\n    _LIBCPP_INLINE_VISIBILITY\n    reference operator*() const {return __i_->__cc;}\n    _LIBCPP_INLINE_VISIBILITY\n    pointer operator->() const {return pointer_traits<pointer>::pointer_to(__i_->__cc);}\n\n    _LIBCPP_INLINE_VISIBILITY\n    __hash_map_iterator& operator++() {++__i_; return *this;}\n    _LIBCPP_INLINE_VISIBILITY\n    __hash_map_iterator operator++(int)\n    {\n        __hash_map_iterator __t(*this);\n        ++(*this);\n        return __t;\n    }\n\n    friend _LIBCPP_INLINE_VISIBILITY\n        bool operator==(const __hash_map_iterator& __x, const __hash_map_iterator& __y)\n        {return __x.__i_ == __y.__i_;}\n    friend _LIBCPP_INLINE_VISIBILITY\n        bool operator!=(const __hash_map_iterator& __x, const __hash_map_iterator& __y)\n        {return __x.__i_ != __y.__i_;}\n\n    template <class, class, class, class, class> friend class _LIBCPP_TEMPLATE_VIS unordered_map;\n    template <class, class, class, class, class> friend class _LIBCPP_TEMPLATE_VIS unordered_multimap;\n    template <class> friend class _LIBCPP_TEMPLATE_VIS __hash_const_iterator;\n    template <class> friend class _LIBCPP_TEMPLATE_VIS __hash_const_local_iterator;\n    template <class> friend class _LIBCPP_TEMPLATE_VIS __hash_map_const_iterator;\n};\n\ntemplate <class _HashIterator>\nclass _LIBCPP_TEMPLATE_VIS __hash_map_const_iterator\n{\n    _HashIterator __i_;\n\n    typedef  __hash_node_types_from_iterator<_HashIterator> _NodeTypes;\n\npublic:\n    typedef forward_iterator_tag                                 iterator_category;\n    typedef typename _NodeTypes::__map_value_type                value_type;\n    typedef typename _NodeTypes::difference_type                 difference_type;\n    typedef const value_type&                                    reference;\n    typedef typename _NodeTypes::__const_map_value_type_pointer  pointer;\n\n    _LIBCPP_INLINE_VISIBILITY\n    __hash_map_const_iterator() _NOEXCEPT {}\n\n    _LIBCPP_INLINE_VISIBILITY\n    __hash_map_const_iterator(_HashIterator __i) _NOEXCEPT : __i_(__i) {}\n    _LIBCPP_INLINE_VISIBILITY\n    __hash_map_const_iterator(\n            __hash_map_iterator<typename _HashIterator::__non_const_iterator> __i)\n                 _NOEXCEPT\n                : __i_(__i.__i_) {}\n\n    _LIBCPP_INLINE_VISIBILITY\n    reference operator*() const {return __i_->__cc;}\n    _LIBCPP_INLINE_VISIBILITY\n    pointer operator->() const {return pointer_traits<pointer>::pointer_to(__i_->__cc);}\n\n    _LIBCPP_INLINE_VISIBILITY\n    __hash_map_const_iterator& operator++() {++__i_; return *this;}\n    _LIBCPP_INLINE_VISIBILITY\n    __hash_map_const_iterator operator++(int)\n    {\n        __hash_map_const_iterator __t(*this);\n        ++(*this);\n        return __t;\n    }\n\n    friend _LIBCPP_INLINE_VISIBILITY\n        bool operator==(const __hash_map_const_iterator& __x, const __hash_map_const_iterator& __y)\n        {return __x.__i_ == __y.__i_;}\n    friend _LIBCPP_INLINE_VISIBILITY\n        bool operator!=(const __hash_map_const_iterator& __x, const __hash_map_const_iterator& __y)\n        {return __x.__i_ != __y.__i_;}\n\n    template <class, class, class, class, class> friend class _LIBCPP_TEMPLATE_VIS unordered_map;\n    template <class, class, class, class, class> friend class _LIBCPP_TEMPLATE_VIS unordered_multimap;\n    template <class> friend class _LIBCPP_TEMPLATE_VIS __hash_const_iterator;\n    template <class> friend class _LIBCPP_TEMPLATE_VIS __hash_const_local_iterator;\n};\n\ntemplate <class _Key, class _Tp, class _Hash = hash<_Key>, class _Pred = equal_to<_Key>,\n          class _Alloc = allocator<pair<const _Key, _Tp> > >\nclass _LIBCPP_TEMPLATE_VIS unordered_map\n{\npublic:\n    // types\n    typedef _Key                                           key_type;\n    typedef _Tp                                            mapped_type;\n    typedef _Hash                                          hasher;\n    typedef _Pred                                          key_equal;\n    typedef _Alloc                                         allocator_type;\n    typedef pair<const key_type, mapped_type>              value_type;\n    typedef pair<key_type, mapped_type>                    __nc_value_type;\n    typedef value_type&                                    reference;\n    typedef const value_type&                              const_reference;\n    static_assert((is_same<value_type, typename allocator_type::value_type>::value),\n                  \"Invalid allocator::value_type\");\n\nprivate:\n    typedef __hash_value_type<key_type, mapped_type>                 __value_type;\n    typedef __unordered_map_hasher<key_type, __value_type, hasher>   __hasher;\n    typedef __unordered_map_equal<key_type, __value_type, key_equal> __key_equal;\n    typedef typename __rebind_alloc_helper<allocator_traits<allocator_type>,\n                                                 __value_type>::type __allocator_type;\n\n    typedef __hash_table<__value_type, __hasher,\n                         __key_equal,  __allocator_type>   __table;\n\n    __table __table_;\n\n    typedef typename __table::_NodeTypes                   _NodeTypes;\n    typedef typename __table::__node_pointer               __node_pointer;\n    typedef typename __table::__node_const_pointer         __node_const_pointer;\n    typedef typename __table::__node_traits                __node_traits;\n    typedef typename __table::__node_allocator             __node_allocator;\n    typedef typename __table::__node                       __node;\n    typedef __hash_map_node_destructor<__node_allocator>   _Dp;\n    typedef unique_ptr<__node, _Dp>                         __node_holder;\n    typedef allocator_traits<allocator_type>               __alloc_traits;\n\n    static_assert((is_same<typename __table::__container_value_type, value_type>::value), \"\");\n    static_assert((is_same<typename __table::__node_value_type, __value_type>::value), \"\");\npublic:\n    typedef typename __alloc_traits::pointer         pointer;\n    typedef typename __alloc_traits::const_pointer   const_pointer;\n    typedef typename __table::size_type              size_type;\n    typedef typename __table::difference_type        difference_type;\n\n    typedef __hash_map_iterator<typename __table::iterator>       iterator;\n    typedef __hash_map_const_iterator<typename __table::const_iterator> const_iterator;\n    typedef __hash_map_iterator<typename __table::local_iterator> local_iterator;\n    typedef __hash_map_const_iterator<typename __table::const_local_iterator> const_local_iterator;\n\n    _LIBCPP_INLINE_VISIBILITY\n    unordered_map()\n        _NOEXCEPT_(is_nothrow_default_constructible<__table>::value)\n        {\n#if _LIBCPP_DEBUG_LEVEL >= 2\n            __get_db()->__insert_c(this);\n#endif\n        }\n    explicit unordered_map(size_type __n, const hasher& __hf = hasher(),\n                           const key_equal& __eql = key_equal());\n    unordered_map(size_type __n, const hasher& __hf,\n                  const key_equal& __eql,\n                  const allocator_type& __a);\n    template <class _InputIterator>\n        unordered_map(_InputIterator __first, _InputIterator __last);\n    template <class _InputIterator>\n        unordered_map(_InputIterator __first, _InputIterator __last,\n                      size_type __n, const hasher& __hf = hasher(),\n                      const key_equal& __eql = key_equal());\n    template <class _InputIterator>\n        unordered_map(_InputIterator __first, _InputIterator __last,\n                      size_type __n, const hasher& __hf,\n                      const key_equal& __eql,\n                      const allocator_type& __a);\n    _LIBCPP_INLINE_VISIBILITY\n    explicit unordered_map(const allocator_type& __a);\n    unordered_map(const unordered_map& __u);\n    unordered_map(const unordered_map& __u, const allocator_type& __a);\n#ifndef _LIBCPP_HAS_NO_RVALUE_REFERENCES\n    _LIBCPP_INLINE_VISIBILITY\n    unordered_map(unordered_map&& __u)\n        _NOEXCEPT_(is_nothrow_move_constructible<__table>::value);\n    unordered_map(unordered_map&& __u, const allocator_type& __a);\n#endif  // _LIBCPP_HAS_NO_RVALUE_REFERENCES\n#ifndef _LIBCPP_HAS_NO_GENERALIZED_INITIALIZERS\n    unordered_map(initializer_list<value_type> __il);\n    unordered_map(initializer_list<value_type> __il, size_type __n,\n                  const hasher& __hf = hasher(), const key_equal& __eql = key_equal());\n    unordered_map(initializer_list<value_type> __il, size_type __n,\n                  const hasher& __hf, const key_equal& __eql,\n                  const allocator_type& __a);\n#endif  // _LIBCPP_HAS_NO_GENERALIZED_INITIALIZERS\n#if _LIBCPP_STD_VER > 11\n    _LIBCPP_INLINE_VISIBILITY\n    unordered_map(size_type __n, const allocator_type& __a)\n      : unordered_map(__n, hasher(), key_equal(), __a) {}\n    _LIBCPP_INLINE_VISIBILITY\n    unordered_map(size_type __n, const hasher& __hf, const allocator_type& __a)\n      : unordered_map(__n, __hf, key_equal(), __a) {}\n    template <class _InputIterator>\n    _LIBCPP_INLINE_VISIBILITY\n      unordered_map(_InputIterator __first, _InputIterator __last, size_type __n, const allocator_type& __a)\n      : unordered_map(__first, __last, __n, hasher(), key_equal(), __a) {}\n    template <class _InputIterator>\n    _LIBCPP_INLINE_VISIBILITY\n      unordered_map(_InputIterator __first, _InputIterator __last, size_type __n, const hasher& __hf, \n        const allocator_type& __a)\n      : unordered_map(__first, __last, __n, __hf, key_equal(), __a) {}\n    _LIBCPP_INLINE_VISIBILITY\n    unordered_map(initializer_list<value_type> __il, size_type __n, const allocator_type& __a)\n      : unordered_map(__il, __n, hasher(), key_equal(), __a) {}\n    _LIBCPP_INLINE_VISIBILITY\n    unordered_map(initializer_list<value_type> __il, size_type __n, const hasher& __hf, \n      const allocator_type& __a)\n      : unordered_map(__il, __n, __hf, key_equal(), __a) {}\n#endif\n    // ~unordered_map() = default;\n    _LIBCPP_INLINE_VISIBILITY\n    unordered_map& operator=(const unordered_map& __u)\n    {\n#ifndef _LIBCPP_CXX03_LANG\n        __table_ = __u.__table_;\n#else\n        if (this != &__u) {\n            __table_.clear();\n            __table_.hash_function() = __u.__table_.hash_function();\n            __table_.key_eq() = __u.__table_.key_eq();\n            __table_.max_load_factor() = __u.__table_.max_load_factor();\n            __table_.__copy_assign_alloc(__u.__table_);\n            insert(__u.begin(), __u.end());\n        }\n#endif\n        return *this;\n    }\n#ifndef _LIBCPP_HAS_NO_RVALUE_REFERENCES\n    _LIBCPP_INLINE_VISIBILITY\n    unordered_map& operator=(unordered_map&& __u)\n        _NOEXCEPT_(is_nothrow_move_assignable<__table>::value);\n#endif\n#ifndef _LIBCPP_HAS_NO_GENERALIZED_INITIALIZERS\n    _LIBCPP_INLINE_VISIBILITY\n    unordered_map& operator=(initializer_list<value_type> __il);\n#endif  // _LIBCPP_HAS_NO_GENERALIZED_INITIALIZERS\n\n    _LIBCPP_INLINE_VISIBILITY\n    allocator_type get_allocator() const _NOEXCEPT\n        {return allocator_type(__table_.__node_alloc());}\n\n    _LIBCPP_INLINE_VISIBILITY\n    bool      empty() const _NOEXCEPT {return __table_.size() == 0;}\n    _LIBCPP_INLINE_VISIBILITY\n    size_type size() const _NOEXCEPT  {return __table_.size();}\n    _LIBCPP_INLINE_VISIBILITY\n    size_type max_size() const _NOEXCEPT {return __table_.max_size();}\n\n    _LIBCPP_INLINE_VISIBILITY\n    iterator       begin() _NOEXCEPT        {return __table_.begin();}\n    _LIBCPP_INLINE_VISIBILITY\n    iterator       end() _NOEXCEPT          {return __table_.end();}\n    _LIBCPP_INLINE_VISIBILITY\n    const_iterator begin()  const _NOEXCEPT {return __table_.begin();}\n    _LIBCPP_INLINE_VISIBILITY\n    const_iterator end()    const _NOEXCEPT {return __table_.end();}\n    _LIBCPP_INLINE_VISIBILITY\n    const_iterator cbegin() const _NOEXCEPT {return __table_.begin();}\n    _LIBCPP_INLINE_VISIBILITY\n    const_iterator cend()   const _NOEXCEPT {return __table_.end();}\n\n    _LIBCPP_INLINE_VISIBILITY\n    pair<iterator, bool> insert(const value_type& __x)\n        {return __table_.__insert_unique(__x);}\n\n    iterator insert(const_iterator __p, const value_type& __x) {\n#if _LIBCPP_DEBUG_LEVEL >= 2\n        _LIBCPP_ASSERT(__get_const_db()->__find_c_from_i(&__p) == this,\n            \"unordered_map::insert(const_iterator, const value_type&) called with an iterator not\"\n            \" referring to this unordered_map\");\n#else\n        ((void)__p);\n#endif\n        return insert(__x).first;\n    }\n\n    template <class _InputIterator>\n        _LIBCPP_INLINE_VISIBILITY\n        void insert(_InputIterator __first, _InputIterator __last);\n\n#ifndef _LIBCPP_HAS_NO_GENERALIZED_INITIALIZERS\n    _LIBCPP_INLINE_VISIBILITY\n    void insert(initializer_list<value_type> __il)\n        {insert(__il.begin(), __il.end());}\n#endif  // _LIBCPP_HAS_NO_GENERALIZED_INITIALIZERS\n\n#ifndef _LIBCPP_CXX03_LANG\n    _LIBCPP_INLINE_VISIBILITY\n    pair<iterator, bool> insert(value_type&& __x)\n        {return __table_.__insert_unique(_VSTD::move(__x));}\n\n    iterator insert(const_iterator __p, value_type&& __x) {\n#if _LIBCPP_DEBUG_LEVEL >= 2\n        _LIBCPP_ASSERT(__get_const_db()->__find_c_from_i(&__p) == this,\n            \"unordered_map::insert(const_iterator, const value_type&) called with an iterator not\"\n            \" referring to this unordered_map\");\n#else\n        ((void)__p);\n#endif\n        return __table_.__insert_unique(_VSTD::move(__x)).first;\n    }\n\n    template <class _Pp,\n              class = typename enable_if<is_constructible<value_type, _Pp>::value>::type>\n        _LIBCPP_INLINE_VISIBILITY\n        pair<iterator, bool> insert(_Pp&& __x)\n            {return __table_.__insert_unique(_VSTD::forward<_Pp>(__x));}\n\n    template <class _Pp,\n              class = typename enable_if<is_constructible<value_type, _Pp>::value>::type>\n        _LIBCPP_INLINE_VISIBILITY\n        iterator insert(const_iterator __p, _Pp&& __x)\n        {\n#if _LIBCPP_DEBUG_LEVEL >= 2\n            _LIBCPP_ASSERT(__get_const_db()->__find_c_from_i(&__p) == this,\n                \"unordered_map::insert(const_iterator, value_type&&) called with an iterator not\"\n                \" referring to this unordered_map\");\n#else\n          ((void)__p);\n#endif\n            return insert(_VSTD::forward<_Pp>(__x)).first;\n        }\n\n    template <class... _Args>\n    _LIBCPP_INLINE_VISIBILITY\n    pair<iterator, bool> emplace(_Args&&... __args) {\n        return __table_.__emplace_unique(_VSTD::forward<_Args>(__args)...);\n    }\n\n    template <class... _Args>\n    _LIBCPP_INLINE_VISIBILITY\n    iterator emplace_hint(const_iterator __p, _Args&&... __args) {\n#if _LIBCPP_DEBUG_LEVEL >= 2\n        _LIBCPP_ASSERT(__get_const_db()->__find_c_from_i(&__p) == this,\n            \"unordered_map::emplace_hint(const_iterator, args...) called with an iterator not\"\n            \" referring to this unordered_map\");\n#else\n          ((void)__p);\n#endif\n        return __table_.__emplace_unique(_VSTD::forward<_Args>(__args)...).first;\n    }\n\n#endif  // _LIBCPP_CXX03_LANG\n\n#if _LIBCPP_STD_VER > 14\n    template <class... _Args>\n        _LIBCPP_INLINE_VISIBILITY\n        pair<iterator, bool> try_emplace(const key_type& __k, _Args&&... __args)\n    {\n        return __table_.__emplace_unique_key_args(__k, _VSTD::piecewise_construct,\n            _VSTD::forward_as_tuple(__k),\n            _VSTD::forward_as_tuple(_VSTD::forward<_Args>(__args)...));\n    }\n\n    template <class... _Args>\n        _LIBCPP_INLINE_VISIBILITY\n        pair<iterator, bool> try_emplace(key_type&& __k, _Args&&... __args)\n    {\n        return __table_.__emplace_unique_key_args(__k, _VSTD::piecewise_construct,\n            _VSTD::forward_as_tuple(_VSTD::move(__k)),\n            _VSTD::forward_as_tuple(_VSTD::forward<_Args>(__args)...));\n    }\n\n    template <class... _Args>\n        _LIBCPP_INLINE_VISIBILITY\n        iterator try_emplace(const_iterator __h, const key_type& __k, _Args&&... __args)\n    {\n#if _LIBCPP_DEBUG_LEVEL >= 2\n        _LIBCPP_ASSERT(__get_const_db()->__find_c_from_i(&__h) == this,\n            \"unordered_map::try_emplace(const_iterator, key, args...) called with an iterator not\"\n            \" referring to this unordered_map\");\n#else\n        ((void)__h);\n#endif\n        return try_emplace(__k, _VSTD::forward<_Args>(__args)...).first;\n    }\n\n    template <class... _Args>\n        _LIBCPP_INLINE_VISIBILITY\n        iterator try_emplace(const_iterator __h, key_type&& __k, _Args&&... __args)\n    {\n#if _LIBCPP_DEBUG_LEVEL >= 2\n        _LIBCPP_ASSERT(__get_const_db()->__find_c_from_i(&__h) == this,\n            \"unordered_map::try_emplace(const_iterator, key, args...) called with an iterator not\"\n            \" referring to this unordered_map\");\n#else\n        ((void)__h);\n#endif\n        return try_emplace(_VSTD::move(__k), _VSTD::forward<_Args>(__args)...).first;\n    }\n\n    template <class _Vp>\n        _LIBCPP_INLINE_VISIBILITY\n        pair<iterator, bool> insert_or_assign(const key_type& __k, _Vp&& __v)\n    {\n        pair<iterator, bool> __res = __table_.__emplace_unique_key_args(__k,\n            __k, _VSTD::forward<_Vp>(__v));\n        if (!__res.second) {\n            __res.first->second = _VSTD::forward<_Vp>(__v);\n        }\n        return __res;\n    }\n\n    template <class _Vp>\n        _LIBCPP_INLINE_VISIBILITY\n        pair<iterator, bool> insert_or_assign(key_type&& __k, _Vp&& __v)\n    {\n        pair<iterator, bool> __res = __table_.__emplace_unique_key_args(__k,\n            _VSTD::move(__k), _VSTD::forward<_Vp>(__v));\n        if (!__res.second) {\n            __res.first->second = _VSTD::forward<_Vp>(__v);\n        }\n        return __res;\n    }\n\n    template <class _Vp>\n        _LIBCPP_INLINE_VISIBILITY\n        iterator insert_or_assign(const_iterator, const key_type& __k, _Vp&& __v)\n     {\n          // FIXME: Add debug mode checking for the iterator input\n          return insert_or_assign(__k, _VSTD::forward<_Vp>(__v)).first;\n     }\n\n    template <class _Vp>\n        _LIBCPP_INLINE_VISIBILITY\n        iterator insert_or_assign(const_iterator, key_type&& __k, _Vp&& __v)\n     {\n        // FIXME: Add debug mode checking for the iterator input\n        return insert_or_assign(_VSTD::move(__k), _VSTD::forward<_Vp>(__v)).first;\n     }\n#endif\n\n    _LIBCPP_INLINE_VISIBILITY\n    iterator erase(const_iterator __p) {return __table_.erase(__p.__i_);}\n    _LIBCPP_INLINE_VISIBILITY\n    iterator erase(iterator __p)       {return __table_.erase(__p.__i_);}\n    _LIBCPP_INLINE_VISIBILITY\n    size_type erase(const key_type& __k) {return __table_.__erase_unique(__k);}\n    _LIBCPP_INLINE_VISIBILITY\n    iterator erase(const_iterator __first, const_iterator __last)\n        {return __table_.erase(__first.__i_, __last.__i_);}\n    _LIBCPP_INLINE_VISIBILITY\n    void clear() _NOEXCEPT {__table_.clear();}\n\n    _LIBCPP_INLINE_VISIBILITY\n    void swap(unordered_map& __u)\n        _NOEXCEPT_(__is_nothrow_swappable<__table>::value)\n        { __table_.swap(__u.__table_);}\n\n    _LIBCPP_INLINE_VISIBILITY\n    hasher hash_function() const\n        {return __table_.hash_function().hash_function();}\n    _LIBCPP_INLINE_VISIBILITY\n    key_equal key_eq() const\n        {return __table_.key_eq().key_eq();}\n\n    _LIBCPP_INLINE_VISIBILITY\n    iterator       find(const key_type& __k)       {return __table_.find(__k);}\n    _LIBCPP_INLINE_VISIBILITY\n    const_iterator find(const key_type& __k) const {return __table_.find(__k);}\n    _LIBCPP_INLINE_VISIBILITY\n    size_type count(const key_type& __k) const {return __table_.__count_unique(__k);}\n    _LIBCPP_INLINE_VISIBILITY\n    pair<iterator, iterator>             equal_range(const key_type& __k)\n        {return __table_.__equal_range_unique(__k);}\n    _LIBCPP_INLINE_VISIBILITY\n    pair<const_iterator, const_iterator> equal_range(const key_type& __k) const\n        {return __table_.__equal_range_unique(__k);}\n\n    mapped_type& operator[](const key_type& __k);\n#ifndef _LIBCPP_CXX03_LANG\n    mapped_type& operator[](key_type&& __k);\n#endif\n\n    mapped_type&       at(const key_type& __k);\n    const mapped_type& at(const key_type& __k) const;\n\n    _LIBCPP_INLINE_VISIBILITY\n    size_type bucket_count() const _NOEXCEPT {return __table_.bucket_count();}\n    _LIBCPP_INLINE_VISIBILITY\n    size_type max_bucket_count() const _NOEXCEPT {return __table_.max_bucket_count();}\n\n    _LIBCPP_INLINE_VISIBILITY\n    size_type bucket_size(size_type __n) const\n        {return __table_.bucket_size(__n);}\n    _LIBCPP_INLINE_VISIBILITY\n    size_type bucket(const key_type& __k) const {return __table_.bucket(__k);}\n\n    _LIBCPP_INLINE_VISIBILITY\n    local_iterator       begin(size_type __n)        {return __table_.begin(__n);}\n    _LIBCPP_INLINE_VISIBILITY\n    local_iterator       end(size_type __n)          {return __table_.end(__n);}\n    _LIBCPP_INLINE_VISIBILITY\n    const_local_iterator begin(size_type __n) const  {return __table_.cbegin(__n);}\n    _LIBCPP_INLINE_VISIBILITY\n    const_local_iterator end(size_type __n) const    {return __table_.cend(__n);}\n    _LIBCPP_INLINE_VISIBILITY\n    const_local_iterator cbegin(size_type __n) const {return __table_.cbegin(__n);}\n    _LIBCPP_INLINE_VISIBILITY\n    const_local_iterator cend(size_type __n) const   {return __table_.cend(__n);}\n\n    _LIBCPP_INLINE_VISIBILITY\n    float load_factor() const _NOEXCEPT {return __table_.load_factor();}\n    _LIBCPP_INLINE_VISIBILITY\n    float max_load_factor() const _NOEXCEPT {return __table_.max_load_factor();}\n    _LIBCPP_INLINE_VISIBILITY\n    void max_load_factor(float __mlf) {__table_.max_load_factor(__mlf);}\n    _LIBCPP_INLINE_VISIBILITY\n    void rehash(size_type __n) {__table_.rehash(__n);}\n    _LIBCPP_INLINE_VISIBILITY\n    void reserve(size_type __n) {__table_.reserve(__n);}\n\n#if _LIBCPP_DEBUG_LEVEL >= 2\n\n    bool __dereferenceable(const const_iterator* __i) const\n        {return __table_.__dereferenceable(&__i->__i_);}\n    bool __decrementable(const const_iterator* __i) const\n        {return __table_.__decrementable(&__i->__i_);}\n    bool __addable(const const_iterator* __i, ptrdiff_t __n) const\n        {return __table_.__addable(&__i->__i_, __n);}\n    bool __subscriptable(const const_iterator* __i, ptrdiff_t __n) const\n        {return __table_.__addable(&__i->__i_, __n);}\n\n#endif  // _LIBCPP_DEBUG_LEVEL >= 2\n\nprivate:\n\n#ifdef _LIBCPP_CXX03_LANG\n    __node_holder __construct_node_with_key(const key_type& __k);\n#endif\n};\n\ntemplate <class _Key, class _Tp, class _Hash, class _Pred, class _Alloc>\nunordered_map<_Key, _Tp, _Hash, _Pred, _Alloc>::unordered_map(\n        size_type __n, const hasher& __hf, const key_equal& __eql)\n    : __table_(__hf, __eql)\n{\n#if _LIBCPP_DEBUG_LEVEL >= 2\n    __get_db()->__insert_c(this);\n#endif\n    __table_.rehash(__n);\n}\n\ntemplate <class _Key, class _Tp, class _Hash, class _Pred, class _Alloc>\nunordered_map<_Key, _Tp, _Hash, _Pred, _Alloc>::unordered_map(\n        size_type __n, const hasher& __hf, const key_equal& __eql,\n        const allocator_type& __a)\n    : __table_(__hf, __eql, typename __table::allocator_type(__a))\n{\n#if _LIBCPP_DEBUG_LEVEL >= 2\n    __get_db()->__insert_c(this);\n#endif\n    __table_.rehash(__n);\n}\n\ntemplate <class _Key, class _Tp, class _Hash, class _Pred, class _Alloc>\ninline\nunordered_map<_Key, _Tp, _Hash, _Pred, _Alloc>::unordered_map(\n        const allocator_type& __a)\n    : __table_(typename __table::allocator_type(__a))\n{\n#if _LIBCPP_DEBUG_LEVEL >= 2\n    __get_db()->__insert_c(this);\n#endif\n}\n\ntemplate <class _Key, class _Tp, class _Hash, class _Pred, class _Alloc>\ntemplate <class _InputIterator>\nunordered_map<_Key, _Tp, _Hash, _Pred, _Alloc>::unordered_map(\n        _InputIterator __first, _InputIterator __last)\n{\n#if _LIBCPP_DEBUG_LEVEL >= 2\n    __get_db()->__insert_c(this);\n#endif\n    insert(__first, __last);\n}\n\ntemplate <class _Key, class _Tp, class _Hash, class _Pred, class _Alloc>\ntemplate <class _InputIterator>\nunordered_map<_Key, _Tp, _Hash, _Pred, _Alloc>::unordered_map(\n        _InputIterator __first, _InputIterator __last, size_type __n,\n        const hasher& __hf, const key_equal& __eql)\n    : __table_(__hf, __eql)\n{\n#if _LIBCPP_DEBUG_LEVEL >= 2\n    __get_db()->__insert_c(this);\n#endif\n    __table_.rehash(__n);\n    insert(__first, __last);\n}\n\ntemplate <class _Key, class _Tp, class _Hash, class _Pred, class _Alloc>\ntemplate <class _InputIterator>\nunordered_map<_Key, _Tp, _Hash, _Pred, _Alloc>::unordered_map(\n        _InputIterator __first, _InputIterator __last, size_type __n,\n        const hasher& __hf, const key_equal& __eql, const allocator_type& __a)\n    : __table_(__hf, __eql, typename __table::allocator_type(__a))\n{\n#if _LIBCPP_DEBUG_LEVEL >= 2\n    __get_db()->__insert_c(this);\n#endif\n    __table_.rehash(__n);\n    insert(__first, __last);\n}\n\ntemplate <class _Key, class _Tp, class _Hash, class _Pred, class _Alloc>\nunordered_map<_Key, _Tp, _Hash, _Pred, _Alloc>::unordered_map(\n        const unordered_map& __u)\n    : __table_(__u.__table_)\n{\n#if _LIBCPP_DEBUG_LEVEL >= 2\n    __get_db()->__insert_c(this);\n#endif\n    __table_.rehash(__u.bucket_count());\n    insert(__u.begin(), __u.end());\n}\n\ntemplate <class _Key, class _Tp, class _Hash, class _Pred, class _Alloc>\nunordered_map<_Key, _Tp, _Hash, _Pred, _Alloc>::unordered_map(\n        const unordered_map& __u, const allocator_type& __a)\n    : __table_(__u.__table_, typename __table::allocator_type(__a))\n{\n#if _LIBCPP_DEBUG_LEVEL >= 2\n    __get_db()->__insert_c(this);\n#endif\n    __table_.rehash(__u.bucket_count());\n    insert(__u.begin(), __u.end());\n}\n\n#ifndef _LIBCPP_HAS_NO_RVALUE_REFERENCES\n\ntemplate <class _Key, class _Tp, class _Hash, class _Pred, class _Alloc>\ninline\nunordered_map<_Key, _Tp, _Hash, _Pred, _Alloc>::unordered_map(\n        unordered_map&& __u)\n    _NOEXCEPT_(is_nothrow_move_constructible<__table>::value)\n    : __table_(_VSTD::move(__u.__table_))\n{\n#if _LIBCPP_DEBUG_LEVEL >= 2\n    __get_db()->__insert_c(this);\n    __get_db()->swap(this, &__u);\n#endif\n}\n\ntemplate <class _Key, class _Tp, class _Hash, class _Pred, class _Alloc>\nunordered_map<_Key, _Tp, _Hash, _Pred, _Alloc>::unordered_map(\n        unordered_map&& __u, const allocator_type& __a)\n    : __table_(_VSTD::move(__u.__table_), typename __table::allocator_type(__a))\n{\n#if _LIBCPP_DEBUG_LEVEL >= 2\n    __get_db()->__insert_c(this);\n#endif\n    if (__a != __u.get_allocator())\n    {\n        iterator __i = __u.begin();\n        while (__u.size() != 0) {\n            __table_.__emplace_unique(_VSTD::move(\n                __u.__table_.remove((__i++).__i_)->__value_.__nc));\n        }\n    }\n#if _LIBCPP_DEBUG_LEVEL >= 2\n    else\n        __get_db()->swap(this, &__u);\n#endif\n}\n\n#endif  // _LIBCPP_HAS_NO_RVALUE_REFERENCES\n\n#ifndef _LIBCPP_HAS_NO_GENERALIZED_INITIALIZERS\n\ntemplate <class _Key, class _Tp, class _Hash, class _Pred, class _Alloc>\nunordered_map<_Key, _Tp, _Hash, _Pred, _Alloc>::unordered_map(\n        initializer_list<value_type> __il)\n{\n#if _LIBCPP_DEBUG_LEVEL >= 2\n    __get_db()->__insert_c(this);\n#endif\n    insert(__il.begin(), __il.end());\n}\n\ntemplate <class _Key, class _Tp, class _Hash, class _Pred, class _Alloc>\nunordered_map<_Key, _Tp, _Hash, _Pred, _Alloc>::unordered_map(\n        initializer_list<value_type> __il, size_type __n, const hasher& __hf,\n        const key_equal& __eql)\n    : __table_(__hf, __eql)\n{\n#if _LIBCPP_DEBUG_LEVEL >= 2\n    __get_db()->__insert_c(this);\n#endif\n    __table_.rehash(__n);\n    insert(__il.begin(), __il.end());\n}\n\ntemplate <class _Key, class _Tp, class _Hash, class _Pred, class _Alloc>\nunordered_map<_Key, _Tp, _Hash, _Pred, _Alloc>::unordered_map(\n        initializer_list<value_type> __il, size_type __n, const hasher& __hf,\n        const key_equal& __eql, const allocator_type& __a)\n    : __table_(__hf, __eql, typename __table::allocator_type(__a))\n{\n#if _LIBCPP_DEBUG_LEVEL >= 2\n    __get_db()->__insert_c(this);\n#endif\n    __table_.rehash(__n);\n    insert(__il.begin(), __il.end());\n}\n\n#endif  // _LIBCPP_HAS_NO_GENERALIZED_INITIALIZERS\n\n#ifndef _LIBCPP_HAS_NO_RVALUE_REFERENCES\n\ntemplate <class _Key, class _Tp, class _Hash, class _Pred, class _Alloc>\ninline\nunordered_map<_Key, _Tp, _Hash, _Pred, _Alloc>&\nunordered_map<_Key, _Tp, _Hash, _Pred, _Alloc>::operator=(unordered_map&& __u)\n    _NOEXCEPT_(is_nothrow_move_assignable<__table>::value)\n{\n    __table_ = _VSTD::move(__u.__table_);\n    return *this;\n}\n\n#endif  // _LIBCPP_HAS_NO_RVALUE_REFERENCES\n\n#ifndef _LIBCPP_HAS_NO_GENERALIZED_INITIALIZERS\n\ntemplate <class _Key, class _Tp, class _Hash, class _Pred, class _Alloc>\ninline\nunordered_map<_Key, _Tp, _Hash, _Pred, _Alloc>&\nunordered_map<_Key, _Tp, _Hash, _Pred, _Alloc>::operator=(\n        initializer_list<value_type> __il)\n{\n    __table_.__assign_unique(__il.begin(), __il.end());\n    return *this;\n}\n\n#endif  // _LIBCPP_HAS_NO_GENERALIZED_INITIALIZERS\n\n#ifdef _LIBCPP_CXX03_LANG\ntemplate <class _Key, class _Tp, class _Hash, class _Pred, class _Alloc>\ntypename unordered_map<_Key, _Tp, _Hash, _Pred, _Alloc>::__node_holder\nunordered_map<_Key, _Tp, _Hash, _Pred, _Alloc>::__construct_node_with_key(const key_type& __k)\n{\n    __node_allocator& __na = __table_.__node_alloc();\n    __node_holder __h(__node_traits::allocate(__na, 1), _Dp(__na));\n    __node_traits::construct(__na, _VSTD::addressof(__h->__value_.__cc.first), __k);\n    __h.get_deleter().__first_constructed = true;\n    __node_traits::construct(__na, _VSTD::addressof(__h->__value_.__cc.second));\n    __h.get_deleter().__second_constructed = true;\n    return _LIBCPP_EXPLICIT_MOVE(__h);  // explicitly moved for C++03\n}\n#endif\n\ntemplate <class _Key, class _Tp, class _Hash, class _Pred, class _Alloc>\ntemplate <class _InputIterator>\ninline\nvoid\nunordered_map<_Key, _Tp, _Hash, _Pred, _Alloc>::insert(_InputIterator __first,\n                                                       _InputIterator __last)\n{\n    for (; __first != __last; ++__first)\n        __table_.__insert_unique(*__first);\n}\n\n#ifdef _LIBCPP_CXX03_LANG\ntemplate <class _Key, class _Tp, class _Hash, class _Pred, class _Alloc>\n_Tp&\nunordered_map<_Key, _Tp, _Hash, _Pred, _Alloc>::operator[](const key_type& __k)\n{\n    iterator __i = find(__k);\n    if (__i != end())\n        return __i->second;\n    __node_holder __h = __construct_node_with_key(__k);\n    pair<iterator, bool> __r = __table_.__node_insert_unique(__h.get());\n    __h.release();\n    return __r.first->second;\n}\n#else\n\ntemplate <class _Key, class _Tp, class _Hash, class _Pred, class _Alloc>\n_Tp&\nunordered_map<_Key, _Tp, _Hash, _Pred, _Alloc>::operator[](const key_type& __k)\n{\n    return __table_.__emplace_unique_key_args(__k,\n        std::piecewise_construct, std::forward_as_tuple(__k),\n                                  std::forward_as_tuple()).first->__cc.second;\n}\n\ntemplate <class _Key, class _Tp, class _Hash, class _Pred, class _Alloc>\n_Tp&\nunordered_map<_Key, _Tp, _Hash, _Pred, _Alloc>::operator[](key_type&& __k)\n{\n    return __table_.__emplace_unique_key_args(__k,\n        std::piecewise_construct, std::forward_as_tuple(std::move(__k)),\n                                  std::forward_as_tuple()).first->__cc.second;\n}\n\n#endif  // !_LIBCPP_CXX03_MODE\n\ntemplate <class _Key, class _Tp, class _Hash, class _Pred, class _Alloc>\n_Tp&\nunordered_map<_Key, _Tp, _Hash, _Pred, _Alloc>::at(const key_type& __k)\n{\n    iterator __i = find(__k);\n#ifndef _LIBCPP_NO_EXCEPTIONS\n    if (__i == end())\n        throw out_of_range(\"unordered_map::at: key not found\");\n#endif  // _LIBCPP_NO_EXCEPTIONS\n    return __i->second;\n}\n\ntemplate <class _Key, class _Tp, class _Hash, class _Pred, class _Alloc>\nconst _Tp&\nunordered_map<_Key, _Tp, _Hash, _Pred, _Alloc>::at(const key_type& __k) const\n{\n    const_iterator __i = find(__k);\n#ifndef _LIBCPP_NO_EXCEPTIONS\n    if (__i == end())\n        throw out_of_range(\"unordered_map::at: key not found\");\n#endif  // _LIBCPP_NO_EXCEPTIONS\n    return __i->second;\n}\n\ntemplate <class _Key, class _Tp, class _Hash, class _Pred, class _Alloc>\ninline _LIBCPP_INLINE_VISIBILITY\nvoid\nswap(unordered_map<_Key, _Tp, _Hash, _Pred, _Alloc>& __x,\n     unordered_map<_Key, _Tp, _Hash, _Pred, _Alloc>& __y)\n    _NOEXCEPT_(_NOEXCEPT_(__x.swap(__y)))\n{\n    __x.swap(__y);\n}\n\ntemplate <class _Key, class _Tp, class _Hash, class _Pred, class _Alloc>\nbool\noperator==(const unordered_map<_Key, _Tp, _Hash, _Pred, _Alloc>& __x,\n           const unordered_map<_Key, _Tp, _Hash, _Pred, _Alloc>& __y)\n{\n    if (__x.size() != __y.size())\n        return false;\n    typedef typename unordered_map<_Key, _Tp, _Hash, _Pred, _Alloc>::const_iterator\n                                                                 const_iterator;\n    for (const_iterator __i = __x.begin(), __ex = __x.end(), __ey = __y.end();\n            __i != __ex; ++__i)\n    {\n        const_iterator __j = __y.find(__i->first);\n        if (__j == __ey || !(*__i == *__j))\n            return false;\n    }\n    return true;\n}\n\ntemplate <class _Key, class _Tp, class _Hash, class _Pred, class _Alloc>\ninline _LIBCPP_INLINE_VISIBILITY\nbool\noperator!=(const unordered_map<_Key, _Tp, _Hash, _Pred, _Alloc>& __x,\n           const unordered_map<_Key, _Tp, _Hash, _Pred, _Alloc>& __y)\n{\n    return !(__x == __y);\n}\n\ntemplate <class _Key, class _Tp, class _Hash = hash<_Key>, class _Pred = equal_to<_Key>,\n          class _Alloc = allocator<pair<const _Key, _Tp> > >\nclass _LIBCPP_TEMPLATE_VIS unordered_multimap\n{\npublic:\n    // types\n    typedef _Key                                           key_type;\n    typedef _Tp                                            mapped_type;\n    typedef _Hash                                          hasher;\n    typedef _Pred                                          key_equal;\n    typedef _Alloc                                         allocator_type;\n    typedef pair<const key_type, mapped_type>              value_type;\n    typedef pair<key_type, mapped_type>                    __nc_value_type;\n    typedef value_type&                                    reference;\n    typedef const value_type&                              const_reference;\n    static_assert((is_same<value_type, typename allocator_type::value_type>::value),\n                  \"Invalid allocator::value_type\");\n\nprivate:\n    typedef __hash_value_type<key_type, mapped_type>                 __value_type;\n    typedef __unordered_map_hasher<key_type, __value_type, hasher>   __hasher;\n    typedef __unordered_map_equal<key_type, __value_type, key_equal> __key_equal;\n    typedef typename __rebind_alloc_helper<allocator_traits<allocator_type>,\n                                                 __value_type>::type __allocator_type;\n\n    typedef __hash_table<__value_type, __hasher,\n                         __key_equal,  __allocator_type>   __table;\n\n    __table __table_;\n\n    typedef typename __table::_NodeTypes                   _NodeTypes;\n    typedef typename __table::__node_traits                __node_traits;\n    typedef typename __table::__node_allocator             __node_allocator;\n    typedef typename __table::__node                       __node;\n    typedef __hash_map_node_destructor<__node_allocator>   _Dp;\n    typedef unique_ptr<__node, _Dp>                         __node_holder;\n    typedef allocator_traits<allocator_type>               __alloc_traits;\n    static_assert((is_same<typename __node_traits::size_type,\n                          typename __alloc_traits::size_type>::value),\n                 \"Allocator uses different size_type for different types\");\npublic:\n    typedef typename __alloc_traits::pointer         pointer;\n    typedef typename __alloc_traits::const_pointer   const_pointer;\n    typedef typename __table::size_type              size_type;\n    typedef typename __table::difference_type        difference_type;\n\n    typedef __hash_map_iterator<typename __table::iterator>       iterator;\n    typedef __hash_map_const_iterator<typename __table::const_iterator> const_iterator;\n    typedef __hash_map_iterator<typename __table::local_iterator> local_iterator;\n    typedef __hash_map_const_iterator<typename __table::const_local_iterator> const_local_iterator;\n\n    _LIBCPP_INLINE_VISIBILITY\n    unordered_multimap()\n        _NOEXCEPT_(is_nothrow_default_constructible<__table>::value)\n        {\n#if _LIBCPP_DEBUG_LEVEL >= 2\n            __get_db()->__insert_c(this);\n#endif\n        }\n    explicit unordered_multimap(size_type __n, const hasher& __hf = hasher(),\n                                const key_equal& __eql = key_equal());\n    unordered_multimap(size_type __n, const hasher& __hf,\n                                const key_equal& __eql,\n                                const allocator_type& __a);\n    template <class _InputIterator>\n        unordered_multimap(_InputIterator __first, _InputIterator __last);\n    template <class _InputIterator>\n        unordered_multimap(_InputIterator __first, _InputIterator __last,\n                      size_type __n, const hasher& __hf = hasher(),\n                      const key_equal& __eql = key_equal());\n    template <class _InputIterator>\n        unordered_multimap(_InputIterator __first, _InputIterator __last,\n                      size_type __n, const hasher& __hf,\n                      const key_equal& __eql,\n                      const allocator_type& __a);\n    _LIBCPP_INLINE_VISIBILITY\n    explicit unordered_multimap(const allocator_type& __a);\n    unordered_multimap(const unordered_multimap& __u);\n    unordered_multimap(const unordered_multimap& __u, const allocator_type& __a);\n#ifndef _LIBCPP_HAS_NO_RVALUE_REFERENCES\n    _LIBCPP_INLINE_VISIBILITY\n    unordered_multimap(unordered_multimap&& __u)\n        _NOEXCEPT_(is_nothrow_move_constructible<__table>::value);\n    unordered_multimap(unordered_multimap&& __u, const allocator_type& __a);\n#endif  // _LIBCPP_HAS_NO_RVALUE_REFERENCES\n#ifndef _LIBCPP_HAS_NO_GENERALIZED_INITIALIZERS\n    unordered_multimap(initializer_list<value_type> __il);\n    unordered_multimap(initializer_list<value_type> __il, size_type __n,\n                       const hasher& __hf = hasher(),\n                       const key_equal& __eql = key_equal());\n    unordered_multimap(initializer_list<value_type> __il, size_type __n,\n                       const hasher& __hf, const key_equal& __eql,\n                       const allocator_type& __a);\n#endif  // _LIBCPP_HAS_NO_GENERALIZED_INITIALIZERS\n#if _LIBCPP_STD_VER > 11\n    _LIBCPP_INLINE_VISIBILITY\n    unordered_multimap(size_type __n, const allocator_type& __a)\n      : unordered_multimap(__n, hasher(), key_equal(), __a) {}\n    _LIBCPP_INLINE_VISIBILITY\n    unordered_multimap(size_type __n, const hasher& __hf, const allocator_type& __a)\n      : unordered_multimap(__n, __hf, key_equal(), __a) {}\n    template <class _InputIterator>\n    _LIBCPP_INLINE_VISIBILITY\n      unordered_multimap(_InputIterator __first, _InputIterator __last, size_type __n, const allocator_type& __a)\n      : unordered_multimap(__first, __last, __n, hasher(), key_equal(), __a) {}\n    template <class _InputIterator>\n    _LIBCPP_INLINE_VISIBILITY\n      unordered_multimap(_InputIterator __first, _InputIterator __last, size_type __n, const hasher& __hf, \n        const allocator_type& __a)\n      : unordered_multimap(__first, __last, __n, __hf, key_equal(), __a) {}\n    _LIBCPP_INLINE_VISIBILITY\n    unordered_multimap(initializer_list<value_type> __il, size_type __n, const allocator_type& __a)\n      : unordered_multimap(__il, __n, hasher(), key_equal(), __a) {}\n    _LIBCPP_INLINE_VISIBILITY\n    unordered_multimap(initializer_list<value_type> __il, size_type __n, const hasher& __hf, \n      const allocator_type& __a)\n      : unordered_multimap(__il, __n, __hf, key_equal(), __a) {}\n#endif\n    // ~unordered_multimap() = default;\n    _LIBCPP_INLINE_VISIBILITY\n    unordered_multimap& operator=(const unordered_multimap& __u)\n    {\n#ifndef _LIBCPP_CXX03_LANG\n        __table_ = __u.__table_;\n#else\n        if (this != &__u) {\n            __table_.clear();\n            __table_.hash_function() = __u.__table_.hash_function();\n            __table_.key_eq() = __u.__table_.key_eq();\n            __table_.max_load_factor() = __u.__table_.max_load_factor();\n            __table_.__copy_assign_alloc(__u.__table_);\n            insert(__u.begin(), __u.end());\n        }\n#endif\n        return *this;\n    }\n#ifndef _LIBCPP_HAS_NO_RVALUE_REFERENCES\n    _LIBCPP_INLINE_VISIBILITY\n    unordered_multimap& operator=(unordered_multimap&& __u)\n        _NOEXCEPT_(is_nothrow_move_assignable<__table>::value);\n#endif\n#ifndef _LIBCPP_HAS_NO_GENERALIZED_INITIALIZERS\n    _LIBCPP_INLINE_VISIBILITY\n    unordered_multimap& operator=(initializer_list<value_type> __il);\n#endif  // _LIBCPP_HAS_NO_GENERALIZED_INITIALIZERS\n\n    _LIBCPP_INLINE_VISIBILITY\n    allocator_type get_allocator() const _NOEXCEPT\n        {return allocator_type(__table_.__node_alloc());}\n\n    _LIBCPP_INLINE_VISIBILITY\n    bool      empty() const _NOEXCEPT {return __table_.size() == 0;}\n    _LIBCPP_INLINE_VISIBILITY\n    size_type size() const _NOEXCEPT  {return __table_.size();}\n    _LIBCPP_INLINE_VISIBILITY\n    size_type max_size() const _NOEXCEPT {return __table_.max_size();}\n\n    _LIBCPP_INLINE_VISIBILITY\n    iterator       begin() _NOEXCEPT        {return __table_.begin();}\n    _LIBCPP_INLINE_VISIBILITY\n    iterator       end() _NOEXCEPT          {return __table_.end();}\n    _LIBCPP_INLINE_VISIBILITY\n    const_iterator begin()  const _NOEXCEPT {return __table_.begin();}\n    _LIBCPP_INLINE_VISIBILITY\n    const_iterator end()    const _NOEXCEPT {return __table_.end();}\n    _LIBCPP_INLINE_VISIBILITY\n    const_iterator cbegin() const _NOEXCEPT {return __table_.begin();}\n    _LIBCPP_INLINE_VISIBILITY\n    const_iterator cend()   const _NOEXCEPT {return __table_.end();}\n\n    _LIBCPP_INLINE_VISIBILITY\n    iterator insert(const value_type& __x) {return __table_.__insert_multi(__x);}\n\n    _LIBCPP_INLINE_VISIBILITY\n    iterator insert(const_iterator __p, const value_type& __x)\n        {return __table_.__insert_multi(__p.__i_, __x);}\n\n    template <class _InputIterator>\n    _LIBCPP_INLINE_VISIBILITY\n    void insert(_InputIterator __first, _InputIterator __last);\n\n#ifndef _LIBCPP_HAS_NO_GENERALIZED_INITIALIZERS\n    _LIBCPP_INLINE_VISIBILITY\n    void insert(initializer_list<value_type> __il)\n        {insert(__il.begin(), __il.end());}\n#endif  // _LIBCPP_HAS_NO_GENERALIZED_INITIALIZERS\n\n#ifndef _LIBCPP_CXX03_LANG\n    _LIBCPP_INLINE_VISIBILITY\n    iterator insert(value_type&& __x) {return __table_.__insert_multi(_VSTD::move(__x));}\n\n    _LIBCPP_INLINE_VISIBILITY\n    iterator insert(const_iterator __p, value_type&& __x)\n        {return __table_.__insert_multi(__p.__i_, _VSTD::move(__x));}\n\n    template <class _Pp,\n              class = typename enable_if<is_constructible<value_type, _Pp>::value>::type>\n    _LIBCPP_INLINE_VISIBILITY\n    iterator insert(_Pp&& __x)\n        {return __table_.__insert_multi(_VSTD::forward<_Pp>(__x));}\n\n    template <class _Pp,\n              class = typename enable_if<is_constructible<value_type, _Pp>::value>::type>\n    _LIBCPP_INLINE_VISIBILITY\n    iterator insert(const_iterator __p, _Pp&& __x)\n        {return __table_.__insert_multi(__p.__i_, _VSTD::forward<_Pp>(__x));}\n\n    template <class... _Args>\n    iterator emplace(_Args&&... __args) {\n        return __table_.__emplace_multi(_VSTD::forward<_Args>(__args)...);\n    }\n\n    template <class... _Args>\n    iterator emplace_hint(const_iterator __p, _Args&&... __args) {\n        return __table_.__emplace_hint_multi(__p.__i_, _VSTD::forward<_Args>(__args)...);\n    }\n#endif  // _LIBCPP_CXX03_LANG\n\n\n    _LIBCPP_INLINE_VISIBILITY\n    iterator erase(const_iterator __p) {return __table_.erase(__p.__i_);}\n    _LIBCPP_INLINE_VISIBILITY\n    iterator erase(iterator __p)       {return __table_.erase(__p.__i_);}\n    _LIBCPP_INLINE_VISIBILITY\n    size_type erase(const key_type& __k) {return __table_.__erase_multi(__k);}\n    _LIBCPP_INLINE_VISIBILITY\n    iterator erase(const_iterator __first, const_iterator __last)\n        {return __table_.erase(__first.__i_, __last.__i_);}\n    _LIBCPP_INLINE_VISIBILITY\n    void clear() _NOEXCEPT {__table_.clear();}\n\n    _LIBCPP_INLINE_VISIBILITY\n    void swap(unordered_multimap& __u)\n        _NOEXCEPT_(__is_nothrow_swappable<__table>::value)\n        {__table_.swap(__u.__table_);}\n\n    _LIBCPP_INLINE_VISIBILITY\n    hasher hash_function() const\n        {return __table_.hash_function().hash_function();}\n    _LIBCPP_INLINE_VISIBILITY\n    key_equal key_eq() const\n        {return __table_.key_eq().key_eq();}\n\n    _LIBCPP_INLINE_VISIBILITY\n    iterator       find(const key_type& __k)       {return __table_.find(__k);}\n    _LIBCPP_INLINE_VISIBILITY\n    const_iterator find(const key_type& __k) const {return __table_.find(__k);}\n    _LIBCPP_INLINE_VISIBILITY\n    size_type count(const key_type& __k) const {return __table_.__count_multi(__k);}\n    _LIBCPP_INLINE_VISIBILITY\n    pair<iterator, iterator>             equal_range(const key_type& __k)\n        {return __table_.__equal_range_multi(__k);}\n    _LIBCPP_INLINE_VISIBILITY\n    pair<const_iterator, const_iterator> equal_range(const key_type& __k) const\n        {return __table_.__equal_range_multi(__k);}\n\n    _LIBCPP_INLINE_VISIBILITY\n    size_type bucket_count() const _NOEXCEPT {return __table_.bucket_count();}\n    _LIBCPP_INLINE_VISIBILITY\n    size_type max_bucket_count() const _NOEXCEPT\n        {return __table_.max_bucket_count();}\n\n    _LIBCPP_INLINE_VISIBILITY\n    size_type bucket_size(size_type __n) const\n        {return __table_.bucket_size(__n);}\n    _LIBCPP_INLINE_VISIBILITY\n    size_type bucket(const key_type& __k) const {return __table_.bucket(__k);}\n\n    _LIBCPP_INLINE_VISIBILITY\n    local_iterator       begin(size_type __n)        {return __table_.begin(__n);}\n    _LIBCPP_INLINE_VISIBILITY\n    local_iterator       end(size_type __n)          {return __table_.end(__n);}\n    _LIBCPP_INLINE_VISIBILITY\n    const_local_iterator begin(size_type __n) const  {return __table_.cbegin(__n);}\n    _LIBCPP_INLINE_VISIBILITY\n    const_local_iterator end(size_type __n) const    {return __table_.cend(__n);}\n    _LIBCPP_INLINE_VISIBILITY\n    const_local_iterator cbegin(size_type __n) const {return __table_.cbegin(__n);}\n    _LIBCPP_INLINE_VISIBILITY\n    const_local_iterator cend(size_type __n) const   {return __table_.cend(__n);}\n\n    _LIBCPP_INLINE_VISIBILITY\n    float load_factor() const _NOEXCEPT {return __table_.load_factor();}\n    _LIBCPP_INLINE_VISIBILITY\n    float max_load_factor() const _NOEXCEPT {return __table_.max_load_factor();}\n    _LIBCPP_INLINE_VISIBILITY\n    void max_load_factor(float __mlf) {__table_.max_load_factor(__mlf);}\n    _LIBCPP_INLINE_VISIBILITY\n    void rehash(size_type __n) {__table_.rehash(__n);}\n    _LIBCPP_INLINE_VISIBILITY\n    void reserve(size_type __n) {__table_.reserve(__n);}\n\n#if _LIBCPP_DEBUG_LEVEL >= 2\n\n    bool __dereferenceable(const const_iterator* __i) const\n        {return __table_.__dereferenceable(&__i->__i_);}\n    bool __decrementable(const const_iterator* __i) const\n        {return __table_.__decrementable(&__i->__i_);}\n    bool __addable(const const_iterator* __i, ptrdiff_t __n) const\n        {return __table_.__addable(&__i->__i_, __n);}\n    bool __subscriptable(const const_iterator* __i, ptrdiff_t __n) const\n        {return __table_.__addable(&__i->__i_, __n);}\n\n#endif  // _LIBCPP_DEBUG_LEVEL >= 2\n\n\n};\n\ntemplate <class _Key, class _Tp, class _Hash, class _Pred, class _Alloc>\nunordered_multimap<_Key, _Tp, _Hash, _Pred, _Alloc>::unordered_multimap(\n        size_type __n, const hasher& __hf, const key_equal& __eql)\n    : __table_(__hf, __eql)\n{\n#if _LIBCPP_DEBUG_LEVEL >= 2\n    __get_db()->__insert_c(this);\n#endif\n    __table_.rehash(__n);\n}\n\ntemplate <class _Key, class _Tp, class _Hash, class _Pred, class _Alloc>\nunordered_multimap<_Key, _Tp, _Hash, _Pred, _Alloc>::unordered_multimap(\n        size_type __n, const hasher& __hf, const key_equal& __eql,\n        const allocator_type& __a)\n    : __table_(__hf, __eql, typename __table::allocator_type(__a))\n{\n#if _LIBCPP_DEBUG_LEVEL >= 2\n    __get_db()->__insert_c(this);\n#endif\n    __table_.rehash(__n);\n}\n\ntemplate <class _Key, class _Tp, class _Hash, class _Pred, class _Alloc>\ntemplate <class _InputIterator>\nunordered_multimap<_Key, _Tp, _Hash, _Pred, _Alloc>::unordered_multimap(\n        _InputIterator __first, _InputIterator __last)\n{\n#if _LIBCPP_DEBUG_LEVEL >= 2\n    __get_db()->__insert_c(this);\n#endif\n    insert(__first, __last);\n}\n\ntemplate <class _Key, class _Tp, class _Hash, class _Pred, class _Alloc>\ntemplate <class _InputIterator>\nunordered_multimap<_Key, _Tp, _Hash, _Pred, _Alloc>::unordered_multimap(\n        _InputIterator __first, _InputIterator __last, size_type __n,\n        const hasher& __hf, const key_equal& __eql)\n    : __table_(__hf, __eql)\n{\n#if _LIBCPP_DEBUG_LEVEL >= 2\n    __get_db()->__insert_c(this);\n#endif\n    __table_.rehash(__n);\n    insert(__first, __last);\n}\n\ntemplate <class _Key, class _Tp, class _Hash, class _Pred, class _Alloc>\ntemplate <class _InputIterator>\nunordered_multimap<_Key, _Tp, _Hash, _Pred, _Alloc>::unordered_multimap(\n        _InputIterator __first, _InputIterator __last, size_type __n,\n        const hasher& __hf, const key_equal& __eql, const allocator_type& __a)\n    : __table_(__hf, __eql, typename __table::allocator_type(__a))\n{\n#if _LIBCPP_DEBUG_LEVEL >= 2\n    __get_db()->__insert_c(this);\n#endif\n    __table_.rehash(__n);\n    insert(__first, __last);\n}\n\ntemplate <class _Key, class _Tp, class _Hash, class _Pred, class _Alloc>\ninline\nunordered_multimap<_Key, _Tp, _Hash, _Pred, _Alloc>::unordered_multimap(\n        const allocator_type& __a)\n    : __table_(typename __table::allocator_type(__a))\n{\n#if _LIBCPP_DEBUG_LEVEL >= 2\n    __get_db()->__insert_c(this);\n#endif\n}\n\ntemplate <class _Key, class _Tp, class _Hash, class _Pred, class _Alloc>\nunordered_multimap<_Key, _Tp, _Hash, _Pred, _Alloc>::unordered_multimap(\n        const unordered_multimap& __u)\n    : __table_(__u.__table_)\n{\n#if _LIBCPP_DEBUG_LEVEL >= 2\n    __get_db()->__insert_c(this);\n#endif\n    __table_.rehash(__u.bucket_count());\n    insert(__u.begin(), __u.end());\n}\n\ntemplate <class _Key, class _Tp, class _Hash, class _Pred, class _Alloc>\nunordered_multimap<_Key, _Tp, _Hash, _Pred, _Alloc>::unordered_multimap(\n        const unordered_multimap& __u, const allocator_type& __a)\n    : __table_(__u.__table_, typename __table::allocator_type(__a))\n{\n#if _LIBCPP_DEBUG_LEVEL >= 2\n    __get_db()->__insert_c(this);\n#endif\n    __table_.rehash(__u.bucket_count());\n    insert(__u.begin(), __u.end());\n}\n\n#ifndef _LIBCPP_HAS_NO_RVALUE_REFERENCES\n\ntemplate <class _Key, class _Tp, class _Hash, class _Pred, class _Alloc>\ninline\nunordered_multimap<_Key, _Tp, _Hash, _Pred, _Alloc>::unordered_multimap(\n        unordered_multimap&& __u)\n    _NOEXCEPT_(is_nothrow_move_constructible<__table>::value)\n    : __table_(_VSTD::move(__u.__table_))\n{\n#if _LIBCPP_DEBUG_LEVEL >= 2\n    __get_db()->__insert_c(this);\n    __get_db()->swap(this, &__u);\n#endif\n}\n\ntemplate <class _Key, class _Tp, class _Hash, class _Pred, class _Alloc>\nunordered_multimap<_Key, _Tp, _Hash, _Pred, _Alloc>::unordered_multimap(\n        unordered_multimap&& __u, const allocator_type& __a)\n    : __table_(_VSTD::move(__u.__table_), typename __table::allocator_type(__a))\n{\n#if _LIBCPP_DEBUG_LEVEL >= 2\n    __get_db()->__insert_c(this);\n#endif\n    if (__a != __u.get_allocator())\n    {\n        iterator __i = __u.begin();\n        while (__u.size() != 0)\n        {\n            __table_.__insert_multi(\n                      _VSTD::move(__u.__table_.remove((__i++).__i_)->__value_.__nc)\n                                   );\n        }\n    }\n#if _LIBCPP_DEBUG_LEVEL >= 2\n    else\n        __get_db()->swap(this, &__u);\n#endif\n}\n\n#endif  // _LIBCPP_HAS_NO_RVALUE_REFERENCES\n\n#ifndef _LIBCPP_HAS_NO_GENERALIZED_INITIALIZERS\n\ntemplate <class _Key, class _Tp, class _Hash, class _Pred, class _Alloc>\nunordered_multimap<_Key, _Tp, _Hash, _Pred, _Alloc>::unordered_multimap(\n        initializer_list<value_type> __il)\n{\n#if _LIBCPP_DEBUG_LEVEL >= 2\n    __get_db()->__insert_c(this);\n#endif\n    insert(__il.begin(), __il.end());\n}\n\ntemplate <class _Key, class _Tp, class _Hash, class _Pred, class _Alloc>\nunordered_multimap<_Key, _Tp, _Hash, _Pred, _Alloc>::unordered_multimap(\n        initializer_list<value_type> __il, size_type __n, const hasher& __hf,\n        const key_equal& __eql)\n    : __table_(__hf, __eql)\n{\n#if _LIBCPP_DEBUG_LEVEL >= 2\n    __get_db()->__insert_c(this);\n#endif\n    __table_.rehash(__n);\n    insert(__il.begin(), __il.end());\n}\n\ntemplate <class _Key, class _Tp, class _Hash, class _Pred, class _Alloc>\nunordered_multimap<_Key, _Tp, _Hash, _Pred, _Alloc>::unordered_multimap(\n        initializer_list<value_type> __il, size_type __n, const hasher& __hf,\n        const key_equal& __eql, const allocator_type& __a)\n    : __table_(__hf, __eql, typename __table::allocator_type(__a))\n{\n#if _LIBCPP_DEBUG_LEVEL >= 2\n    __get_db()->__insert_c(this);\n#endif\n    __table_.rehash(__n);\n    insert(__il.begin(), __il.end());\n}\n\n#endif  // _LIBCPP_HAS_NO_GENERALIZED_INITIALIZERS\n\n#ifndef _LIBCPP_HAS_NO_RVALUE_REFERENCES\n\ntemplate <class _Key, class _Tp, class _Hash, class _Pred, class _Alloc>\ninline\nunordered_multimap<_Key, _Tp, _Hash, _Pred, _Alloc>&\nunordered_multimap<_Key, _Tp, _Hash, _Pred, _Alloc>::operator=(unordered_multimap&& __u)\n    _NOEXCEPT_(is_nothrow_move_assignable<__table>::value)\n{\n    __table_ = _VSTD::move(__u.__table_);\n    return *this;\n}\n\n#endif  // _LIBCPP_HAS_NO_RVALUE_REFERENCES\n\n#ifndef _LIBCPP_HAS_NO_GENERALIZED_INITIALIZERS\n\ntemplate <class _Key, class _Tp, class _Hash, class _Pred, class _Alloc>\ninline\nunordered_multimap<_Key, _Tp, _Hash, _Pred, _Alloc>&\nunordered_multimap<_Key, _Tp, _Hash, _Pred, _Alloc>::operator=(\n        initializer_list<value_type> __il)\n{\n    __table_.__assign_multi(__il.begin(), __il.end());\n    return *this;\n}\n\n#endif  // _LIBCPP_HAS_NO_GENERALIZED_INITIALIZERS\n\n\n\ntemplate <class _Key, class _Tp, class _Hash, class _Pred, class _Alloc>\ntemplate <class _InputIterator>\ninline\nvoid\nunordered_multimap<_Key, _Tp, _Hash, _Pred, _Alloc>::insert(_InputIterator __first,\n                                                            _InputIterator __last)\n{\n    for (; __first != __last; ++__first)\n        __table_.__insert_multi(*__first);\n}\n\ntemplate <class _Key, class _Tp, class _Hash, class _Pred, class _Alloc>\ninline _LIBCPP_INLINE_VISIBILITY\nvoid\nswap(unordered_multimap<_Key, _Tp, _Hash, _Pred, _Alloc>& __x,\n     unordered_multimap<_Key, _Tp, _Hash, _Pred, _Alloc>& __y)\n    _NOEXCEPT_(_NOEXCEPT_(__x.swap(__y)))\n{\n    __x.swap(__y);\n}\n\ntemplate <class _Key, class _Tp, class _Hash, class _Pred, class _Alloc>\nbool\noperator==(const unordered_multimap<_Key, _Tp, _Hash, _Pred, _Alloc>& __x,\n           const unordered_multimap<_Key, _Tp, _Hash, _Pred, _Alloc>& __y)\n{\n    if (__x.size() != __y.size())\n        return false;\n    typedef typename unordered_multimap<_Key, _Tp, _Hash, _Pred, _Alloc>::const_iterator\n                                                                 const_iterator;\n    typedef pair<const_iterator, const_iterator> _EqRng;\n    for (const_iterator __i = __x.begin(), __ex = __x.end(); __i != __ex;)\n    {\n        _EqRng __xeq = __x.equal_range(__i->first);\n        _EqRng __yeq = __y.equal_range(__i->first);\n        if (_VSTD::distance(__xeq.first, __xeq.second) !=\n            _VSTD::distance(__yeq.first, __yeq.second) ||\n                  !_VSTD::is_permutation(__xeq.first, __xeq.second, __yeq.first))\n            return false;\n        __i = __xeq.second;\n    }\n    return true;\n}\n\ntemplate <class _Key, class _Tp, class _Hash, class _Pred, class _Alloc>\ninline _LIBCPP_INLINE_VISIBILITY\nbool\noperator!=(const unordered_multimap<_Key, _Tp, _Hash, _Pred, _Alloc>& __x,\n           const unordered_multimap<_Key, _Tp, _Hash, _Pred, _Alloc>& __y)\n{\n    return !(__x == __y);\n}\n\n_LIBCPP_END_NAMESPACE_STD\n\n#endif  // _LIBCPP_UNORDERED_MAP\n","#include \"Stack.h\"\n#include \"ParserTypes.h\"\n\n#include <algorithm>\n\nCharmFunction Stack::zeroF() {\n\tCharmFunction zeroFunction;\n\tCharmNumber zeroNumber;\n\tzeroNumber.whichType = INTEGER_VALUE;\n\tzeroNumber.integerValue = 0;\n\tzeroFunction.functionType = NUMBER_FUNCTION;\n\tzeroFunction.numberValue = zeroNumber;\n\treturn zeroFunction;\n}\n\nbool Stack::isInt(CharmFunction f) {\n\tif (f.functionType == NUMBER_FUNCTION) {\n\t\tif (f.numberValue.whichType == INTEGER_VALUE) {\n\t\t\treturn true;\n\t\t}\n\t}\n\treturn false;\n}\n\nbool Stack::isFloat(CharmFunction f) {\n\tif (f.functionType == NUMBER_FUNCTION) {\n\t\tif (f.numberValue.whichType == FLOAT_VALUE) {\n\t\t\treturn true;\n\t\t}\n\t}\n\treturn false;\n}\n\nbool Stack::isNameEqualTo(CharmFunction f) {\n    return (Stack::name == f);\n}\n\nStack::Stack(unsigned long long size, CharmFunction name) {\n    Stack::modifiedStackArea = 0;\n\tfor (unsigned long long stackIndex = 0; stackIndex < size; stackIndex++) {\n\t\tStack::stack.push_back(Stack::zeroF());\n\t}\n    Stack::name = name;\n}\n\n\nunsigned int Stack::getModifiedStackArea() {\n    return Stack::modifiedStackArea;\n}\n\n\nCharmFunction Stack::pop() {\n\t//ensure that the stack never changes size\n\t//this is by placing more zeroes at the start\n\t//as stuff is popped off the end\n\tStack::stack.insert(Stack::stack.begin(), Stack::zeroF());\n\tCharmFunction tempCharmF = Stack::stack.at(Stack::stack.size() - 1);\n\tStack::stack.pop_back();\n\tif (Stack::modifiedStackArea != 0) Stack::modifiedStackArea--;\n\treturn tempCharmF;\n}\n\nvoid Stack::push(CharmFunction f) {\n\t//ensure the stack never changes size again\n\t//pop an element off the back of the stack\n\tStack::stack.push_back(f);\n\tStack::stack.erase(Stack::stack.begin());\n\tStack::modifiedStackArea++;\n}\n\nvoid Stack::swap(unsigned long long n1, unsigned long long n2) {\n\t/*CharmFunction tempFromN1 = Stack::stack.at(Stack::stack.size() - n1 - 1);\n\tCharmFunction tempFromN2 = Stack::stack.at(Stack::stack.size() - n2 - 1);\n\tStack::stack[Stack::stack.size() - n1 - 1] = tempFromN2;\n\tStack::stack[Stack::stack.size() - n2 - 1] = tempFromN1;\n\tStack::updateModifiedStackArea();\n\t*/\n\tstd::iter_swap(Stack::stack.end() - n1 - 1, Stack::stack.end() - n2 - 1);\n\tif (n1 + 1 > Stack::modifiedStackArea) Stack::modifiedStackArea = n1;\n\tif (n2 + 1 > Stack::modifiedStackArea) Stack::modifiedStackArea = n2;\n}\n","// -*- C++ -*-\n#ifndef _LIBCPP_SPLIT_BUFFER\n#define _LIBCPP_SPLIT_BUFFER\n\n#include <__config>\n#include <type_traits>\n#include <algorithm>\n\n#include <__undef_min_max>\n\n#if !defined(_LIBCPP_HAS_NO_PRAGMA_SYSTEM_HEADER)\n#pragma GCC system_header\n#endif\n\n_LIBCPP_BEGIN_NAMESPACE_STD\n\ntemplate <bool>\nclass __split_buffer_common\n{\nprotected:\n    void __throw_length_error() const;\n    void __throw_out_of_range() const;\n};\n\ntemplate <class _Tp, class _Allocator = allocator<_Tp> >\nstruct __split_buffer\n    : private __split_buffer_common<true>\n{\nprivate:\n    __split_buffer(const __split_buffer&);\n    __split_buffer& operator=(const __split_buffer&);\npublic:\n    typedef _Tp                                             value_type;\n    typedef _Allocator                                      allocator_type;\n    typedef typename remove_reference<allocator_type>::type __alloc_rr;\n    typedef allocator_traits<__alloc_rr>                    __alloc_traits;\n    typedef value_type&                                     reference;\n    typedef const value_type&                               const_reference;\n    typedef typename __alloc_traits::size_type              size_type;\n    typedef typename __alloc_traits::difference_type        difference_type;\n    typedef typename __alloc_traits::pointer                pointer;\n    typedef typename __alloc_traits::const_pointer          const_pointer;\n    typedef pointer                                         iterator;\n    typedef const_pointer                                   const_iterator;\n\n    pointer                                         __first_;\n    pointer                                         __begin_;\n    pointer                                         __end_;\n    __compressed_pair<pointer, allocator_type> __end_cap_;\n\n    typedef typename add_lvalue_reference<allocator_type>::type __alloc_ref;\n    typedef typename add_lvalue_reference<allocator_type>::type __alloc_const_ref;\n\n    _LIBCPP_INLINE_VISIBILITY __alloc_rr&           __alloc() _NOEXCEPT         {return __end_cap_.second();}\n    _LIBCPP_INLINE_VISIBILITY const __alloc_rr&     __alloc() const _NOEXCEPT   {return __end_cap_.second();}\n    _LIBCPP_INLINE_VISIBILITY pointer&              __end_cap() _NOEXCEPT       {return __end_cap_.first();}\n    _LIBCPP_INLINE_VISIBILITY const pointer&        __end_cap() const _NOEXCEPT {return __end_cap_.first();}\n\n    _LIBCPP_INLINE_VISIBILITY\n    __split_buffer()\n        _NOEXCEPT_(is_nothrow_default_constructible<allocator_type>::value);\n    _LIBCPP_INLINE_VISIBILITY\n    explicit __split_buffer(__alloc_rr& __a);\n    _LIBCPP_INLINE_VISIBILITY\n    explicit __split_buffer(const __alloc_rr& __a);\n    __split_buffer(size_type __cap, size_type __start, __alloc_rr& __a);\n    ~__split_buffer();\n\n#ifndef _LIBCPP_HAS_NO_RVALUE_REFERENCES\n    __split_buffer(__split_buffer&& __c)\n        _NOEXCEPT_(is_nothrow_move_constructible<allocator_type>::value);\n    __split_buffer(__split_buffer&& __c, const __alloc_rr& __a);\n    __split_buffer& operator=(__split_buffer&& __c)\n        _NOEXCEPT_((__alloc_traits::propagate_on_container_move_assignment::value &&\n                is_nothrow_move_assignable<allocator_type>::value) ||\n               !__alloc_traits::propagate_on_container_move_assignment::value);\n#endif  // _LIBCPP_HAS_NO_RVALUE_REFERENCES\n\n    _LIBCPP_INLINE_VISIBILITY       iterator begin() _NOEXCEPT       {return __begin_;}\n    _LIBCPP_INLINE_VISIBILITY const_iterator begin() const _NOEXCEPT {return __begin_;}\n    _LIBCPP_INLINE_VISIBILITY       iterator end() _NOEXCEPT         {return __end_;}\n    _LIBCPP_INLINE_VISIBILITY const_iterator end() const _NOEXCEPT   {return __end_;}\n\n    _LIBCPP_INLINE_VISIBILITY\n    void clear() _NOEXCEPT\n        {__destruct_at_end(__begin_);}\n    _LIBCPP_INLINE_VISIBILITY size_type size() const {return static_cast<size_type>(__end_ - __begin_);}\n    _LIBCPP_INLINE_VISIBILITY bool empty()     const {return __end_ == __begin_;}\n    _LIBCPP_INLINE_VISIBILITY size_type capacity() const {return static_cast<size_type>(__end_cap() - __first_);}\n    _LIBCPP_INLINE_VISIBILITY size_type __front_spare() const {return static_cast<size_type>(__begin_ - __first_);}\n    _LIBCPP_INLINE_VISIBILITY size_type __back_spare() const {return static_cast<size_type>(__end_cap() - __end_);}\n\n    _LIBCPP_INLINE_VISIBILITY       reference front()       {return *__begin_;}\n    _LIBCPP_INLINE_VISIBILITY const_reference front() const {return *__begin_;}\n    _LIBCPP_INLINE_VISIBILITY       reference back()        {return *(__end_ - 1);}\n    _LIBCPP_INLINE_VISIBILITY const_reference back() const  {return *(__end_ - 1);}\n\n    void reserve(size_type __n);\n    void shrink_to_fit() _NOEXCEPT;\n    void push_front(const_reference __x);\n    _LIBCPP_INLINE_VISIBILITY void push_back(const_reference __x);\n#if !defined(_LIBCPP_HAS_NO_RVALUE_REFERENCES)\n    void push_front(value_type&& __x);\n    void push_back(value_type&& __x);\n#if !defined(_LIBCPP_HAS_NO_VARIADICS)\n    template <class... _Args>\n        void emplace_back(_Args&&... __args);\n#endif  // !defined(_LIBCPP_HAS_NO_VARIADICS)\n#endif  // !defined(_LIBCPP_HAS_NO_RVALUE_REFERENCES)\n\n    _LIBCPP_INLINE_VISIBILITY void pop_front() {__destruct_at_begin(__begin_+1);}\n    _LIBCPP_INLINE_VISIBILITY void pop_back() {__destruct_at_end(__end_-1);}\n\n    void __construct_at_end(size_type __n);\n    void __construct_at_end(size_type __n, const_reference __x);\n    template <class _InputIter>\n        typename enable_if\n        <\n            __is_input_iterator<_InputIter>::value &&\n           !__is_forward_iterator<_InputIter>::value,\n            void\n        >::type\n        __construct_at_end(_InputIter __first, _InputIter __last);\n    template <class _ForwardIterator>\n        typename enable_if\n        <\n            __is_forward_iterator<_ForwardIterator>::value,\n            void\n        >::type\n        __construct_at_end(_ForwardIterator __first, _ForwardIterator __last);\n\n    _LIBCPP_INLINE_VISIBILITY void __destruct_at_begin(pointer __new_begin)\n        {__destruct_at_begin(__new_begin, is_trivially_destructible<value_type>());}\n        _LIBCPP_INLINE_VISIBILITY\n        void __destruct_at_begin(pointer __new_begin, false_type);\n        _LIBCPP_INLINE_VISIBILITY\n        void __destruct_at_begin(pointer __new_begin, true_type);\n\n    _LIBCPP_INLINE_VISIBILITY\n    void __destruct_at_end(pointer __new_last) _NOEXCEPT\n        {__destruct_at_end(__new_last, false_type());}\n    _LIBCPP_INLINE_VISIBILITY\n        void __destruct_at_end(pointer __new_last, false_type) _NOEXCEPT;\n    _LIBCPP_INLINE_VISIBILITY\n        void __destruct_at_end(pointer __new_last, true_type) _NOEXCEPT;\n\n    void swap(__split_buffer& __x)\n        _NOEXCEPT_(!__alloc_traits::propagate_on_container_swap::value||\n                   __is_nothrow_swappable<__alloc_rr>::value);\n\n    bool __invariants() const;\n\nprivate:\n    _LIBCPP_INLINE_VISIBILITY\n    void __move_assign_alloc(__split_buffer& __c, true_type)\n        _NOEXCEPT_(is_nothrow_move_assignable<allocator_type>::value)\n        {\n            __alloc() = _VSTD::move(__c.__alloc());\n        }\n\n    _LIBCPP_INLINE_VISIBILITY\n    void __move_assign_alloc(__split_buffer&, false_type) _NOEXCEPT\n        {}\n};\n\ntemplate <class _Tp, class _Allocator>\nbool\n__split_buffer<_Tp, _Allocator>::__invariants() const\n{\n    if (__first_ == nullptr)\n    {\n        if (__begin_ != nullptr)\n            return false;\n        if (__end_ != nullptr)\n            return false;\n        if (__end_cap() != nullptr)\n            return false;\n    }\n    else\n    {\n        if (__begin_ < __first_)\n            return false;\n        if (__end_ < __begin_)\n            return false;\n        if (__end_cap() < __end_)\n            return false;\n    }\n    return true;\n}\n\n//  Default constructs __n objects starting at __end_\n//  throws if construction throws\n//  Precondition:  __n > 0\n//  Precondition:  size() + __n <= capacity()\n//  Postcondition:  size() == size() + __n\ntemplate <class _Tp, class _Allocator>\nvoid\n__split_buffer<_Tp, _Allocator>::__construct_at_end(size_type __n)\n{\n    __alloc_rr& __a = this->__alloc();\n    do\n    {\n        __alloc_traits::construct(__a, _VSTD::__to_raw_pointer(this->__end_));\n        ++this->__end_;\n        --__n;\n    } while (__n > 0);\n}\n\n//  Copy constructs __n objects starting at __end_ from __x\n//  throws if construction throws\n//  Precondition:  __n > 0\n//  Precondition:  size() + __n <= capacity()\n//  Postcondition:  size() == old size() + __n\n//  Postcondition:  [i] == __x for all i in [size() - __n, __n)\ntemplate <class _Tp, class _Allocator>\nvoid\n__split_buffer<_Tp, _Allocator>::__construct_at_end(size_type __n, const_reference __x)\n{\n    __alloc_rr& __a = this->__alloc();\n    do\n    {\n        __alloc_traits::construct(__a, _VSTD::__to_raw_pointer(this->__end_), __x);\n        ++this->__end_;\n        --__n;\n    } while (__n > 0);\n}\n\ntemplate <class _Tp, class _Allocator>\ntemplate <class _InputIter>\ntypename enable_if\n<\n     __is_input_iterator<_InputIter>::value &&\n    !__is_forward_iterator<_InputIter>::value,\n    void\n>::type\n__split_buffer<_Tp, _Allocator>::__construct_at_end(_InputIter __first, _InputIter __last)\n{\n    __alloc_rr& __a = this->__alloc();\n    for (; __first != __last; ++__first)\n    {\n        if (__end_ == __end_cap())\n        {\n            size_type __old_cap = __end_cap() - __first_;\n            size_type __new_cap = _VSTD::max<size_type>(2 * __old_cap, 8);\n            __split_buffer __buf(__new_cap, 0, __a);\n            for (pointer __p = __begin_; __p != __end_; ++__p, ++__buf.__end_)\n                __alloc_traits::construct(__buf.__alloc(),\n                        _VSTD::__to_raw_pointer(__buf.__end_), _VSTD::move(*__p));\n            swap(__buf);\n        }\n        __alloc_traits::construct(__a, _VSTD::__to_raw_pointer(this->__end_), *__first);\n        ++this->__end_;\n    }\n}\n\ntemplate <class _Tp, class _Allocator>\ntemplate <class _ForwardIterator>\ntypename enable_if\n<\n    __is_forward_iterator<_ForwardIterator>::value,\n    void\n>::type\n__split_buffer<_Tp, _Allocator>::__construct_at_end(_ForwardIterator __first, _ForwardIterator __last)\n{\n    __alloc_rr& __a = this->__alloc();\n    for (; __first != __last; ++__first)\n    {\n        __alloc_traits::construct(__a, _VSTD::__to_raw_pointer(this->__end_), *__first);\n        ++this->__end_;\n    }\n}\n\ntemplate <class _Tp, class _Allocator>\ninline\nvoid\n__split_buffer<_Tp, _Allocator>::__destruct_at_begin(pointer __new_begin, false_type)\n{\n    while (__begin_ != __new_begin)\n        __alloc_traits::destroy(__alloc(), __to_raw_pointer(__begin_++));\n}\n\ntemplate <class _Tp, class _Allocator>\ninline\nvoid\n__split_buffer<_Tp, _Allocator>::__destruct_at_begin(pointer __new_begin, true_type)\n{\n    __begin_ = __new_begin;\n}\n\ntemplate <class _Tp, class _Allocator>\ninline _LIBCPP_INLINE_VISIBILITY\nvoid\n__split_buffer<_Tp, _Allocator>::__destruct_at_end(pointer __new_last, false_type) _NOEXCEPT\n{\n    while (__new_last != __end_)\n        __alloc_traits::destroy(__alloc(), __to_raw_pointer(--__end_));\n}\n\ntemplate <class _Tp, class _Allocator>\ninline _LIBCPP_INLINE_VISIBILITY\nvoid\n__split_buffer<_Tp, _Allocator>::__destruct_at_end(pointer __new_last, true_type) _NOEXCEPT\n{\n    __end_ = __new_last;\n}\n\ntemplate <class _Tp, class _Allocator>\n__split_buffer<_Tp, _Allocator>::__split_buffer(size_type __cap, size_type __start, __alloc_rr& __a)\n    : __end_cap_(nullptr, __a)\n{\n    __first_ = __cap != 0 ? __alloc_traits::allocate(__alloc(), __cap) : nullptr;\n    __begin_ = __end_ = __first_ + __start;\n    __end_cap() = __first_ + __cap;\n}\n\ntemplate <class _Tp, class _Allocator>\ninline\n__split_buffer<_Tp, _Allocator>::__split_buffer()\n    _NOEXCEPT_(is_nothrow_default_constructible<allocator_type>::value)\n    : __first_(nullptr), __begin_(nullptr), __end_(nullptr), __end_cap_(nullptr)\n{\n}\n\ntemplate <class _Tp, class _Allocator>\ninline\n__split_buffer<_Tp, _Allocator>::__split_buffer(__alloc_rr& __a)\n    : __first_(nullptr), __begin_(nullptr), __end_(nullptr), __end_cap_(nullptr, __a)\n{\n}\n\ntemplate <class _Tp, class _Allocator>\ninline\n__split_buffer<_Tp, _Allocator>::__split_buffer(const __alloc_rr& __a)\n    : __first_(nullptr), __begin_(nullptr), __end_(nullptr), __end_cap_(nullptr, __a)\n{\n}\n\ntemplate <class _Tp, class _Allocator>\n__split_buffer<_Tp, _Allocator>::~__split_buffer()\n{\n    clear();\n    if (__first_)\n        __alloc_traits::deallocate(__alloc(), __first_, capacity());\n}\n\n#ifndef _LIBCPP_HAS_NO_RVALUE_REFERENCES\n\ntemplate <class _Tp, class _Allocator>\n__split_buffer<_Tp, _Allocator>::__split_buffer(__split_buffer&& __c)\n    _NOEXCEPT_(is_nothrow_move_constructible<allocator_type>::value)\n    : __first_(_VSTD::move(__c.__first_)),\n      __begin_(_VSTD::move(__c.__begin_)),\n      __end_(_VSTD::move(__c.__end_)),\n      __end_cap_(_VSTD::move(__c.__end_cap_))\n{\n    __c.__first_ = nullptr;\n    __c.__begin_ = nullptr;\n    __c.__end_ = nullptr;\n    __c.__end_cap() = nullptr;\n}\n\ntemplate <class _Tp, class _Allocator>\n__split_buffer<_Tp, _Allocator>::__split_buffer(__split_buffer&& __c, const __alloc_rr& __a)\n    : __end_cap_(__a)\n{\n    if (__a == __c.__alloc())\n    {\n        __first_ = __c.__first_;\n        __begin_ = __c.__begin_;\n        __end_ = __c.__end_;\n        __end_cap() = __c.__end_cap();\n        __c.__first_ = nullptr;\n        __c.__begin_ = nullptr;\n        __c.__end_ = nullptr;\n        __c.__end_cap() = nullptr;\n    }\n    else\n    {\n        size_type __cap = __c.size();\n        __first_ = __alloc_traits::allocate(__alloc(), __cap);\n        __begin_ = __end_ = __first_;\n        __end_cap() = __first_ + __cap;\n        typedef move_iterator<iterator> _Ip;\n        __construct_at_end(_Ip(__c.begin()), _Ip(__c.end()));\n    }\n}\n\ntemplate <class _Tp, class _Allocator>\n__split_buffer<_Tp, _Allocator>&\n__split_buffer<_Tp, _Allocator>::operator=(__split_buffer&& __c)\n    _NOEXCEPT_((__alloc_traits::propagate_on_container_move_assignment::value &&\n                is_nothrow_move_assignable<allocator_type>::value) ||\n               !__alloc_traits::propagate_on_container_move_assignment::value)\n{\n    clear();\n    shrink_to_fit();\n    __first_ = __c.__first_;\n    __begin_ = __c.__begin_;\n    __end_ = __c.__end_;\n    __end_cap() = __c.__end_cap();\n    __move_assign_alloc(__c,\n        integral_constant<bool,\n                          __alloc_traits::propagate_on_container_move_assignment::value>());\n    __c.__first_ = __c.__begin_ = __c.__end_ = __c.__end_cap() = nullptr;\n    return *this;\n}\n\n#endif  // _LIBCPP_HAS_NO_RVALUE_REFERENCES\n\ntemplate <class _Tp, class _Allocator>\nvoid\n__split_buffer<_Tp, _Allocator>::swap(__split_buffer& __x)\n        _NOEXCEPT_(!__alloc_traits::propagate_on_container_swap::value||\n                   __is_nothrow_swappable<__alloc_rr>::value)\n{\n    _VSTD::swap(__first_, __x.__first_);\n    _VSTD::swap(__begin_, __x.__begin_);\n    _VSTD::swap(__end_, __x.__end_);\n    _VSTD::swap(__end_cap(), __x.__end_cap());\n    __swap_allocator(__alloc(), __x.__alloc());\n}\n\ntemplate <class _Tp, class _Allocator>\nvoid\n__split_buffer<_Tp, _Allocator>::reserve(size_type __n)\n{\n    if (__n < capacity())\n    {\n        __split_buffer<value_type, __alloc_rr&> __t(__n, 0, __alloc());\n        __t.__construct_at_end(move_iterator<pointer>(__begin_),\n                               move_iterator<pointer>(__end_));\n        _VSTD::swap(__first_, __t.__first_);\n        _VSTD::swap(__begin_, __t.__begin_);\n        _VSTD::swap(__end_, __t.__end_);\n        _VSTD::swap(__end_cap(), __t.__end_cap());\n    }\n}\n\ntemplate <class _Tp, class _Allocator>\nvoid\n__split_buffer<_Tp, _Allocator>::shrink_to_fit() _NOEXCEPT\n{\n    if (capacity() > size())\n    {\n#ifndef _LIBCPP_NO_EXCEPTIONS\n        try\n        {\n#endif  // _LIBCPP_NO_EXCEPTIONS\n            __split_buffer<value_type, __alloc_rr&> __t(size(), 0, __alloc());\n            __t.__construct_at_end(move_iterator<pointer>(__begin_),\n                                   move_iterator<pointer>(__end_));\n            __t.__end_ = __t.__begin_ + (__end_ - __begin_);\n            _VSTD::swap(__first_, __t.__first_);\n            _VSTD::swap(__begin_, __t.__begin_);\n            _VSTD::swap(__end_, __t.__end_);\n            _VSTD::swap(__end_cap(), __t.__end_cap());\n#ifndef _LIBCPP_NO_EXCEPTIONS\n        }\n        catch (...)\n        {\n        }\n#endif  // _LIBCPP_NO_EXCEPTIONS\n    }\n}\n\ntemplate <class _Tp, class _Allocator>\nvoid\n__split_buffer<_Tp, _Allocator>::push_front(const_reference __x)\n{\n    if (__begin_ == __first_)\n    {\n        if (__end_ < __end_cap())\n        {\n            difference_type __d = __end_cap() - __end_;\n            __d = (__d + 1) / 2;\n            __begin_ = _VSTD::move_backward(__begin_, __end_, __end_ + __d);\n            __end_ += __d;\n        }\n        else\n        {\n            size_type __c = max<size_type>(2 * static_cast<size_t>(__end_cap() - __first_), 1);\n            __split_buffer<value_type, __alloc_rr&> __t(__c, (__c + 3) / 4, __alloc());\n            __t.__construct_at_end(move_iterator<pointer>(__begin_),\n                                   move_iterator<pointer>(__end_));\n            _VSTD::swap(__first_, __t.__first_);\n            _VSTD::swap(__begin_, __t.__begin_);\n            _VSTD::swap(__end_, __t.__end_);\n            _VSTD::swap(__end_cap(), __t.__end_cap());\n        }\n    }\n    __alloc_traits::construct(__alloc(), _VSTD::__to_raw_pointer(__begin_-1), __x);\n    --__begin_;\n}\n\n#ifndef _LIBCPP_HAS_NO_RVALUE_REFERENCES\n\ntemplate <class _Tp, class _Allocator>\nvoid\n__split_buffer<_Tp, _Allocator>::push_front(value_type&& __x)\n{\n    if (__begin_ == __first_)\n    {\n        if (__end_ < __end_cap())\n        {\n            difference_type __d = __end_cap() - __end_;\n            __d = (__d + 1) / 2;\n            __begin_ = _VSTD::move_backward(__begin_, __end_, __end_ + __d);\n            __end_ += __d;\n        }\n        else\n        {\n            size_type __c = max<size_type>(2 * static_cast<size_t>(__end_cap() - __first_), 1);\n            __split_buffer<value_type, __alloc_rr&> __t(__c, (__c + 3) / 4, __alloc());\n            __t.__construct_at_end(move_iterator<pointer>(__begin_),\n                                   move_iterator<pointer>(__end_));\n            _VSTD::swap(__first_, __t.__first_);\n            _VSTD::swap(__begin_, __t.__begin_);\n            _VSTD::swap(__end_, __t.__end_);\n            _VSTD::swap(__end_cap(), __t.__end_cap());\n        }\n    }\n    __alloc_traits::construct(__alloc(), _VSTD::__to_raw_pointer(__begin_-1),\n            _VSTD::move(__x));\n    --__begin_;\n}\n\n#endif  // _LIBCPP_HAS_NO_RVALUE_REFERENCES\n\ntemplate <class _Tp, class _Allocator>\ninline _LIBCPP_INLINE_VISIBILITY\nvoid\n__split_buffer<_Tp, _Allocator>::push_back(const_reference __x)\n{\n    if (__end_ == __end_cap())\n    {\n        if (__begin_ > __first_)\n        {\n            difference_type __d = __begin_ - __first_;\n            __d = (__d + 1) / 2;\n            __end_ = _VSTD::move(__begin_, __end_, __begin_ - __d);\n            __begin_ -= __d;\n        }\n        else\n        {\n            size_type __c = max<size_type>(2 * static_cast<size_t>(__end_cap() - __first_), 1);\n            __split_buffer<value_type, __alloc_rr&> __t(__c, __c / 4, __alloc());\n            __t.__construct_at_end(move_iterator<pointer>(__begin_),\n                                   move_iterator<pointer>(__end_));\n            _VSTD::swap(__first_, __t.__first_);\n            _VSTD::swap(__begin_, __t.__begin_);\n            _VSTD::swap(__end_, __t.__end_);\n            _VSTD::swap(__end_cap(), __t.__end_cap());\n        }\n    }\n    __alloc_traits::construct(__alloc(), _VSTD::__to_raw_pointer(__end_), __x);\n    ++__end_;\n}\n\n#ifndef _LIBCPP_HAS_NO_RVALUE_REFERENCES\n\ntemplate <class _Tp, class _Allocator>\nvoid\n__split_buffer<_Tp, _Allocator>::push_back(value_type&& __x)\n{\n    if (__end_ == __end_cap())\n    {\n        if (__begin_ > __first_)\n        {\n            difference_type __d = __begin_ - __first_;\n            __d = (__d + 1) / 2;\n            __end_ = _VSTD::move(__begin_, __end_, __begin_ - __d);\n            __begin_ -= __d;\n        }\n        else\n        {\n            size_type __c = max<size_type>(2 * static_cast<size_t>(__end_cap() - __first_), 1);\n            __split_buffer<value_type, __alloc_rr&> __t(__c, __c / 4, __alloc());\n            __t.__construct_at_end(move_iterator<pointer>(__begin_),\n                                   move_iterator<pointer>(__end_));\n            _VSTD::swap(__first_, __t.__first_);\n            _VSTD::swap(__begin_, __t.__begin_);\n            _VSTD::swap(__end_, __t.__end_);\n            _VSTD::swap(__end_cap(), __t.__end_cap());\n        }\n    }\n    __alloc_traits::construct(__alloc(), _VSTD::__to_raw_pointer(__end_),\n            _VSTD::move(__x));\n    ++__end_;\n}\n\n#ifndef _LIBCPP_HAS_NO_VARIADICS\n\ntemplate <class _Tp, class _Allocator>\ntemplate <class... _Args>\nvoid\n__split_buffer<_Tp, _Allocator>::emplace_back(_Args&&... __args)\n{\n    if (__end_ == __end_cap())\n    {\n        if (__begin_ > __first_)\n        {\n            difference_type __d = __begin_ - __first_;\n            __d = (__d + 1) / 2;\n            __end_ = _VSTD::move(__begin_, __end_, __begin_ - __d);\n            __begin_ -= __d;\n        }\n        else\n        {\n            size_type __c = max<size_type>(2 * static_cast<size_t>(__end_cap() - __first_), 1);\n            __split_buffer<value_type, __alloc_rr&> __t(__c, __c / 4, __alloc());\n            __t.__construct_at_end(move_iterator<pointer>(__begin_),\n                                   move_iterator<pointer>(__end_));\n            _VSTD::swap(__first_, __t.__first_);\n            _VSTD::swap(__begin_, __t.__begin_);\n            _VSTD::swap(__end_, __t.__end_);\n            _VSTD::swap(__end_cap(), __t.__end_cap());\n        }\n    }\n    __alloc_traits::construct(__alloc(), _VSTD::__to_raw_pointer(__end_),\n                              _VSTD::forward<_Args>(__args)...);\n    ++__end_;\n}\n\n#endif  // _LIBCPP_HAS_NO_VARIADICS\n\n#endif  // _LIBCPP_HAS_NO_RVALUE_REFERENCES\n\ntemplate <class _Tp, class _Allocator>\ninline _LIBCPP_INLINE_VISIBILITY\nvoid\nswap(__split_buffer<_Tp, _Allocator>& __x, __split_buffer<_Tp, _Allocator>& __y)\n        _NOEXCEPT_(_NOEXCEPT_(__x.swap(__y)))\n{\n    __x.swap(__y);\n}\n\n\n_LIBCPP_END_NAMESPACE_STD\n\n#endif  // _LIBCPP_SPLIT_BUFFER\n","// -*- C++ -*-\n//===---------------------------- deque -----------------------------------===//\n//\n//                     The LLVM Compiler Infrastructure\n//\n// This file is dual licensed under the MIT and the University of Illinois Open\n// Source Licenses. See LICENSE.TXT for details.\n//\n//===----------------------------------------------------------------------===//\n\n#ifndef _LIBCPP_DEQUE\n#define _LIBCPP_DEQUE\n\n/*\n    deque synopsis\n\nnamespace std\n{\n\ntemplate <class T, class Allocator = allocator<T> >\nclass deque\n{\npublic:\n    // types:\n    typedef T value_type;\n    typedef Allocator allocator_type;\n\n    typedef typename allocator_type::reference       reference;\n    typedef typename allocator_type::const_reference const_reference;\n    typedef implementation-defined                   iterator;\n    typedef implementation-defined                   const_iterator;\n    typedef typename allocator_type::size_type       size_type;\n    typedef typename allocator_type::difference_type difference_type;\n\n    typedef typename allocator_type::pointer         pointer;\n    typedef typename allocator_type::const_pointer   const_pointer;\n    typedef std::reverse_iterator<iterator>          reverse_iterator;\n    typedef std::reverse_iterator<const_iterator>    const_reverse_iterator;\n\n    // construct/copy/destroy:\n    deque() noexcept(is_nothrow_default_constructible<allocator_type>::value);\n    explicit deque(const allocator_type& a);\n    explicit deque(size_type n);\n    explicit deque(size_type n, const allocator_type& a); // C++14\n    deque(size_type n, const value_type& v);\n    deque(size_type n, const value_type& v, const allocator_type& a);\n    template <class InputIterator>\n        deque(InputIterator f, InputIterator l);\n    template <class InputIterator>\n        deque(InputIterator f, InputIterator l, const allocator_type& a);\n    deque(const deque& c);\n    deque(deque&& c)\n        noexcept(is_nothrow_move_constructible<allocator_type>::value);\n    deque(initializer_list<value_type> il, const Allocator& a = allocator_type());\n    deque(const deque& c, const allocator_type& a);\n    deque(deque&& c, const allocator_type& a);\n    ~deque();\n\n    deque& operator=(const deque& c);\n    deque& operator=(deque&& c)\n        noexcept(\n             allocator_type::propagate_on_container_move_assignment::value &&\n             is_nothrow_move_assignable<allocator_type>::value);\n    deque& operator=(initializer_list<value_type> il);\n\n    template <class InputIterator>\n        void assign(InputIterator f, InputIterator l);\n    void assign(size_type n, const value_type& v);\n    void assign(initializer_list<value_type> il);\n\n    allocator_type get_allocator() const noexcept;\n\n    // iterators:\n\n    iterator       begin() noexcept;\n    const_iterator begin() const noexcept;\n    iterator       end() noexcept;\n    const_iterator end() const noexcept;\n\n    reverse_iterator       rbegin() noexcept;\n    const_reverse_iterator rbegin() const noexcept;\n    reverse_iterator       rend() noexcept;\n    const_reverse_iterator rend() const noexcept;\n\n    const_iterator         cbegin() const noexcept;\n    const_iterator         cend() const noexcept;\n    const_reverse_iterator crbegin() const noexcept;\n    const_reverse_iterator crend() const noexcept;\n\n    // capacity:\n    size_type size() const noexcept;\n    size_type max_size() const noexcept;\n    void resize(size_type n);\n    void resize(size_type n, const value_type& v);\n    void shrink_to_fit();\n    bool empty() const noexcept;\n\n    // element access:\n    reference operator[](size_type i);\n    const_reference operator[](size_type i) const;\n    reference at(size_type i);\n    const_reference at(size_type i) const;\n    reference front();\n    const_reference front() const;\n    reference back();\n    const_reference back() const;\n\n    // modifiers:\n    void push_front(const value_type& v);\n    void push_front(value_type&& v);\n    void push_back(const value_type& v);\n    void push_back(value_type&& v);\n    template <class... Args> reference emplace_front(Args&&... args);  // reference in C++17\n    template <class... Args> reference emplace_back(Args&&... args);   // reference in C++17\n    template <class... Args> iterator emplace(const_iterator p, Args&&... args);\n    iterator insert(const_iterator p, const value_type& v);\n    iterator insert(const_iterator p, value_type&& v);\n    iterator insert(const_iterator p, size_type n, const value_type& v);\n    template <class InputIterator>\n        iterator insert(const_iterator p, InputIterator f, InputIterator l);\n    iterator insert(const_iterator p, initializer_list<value_type> il);\n    void pop_front();\n    void pop_back();\n    iterator erase(const_iterator p);\n    iterator erase(const_iterator f, const_iterator l);\n    void swap(deque& c)\n        noexcept(allocator_traits<allocator_type>::is_always_equal::value);  // C++17\n    void clear() noexcept;\n};\n\ntemplate <class T, class Allocator>\n    bool operator==(const deque<T,Allocator>& x, const deque<T,Allocator>& y);\ntemplate <class T, class Allocator>\n    bool operator< (const deque<T,Allocator>& x, const deque<T,Allocator>& y);\ntemplate <class T, class Allocator>\n    bool operator!=(const deque<T,Allocator>& x, const deque<T,Allocator>& y);\ntemplate <class T, class Allocator>\n    bool operator> (const deque<T,Allocator>& x, const deque<T,Allocator>& y);\ntemplate <class T, class Allocator>\n    bool operator>=(const deque<T,Allocator>& x, const deque<T,Allocator>& y);\ntemplate <class T, class Allocator>\n    bool operator<=(const deque<T,Allocator>& x, const deque<T,Allocator>& y);\n\n// specialized algorithms:\ntemplate <class T, class Allocator>\n    void swap(deque<T,Allocator>& x, deque<T,Allocator>& y)\n         noexcept(noexcept(x.swap(y)));\n\n}  // std\n\n*/\n\n#if !defined(_LIBCPP_HAS_NO_PRAGMA_SYSTEM_HEADER)\n#pragma GCC system_header\n#endif\n\n#include <__config>\n#include <__split_buffer>\n#include <type_traits>\n#include <initializer_list>\n#include <iterator>\n#include <algorithm>\n#include <stdexcept>\n\n#include <__undef_min_max>\n\n_LIBCPP_BEGIN_NAMESPACE_STD\n\ntemplate <class _Tp, class _Allocator> class __deque_base;\ntemplate <class _Tp, class _Allocator = allocator<_Tp> > class _LIBCPP_TEMPLATE_VIS deque;\n\ntemplate <class _ValueType, class _Pointer, class _Reference, class _MapPointer,\n          class _DiffType, _DiffType _BlockSize>\nclass _LIBCPP_TEMPLATE_VIS __deque_iterator;\n\ntemplate <class _RAIter,\n          class _V2, class _P2, class _R2, class _M2, class _D2, _D2 _B2>\n__deque_iterator<_V2, _P2, _R2, _M2, _D2, _B2>\ncopy(_RAIter __f,\n     _RAIter __l,\n     __deque_iterator<_V2, _P2, _R2, _M2, _D2, _B2> __r,\n     typename enable_if<__is_random_access_iterator<_RAIter>::value>::type* = 0);\n\ntemplate <class _V1, class _P1, class _R1, class _M1, class _D1, _D1 _B1,\n          class _OutputIterator>\n_OutputIterator\ncopy(__deque_iterator<_V1, _P1, _R1, _M1, _D1, _B1> __f,\n     __deque_iterator<_V1, _P1, _R1, _M1, _D1, _B1> __l,\n     _OutputIterator __r);\n\ntemplate <class _V1, class _P1, class _R1, class _M1, class _D1, _D1 _B1,\n          class _V2, class _P2, class _R2, class _M2, class _D2, _D2 _B2>\n__deque_iterator<_V2, _P2, _R2, _M2, _D2, _B2>\ncopy(__deque_iterator<_V1, _P1, _R1, _M1, _D1, _B1> __f,\n     __deque_iterator<_V1, _P1, _R1, _M1, _D1, _B1> __l,\n     __deque_iterator<_V2, _P2, _R2, _M2, _D2, _B2> __r);\n\ntemplate <class _RAIter,\n          class _V2, class _P2, class _R2, class _M2, class _D2, _D2 _B2>\n__deque_iterator<_V2, _P2, _R2, _M2, _D2, _B2>\ncopy_backward(_RAIter __f,\n              _RAIter __l,\n              __deque_iterator<_V2, _P2, _R2, _M2, _D2, _B2> __r,\n              typename enable_if<__is_random_access_iterator<_RAIter>::value>::type* = 0);\n\ntemplate <class _V1, class _P1, class _R1, class _M1, class _D1, _D1 _B1,\n          class _OutputIterator>\n_OutputIterator\ncopy_backward(__deque_iterator<_V1, _P1, _R1, _M1, _D1, _B1> __f,\n              __deque_iterator<_V1, _P1, _R1, _M1, _D1, _B1> __l,\n              _OutputIterator __r);\n\ntemplate <class _V1, class _P1, class _R1, class _M1, class _D1, _D1 _B1,\n          class _V2, class _P2, class _R2, class _M2, class _D2, _D2 _B2>\n__deque_iterator<_V2, _P2, _R2, _M2, _D2, _B2>\ncopy_backward(__deque_iterator<_V1, _P1, _R1, _M1, _D1, _B1> __f,\n              __deque_iterator<_V1, _P1, _R1, _M1, _D1, _B1> __l,\n              __deque_iterator<_V2, _P2, _R2, _M2, _D2, _B2> __r);\n\ntemplate <class _RAIter,\n          class _V2, class _P2, class _R2, class _M2, class _D2, _D2 _B2>\n__deque_iterator<_V2, _P2, _R2, _M2, _D2, _B2>\nmove(_RAIter __f,\n     _RAIter __l,\n     __deque_iterator<_V2, _P2, _R2, _M2, _D2, _B2> __r,\n     typename enable_if<__is_random_access_iterator<_RAIter>::value>::type* = 0);\n\ntemplate <class _V1, class _P1, class _R1, class _M1, class _D1, _D1 _B1,\n          class _OutputIterator>\n_OutputIterator\nmove(__deque_iterator<_V1, _P1, _R1, _M1, _D1, _B1> __f,\n     __deque_iterator<_V1, _P1, _R1, _M1, _D1, _B1> __l,\n     _OutputIterator __r);\n\ntemplate <class _V1, class _P1, class _R1, class _M1, class _D1, _D1 _B1,\n          class _V2, class _P2, class _R2, class _M2, class _D2, _D2 _B2>\n__deque_iterator<_V2, _P2, _R2, _M2, _D2, _B2>\nmove(__deque_iterator<_V1, _P1, _R1, _M1, _D1, _B1> __f,\n     __deque_iterator<_V1, _P1, _R1, _M1, _D1, _B1> __l,\n     __deque_iterator<_V2, _P2, _R2, _M2, _D2, _B2> __r);\n\ntemplate <class _RAIter,\n          class _V2, class _P2, class _R2, class _M2, class _D2, _D2 _B2>\n__deque_iterator<_V2, _P2, _R2, _M2, _D2, _B2>\nmove_backward(_RAIter __f,\n              _RAIter __l,\n              __deque_iterator<_V2, _P2, _R2, _M2, _D2, _B2> __r,\n              typename enable_if<__is_random_access_iterator<_RAIter>::value>::type* = 0);\n\ntemplate <class _V1, class _P1, class _R1, class _M1, class _D1, _D1 _B1,\n          class _OutputIterator>\n_OutputIterator\nmove_backward(__deque_iterator<_V1, _P1, _R1, _M1, _D1, _B1> __f,\n              __deque_iterator<_V1, _P1, _R1, _M1, _D1, _B1> __l,\n              _OutputIterator __r);\n\ntemplate <class _V1, class _P1, class _R1, class _M1, class _D1, _D1 _B1,\n          class _V2, class _P2, class _R2, class _M2, class _D2, _D2 _B2>\n__deque_iterator<_V2, _P2, _R2, _M2, _D2, _B2>\nmove_backward(__deque_iterator<_V1, _P1, _R1, _M1, _D1, _B1> __f,\n              __deque_iterator<_V1, _P1, _R1, _M1, _D1, _B1> __l,\n              __deque_iterator<_V2, _P2, _R2, _M2, _D2, _B2> __r);\n\ntemplate <class _ValueType, class _DiffType>\nstruct __deque_block_size {\n  static const _DiffType value = sizeof(_ValueType) < 256 ? 4096 / sizeof(_ValueType) : 16;\n};\n\ntemplate <class _ValueType, class _Pointer, class _Reference, class _MapPointer,\n          class _DiffType, _DiffType _BS =\n#ifdef _LIBCPP_ABI_INCOMPLETE_TYPES_IN_DEQUE\n// Keep template parameter to avoid changing all template declarations thoughout\n// this file.\n                               0\n#else\n                               __deque_block_size<_ValueType, _DiffType>::value\n#endif\n          >\nclass _LIBCPP_TEMPLATE_VIS __deque_iterator\n{\n    typedef _MapPointer __map_iterator;\npublic:\n    typedef _Pointer  pointer;\n    typedef _DiffType difference_type;\nprivate:\n    __map_iterator __m_iter_;\n    pointer        __ptr_;\n\n    static const difference_type __block_size;\npublic:\n    typedef _ValueType                  value_type;\n    typedef random_access_iterator_tag  iterator_category;\n    typedef _Reference                  reference;\n\n    _LIBCPP_INLINE_VISIBILITY __deque_iterator() _NOEXCEPT\n#if _LIBCPP_STD_VER > 11\n     : __m_iter_(nullptr), __ptr_(nullptr)\n#endif\n     {}\n\n    template <class _Pp, class _Rp, class _MP>\n    _LIBCPP_INLINE_VISIBILITY\n    __deque_iterator(const __deque_iterator<value_type, _Pp, _Rp, _MP, difference_type, _BS>& __it,\n                typename enable_if<is_convertible<_Pp, pointer>::value>::type* = 0) _NOEXCEPT\n        : __m_iter_(__it.__m_iter_), __ptr_(__it.__ptr_) {}\n\n    _LIBCPP_INLINE_VISIBILITY reference operator*() const {return *__ptr_;}\n    _LIBCPP_INLINE_VISIBILITY pointer operator->() const {return __ptr_;}\n\n    _LIBCPP_INLINE_VISIBILITY __deque_iterator& operator++()\n    {\n        if (++__ptr_ - *__m_iter_ == __block_size)\n        {\n            ++__m_iter_;\n            __ptr_ = *__m_iter_;\n        }\n        return *this;\n    }\n\n    _LIBCPP_INLINE_VISIBILITY __deque_iterator operator++(int)\n    {\n        __deque_iterator __tmp = *this;\n        ++(*this);\n        return __tmp;\n    }\n\n    _LIBCPP_INLINE_VISIBILITY __deque_iterator& operator--()\n    {\n        if (__ptr_ == *__m_iter_)\n        {\n            --__m_iter_;\n            __ptr_ = *__m_iter_ + __block_size;\n        }\n        --__ptr_;\n        return *this;\n    }\n\n    _LIBCPP_INLINE_VISIBILITY __deque_iterator operator--(int)\n    {\n        __deque_iterator __tmp = *this;\n        --(*this);\n        return __tmp;\n    }\n\n    _LIBCPP_INLINE_VISIBILITY __deque_iterator& operator+=(difference_type __n)\n    {\n        if (__n != 0)\n        {\n            __n += __ptr_ - *__m_iter_;\n            if (__n > 0)\n            {\n                __m_iter_ += __n / __block_size;\n                __ptr_ = *__m_iter_ + __n % __block_size;\n            }\n            else // (__n < 0)\n            {\n                difference_type __z = __block_size - 1 - __n;\n                __m_iter_ -= __z / __block_size;\n                __ptr_ = *__m_iter_ + (__block_size - 1 - __z % __block_size);\n            }\n        }\n        return *this;\n    }\n\n    _LIBCPP_INLINE_VISIBILITY __deque_iterator& operator-=(difference_type __n)\n    {\n        return *this += -__n;\n    }\n\n    _LIBCPP_INLINE_VISIBILITY __deque_iterator operator+(difference_type __n) const\n    {\n        __deque_iterator __t(*this);\n        __t += __n;\n        return __t;\n    }\n\n    _LIBCPP_INLINE_VISIBILITY __deque_iterator operator-(difference_type __n) const\n    {\n        __deque_iterator __t(*this);\n        __t -= __n;\n        return __t;\n    }\n\n    _LIBCPP_INLINE_VISIBILITY\n    friend __deque_iterator operator+(difference_type __n, const __deque_iterator& __it)\n        {return __it + __n;}\n\n    _LIBCPP_INLINE_VISIBILITY\n    friend difference_type operator-(const __deque_iterator& __x, const __deque_iterator& __y)\n    {\n        if (__x != __y)\n            return (__x.__m_iter_ - __y.__m_iter_) * __block_size\n                 + (__x.__ptr_ - *__x.__m_iter_)\n                 - (__y.__ptr_ - *__y.__m_iter_);\n        return 0;\n    }\n\n    _LIBCPP_INLINE_VISIBILITY reference operator[](difference_type __n) const\n        {return *(*this + __n);}\n\n    _LIBCPP_INLINE_VISIBILITY friend\n        bool operator==(const __deque_iterator& __x, const __deque_iterator& __y)\n        {return __x.__ptr_ == __y.__ptr_;}\n\n    _LIBCPP_INLINE_VISIBILITY friend\n        bool operator!=(const __deque_iterator& __x, const __deque_iterator& __y)\n        {return !(__x == __y);}\n\n    _LIBCPP_INLINE_VISIBILITY friend\n        bool operator<(const __deque_iterator& __x, const __deque_iterator& __y)\n        {return __x.__m_iter_ < __y.__m_iter_ ||\n               (__x.__m_iter_ == __y.__m_iter_ && __x.__ptr_ < __y.__ptr_);}\n\n    _LIBCPP_INLINE_VISIBILITY friend\n        bool operator>(const __deque_iterator& __x, const __deque_iterator& __y)\n        {return __y < __x;}\n\n    _LIBCPP_INLINE_VISIBILITY friend\n        bool operator<=(const __deque_iterator& __x, const __deque_iterator& __y)\n        {return !(__y < __x);}\n\n    _LIBCPP_INLINE_VISIBILITY friend\n        bool operator>=(const __deque_iterator& __x, const __deque_iterator& __y)\n        {return !(__x < __y);}\n\nprivate:\n    _LIBCPP_INLINE_VISIBILITY __deque_iterator(__map_iterator __m, pointer __p) _NOEXCEPT\n        : __m_iter_(__m), __ptr_(__p) {}\n\n    template <class _Tp, class _Ap> friend class __deque_base;\n    template <class _Tp, class _Ap> friend class _LIBCPP_TEMPLATE_VIS deque;\n    template <class _Vp, class _Pp, class _Rp, class _MP, class _Dp, _Dp>\n        friend class _LIBCPP_TEMPLATE_VIS __deque_iterator;\n\n    template <class _RAIter,\n              class _V2, class _P2, class _R2, class _M2, class _D2, _D2 _B2>\n    friend\n    __deque_iterator<_V2, _P2, _R2, _M2, _D2, _B2>\n    copy(_RAIter __f,\n         _RAIter __l,\n         __deque_iterator<_V2, _P2, _R2, _M2, _D2, _B2> __r,\n         typename enable_if<__is_random_access_iterator<_RAIter>::value>::type*);\n\n    template <class _V1, class _P1, class _R1, class _M1, class _D1, _D1 _B1,\n              class _OutputIterator>\n    friend\n    _OutputIterator\n    copy(__deque_iterator<_V1, _P1, _R1, _M1, _D1, _B1> __f,\n         __deque_iterator<_V1, _P1, _R1, _M1, _D1, _B1> __l,\n         _OutputIterator __r);\n\n    template <class _V1, class _P1, class _R1, class _M1, class _D1, _D1 _B1,\n              class _V2, class _P2, class _R2, class _M2, class _D2, _D2 _B2>\n    friend\n    __deque_iterator<_V2, _P2, _R2, _M2, _D2, _B2>\n    copy(__deque_iterator<_V1, _P1, _R1, _M1, _D1, _B1> __f,\n         __deque_iterator<_V1, _P1, _R1, _M1, _D1, _B1> __l,\n         __deque_iterator<_V2, _P2, _R2, _M2, _D2, _B2> __r);\n\n    template <class _RAIter,\n              class _V2, class _P2, class _R2, class _M2, class _D2, _D2 _B2>\n    friend\n    __deque_iterator<_V2, _P2, _R2, _M2, _D2, _B2>\n    copy_backward(_RAIter __f,\n                  _RAIter __l,\n                  __deque_iterator<_V2, _P2, _R2, _M2, _D2, _B2> __r,\n                  typename enable_if<__is_random_access_iterator<_RAIter>::value>::type*);\n\n    template <class _V1, class _P1, class _R1, class _M1, class _D1, _D1 _B1,\n              class _OutputIterator>\n    friend\n    _OutputIterator\n    copy_backward(__deque_iterator<_V1, _P1, _R1, _M1, _D1, _B1> __f,\n                  __deque_iterator<_V1, _P1, _R1, _M1, _D1, _B1> __l,\n                  _OutputIterator __r);\n\n    template <class _V1, class _P1, class _R1, class _M1, class _D1, _D1 _B1,\n              class _V2, class _P2, class _R2, class _M2, class _D2, _D2 _B2>\n    friend\n    __deque_iterator<_V2, _P2, _R2, _M2, _D2, _B2>\n    copy_backward(__deque_iterator<_V1, _P1, _R1, _M1, _D1, _B1> __f,\n                  __deque_iterator<_V1, _P1, _R1, _M1, _D1, _B1> __l,\n                  __deque_iterator<_V2, _P2, _R2, _M2, _D2, _B2> __r);\n\n    template <class _RAIter,\n              class _V2, class _P2, class _R2, class _M2, class _D2, _D2 _B2>\n    friend\n    __deque_iterator<_V2, _P2, _R2, _M2, _D2, _B2>\n    move(_RAIter __f,\n         _RAIter __l,\n         __deque_iterator<_V2, _P2, _R2, _M2, _D2, _B2> __r,\n         typename enable_if<__is_random_access_iterator<_RAIter>::value>::type*);\n\n    template <class _V1, class _P1, class _R1, class _M1, class _D1, _D1 _B1,\n              class _OutputIterator>\n    friend\n    _OutputIterator\n    move(__deque_iterator<_V1, _P1, _R1, _M1, _D1, _B1> __f,\n         __deque_iterator<_V1, _P1, _R1, _M1, _D1, _B1> __l,\n         _OutputIterator __r);\n\n    template <class _V1, class _P1, class _R1, class _M1, class _D1, _D1 _B1,\n              class _V2, class _P2, class _R2, class _M2, class _D2, _D2 _B2>\n    friend\n    __deque_iterator<_V2, _P2, _R2, _M2, _D2, _B2>\n    move(__deque_iterator<_V1, _P1, _R1, _M1, _D1, _B1> __f,\n         __deque_iterator<_V1, _P1, _R1, _M1, _D1, _B1> __l,\n         __deque_iterator<_V2, _P2, _R2, _M2, _D2, _B2> __r);\n\n    template <class _RAIter,\n              class _V2, class _P2, class _R2, class _M2, class _D2, _D2 _B2>\n    friend\n    __deque_iterator<_V2, _P2, _R2, _M2, _D2, _B2>\n    move_backward(_RAIter __f,\n                  _RAIter __l,\n                  __deque_iterator<_V2, _P2, _R2, _M2, _D2, _B2> __r,\n                  typename enable_if<__is_random_access_iterator<_RAIter>::value>::type*);\n\n    template <class _V1, class _P1, class _R1, class _M1, class _D1, _D1 _B1,\n              class _OutputIterator>\n    friend\n    _OutputIterator\n    move_backward(__deque_iterator<_V1, _P1, _R1, _M1, _D1, _B1> __f,\n                  __deque_iterator<_V1, _P1, _R1, _M1, _D1, _B1> __l,\n                  _OutputIterator __r);\n\n    template <class _V1, class _P1, class _R1, class _M1, class _D1, _D1 _B1,\n              class _V2, class _P2, class _R2, class _M2, class _D2, _D2 _B2>\n    friend\n    __deque_iterator<_V2, _P2, _R2, _M2, _D2, _B2>\n    move_backward(__deque_iterator<_V1, _P1, _R1, _M1, _D1, _B1> __f,\n                  __deque_iterator<_V1, _P1, _R1, _M1, _D1, _B1> __l,\n                  __deque_iterator<_V2, _P2, _R2, _M2, _D2, _B2> __r);\n};\n\ntemplate <class _ValueType, class _Pointer, class _Reference, class _MapPointer,\n          class _DiffType, _DiffType _BlockSize>\nconst _DiffType __deque_iterator<_ValueType, _Pointer, _Reference, _MapPointer,\n                                 _DiffType, _BlockSize>::__block_size =\n    __deque_block_size<_ValueType, _DiffType>::value;\n\n// copy\n\ntemplate <class _RAIter,\n          class _V2, class _P2, class _R2, class _M2, class _D2, _D2 _B2>\n__deque_iterator<_V2, _P2, _R2, _M2, _D2, _B2>\ncopy(_RAIter __f,\n     _RAIter __l,\n     __deque_iterator<_V2, _P2, _R2, _M2, _D2, _B2> __r,\n     typename enable_if<__is_random_access_iterator<_RAIter>::value>::type*)\n{\n    typedef typename __deque_iterator<_V2, _P2, _R2, _M2, _D2, _B2>::difference_type difference_type;\n    typedef typename __deque_iterator<_V2, _P2, _R2, _M2, _D2, _B2>::pointer pointer;\n    const difference_type __block_size = __deque_iterator<_V2, _P2, _R2, _M2, _D2, _B2>::__block_size;\n    while (__f != __l)\n    {\n        pointer __rb = __r.__ptr_;\n        pointer __re = *__r.__m_iter_ + __block_size;\n        difference_type __bs = __re - __rb;\n        difference_type __n = __l - __f;\n        _RAIter __m = __l;\n        if (__n > __bs)\n        {\n            __n = __bs;\n            __m = __f + __n;\n        }\n        _VSTD::copy(__f, __m, __rb);\n        __f = __m;\n        __r += __n;\n    }\n    return __r;\n}\n\ntemplate <class _V1, class _P1, class _R1, class _M1, class _D1, _D1 _B1,\n          class _OutputIterator>\n_OutputIterator\ncopy(__deque_iterator<_V1, _P1, _R1, _M1, _D1, _B1> __f,\n     __deque_iterator<_V1, _P1, _R1, _M1, _D1, _B1> __l,\n     _OutputIterator __r)\n{\n    typedef typename __deque_iterator<_V1, _P1, _R1, _M1, _D1, _B1>::difference_type difference_type;\n    typedef typename __deque_iterator<_V1, _P1, _R1, _M1, _D1, _B1>::pointer pointer;\n    const difference_type __block_size = __deque_iterator<_V1, _P1, _R1, _M1, _D1, _B1>::__block_size;\n    difference_type __n = __l - __f;\n    while (__n > 0)\n    {\n        pointer __fb = __f.__ptr_;\n        pointer __fe = *__f.__m_iter_ + __block_size;\n        difference_type __bs = __fe - __fb;\n        if (__bs > __n)\n        {\n            __bs = __n;\n            __fe = __fb + __bs;\n        }\n        __r = _VSTD::copy(__fb, __fe, __r);\n        __n -= __bs;\n        __f += __bs;\n    }\n    return __r;\n}\n\ntemplate <class _V1, class _P1, class _R1, class _M1, class _D1, _D1 _B1,\n          class _V2, class _P2, class _R2, class _M2, class _D2, _D2 _B2>\n__deque_iterator<_V2, _P2, _R2, _M2, _D2, _B2>\ncopy(__deque_iterator<_V1, _P1, _R1, _M1, _D1, _B1> __f,\n     __deque_iterator<_V1, _P1, _R1, _M1, _D1, _B1> __l,\n     __deque_iterator<_V2, _P2, _R2, _M2, _D2, _B2> __r)\n{\n    typedef typename __deque_iterator<_V1, _P1, _R1, _M1, _D1, _B1>::difference_type difference_type;\n    typedef typename __deque_iterator<_V1, _P1, _R1, _M1, _D1, _B1>::pointer pointer;\n    const difference_type __block_size = __deque_iterator<_V1, _P1, _R1, _M1, _D1, _B1>::__block_size;\n    difference_type __n = __l - __f;\n    while (__n > 0)\n    {\n        pointer __fb = __f.__ptr_;\n        pointer __fe = *__f.__m_iter_ + __block_size;\n        difference_type __bs = __fe - __fb;\n        if (__bs > __n)\n        {\n            __bs = __n;\n            __fe = __fb + __bs;\n        }\n        __r = _VSTD::copy(__fb, __fe, __r);\n        __n -= __bs;\n        __f += __bs;\n    }\n    return __r;\n}\n\n// copy_backward\n\ntemplate <class _RAIter,\n          class _V2, class _P2, class _R2, class _M2, class _D2, _D2 _B2>\n__deque_iterator<_V2, _P2, _R2, _M2, _D2, _B2>\ncopy_backward(_RAIter __f,\n              _RAIter __l,\n              __deque_iterator<_V2, _P2, _R2, _M2, _D2, _B2> __r,\n              typename enable_if<__is_random_access_iterator<_RAIter>::value>::type*)\n{\n    typedef typename __deque_iterator<_V2, _P2, _R2, _M2, _D2, _B2>::difference_type difference_type;\n    typedef typename __deque_iterator<_V2, _P2, _R2, _M2, _D2, _B2>::pointer pointer;\n    while (__f != __l)\n    {\n        __deque_iterator<_V2, _P2, _R2, _M2, _D2, _B2> __rp = _VSTD::prev(__r);\n        pointer __rb = *__rp.__m_iter_;\n        pointer __re = __rp.__ptr_ + 1;\n        difference_type __bs = __re - __rb;\n        difference_type __n = __l - __f;\n        _RAIter __m = __f;\n        if (__n > __bs)\n        {\n            __n = __bs;\n            __m = __l - __n;\n        }\n        _VSTD::copy_backward(__m, __l, __re);\n        __l = __m;\n        __r -= __n;\n    }\n    return __r;\n}\n\ntemplate <class _V1, class _P1, class _R1, class _M1, class _D1, _D1 _B1,\n          class _OutputIterator>\n_OutputIterator\ncopy_backward(__deque_iterator<_V1, _P1, _R1, _M1, _D1, _B1> __f,\n              __deque_iterator<_V1, _P1, _R1, _M1, _D1, _B1> __l,\n              _OutputIterator __r)\n{\n    typedef typename __deque_iterator<_V1, _P1, _R1, _M1, _D1, _B1>::difference_type difference_type;\n    typedef typename __deque_iterator<_V1, _P1, _R1, _M1, _D1, _B1>::pointer pointer;\n    difference_type __n = __l - __f;\n    while (__n > 0)\n    {\n        --__l;\n        pointer __lb = *__l.__m_iter_;\n        pointer __le = __l.__ptr_ + 1;\n        difference_type __bs = __le - __lb;\n        if (__bs > __n)\n        {\n            __bs = __n;\n            __lb = __le - __bs;\n        }\n        __r = _VSTD::copy_backward(__lb, __le, __r);\n        __n -= __bs;\n        __l -= __bs - 1;\n    }\n    return __r;\n}\n\ntemplate <class _V1, class _P1, class _R1, class _M1, class _D1, _D1 _B1,\n          class _V2, class _P2, class _R2, class _M2, class _D2, _D2 _B2>\n__deque_iterator<_V2, _P2, _R2, _M2, _D2, _B2>\ncopy_backward(__deque_iterator<_V1, _P1, _R1, _M1, _D1, _B1> __f,\n              __deque_iterator<_V1, _P1, _R1, _M1, _D1, _B1> __l,\n              __deque_iterator<_V2, _P2, _R2, _M2, _D2, _B2> __r)\n{\n    typedef typename __deque_iterator<_V1, _P1, _R1, _M1, _D1, _B1>::difference_type difference_type;\n    typedef typename __deque_iterator<_V1, _P1, _R1, _M1, _D1, _B1>::pointer pointer;\n    difference_type __n = __l - __f;\n    while (__n > 0)\n    {\n        --__l;\n        pointer __lb = *__l.__m_iter_;\n        pointer __le = __l.__ptr_ + 1;\n        difference_type __bs = __le - __lb;\n        if (__bs > __n)\n        {\n            __bs = __n;\n            __lb = __le - __bs;\n        }\n        __r = _VSTD::copy_backward(__lb, __le, __r);\n        __n -= __bs;\n        __l -= __bs - 1;\n    }\n    return __r;\n}\n\n// move\n\ntemplate <class _RAIter,\n          class _V2, class _P2, class _R2, class _M2, class _D2, _D2 _B2>\n__deque_iterator<_V2, _P2, _R2, _M2, _D2, _B2>\nmove(_RAIter __f,\n     _RAIter __l,\n     __deque_iterator<_V2, _P2, _R2, _M2, _D2, _B2> __r,\n     typename enable_if<__is_random_access_iterator<_RAIter>::value>::type*)\n{\n    typedef typename __deque_iterator<_V2, _P2, _R2, _M2, _D2, _B2>::difference_type difference_type;\n    typedef typename __deque_iterator<_V2, _P2, _R2, _M2, _D2, _B2>::pointer pointer;\n    const difference_type __block_size = __deque_iterator<_V2, _P2, _R2, _M2, _D2, _B2>::__block_size;\n    while (__f != __l)\n    {\n        pointer __rb = __r.__ptr_;\n        pointer __re = *__r.__m_iter_ + __block_size;\n        difference_type __bs = __re - __rb;\n        difference_type __n = __l - __f;\n        _RAIter __m = __l;\n        if (__n > __bs)\n        {\n            __n = __bs;\n            __m = __f + __n;\n        }\n        _VSTD::move(__f, __m, __rb);\n        __f = __m;\n        __r += __n;\n    }\n    return __r;\n}\n\ntemplate <class _V1, class _P1, class _R1, class _M1, class _D1, _D1 _B1,\n          class _OutputIterator>\n_OutputIterator\nmove(__deque_iterator<_V1, _P1, _R1, _M1, _D1, _B1> __f,\n     __deque_iterator<_V1, _P1, _R1, _M1, _D1, _B1> __l,\n     _OutputIterator __r)\n{\n    typedef typename __deque_iterator<_V1, _P1, _R1, _M1, _D1, _B1>::difference_type difference_type;\n    typedef typename __deque_iterator<_V1, _P1, _R1, _M1, _D1, _B1>::pointer pointer;\n    const difference_type __block_size = __deque_iterator<_V1, _P1, _R1, _M1, _D1, _B1>::__block_size;\n    difference_type __n = __l - __f;\n    while (__n > 0)\n    {\n        pointer __fb = __f.__ptr_;\n        pointer __fe = *__f.__m_iter_ + __block_size;\n        difference_type __bs = __fe - __fb;\n        if (__bs > __n)\n        {\n            __bs = __n;\n            __fe = __fb + __bs;\n        }\n        __r = _VSTD::move(__fb, __fe, __r);\n        __n -= __bs;\n        __f += __bs;\n    }\n    return __r;\n}\n\ntemplate <class _V1, class _P1, class _R1, class _M1, class _D1, _D1 _B1,\n          class _V2, class _P2, class _R2, class _M2, class _D2, _D2 _B2>\n__deque_iterator<_V2, _P2, _R2, _M2, _D2, _B2>\nmove(__deque_iterator<_V1, _P1, _R1, _M1, _D1, _B1> __f,\n     __deque_iterator<_V1, _P1, _R1, _M1, _D1, _B1> __l,\n     __deque_iterator<_V2, _P2, _R2, _M2, _D2, _B2> __r)\n{\n    typedef typename __deque_iterator<_V1, _P1, _R1, _M1, _D1, _B1>::difference_type difference_type;\n    typedef typename __deque_iterator<_V1, _P1, _R1, _M1, _D1, _B1>::pointer pointer;\n    const difference_type __block_size = __deque_iterator<_V1, _P1, _R1, _M1, _D1, _B1>::__block_size;\n    difference_type __n = __l - __f;\n    while (__n > 0)\n    {\n        pointer __fb = __f.__ptr_;\n        pointer __fe = *__f.__m_iter_ + __block_size;\n        difference_type __bs = __fe - __fb;\n        if (__bs > __n)\n        {\n            __bs = __n;\n            __fe = __fb + __bs;\n        }\n        __r = _VSTD::move(__fb, __fe, __r);\n        __n -= __bs;\n        __f += __bs;\n    }\n    return __r;\n}\n\n// move_backward\n\ntemplate <class _RAIter,\n          class _V2, class _P2, class _R2, class _M2, class _D2, _D2 _B2>\n__deque_iterator<_V2, _P2, _R2, _M2, _D2, _B2>\nmove_backward(_RAIter __f,\n              _RAIter __l,\n              __deque_iterator<_V2, _P2, _R2, _M2, _D2, _B2> __r,\n              typename enable_if<__is_random_access_iterator<_RAIter>::value>::type*)\n{\n    typedef typename __deque_iterator<_V2, _P2, _R2, _M2, _D2, _B2>::difference_type difference_type;\n    typedef typename __deque_iterator<_V2, _P2, _R2, _M2, _D2, _B2>::pointer pointer;\n    while (__f != __l)\n    {\n        __deque_iterator<_V2, _P2, _R2, _M2, _D2, _B2> __rp = _VSTD::prev(__r);\n        pointer __rb = *__rp.__m_iter_;\n        pointer __re = __rp.__ptr_ + 1;\n        difference_type __bs = __re - __rb;\n        difference_type __n = __l - __f;\n        _RAIter __m = __f;\n        if (__n > __bs)\n        {\n            __n = __bs;\n            __m = __l - __n;\n        }\n        _VSTD::move_backward(__m, __l, __re);\n        __l = __m;\n        __r -= __n;\n    }\n    return __r;\n}\n\ntemplate <class _V1, class _P1, class _R1, class _M1, class _D1, _D1 _B1,\n          class _OutputIterator>\n_OutputIterator\nmove_backward(__deque_iterator<_V1, _P1, _R1, _M1, _D1, _B1> __f,\n              __deque_iterator<_V1, _P1, _R1, _M1, _D1, _B1> __l,\n              _OutputIterator __r)\n{\n    typedef typename __deque_iterator<_V1, _P1, _R1, _M1, _D1, _B1>::difference_type difference_type;\n    typedef typename __deque_iterator<_V1, _P1, _R1, _M1, _D1, _B1>::pointer pointer;\n    difference_type __n = __l - __f;\n    while (__n > 0)\n    {\n        --__l;\n        pointer __lb = *__l.__m_iter_;\n        pointer __le = __l.__ptr_ + 1;\n        difference_type __bs = __le - __lb;\n        if (__bs > __n)\n        {\n            __bs = __n;\n            __lb = __le - __bs;\n        }\n        __r = _VSTD::move_backward(__lb, __le, __r);\n        __n -= __bs;\n        __l -= __bs - 1;\n    }\n    return __r;\n}\n\ntemplate <class _V1, class _P1, class _R1, class _M1, class _D1, _D1 _B1,\n          class _V2, class _P2, class _R2, class _M2, class _D2, _D2 _B2>\n__deque_iterator<_V2, _P2, _R2, _M2, _D2, _B2>\nmove_backward(__deque_iterator<_V1, _P1, _R1, _M1, _D1, _B1> __f,\n              __deque_iterator<_V1, _P1, _R1, _M1, _D1, _B1> __l,\n              __deque_iterator<_V2, _P2, _R2, _M2, _D2, _B2> __r)\n{\n    typedef typename __deque_iterator<_V1, _P1, _R1, _M1, _D1, _B1>::difference_type difference_type;\n    typedef typename __deque_iterator<_V1, _P1, _R1, _M1, _D1, _B1>::pointer pointer;\n    difference_type __n = __l - __f;\n    while (__n > 0)\n    {\n        --__l;\n        pointer __lb = *__l.__m_iter_;\n        pointer __le = __l.__ptr_ + 1;\n        difference_type __bs = __le - __lb;\n        if (__bs > __n)\n        {\n            __bs = __n;\n            __lb = __le - __bs;\n        }\n        __r = _VSTD::move_backward(__lb, __le, __r);\n        __n -= __bs;\n        __l -= __bs - 1;\n    }\n    return __r;\n}\n\ntemplate <bool>\nclass __deque_base_common\n{\nprotected:\n    _LIBCPP_NORETURN void __throw_length_error() const;\n    _LIBCPP_NORETURN void __throw_out_of_range() const;\n};\n\ntemplate <bool __b>\nvoid\n__deque_base_common<__b>::__throw_length_error() const\n{\n    _VSTD::__throw_length_error(\"deque\");\n}\n\ntemplate <bool __b>\nvoid\n__deque_base_common<__b>::__throw_out_of_range() const\n{\n    _VSTD::__throw_out_of_range(\"deque\");\n}\n\ntemplate <class _Tp, class _Allocator>\nclass __deque_base\n    : protected __deque_base_common<true>\n{\n    __deque_base(const __deque_base& __c);\n    __deque_base& operator=(const __deque_base& __c);\nprotected:\n    typedef _Tp                                      value_type;\n    typedef _Allocator                               allocator_type;\n    typedef allocator_traits<allocator_type>         __alloc_traits;\n    typedef value_type&                              reference;\n    typedef const value_type&                        const_reference;\n    typedef typename __alloc_traits::size_type       size_type;\n    typedef typename __alloc_traits::difference_type difference_type;\n    typedef typename __alloc_traits::pointer         pointer;\n    typedef typename __alloc_traits::const_pointer   const_pointer;\n\n    static const difference_type __block_size;\n\n    typedef typename __rebind_alloc_helper<__alloc_traits, pointer>::type __pointer_allocator;\n    typedef allocator_traits<__pointer_allocator>        __map_traits;\n    typedef typename __map_traits::pointer               __map_pointer;\n    typedef typename __rebind_alloc_helper<__alloc_traits, const_pointer>::type __const_pointer_allocator;\n    typedef typename allocator_traits<__const_pointer_allocator>::const_pointer __map_const_pointer;\n    typedef __split_buffer<pointer, __pointer_allocator> __map;\n\n    typedef __deque_iterator<value_type, pointer, reference, __map_pointer,\n                             difference_type>    iterator;\n    typedef __deque_iterator<value_type, const_pointer, const_reference, __map_const_pointer,\n                             difference_type>    const_iterator;\n\n    __map __map_;\n    size_type __start_;\n    __compressed_pair<size_type, allocator_type> __size_;\n\n    iterator       begin() _NOEXCEPT;\n    const_iterator begin() const _NOEXCEPT;\n    iterator       end() _NOEXCEPT;\n    const_iterator end() const _NOEXCEPT;\n\n    _LIBCPP_INLINE_VISIBILITY size_type&            size()          {return __size_.first();}\n    _LIBCPP_INLINE_VISIBILITY\n    const size_type& size() const _NOEXCEPT {return __size_.first();}\n    _LIBCPP_INLINE_VISIBILITY allocator_type&       __alloc()       {return __size_.second();}\n    _LIBCPP_INLINE_VISIBILITY\n    const allocator_type& __alloc() const _NOEXCEPT {return __size_.second();}\n\n    _LIBCPP_INLINE_VISIBILITY\n    __deque_base()\n        _NOEXCEPT_(is_nothrow_default_constructible<allocator_type>::value);\n    _LIBCPP_INLINE_VISIBILITY\n    explicit __deque_base(const allocator_type& __a);\npublic:\n    ~__deque_base();\n\n#ifndef _LIBCPP_HAS_NO_RVALUE_REFERENCES\n\n    __deque_base(__deque_base&& __c)\n        _NOEXCEPT_(is_nothrow_move_constructible<allocator_type>::value);\n    __deque_base(__deque_base&& __c, const allocator_type& __a);\n\n#endif  // _LIBCPP_HAS_NO_RVALUE_REFERENCES\n    void swap(__deque_base& __c)\n#if _LIBCPP_STD_VER >= 14\n        _NOEXCEPT;\n#else\n        _NOEXCEPT_(!__alloc_traits::propagate_on_container_swap::value || \n                    __is_nothrow_swappable<allocator_type>::value);\n#endif\nprotected:\n    void clear() _NOEXCEPT;\n\n    bool __invariants() const;\n\n    _LIBCPP_INLINE_VISIBILITY\n    void __move_assign(__deque_base& __c)\n        _NOEXCEPT_(__alloc_traits::propagate_on_container_move_assignment::value &&\n                   is_nothrow_move_assignable<allocator_type>::value)\n    {\n        __map_ = _VSTD::move(__c.__map_);\n        __start_ = __c.__start_;\n        size() = __c.size();\n        __move_assign_alloc(__c);\n        __c.__start_ = __c.size() = 0;\n    }\n\n    _LIBCPP_INLINE_VISIBILITY\n    void __move_assign_alloc(__deque_base& __c)\n        _NOEXCEPT_(!__alloc_traits::propagate_on_container_move_assignment::value ||\n                   is_nothrow_move_assignable<allocator_type>::value)\n        {__move_assign_alloc(__c, integral_constant<bool,\n                      __alloc_traits::propagate_on_container_move_assignment::value>());}\n\nprivate:\n    _LIBCPP_INLINE_VISIBILITY\n    void __move_assign_alloc(__deque_base& __c, true_type)\n        _NOEXCEPT_(is_nothrow_move_assignable<allocator_type>::value)\n        {\n            __alloc() = _VSTD::move(__c.__alloc());\n        }\n\n    _LIBCPP_INLINE_VISIBILITY\n    void __move_assign_alloc(__deque_base&, false_type) _NOEXCEPT\n        {}\n};\n\ntemplate <class _Tp, class _Allocator>\nconst typename __deque_base<_Tp, _Allocator>::difference_type\n    __deque_base<_Tp, _Allocator>::__block_size =\n        __deque_block_size<value_type, difference_type>::value;\n\ntemplate <class _Tp, class _Allocator>\nbool\n__deque_base<_Tp, _Allocator>::__invariants() const\n{\n    if (!__map_.__invariants())\n        return false;\n    if (__map_.size() >= size_type(-1) / __block_size)\n        return false;\n    for (typename __map::const_iterator __i = __map_.begin(), __e = __map_.end();\n         __i != __e; ++__i)\n        if (*__i == nullptr)\n            return false;\n    if (__map_.size() != 0)\n    {\n        if (size() >= __map_.size() * __block_size)\n            return false;\n        if (__start_ >= __map_.size() * __block_size - size())\n            return false;\n    }\n    else\n    {\n        if (size() != 0)\n            return false;\n        if (__start_ != 0)\n            return false;\n    }\n    return true;\n}\n\ntemplate <class _Tp, class _Allocator>\ntypename __deque_base<_Tp, _Allocator>::iterator\n__deque_base<_Tp, _Allocator>::begin() _NOEXCEPT\n{\n    __map_pointer __mp = __map_.begin() + __start_ / __block_size;\n    return iterator(__mp, __map_.empty() ? 0 : *__mp + __start_ % __block_size);\n}\n\ntemplate <class _Tp, class _Allocator>\ntypename __deque_base<_Tp, _Allocator>::const_iterator\n__deque_base<_Tp, _Allocator>::begin() const _NOEXCEPT\n{\n    __map_const_pointer __mp = static_cast<__map_const_pointer>(__map_.begin() + __start_ / __block_size);\n    return const_iterator(__mp, __map_.empty() ? 0 : *__mp + __start_ % __block_size);\n}\n\ntemplate <class _Tp, class _Allocator>\ntypename __deque_base<_Tp, _Allocator>::iterator\n__deque_base<_Tp, _Allocator>::end() _NOEXCEPT\n{\n    size_type __p = size() + __start_;\n    __map_pointer __mp = __map_.begin() + __p / __block_size;\n    return iterator(__mp, __map_.empty() ? 0 : *__mp + __p % __block_size);\n}\n\ntemplate <class _Tp, class _Allocator>\ntypename __deque_base<_Tp, _Allocator>::const_iterator\n__deque_base<_Tp, _Allocator>::end() const _NOEXCEPT\n{\n    size_type __p = size() + __start_;\n    __map_const_pointer __mp = static_cast<__map_const_pointer>(__map_.begin() + __p / __block_size);\n    return const_iterator(__mp, __map_.empty() ? 0 : *__mp + __p % __block_size);\n}\n\ntemplate <class _Tp, class _Allocator>\ninline\n__deque_base<_Tp, _Allocator>::__deque_base()\n    _NOEXCEPT_(is_nothrow_default_constructible<allocator_type>::value)\n    : __start_(0), __size_(0) {}\n\ntemplate <class _Tp, class _Allocator>\ninline\n__deque_base<_Tp, _Allocator>::__deque_base(const allocator_type& __a)\n    : __map_(__pointer_allocator(__a)), __start_(0), __size_(0, __a) {}\n\ntemplate <class _Tp, class _Allocator>\n__deque_base<_Tp, _Allocator>::~__deque_base()\n{\n    clear();\n    typename __map::iterator __i = __map_.begin();\n    typename __map::iterator __e = __map_.end();\n    for (; __i != __e; ++__i)\n        __alloc_traits::deallocate(__alloc(), *__i, __block_size);\n}\n\n#ifndef _LIBCPP_HAS_NO_RVALUE_REFERENCES\n\ntemplate <class _Tp, class _Allocator>\n__deque_base<_Tp, _Allocator>::__deque_base(__deque_base&& __c)\n    _NOEXCEPT_(is_nothrow_move_constructible<allocator_type>::value)\n    : __map_(_VSTD::move(__c.__map_)),\n      __start_(_VSTD::move(__c.__start_)),\n      __size_(_VSTD::move(__c.__size_))\n{\n    __c.__start_ = 0;\n    __c.size() = 0;\n}\n\ntemplate <class _Tp, class _Allocator>\n__deque_base<_Tp, _Allocator>::__deque_base(__deque_base&& __c, const allocator_type& __a)\n    : __map_(_VSTD::move(__c.__map_), __pointer_allocator(__a)),\n      __start_(_VSTD::move(__c.__start_)),\n      __size_(_VSTD::move(__c.size()), __a)\n{\n    if (__a == __c.__alloc())\n    {\n        __c.__start_ = 0;\n        __c.size() = 0;\n    }\n    else\n    {\n        __map_.clear();\n        __start_ = 0;\n        size() = 0;\n    }\n}\n\n#endif  // _LIBCPP_HAS_NO_RVALUE_REFERENCES\n\ntemplate <class _Tp, class _Allocator>\nvoid\n__deque_base<_Tp, _Allocator>::swap(__deque_base& __c)\n#if _LIBCPP_STD_VER >= 14\n        _NOEXCEPT\n#else\n        _NOEXCEPT_(!__alloc_traits::propagate_on_container_swap::value || \n                    __is_nothrow_swappable<allocator_type>::value)\n#endif\n{\n    __map_.swap(__c.__map_);\n    _VSTD::swap(__start_, __c.__start_);\n    _VSTD::swap(size(), __c.size());\n    __swap_allocator(__alloc(), __c.__alloc());\n}\n\ntemplate <class _Tp, class _Allocator>\nvoid\n__deque_base<_Tp, _Allocator>::clear() _NOEXCEPT\n{\n    allocator_type& __a = __alloc();\n    for (iterator __i = begin(), __e = end(); __i != __e; ++__i)\n        __alloc_traits::destroy(__a, _VSTD::addressof(*__i));\n    size() = 0;\n    while (__map_.size() > 2)\n    {\n        __alloc_traits::deallocate(__a, __map_.front(), __block_size);\n        __map_.pop_front();\n    }\n    switch (__map_.size())\n    {\n    case 1:\n        __start_ = __block_size / 2;\n        break;\n    case 2:\n        __start_ = __block_size;\n        break;\n    }\n}\n\ntemplate <class _Tp, class _Allocator /*= allocator<_Tp>*/>\nclass _LIBCPP_TEMPLATE_VIS deque\n    : private __deque_base<_Tp, _Allocator>\n{\npublic:\n    // types:\n\n    typedef _Tp value_type;\n    typedef _Allocator allocator_type;\n\n    static_assert((is_same<typename allocator_type::value_type, value_type>::value),\n                  \"Allocator::value_type must be same type as value_type\");\n\n    typedef __deque_base<value_type, allocator_type> __base;\n\n    typedef typename __base::__alloc_traits        __alloc_traits;\n    typedef typename __base::reference             reference;\n    typedef typename __base::const_reference       const_reference;\n    typedef typename __base::iterator              iterator;\n    typedef typename __base::const_iterator        const_iterator;\n    typedef typename __base::size_type             size_type;\n    typedef typename __base::difference_type       difference_type;\n\n    typedef typename __base::pointer               pointer;\n    typedef typename __base::const_pointer         const_pointer;\n    typedef _VSTD::reverse_iterator<iterator>       reverse_iterator;\n    typedef _VSTD::reverse_iterator<const_iterator> const_reverse_iterator;\n\n    // construct/copy/destroy:\n    _LIBCPP_INLINE_VISIBILITY\n    deque()\n        _NOEXCEPT_(is_nothrow_default_constructible<allocator_type>::value)\n        {}\n    _LIBCPP_INLINE_VISIBILITY explicit deque(const allocator_type& __a) : __base(__a) {}\n    explicit deque(size_type __n);\n#if _LIBCPP_STD_VER > 11\n    explicit deque(size_type __n, const _Allocator& __a);\n#endif\n    deque(size_type __n, const value_type& __v);\n    deque(size_type __n, const value_type& __v, const allocator_type& __a);\n    template <class _InputIter>\n        deque(_InputIter __f, _InputIter __l,\n              typename enable_if<__is_input_iterator<_InputIter>::value>::type* = 0);\n    template <class _InputIter>\n        deque(_InputIter __f, _InputIter __l, const allocator_type& __a,\n              typename enable_if<__is_input_iterator<_InputIter>::value>::type* = 0);\n    deque(const deque& __c);\n    deque(const deque& __c, const allocator_type& __a);\n#ifndef _LIBCPP_HAS_NO_GENERALIZED_INITIALIZERS\n    deque(initializer_list<value_type> __il);\n    deque(initializer_list<value_type> __il, const allocator_type& __a);\n#endif  // _LIBCPP_HAS_NO_GENERALIZED_INITIALIZERS\n\n    deque& operator=(const deque& __c);\n#ifndef _LIBCPP_HAS_NO_GENERALIZED_INITIALIZERS\n    _LIBCPP_INLINE_VISIBILITY\n    deque& operator=(initializer_list<value_type> __il) {assign(__il); return *this;}\n#endif   // _LIBCPP_HAS_NO_GENERALIZED_INITIALIZERS\n\n#ifndef _LIBCPP_HAS_NO_RVALUE_REFERENCES\n    _LIBCPP_INLINE_VISIBILITY\n    deque(deque&& __c) _NOEXCEPT_(is_nothrow_move_constructible<__base>::value);\n    _LIBCPP_INLINE_VISIBILITY\n    deque(deque&& __c, const allocator_type& __a);\n    _LIBCPP_INLINE_VISIBILITY\n    deque& operator=(deque&& __c)\n        _NOEXCEPT_(__alloc_traits::propagate_on_container_move_assignment::value &&\n                   is_nothrow_move_assignable<allocator_type>::value);\n#endif  // _LIBCPP_HAS_NO_RVALUE_REFERENCES\n\n    template <class _InputIter>\n        void assign(_InputIter __f, _InputIter __l,\n                    typename enable_if<__is_input_iterator<_InputIter>::value &&\n                                      !__is_random_access_iterator<_InputIter>::value>::type* = 0);\n    template <class _RAIter>\n        void assign(_RAIter __f, _RAIter __l,\n                    typename enable_if<__is_random_access_iterator<_RAIter>::value>::type* = 0);\n    void assign(size_type __n, const value_type& __v);\n#ifndef _LIBCPP_HAS_NO_GENERALIZED_INITIALIZERS\n    _LIBCPP_INLINE_VISIBILITY\n    void assign(initializer_list<value_type> __il) {assign(__il.begin(), __il.end());}\n#endif  // _LIBCPP_HAS_NO_GENERALIZED_INITIALIZERS\n\n    _LIBCPP_INLINE_VISIBILITY\n    allocator_type get_allocator() const _NOEXCEPT;\n\n    // iterators:\n\n    _LIBCPP_INLINE_VISIBILITY\n    iterator       begin() _NOEXCEPT       {return __base::begin();}\n    _LIBCPP_INLINE_VISIBILITY\n    const_iterator begin() const _NOEXCEPT {return __base::begin();}\n    _LIBCPP_INLINE_VISIBILITY\n    iterator       end() _NOEXCEPT         {return __base::end();}\n    _LIBCPP_INLINE_VISIBILITY\n    const_iterator end()   const _NOEXCEPT {return __base::end();}\n\n    _LIBCPP_INLINE_VISIBILITY\n    reverse_iterator       rbegin() _NOEXCEPT\n        {return       reverse_iterator(__base::end());}\n    _LIBCPP_INLINE_VISIBILITY\n    const_reverse_iterator rbegin() const _NOEXCEPT\n        {return const_reverse_iterator(__base::end());}\n    _LIBCPP_INLINE_VISIBILITY\n    reverse_iterator       rend() _NOEXCEPT\n        {return       reverse_iterator(__base::begin());}\n    _LIBCPP_INLINE_VISIBILITY\n    const_reverse_iterator rend()   const _NOEXCEPT\n        {return const_reverse_iterator(__base::begin());}\n\n    _LIBCPP_INLINE_VISIBILITY\n    const_iterator         cbegin()  const _NOEXCEPT\n        {return __base::begin();}\n    _LIBCPP_INLINE_VISIBILITY\n    const_iterator         cend()    const _NOEXCEPT\n        {return __base::end();}\n    _LIBCPP_INLINE_VISIBILITY\n    const_reverse_iterator crbegin() const _NOEXCEPT\n        {return const_reverse_iterator(__base::end());}\n    _LIBCPP_INLINE_VISIBILITY\n    const_reverse_iterator crend()   const _NOEXCEPT\n        {return const_reverse_iterator(__base::begin());}\n\n    // capacity:\n    _LIBCPP_INLINE_VISIBILITY\n    size_type size() const _NOEXCEPT {return __base::size();}\n    _LIBCPP_INLINE_VISIBILITY\n    size_type max_size() const _NOEXCEPT\n        {return std::min<size_type>(\n            __alloc_traits::max_size(__base::__alloc()),\n            numeric_limits<difference_type>::max());}\n    void resize(size_type __n);\n    void resize(size_type __n, const value_type& __v);\n    void shrink_to_fit() _NOEXCEPT;\n    _LIBCPP_INLINE_VISIBILITY\n    bool empty() const _NOEXCEPT {return __base::size() == 0;}\n\n    // element access:\n    _LIBCPP_INLINE_VISIBILITY\n    reference operator[](size_type __i);\n    _LIBCPP_INLINE_VISIBILITY\n    const_reference operator[](size_type __i) const;\n    _LIBCPP_INLINE_VISIBILITY\n    reference at(size_type __i);\n    _LIBCPP_INLINE_VISIBILITY\n    const_reference at(size_type __i) const;\n    _LIBCPP_INLINE_VISIBILITY\n    reference front();\n    _LIBCPP_INLINE_VISIBILITY\n    const_reference front() const;\n    _LIBCPP_INLINE_VISIBILITY\n    reference back();\n    _LIBCPP_INLINE_VISIBILITY\n    const_reference back() const;\n\n    // 23.2.2.3 modifiers:\n    void push_front(const value_type& __v);\n    void push_back(const value_type& __v);\n#ifndef _LIBCPP_HAS_NO_RVALUE_REFERENCES\n#ifndef _LIBCPP_HAS_NO_VARIADICS\n#if _LIBCPP_STD_VER > 14\n    template <class... _Args> reference emplace_front(_Args&&... __args);\n    template <class... _Args> reference emplace_back (_Args&&... __args);\n#else\n    template <class... _Args> void      emplace_front(_Args&&... __args);\n    template <class... _Args> void      emplace_back (_Args&&... __args);\n#endif\n    template <class... _Args> iterator emplace(const_iterator __p, _Args&&... __args);\n#endif  // _LIBCPP_HAS_NO_VARIADICS\n    void push_front(value_type&& __v);\n    void push_back(value_type&& __v);\n    iterator insert(const_iterator __p, value_type&& __v);\n#endif  // _LIBCPP_HAS_NO_RVALUE_REFERENCES\n    iterator insert(const_iterator __p, const value_type& __v);\n    iterator insert(const_iterator __p, size_type __n, const value_type& __v);\n    template <class _InputIter>\n        iterator insert(const_iterator __p, _InputIter __f, _InputIter __l,\n                         typename enable_if<__is_input_iterator<_InputIter>::value\n                                         &&!__is_forward_iterator<_InputIter>::value>::type* = 0);\n    template <class _ForwardIterator>\n        iterator insert(const_iterator __p, _ForwardIterator __f, _ForwardIterator __l,\n                               typename enable_if<__is_forward_iterator<_ForwardIterator>::value\n                                         &&!__is_bidirectional_iterator<_ForwardIterator>::value>::type* = 0);\n    template <class _BiIter>\n        iterator insert(const_iterator __p, _BiIter __f, _BiIter __l,\n                         typename enable_if<__is_bidirectional_iterator<_BiIter>::value>::type* = 0);\n#ifndef _LIBCPP_HAS_NO_GENERALIZED_INITIALIZERS\n    _LIBCPP_INLINE_VISIBILITY\n    iterator insert(const_iterator __p, initializer_list<value_type> __il)\n        {return insert(__p, __il.begin(), __il.end());}\n#endif  // _LIBCPP_HAS_NO_GENERALIZED_INITIALIZERS\n    void pop_front();\n    void pop_back();\n    iterator erase(const_iterator __p);\n    iterator erase(const_iterator __f, const_iterator __l);\n\n    _LIBCPP_INLINE_VISIBILITY\n    void swap(deque& __c)\n#if _LIBCPP_STD_VER >= 14\n        _NOEXCEPT;\n#else\n        _NOEXCEPT_(!__alloc_traits::propagate_on_container_swap::value ||\n                   __is_nothrow_swappable<allocator_type>::value);\n#endif\n    _LIBCPP_INLINE_VISIBILITY\n    void clear() _NOEXCEPT;\n\n    _LIBCPP_INLINE_VISIBILITY\n    bool __invariants() const {return __base::__invariants();}\nprivate:\n    typedef typename __base::__map_const_pointer __map_const_pointer;\n\n    _LIBCPP_INLINE_VISIBILITY\n    static size_type __recommend_blocks(size_type __n)\n    {\n        return __n / __base::__block_size + (__n % __base::__block_size != 0);\n    }\n    _LIBCPP_INLINE_VISIBILITY\n    size_type __capacity() const\n    {\n        return __base::__map_.size() == 0 ? 0 : __base::__map_.size() * __base::__block_size - 1;\n    }\n    _LIBCPP_INLINE_VISIBILITY\n    size_type __front_spare() const\n    {\n        return __base::__start_;\n    }\n    _LIBCPP_INLINE_VISIBILITY\n    size_type __back_spare() const\n    {\n        return __capacity() - (__base::__start_ + __base::size());\n    }\n\n    template <class _InpIter>\n        void __append(_InpIter __f, _InpIter __l,\n                 typename enable_if<__is_input_iterator<_InpIter>::value &&\n                                   !__is_forward_iterator<_InpIter>::value>::type* = 0);\n    template <class _ForIter>\n        void __append(_ForIter __f, _ForIter __l,\n                      typename enable_if<__is_forward_iterator<_ForIter>::value>::type* = 0);\n    void __append(size_type __n);\n    void __append(size_type __n, const value_type& __v);\n    void __erase_to_end(const_iterator __f);\n    void __add_front_capacity();\n    void __add_front_capacity(size_type __n);\n    void __add_back_capacity();\n    void __add_back_capacity(size_type __n);\n    iterator __move_and_check(iterator __f, iterator __l, iterator __r,\n                              const_pointer& __vt);\n    iterator __move_backward_and_check(iterator __f, iterator __l, iterator __r,\n                                       const_pointer& __vt);\n    void __move_construct_and_check(iterator __f, iterator __l,\n                                    iterator __r, const_pointer& __vt);\n    void __move_construct_backward_and_check(iterator __f, iterator __l,\n                                             iterator __r, const_pointer& __vt);\n\n    _LIBCPP_INLINE_VISIBILITY\n    void __copy_assign_alloc(const deque& __c)\n        {__copy_assign_alloc(__c, integral_constant<bool,\n                      __alloc_traits::propagate_on_container_copy_assignment::value>());}\n\n    _LIBCPP_INLINE_VISIBILITY\n    void __copy_assign_alloc(const deque& __c, true_type)\n        {\n            if (__base::__alloc() != __c.__alloc())\n            {\n                clear();\n                shrink_to_fit();\n            }\n            __base::__alloc() = __c.__alloc();\n            __base::__map_.__alloc() = __c.__map_.__alloc();\n        }\n\n    _LIBCPP_INLINE_VISIBILITY\n    void __copy_assign_alloc(const deque&, false_type)\n        {}\n\n    void __move_assign(deque& __c, true_type)\n        _NOEXCEPT_(is_nothrow_move_assignable<allocator_type>::value);\n    void __move_assign(deque& __c, false_type);\n};\n\ntemplate <class _Tp, class _Allocator>\ndeque<_Tp, _Allocator>::deque(size_type __n)\n{\n    if (__n > 0)\n        __append(__n);\n}\n\n#if _LIBCPP_STD_VER > 11\ntemplate <class _Tp, class _Allocator>\ndeque<_Tp, _Allocator>::deque(size_type __n, const _Allocator& __a)\n    : __base(__a)\n{\n    if (__n > 0)\n        __append(__n);\n}\n#endif\n\ntemplate <class _Tp, class _Allocator>\ndeque<_Tp, _Allocator>::deque(size_type __n, const value_type& __v)\n{\n    if (__n > 0)\n        __append(__n, __v);\n}\n\ntemplate <class _Tp, class _Allocator>\ndeque<_Tp, _Allocator>::deque(size_type __n, const value_type& __v, const allocator_type& __a)\n    : __base(__a)\n{\n    if (__n > 0)\n        __append(__n, __v);\n}\n\ntemplate <class _Tp, class _Allocator>\ntemplate <class _InputIter>\ndeque<_Tp, _Allocator>::deque(_InputIter __f, _InputIter __l,\n              typename enable_if<__is_input_iterator<_InputIter>::value>::type*)\n{\n    __append(__f, __l);\n}\n\ntemplate <class _Tp, class _Allocator>\ntemplate <class _InputIter>\ndeque<_Tp, _Allocator>::deque(_InputIter __f, _InputIter __l, const allocator_type& __a,\n              typename enable_if<__is_input_iterator<_InputIter>::value>::type*)\n    : __base(__a)\n{\n    __append(__f, __l);\n}\n\ntemplate <class _Tp, class _Allocator>\ndeque<_Tp, _Allocator>::deque(const deque& __c)\n    : __base(__alloc_traits::select_on_container_copy_construction(__c.__alloc()))\n{\n    __append(__c.begin(), __c.end());\n}\n\ntemplate <class _Tp, class _Allocator>\ndeque<_Tp, _Allocator>::deque(const deque& __c, const allocator_type& __a)\n    : __base(__a)\n{\n    __append(__c.begin(), __c.end());\n}\n\n#ifndef _LIBCPP_HAS_NO_GENERALIZED_INITIALIZERS\n\ntemplate <class _Tp, class _Allocator>\ndeque<_Tp, _Allocator>::deque(initializer_list<value_type> __il)\n{\n    __append(__il.begin(), __il.end());\n}\n\ntemplate <class _Tp, class _Allocator>\ndeque<_Tp, _Allocator>::deque(initializer_list<value_type> __il, const allocator_type& __a)\n    : __base(__a)\n{\n    __append(__il.begin(), __il.end());\n}\n\n#endif  // _LIBCPP_HAS_NO_GENERALIZED_INITIALIZERS\n\ntemplate <class _Tp, class _Allocator>\ndeque<_Tp, _Allocator>&\ndeque<_Tp, _Allocator>::operator=(const deque& __c)\n{\n    if (this != &__c)\n    {\n        __copy_assign_alloc(__c);\n        assign(__c.begin(), __c.end());\n    }\n    return *this;\n}\n\n#ifndef _LIBCPP_HAS_NO_RVALUE_REFERENCES\n\ntemplate <class _Tp, class _Allocator>\ninline\ndeque<_Tp, _Allocator>::deque(deque&& __c)\n    _NOEXCEPT_(is_nothrow_move_constructible<__base>::value)\n    : __base(_VSTD::move(__c))\n{\n}\n\ntemplate <class _Tp, class _Allocator>\ninline\ndeque<_Tp, _Allocator>::deque(deque&& __c, const allocator_type& __a)\n    : __base(_VSTD::move(__c), __a)\n{\n    if (__a != __c.__alloc())\n    {\n        typedef move_iterator<iterator> _Ip;\n        assign(_Ip(__c.begin()), _Ip(__c.end()));\n    }\n}\n\ntemplate <class _Tp, class _Allocator>\ninline\ndeque<_Tp, _Allocator>&\ndeque<_Tp, _Allocator>::operator=(deque&& __c)\n        _NOEXCEPT_(__alloc_traits::propagate_on_container_move_assignment::value &&\n                   is_nothrow_move_assignable<allocator_type>::value)\n{\n    __move_assign(__c, integral_constant<bool,\n          __alloc_traits::propagate_on_container_move_assignment::value>());\n    return *this;\n}\n\ntemplate <class _Tp, class _Allocator>\nvoid\ndeque<_Tp, _Allocator>::__move_assign(deque& __c, false_type)\n{\n    if (__base::__alloc() != __c.__alloc())\n    {\n        typedef move_iterator<iterator> _Ip;\n        assign(_Ip(__c.begin()), _Ip(__c.end()));\n    }\n    else\n        __move_assign(__c, true_type());\n}\n\ntemplate <class _Tp, class _Allocator>\nvoid\ndeque<_Tp, _Allocator>::__move_assign(deque& __c, true_type)\n    _NOEXCEPT_(is_nothrow_move_assignable<allocator_type>::value)\n{\n    clear();\n    shrink_to_fit();\n    __base::__move_assign(__c);\n}\n\n#endif  // _LIBCPP_HAS_NO_RVALUE_REFERENCES\n\ntemplate <class _Tp, class _Allocator>\ntemplate <class _InputIter>\nvoid\ndeque<_Tp, _Allocator>::assign(_InputIter __f, _InputIter __l,\n                               typename enable_if<__is_input_iterator<_InputIter>::value &&\n                                                 !__is_random_access_iterator<_InputIter>::value>::type*)\n{\n    iterator __i = __base::begin();\n    iterator __e = __base::end();\n    for (; __f != __l && __i != __e; ++__f, (void) ++__i)\n        *__i = *__f;\n    if (__f != __l)\n        __append(__f, __l);\n    else\n        __erase_to_end(__i);\n}\n\ntemplate <class _Tp, class _Allocator>\ntemplate <class _RAIter>\nvoid\ndeque<_Tp, _Allocator>::assign(_RAIter __f, _RAIter __l,\n                               typename enable_if<__is_random_access_iterator<_RAIter>::value>::type*)\n{\n    if (static_cast<size_type>(__l - __f) > __base::size())\n    {\n        _RAIter __m = __f + __base::size();\n        _VSTD::copy(__f, __m, __base::begin());\n        __append(__m, __l);\n    }\n    else\n        __erase_to_end(_VSTD::copy(__f, __l, __base::begin()));\n}\n\ntemplate <class _Tp, class _Allocator>\nvoid\ndeque<_Tp, _Allocator>::assign(size_type __n, const value_type& __v)\n{\n    if (__n > __base::size())\n    {\n        _VSTD::fill_n(__base::begin(), __base::size(), __v);\n        __n -= __base::size();\n        __append(__n, __v);\n    }\n    else\n        __erase_to_end(_VSTD::fill_n(__base::begin(), __n, __v));\n}\n\ntemplate <class _Tp, class _Allocator>\ninline\n_Allocator\ndeque<_Tp, _Allocator>::get_allocator() const _NOEXCEPT\n{\n    return __base::__alloc();\n}\n\ntemplate <class _Tp, class _Allocator>\nvoid\ndeque<_Tp, _Allocator>::resize(size_type __n)\n{\n    if (__n > __base::size())\n        __append(__n - __base::size());\n    else if (__n < __base::size())\n        __erase_to_end(__base::begin() + __n);\n}\n\ntemplate <class _Tp, class _Allocator>\nvoid\ndeque<_Tp, _Allocator>::resize(size_type __n, const value_type& __v)\n{\n    if (__n > __base::size())\n        __append(__n - __base::size(), __v);\n    else if (__n < __base::size())\n        __erase_to_end(__base::begin() + __n);\n}\n\ntemplate <class _Tp, class _Allocator>\nvoid\ndeque<_Tp, _Allocator>::shrink_to_fit() _NOEXCEPT\n{\n    allocator_type& __a = __base::__alloc();\n    if (empty())\n    {\n        while (__base::__map_.size() > 0)\n        {\n            __alloc_traits::deallocate(__a, __base::__map_.back(), __base::__block_size);\n            __base::__map_.pop_back();\n        }\n        __base::__start_ = 0;\n    }\n    else\n    {\n        if (__front_spare() >= __base::__block_size)\n        {\n            __alloc_traits::deallocate(__a, __base::__map_.front(), __base::__block_size);\n            __base::__map_.pop_front();\n            __base::__start_ -= __base::__block_size;\n        }\n        if (__back_spare() >= __base::__block_size)\n        {\n            __alloc_traits::deallocate(__a, __base::__map_.back(), __base::__block_size);\n            __base::__map_.pop_back();\n        }\n    }\n    __base::__map_.shrink_to_fit();\n}\n\ntemplate <class _Tp, class _Allocator>\ninline\ntypename deque<_Tp, _Allocator>::reference\ndeque<_Tp, _Allocator>::operator[](size_type __i)\n{\n    size_type __p = __base::__start_ + __i;\n    return *(*(__base::__map_.begin() + __p / __base::__block_size) + __p % __base::__block_size);\n}\n\ntemplate <class _Tp, class _Allocator>\ninline\ntypename deque<_Tp, _Allocator>::const_reference\ndeque<_Tp, _Allocator>::operator[](size_type __i) const\n{\n    size_type __p = __base::__start_ + __i;\n    return *(*(__base::__map_.begin() + __p / __base::__block_size) + __p % __base::__block_size);\n}\n\ntemplate <class _Tp, class _Allocator>\ninline\ntypename deque<_Tp, _Allocator>::reference\ndeque<_Tp, _Allocator>::at(size_type __i)\n{\n    if (__i >= __base::size())\n        __base::__throw_out_of_range();\n    size_type __p = __base::__start_ + __i;\n    return *(*(__base::__map_.begin() + __p / __base::__block_size) + __p % __base::__block_size);\n}\n\ntemplate <class _Tp, class _Allocator>\ninline\ntypename deque<_Tp, _Allocator>::const_reference\ndeque<_Tp, _Allocator>::at(size_type __i) const\n{\n    if (__i >= __base::size())\n        __base::__throw_out_of_range();\n    size_type __p = __base::__start_ + __i;\n    return *(*(__base::__map_.begin() + __p / __base::__block_size) + __p % __base::__block_size);\n}\n\ntemplate <class _Tp, class _Allocator>\ninline\ntypename deque<_Tp, _Allocator>::reference\ndeque<_Tp, _Allocator>::front()\n{\n    return *(*(__base::__map_.begin() + __base::__start_ / __base::__block_size)\n                                      + __base::__start_ % __base::__block_size);\n}\n\ntemplate <class _Tp, class _Allocator>\ninline\ntypename deque<_Tp, _Allocator>::const_reference\ndeque<_Tp, _Allocator>::front() const\n{\n    return *(*(__base::__map_.begin() + __base::__start_ / __base::__block_size)\n                                      + __base::__start_ % __base::__block_size);\n}\n\ntemplate <class _Tp, class _Allocator>\ninline\ntypename deque<_Tp, _Allocator>::reference\ndeque<_Tp, _Allocator>::back()\n{\n    size_type __p = __base::size() + __base::__start_ - 1;\n    return *(*(__base::__map_.begin() + __p / __base::__block_size) + __p % __base::__block_size);\n}\n\ntemplate <class _Tp, class _Allocator>\ninline\ntypename deque<_Tp, _Allocator>::const_reference\ndeque<_Tp, _Allocator>::back() const\n{\n    size_type __p = __base::size() + __base::__start_ - 1;\n    return *(*(__base::__map_.begin() + __p / __base::__block_size) + __p % __base::__block_size);\n}\n\ntemplate <class _Tp, class _Allocator>\nvoid\ndeque<_Tp, _Allocator>::push_back(const value_type& __v)\n{\n    allocator_type& __a = __base::__alloc();\n    if (__back_spare() == 0)\n        __add_back_capacity();\n    // __back_spare() >= 1\n    __alloc_traits::construct(__a, _VSTD::addressof(*__base::end()), __v);\n    ++__base::size();\n}\n\n#ifndef _LIBCPP_HAS_NO_RVALUE_REFERENCES\n\ntemplate <class _Tp, class _Allocator>\nvoid\ndeque<_Tp, _Allocator>::push_back(value_type&& __v)\n{\n    allocator_type& __a = __base::__alloc();\n    if (__back_spare() == 0)\n        __add_back_capacity();\n    // __back_spare() >= 1\n    __alloc_traits::construct(__a, _VSTD::addressof(*__base::end()), _VSTD::move(__v));\n    ++__base::size();\n}\n\n#ifndef _LIBCPP_HAS_NO_VARIADICS\n\ntemplate <class _Tp, class _Allocator>\ntemplate <class... _Args>\n#if _LIBCPP_STD_VER > 14\ntypename deque<_Tp, _Allocator>::reference\n#else\nvoid\n#endif\ndeque<_Tp, _Allocator>::emplace_back(_Args&&... __args)\n{\n    allocator_type& __a = __base::__alloc();\n    if (__back_spare() == 0)\n        __add_back_capacity();\n    // __back_spare() >= 1\n    __alloc_traits::construct(__a, _VSTD::addressof(*__base::end()),\n                              _VSTD::forward<_Args>(__args)...);\n    ++__base::size();\n#if _LIBCPP_STD_VER > 14\n    return *--__base::end();\n#endif\n}\n\n#endif  // _LIBCPP_HAS_NO_VARIADICS\n#endif  // _LIBCPP_HAS_NO_RVALUE_REFERENCES\n\ntemplate <class _Tp, class _Allocator>\nvoid\ndeque<_Tp, _Allocator>::push_front(const value_type& __v)\n{\n    allocator_type& __a = __base::__alloc();\n    if (__front_spare() == 0)\n        __add_front_capacity();\n    // __front_spare() >= 1\n    __alloc_traits::construct(__a, _VSTD::addressof(*--__base::begin()), __v);\n    --__base::__start_;\n    ++__base::size();\n}\n\n#ifndef _LIBCPP_HAS_NO_RVALUE_REFERENCES\n\ntemplate <class _Tp, class _Allocator>\nvoid\ndeque<_Tp, _Allocator>::push_front(value_type&& __v)\n{\n    allocator_type& __a = __base::__alloc();\n    if (__front_spare() == 0)\n        __add_front_capacity();\n    // __front_spare() >= 1\n    __alloc_traits::construct(__a, _VSTD::addressof(*--__base::begin()), _VSTD::move(__v));\n    --__base::__start_;\n    ++__base::size();\n}\n\n#ifndef _LIBCPP_HAS_NO_VARIADICS\n\ntemplate <class _Tp, class _Allocator>\ntemplate <class... _Args>\n#if _LIBCPP_STD_VER > 14\ntypename deque<_Tp, _Allocator>::reference\n#else\nvoid\n#endif\ndeque<_Tp, _Allocator>::emplace_front(_Args&&... __args)\n{\n    allocator_type& __a = __base::__alloc();\n    if (__front_spare() == 0)\n        __add_front_capacity();\n    // __front_spare() >= 1\n    __alloc_traits::construct(__a, _VSTD::addressof(*--__base::begin()), _VSTD::forward<_Args>(__args)...);\n    --__base::__start_;\n    ++__base::size();\n#if _LIBCPP_STD_VER > 14\n    return *__base::begin();\n#endif\n}\n\n#endif  // _LIBCPP_HAS_NO_VARIADICS\n#endif  // _LIBCPP_HAS_NO_RVALUE_REFERENCES\n\ntemplate <class _Tp, class _Allocator>\ntypename deque<_Tp, _Allocator>::iterator\ndeque<_Tp, _Allocator>::insert(const_iterator __p, const value_type& __v)\n{\n    size_type __pos = __p - __base::begin();\n    size_type __to_end = __base::size() - __pos;\n    allocator_type& __a = __base::__alloc();\n    if (__pos < __to_end)\n    {   // insert by shifting things backward\n        if (__front_spare() == 0)\n            __add_front_capacity();\n        // __front_spare() >= 1\n        if (__pos == 0)\n        {\n            __alloc_traits::construct(__a, _VSTD::addressof(*--__base::begin()), __v);\n            --__base::__start_;\n            ++__base::size();\n        }\n        else\n        {\n            const_pointer __vt = pointer_traits<const_pointer>::pointer_to(__v);\n            iterator __b = __base::begin();\n            iterator __bm1 = _VSTD::prev(__b);\n            if (__vt == pointer_traits<const_pointer>::pointer_to(*__b))\n                __vt = pointer_traits<const_pointer>::pointer_to(*__bm1);\n            __alloc_traits::construct(__a, _VSTD::addressof(*__bm1), _VSTD::move(*__b));\n            --__base::__start_;\n            ++__base::size();\n            if (__pos > 1)\n                __b = __move_and_check(_VSTD::next(__b), __b + __pos, __b, __vt);\n            *__b = *__vt;\n        }\n    }\n    else\n    {   // insert by shifting things forward\n        if (__back_spare() == 0)\n            __add_back_capacity();\n        // __back_capacity >= 1\n        size_type __de = __base::size() - __pos;\n        if (__de == 0)\n        {\n            __alloc_traits::construct(__a, _VSTD::addressof(*__base::end()), __v);\n            ++__base::size();\n        }\n        else\n        {\n            const_pointer __vt = pointer_traits<const_pointer>::pointer_to(__v);\n            iterator __e = __base::end();\n            iterator __em1 = _VSTD::prev(__e);\n            if (__vt == pointer_traits<const_pointer>::pointer_to(*__em1))\n                __vt = pointer_traits<const_pointer>::pointer_to(*__e);\n            __alloc_traits::construct(__a, _VSTD::addressof(*__e), _VSTD::move(*__em1));\n            ++__base::size();\n            if (__de > 1)\n                __e = __move_backward_and_check(__e - __de, __em1, __e, __vt);\n            *--__e = *__vt;\n        }\n    }\n    return __base::begin() + __pos;\n}\n\n#ifndef _LIBCPP_HAS_NO_RVALUE_REFERENCES\n\ntemplate <class _Tp, class _Allocator>\ntypename deque<_Tp, _Allocator>::iterator\ndeque<_Tp, _Allocator>::insert(const_iterator __p, value_type&& __v)\n{\n    size_type __pos = __p - __base::begin();\n    size_type __to_end = __base::size() - __pos;\n    allocator_type& __a = __base::__alloc();\n    if (__pos < __to_end)\n    {   // insert by shifting things backward\n        if (__front_spare() == 0)\n            __add_front_capacity();\n        // __front_spare() >= 1\n        if (__pos == 0)\n        {\n            __alloc_traits::construct(__a, _VSTD::addressof(*--__base::begin()), _VSTD::move(__v));\n            --__base::__start_;\n            ++__base::size();\n        }\n        else\n        {\n            iterator __b = __base::begin();\n            iterator __bm1 = _VSTD::prev(__b);\n            __alloc_traits::construct(__a, _VSTD::addressof(*__bm1), _VSTD::move(*__b));\n            --__base::__start_;\n            ++__base::size();\n            if (__pos > 1)\n                __b = _VSTD::move(_VSTD::next(__b), __b + __pos, __b);\n            *__b = _VSTD::move(__v);\n        }\n    }\n    else\n    {   // insert by shifting things forward\n        if (__back_spare() == 0)\n            __add_back_capacity();\n        // __back_capacity >= 1\n        size_type __de = __base::size() - __pos;\n        if (__de == 0)\n        {\n            __alloc_traits::construct(__a, _VSTD::addressof(*__base::end()), _VSTD::move(__v));\n            ++__base::size();\n        }\n        else\n        {\n            iterator __e = __base::end();\n            iterator __em1 = _VSTD::prev(__e);\n            __alloc_traits::construct(__a, _VSTD::addressof(*__e), _VSTD::move(*__em1));\n            ++__base::size();\n            if (__de > 1)\n                __e = _VSTD::move_backward(__e - __de, __em1, __e);\n            *--__e = _VSTD::move(__v);\n        }\n    }\n    return __base::begin() + __pos;\n}\n\n#ifndef _LIBCPP_HAS_NO_VARIADICS\n\ntemplate <class _Tp, class _Allocator>\ntemplate <class... _Args>\ntypename deque<_Tp, _Allocator>::iterator\ndeque<_Tp, _Allocator>::emplace(const_iterator __p, _Args&&... __args)\n{\n    size_type __pos = __p - __base::begin();\n    size_type __to_end = __base::size() - __pos;\n    allocator_type& __a = __base::__alloc();\n    if (__pos < __to_end)\n    {   // insert by shifting things backward\n        if (__front_spare() == 0)\n            __add_front_capacity();\n        // __front_spare() >= 1\n        if (__pos == 0)\n        {\n            __alloc_traits::construct(__a, _VSTD::addressof(*--__base::begin()), _VSTD::forward<_Args>(__args)...);\n            --__base::__start_;\n            ++__base::size();\n        }\n        else\n        {\n            __temp_value<value_type, _Allocator> __tmp(this->__alloc(), _VSTD::forward<_Args>(__args)...);\n            iterator __b = __base::begin();\n            iterator __bm1 = _VSTD::prev(__b);\n            __alloc_traits::construct(__a, _VSTD::addressof(*__bm1), _VSTD::move(*__b));\n            --__base::__start_;\n            ++__base::size();\n            if (__pos > 1)\n                __b = _VSTD::move(_VSTD::next(__b), __b + __pos, __b);\n            *__b = _VSTD::move(__tmp.get());\n        }\n    }\n    else\n    {   // insert by shifting things forward\n        if (__back_spare() == 0)\n            __add_back_capacity();\n        // __back_capacity >= 1\n        size_type __de = __base::size() - __pos;\n        if (__de == 0)\n        {\n            __alloc_traits::construct(__a, _VSTD::addressof(*__base::end()), _VSTD::forward<_Args>(__args)...);\n            ++__base::size();\n        }\n        else\n        {\n            __temp_value<value_type, _Allocator> __tmp(this->__alloc(), _VSTD::forward<_Args>(__args)...);\n            iterator __e = __base::end();\n            iterator __em1 = _VSTD::prev(__e);\n            __alloc_traits::construct(__a, _VSTD::addressof(*__e), _VSTD::move(*__em1));\n            ++__base::size();\n            if (__de > 1)\n                __e = _VSTD::move_backward(__e - __de, __em1, __e);\n            *--__e = _VSTD::move(__tmp.get());\n        }\n    }\n    return __base::begin() + __pos;\n}\n\n#endif  // _LIBCPP_HAS_NO_VARIADICS\n#endif  // _LIBCPP_HAS_NO_RVALUE_REFERENCES\n\ntemplate <class _Tp, class _Allocator>\ntypename deque<_Tp, _Allocator>::iterator\ndeque<_Tp, _Allocator>::insert(const_iterator __p, size_type __n, const value_type& __v)\n{\n    size_type __pos = __p - __base::begin();\n    size_type __to_end = __base::size() - __pos;\n    allocator_type& __a = __base::__alloc();\n    if (__pos < __to_end)\n    {   // insert by shifting things backward\n        if (__n > __front_spare())\n            __add_front_capacity(__n - __front_spare());\n        // __n <= __front_spare()\n        iterator __old_begin = __base::begin();\n        iterator __i = __old_begin;\n        if (__n > __pos)\n        {\n            for (size_type __m = __n - __pos; __m; --__m, --__base::__start_, ++__base::size())\n                __alloc_traits::construct(__a, _VSTD::addressof(*--__i), __v);\n            __n = __pos;\n        }\n        if (__n > 0)\n        {\n            const_pointer __vt = pointer_traits<const_pointer>::pointer_to(__v);\n            iterator __obn = __old_begin + __n;\n            __move_construct_backward_and_check(__old_begin, __obn, __i, __vt);\n            if (__n < __pos)\n                __old_begin = __move_and_check(__obn, __old_begin + __pos, __old_begin, __vt);\n            _VSTD::fill_n(__old_begin, __n, *__vt);\n        }\n    }\n    else\n    {   // insert by shifting things forward\n        size_type __back_capacity = __back_spare();\n        if (__n > __back_capacity)\n            __add_back_capacity(__n - __back_capacity);\n        // __n <= __back_capacity\n        iterator __old_end = __base::end();\n        iterator __i = __old_end;\n        size_type __de = __base::size() - __pos;\n        if (__n > __de)\n        {\n            for (size_type __m = __n - __de; __m; --__m, ++__i, ++__base::size())\n                __alloc_traits::construct(__a, _VSTD::addressof(*__i), __v);\n            __n = __de;\n        }\n        if (__n > 0)\n        {\n            const_pointer __vt = pointer_traits<const_pointer>::pointer_to(__v);\n            iterator __oen = __old_end - __n;\n            __move_construct_and_check(__oen, __old_end, __i, __vt);\n            if (__n < __de)\n                __old_end = __move_backward_and_check(__old_end - __de, __oen, __old_end, __vt);\n            _VSTD::fill_n(__old_end - __n, __n, *__vt);\n        }\n    }\n    return __base::begin() + __pos;\n}\n\ntemplate <class _Tp, class _Allocator>\ntemplate <class _InputIter>\ntypename deque<_Tp, _Allocator>::iterator\ndeque<_Tp, _Allocator>::insert(const_iterator __p, _InputIter __f, _InputIter __l,\n                               typename enable_if<__is_input_iterator<_InputIter>::value\n                                               &&!__is_forward_iterator<_InputIter>::value>::type*)\n{\n    __split_buffer<value_type, allocator_type&> __buf(__base::__alloc());\n    __buf.__construct_at_end(__f, __l);\n    typedef typename __split_buffer<value_type, allocator_type&>::iterator __bi;\n    return insert(__p, move_iterator<__bi>(__buf.begin()), move_iterator<__bi>(__buf.end()));\n}\n\ntemplate <class _Tp, class _Allocator>\ntemplate <class _ForwardIterator>\ntypename deque<_Tp, _Allocator>::iterator\ndeque<_Tp, _Allocator>::insert(const_iterator __p, _ForwardIterator __f, _ForwardIterator __l,\n                               typename enable_if<__is_forward_iterator<_ForwardIterator>::value\n                                               &&!__is_bidirectional_iterator<_ForwardIterator>::value>::type*)\n{\n    size_type __n = _VSTD::distance(__f, __l);\n    __split_buffer<value_type, allocator_type&> __buf(__n, 0, __base::__alloc());\n    __buf.__construct_at_end(__f, __l);\n    typedef typename __split_buffer<value_type, allocator_type&>::iterator __fwd;\n    return insert(__p, move_iterator<__fwd>(__buf.begin()), move_iterator<__fwd>(__buf.end()));\n}\n\ntemplate <class _Tp, class _Allocator>\ntemplate <class _BiIter>\ntypename deque<_Tp, _Allocator>::iterator\ndeque<_Tp, _Allocator>::insert(const_iterator __p, _BiIter __f, _BiIter __l,\n                               typename enable_if<__is_bidirectional_iterator<_BiIter>::value>::type*)\n{\n    size_type __n = _VSTD::distance(__f, __l);\n    size_type __pos = __p - __base::begin();\n    size_type __to_end = __base::size() - __pos;\n    allocator_type& __a = __base::__alloc();\n    if (__pos < __to_end)\n    {   // insert by shifting things backward\n        if (__n > __front_spare())\n            __add_front_capacity(__n - __front_spare());\n        // __n <= __front_spare()\n        iterator __old_begin = __base::begin();\n        iterator __i = __old_begin;\n        _BiIter __m = __f;\n        if (__n > __pos)\n        {\n            __m = __pos < __n / 2 ? _VSTD::prev(__l, __pos) : _VSTD::next(__f, __n - __pos);\n            for (_BiIter __j = __m; __j != __f; --__base::__start_, ++__base::size())\n                __alloc_traits::construct(__a, _VSTD::addressof(*--__i), *--__j);\n            __n = __pos;\n        }\n        if (__n > 0)\n        {\n            iterator __obn = __old_begin + __n;\n            for (iterator __j = __obn; __j != __old_begin;)\n            {\n                __alloc_traits::construct(__a, _VSTD::addressof(*--__i), _VSTD::move(*--__j));\n                --__base::__start_;\n                ++__base::size();\n            }\n            if (__n < __pos)\n                __old_begin = _VSTD::move(__obn, __old_begin + __pos, __old_begin);\n            _VSTD::copy(__m, __l, __old_begin);\n        }\n    }\n    else\n    {   // insert by shifting things forward\n        size_type __back_capacity = __back_spare();\n        if (__n > __back_capacity)\n            __add_back_capacity(__n - __back_capacity);\n        // __n <= __back_capacity\n        iterator __old_end = __base::end();\n        iterator __i = __old_end;\n        _BiIter __m = __l;\n        size_type __de = __base::size() - __pos;\n        if (__n > __de)\n        {\n            __m = __de < __n / 2 ? _VSTD::next(__f, __de) : _VSTD::prev(__l, __n - __de);\n            for (_BiIter __j = __m; __j != __l; ++__i, (void) ++__j, ++__base::size())\n                __alloc_traits::construct(__a, _VSTD::addressof(*__i), *__j);\n            __n = __de;\n        }\n        if (__n > 0)\n        {\n            iterator __oen = __old_end - __n;\n            for (iterator __j = __oen; __j != __old_end; ++__i, ++__j, ++__base::size())\n                __alloc_traits::construct(__a, _VSTD::addressof(*__i), _VSTD::move(*__j));\n            if (__n < __de)\n                __old_end = _VSTD::move_backward(__old_end - __de, __oen, __old_end);\n            _VSTD::copy_backward(__f, __m, __old_end);\n        }\n    }\n    return __base::begin() + __pos;\n}\n\ntemplate <class _Tp, class _Allocator>\ntemplate <class _InpIter>\nvoid\ndeque<_Tp, _Allocator>::__append(_InpIter __f, _InpIter __l,\n                                 typename enable_if<__is_input_iterator<_InpIter>::value &&\n                                                   !__is_forward_iterator<_InpIter>::value>::type*)\n{\n    for (; __f != __l; ++__f)\n        push_back(*__f);\n}\n\ntemplate <class _Tp, class _Allocator>\ntemplate <class _ForIter>\nvoid\ndeque<_Tp, _Allocator>::__append(_ForIter __f, _ForIter __l,\n                                 typename enable_if<__is_forward_iterator<_ForIter>::value>::type*)\n{\n    size_type __n = _VSTD::distance(__f, __l);\n    allocator_type& __a = __base::__alloc();\n    size_type __back_capacity = __back_spare();\n    if (__n > __back_capacity)\n        __add_back_capacity(__n - __back_capacity);\n    // __n <= __back_capacity\n    for (iterator __i = __base::end(); __f != __l; ++__i, (void) ++__f, ++__base::size())\n        __alloc_traits::construct(__a, _VSTD::addressof(*__i), *__f);\n}\n\ntemplate <class _Tp, class _Allocator>\nvoid\ndeque<_Tp, _Allocator>::__append(size_type __n)\n{\n    allocator_type& __a = __base::__alloc();\n    size_type __back_capacity = __back_spare();\n    if (__n > __back_capacity)\n        __add_back_capacity(__n - __back_capacity);\n    // __n <= __back_capacity\n    for (iterator __i = __base::end(); __n; --__n, ++__i, ++__base::size())\n        __alloc_traits::construct(__a, _VSTD::addressof(*__i));\n}\n\ntemplate <class _Tp, class _Allocator>\nvoid\ndeque<_Tp, _Allocator>::__append(size_type __n, const value_type& __v)\n{\n    allocator_type& __a = __base::__alloc();\n    size_type __back_capacity = __back_spare();\n    if (__n > __back_capacity)\n        __add_back_capacity(__n - __back_capacity);\n    // __n <= __back_capacity\n    for (iterator __i = __base::end(); __n; --__n, ++__i, ++__base::size())\n        __alloc_traits::construct(__a, _VSTD::addressof(*__i), __v);\n}\n\n// Create front capacity for one block of elements.\n// Strong guarantee.  Either do it or don't touch anything.\ntemplate <class _Tp, class _Allocator>\nvoid\ndeque<_Tp, _Allocator>::__add_front_capacity()\n{\n    allocator_type& __a = __base::__alloc();\n    if (__back_spare() >= __base::__block_size)\n    {\n        __base::__start_ += __base::__block_size;\n        pointer __pt = __base::__map_.back();\n        __base::__map_.pop_back();\n        __base::__map_.push_front(__pt);\n    }\n    // Else if __base::__map_.size() < __base::__map_.capacity() then we need to allocate 1 buffer\n    else if (__base::__map_.size() < __base::__map_.capacity())\n    {   // we can put the new buffer into the map, but don't shift things around\n        // until all buffers are allocated.  If we throw, we don't need to fix\n        // anything up (any added buffers are undetectible)\n        if (__base::__map_.__front_spare() > 0)\n            __base::__map_.push_front(__alloc_traits::allocate(__a, __base::__block_size));\n        else\n        {\n            __base::__map_.push_back(__alloc_traits::allocate(__a, __base::__block_size));\n            // Done allocating, reorder capacity\n            pointer __pt = __base::__map_.back();\n            __base::__map_.pop_back();\n            __base::__map_.push_front(__pt);\n        }\n        __base::__start_ = __base::__map_.size() == 1 ?\n                               __base::__block_size / 2 :\n                               __base::__start_ + __base::__block_size;\n    }\n    // Else need to allocate 1 buffer, *and* we need to reallocate __map_.\n    else\n    {\n        __split_buffer<pointer, typename __base::__pointer_allocator&>\n            __buf(max<size_type>(2 * __base::__map_.capacity(), 1),\n                  0, __base::__map_.__alloc());\n\n        typedef __allocator_destructor<_Allocator> _Dp;\n        unique_ptr<pointer, _Dp> __hold(\n            __alloc_traits::allocate(__a, __base::__block_size),\n                _Dp(__a, __base::__block_size));\n        __buf.push_back(__hold.get());\n        __hold.release();\n    \n        for (typename __base::__map_pointer __i = __base::__map_.begin();\n                __i != __base::__map_.end(); ++__i)\n            __buf.push_back(*__i);\n        _VSTD::swap(__base::__map_.__first_, __buf.__first_);\n        _VSTD::swap(__base::__map_.__begin_, __buf.__begin_);\n        _VSTD::swap(__base::__map_.__end_, __buf.__end_);\n        _VSTD::swap(__base::__map_.__end_cap(), __buf.__end_cap());\n        __base::__start_ = __base::__map_.size() == 1 ?\n                               __base::__block_size / 2 :\n                               __base::__start_ + __base::__block_size;\n    }\n}\n\n// Create front capacity for __n elements.\n// Strong guarantee.  Either do it or don't touch anything.\ntemplate <class _Tp, class _Allocator>\nvoid\ndeque<_Tp, _Allocator>::__add_front_capacity(size_type __n)\n{\n    allocator_type& __a = __base::__alloc();\n    size_type __nb = __recommend_blocks(__n + __base::__map_.empty());\n    // Number of unused blocks at back:\n    size_type __back_capacity = __back_spare() / __base::__block_size;\n    __back_capacity = _VSTD::min(__back_capacity, __nb);  // don't take more than you need\n    __nb -= __back_capacity;  // number of blocks need to allocate\n    // If __nb == 0, then we have sufficient capacity.\n    if (__nb == 0)\n    {\n        __base::__start_ += __base::__block_size * __back_capacity;\n        for (; __back_capacity > 0; --__back_capacity)\n        {\n            pointer __pt = __base::__map_.back();\n            __base::__map_.pop_back();\n            __base::__map_.push_front(__pt);\n        }\n    }\n    // Else if __nb <= __map_.capacity() - __map_.size() then we need to allocate __nb buffers\n    else if (__nb <= __base::__map_.capacity() - __base::__map_.size())\n    {   // we can put the new buffers into the map, but don't shift things around\n        // until all buffers are allocated.  If we throw, we don't need to fix\n        // anything up (any added buffers are undetectible)\n        for (; __nb > 0; --__nb, __base::__start_ += __base::__block_size - (__base::__map_.size() == 1))\n        {\n            if (__base::__map_.__front_spare() == 0)\n                break;\n            __base::__map_.push_front(__alloc_traits::allocate(__a, __base::__block_size));\n        }\n        for (; __nb > 0; --__nb, ++__back_capacity)\n            __base::__map_.push_back(__alloc_traits::allocate(__a, __base::__block_size));\n        // Done allocating, reorder capacity\n        __base::__start_ += __back_capacity * __base::__block_size;\n        for (; __back_capacity > 0; --__back_capacity)\n        {\n            pointer __pt = __base::__map_.back();\n            __base::__map_.pop_back();\n            __base::__map_.push_front(__pt);\n        }\n    }\n    // Else need to allocate __nb buffers, *and* we need to reallocate __map_.\n    else\n    {\n        size_type __ds = (__nb + __back_capacity) * __base::__block_size - __base::__map_.empty();\n        __split_buffer<pointer, typename __base::__pointer_allocator&>\n            __buf(max<size_type>(2* __base::__map_.capacity(),\n                                 __nb + __base::__map_.size()),\n                  0, __base::__map_.__alloc());\n#ifndef _LIBCPP_NO_EXCEPTIONS\n        try\n        {\n#endif  // _LIBCPP_NO_EXCEPTIONS\n            for (; __nb > 0; --__nb)\n                __buf.push_back(__alloc_traits::allocate(__a, __base::__block_size));\n#ifndef _LIBCPP_NO_EXCEPTIONS\n        }\n        catch (...)\n        {\n            for (typename __base::__map_pointer __i = __buf.begin();\n                    __i != __buf.end(); ++__i)\n                __alloc_traits::deallocate(__a, *__i, __base::__block_size);\n            throw;\n        }\n#endif  // _LIBCPP_NO_EXCEPTIONS\n        for (; __back_capacity > 0; --__back_capacity)\n        {\n            __buf.push_back(__base::__map_.back());\n            __base::__map_.pop_back();\n        }\n        for (typename __base::__map_pointer __i = __base::__map_.begin();\n                __i != __base::__map_.end(); ++__i)\n            __buf.push_back(*__i);\n        _VSTD::swap(__base::__map_.__first_, __buf.__first_);\n        _VSTD::swap(__base::__map_.__begin_, __buf.__begin_);\n        _VSTD::swap(__base::__map_.__end_, __buf.__end_);\n        _VSTD::swap(__base::__map_.__end_cap(), __buf.__end_cap());\n        __base::__start_ += __ds;\n    }\n}\n\n// Create back capacity for one block of elements.\n// Strong guarantee.  Either do it or don't touch anything.\ntemplate <class _Tp, class _Allocator>\nvoid\ndeque<_Tp, _Allocator>::__add_back_capacity()\n{\n    allocator_type& __a = __base::__alloc();\n    if (__front_spare() >= __base::__block_size)\n    {\n        __base::__start_ -= __base::__block_size;\n        pointer __pt = __base::__map_.front();\n        __base::__map_.pop_front();\n        __base::__map_.push_back(__pt);\n    }\n    // Else if __nb <= __map_.capacity() - __map_.size() then we need to allocate __nb buffers\n    else if (__base::__map_.size() < __base::__map_.capacity())\n    {   // we can put the new buffer into the map, but don't shift things around\n        // until it is allocated.  If we throw, we don't need to fix\n        // anything up (any added buffers are undetectible)\n        if (__base::__map_.__back_spare() != 0)\n            __base::__map_.push_back(__alloc_traits::allocate(__a, __base::__block_size));\n        else\n        {\n            __base::__map_.push_front(__alloc_traits::allocate(__a, __base::__block_size));\n            // Done allocating, reorder capacity\n            pointer __pt = __base::__map_.front();\n            __base::__map_.pop_front();\n            __base::__map_.push_back(__pt);\n        }\n    }\n    // Else need to allocate 1 buffer, *and* we need to reallocate __map_.\n    else\n    {\n        __split_buffer<pointer, typename __base::__pointer_allocator&>\n            __buf(max<size_type>(2* __base::__map_.capacity(), 1),\n                  __base::__map_.size(),\n                  __base::__map_.__alloc());\n\n        typedef __allocator_destructor<_Allocator> _Dp;\n        unique_ptr<pointer, _Dp> __hold(\n            __alloc_traits::allocate(__a, __base::__block_size),\n                _Dp(__a, __base::__block_size));\n        __buf.push_back(__hold.get());\n        __hold.release();\n\n        for (typename __base::__map_pointer __i = __base::__map_.end();\n                __i != __base::__map_.begin();)\n            __buf.push_front(*--__i);\n        _VSTD::swap(__base::__map_.__first_, __buf.__first_);\n        _VSTD::swap(__base::__map_.__begin_, __buf.__begin_);\n        _VSTD::swap(__base::__map_.__end_, __buf.__end_);\n        _VSTD::swap(__base::__map_.__end_cap(), __buf.__end_cap());\n    }\n}\n\n// Create back capacity for __n elements.\n// Strong guarantee.  Either do it or don't touch anything.\ntemplate <class _Tp, class _Allocator>\nvoid\ndeque<_Tp, _Allocator>::__add_back_capacity(size_type __n)\n{\n    allocator_type& __a = __base::__alloc();\n    size_type __nb = __recommend_blocks(__n + __base::__map_.empty());\n    // Number of unused blocks at front:\n    size_type __front_capacity = __front_spare() / __base::__block_size;\n    __front_capacity = _VSTD::min(__front_capacity, __nb);  // don't take more than you need\n    __nb -= __front_capacity;  // number of blocks need to allocate\n    // If __nb == 0, then we have sufficient capacity.\n    if (__nb == 0)\n    {\n        __base::__start_ -= __base::__block_size * __front_capacity;\n        for (; __front_capacity > 0; --__front_capacity)\n        {\n            pointer __pt = __base::__map_.front();\n            __base::__map_.pop_front();\n            __base::__map_.push_back(__pt);\n        }\n    }\n    // Else if __nb <= __map_.capacity() - __map_.size() then we need to allocate __nb buffers\n    else if (__nb <= __base::__map_.capacity() - __base::__map_.size())\n    {   // we can put the new buffers into the map, but don't shift things around\n        // until all buffers are allocated.  If we throw, we don't need to fix\n        // anything up (any added buffers are undetectible)\n        for (; __nb > 0; --__nb)\n        {\n            if (__base::__map_.__back_spare() == 0)\n                break;\n            __base::__map_.push_back(__alloc_traits::allocate(__a, __base::__block_size));\n        }\n        for (; __nb > 0; --__nb, ++__front_capacity, __base::__start_ +=\n                                 __base::__block_size - (__base::__map_.size() == 1))\n            __base::__map_.push_front(__alloc_traits::allocate(__a, __base::__block_size));\n        // Done allocating, reorder capacity\n        __base::__start_ -= __base::__block_size * __front_capacity;\n        for (; __front_capacity > 0; --__front_capacity)\n        {\n            pointer __pt = __base::__map_.front();\n            __base::__map_.pop_front();\n            __base::__map_.push_back(__pt);\n        }\n    }\n    // Else need to allocate __nb buffers, *and* we need to reallocate __map_.\n    else\n    {\n        size_type __ds = __front_capacity * __base::__block_size;\n        __split_buffer<pointer, typename __base::__pointer_allocator&>\n            __buf(max<size_type>(2* __base::__map_.capacity(),\n                                 __nb + __base::__map_.size()),\n                  __base::__map_.size() - __front_capacity,\n                  __base::__map_.__alloc());\n#ifndef _LIBCPP_NO_EXCEPTIONS\n        try\n        {\n#endif  // _LIBCPP_NO_EXCEPTIONS\n            for (; __nb > 0; --__nb)\n                __buf.push_back(__alloc_traits::allocate(__a, __base::__block_size));\n#ifndef _LIBCPP_NO_EXCEPTIONS\n        }\n        catch (...)\n        {\n            for (typename __base::__map_pointer __i = __buf.begin();\n                    __i != __buf.end(); ++__i)\n                __alloc_traits::deallocate(__a, *__i, __base::__block_size);\n            throw;\n        }\n#endif  // _LIBCPP_NO_EXCEPTIONS\n        for (; __front_capacity > 0; --__front_capacity)\n        {\n            __buf.push_back(__base::__map_.front());\n            __base::__map_.pop_front();\n        }\n        for (typename __base::__map_pointer __i = __base::__map_.end();\n                __i != __base::__map_.begin();)\n            __buf.push_front(*--__i);\n        _VSTD::swap(__base::__map_.__first_, __buf.__first_);\n        _VSTD::swap(__base::__map_.__begin_, __buf.__begin_);\n        _VSTD::swap(__base::__map_.__end_, __buf.__end_);\n        _VSTD::swap(__base::__map_.__end_cap(), __buf.__end_cap());\n        __base::__start_ -= __ds;\n    }\n}\n\ntemplate <class _Tp, class _Allocator>\nvoid\ndeque<_Tp, _Allocator>::pop_front()\n{\n    allocator_type& __a = __base::__alloc();\n    __alloc_traits::destroy(__a, __to_raw_pointer(*(__base::__map_.begin() +\n                                                    __base::__start_ / __base::__block_size) +\n                                                    __base::__start_ % __base::__block_size));\n    --__base::size();\n    if (++__base::__start_ >= 2 * __base::__block_size)\n    {\n        __alloc_traits::deallocate(__a, __base::__map_.front(), __base::__block_size);\n        __base::__map_.pop_front();\n        __base::__start_ -= __base::__block_size;\n    }\n}\n\ntemplate <class _Tp, class _Allocator>\nvoid\ndeque<_Tp, _Allocator>::pop_back()\n{\n    allocator_type& __a = __base::__alloc();\n    size_type __p = __base::size() + __base::__start_ - 1;\n    __alloc_traits::destroy(__a, __to_raw_pointer(*(__base::__map_.begin() +\n                                                    __p / __base::__block_size) +\n                                                    __p % __base::__block_size));\n    --__base::size();\n    if (__back_spare() >= 2 * __base::__block_size)\n    {\n        __alloc_traits::deallocate(__a, __base::__map_.back(), __base::__block_size);\n        __base::__map_.pop_back();\n    }\n}\n\n// move assign [__f, __l) to [__r, __r + (__l-__f)).\n// If __vt points into [__f, __l), then subtract (__f - __r) from __vt.\ntemplate <class _Tp, class _Allocator>\ntypename deque<_Tp, _Allocator>::iterator\ndeque<_Tp, _Allocator>::__move_and_check(iterator __f, iterator __l, iterator __r,\n                                         const_pointer& __vt)\n{\n    // as if\n    //   for (; __f != __l; ++__f, ++__r)\n    //       *__r = _VSTD::move(*__f);\n    difference_type __n = __l - __f;\n    while (__n > 0)\n    {\n        pointer __fb = __f.__ptr_;\n        pointer __fe = *__f.__m_iter_ + __base::__block_size;\n        difference_type __bs = __fe - __fb;\n        if (__bs > __n)\n        {\n            __bs = __n;\n            __fe = __fb + __bs;\n        }\n        if (__fb <= __vt && __vt < __fe)\n            __vt = (const_iterator(static_cast<__map_const_pointer>(__f.__m_iter_), __vt) -= __f - __r).__ptr_;\n        __r = _VSTD::move(__fb, __fe, __r);\n        __n -= __bs;\n        __f += __bs;\n    }\n    return __r;\n}\n\n// move assign [__f, __l) to [__r - (__l-__f), __r) backwards.\n// If __vt points into [__f, __l), then add (__r - __l) to __vt.\ntemplate <class _Tp, class _Allocator>\ntypename deque<_Tp, _Allocator>::iterator\ndeque<_Tp, _Allocator>::__move_backward_and_check(iterator __f, iterator __l, iterator __r,\n                                                  const_pointer& __vt)\n{\n    // as if\n    //   while (__f != __l)\n    //       *--__r = _VSTD::move(*--__l);\n    difference_type __n = __l - __f;\n    while (__n > 0)\n    {\n        --__l;\n        pointer __lb = *__l.__m_iter_;\n        pointer __le = __l.__ptr_ + 1;\n        difference_type __bs = __le - __lb;\n        if (__bs > __n)\n        {\n            __bs = __n;\n            __lb = __le - __bs;\n        }\n        if (__lb <= __vt && __vt < __le)\n            __vt = (const_iterator(static_cast<__map_const_pointer>(__l.__m_iter_), __vt) += __r - __l - 1).__ptr_;\n        __r = _VSTD::move_backward(__lb, __le, __r);\n        __n -= __bs;\n        __l -= __bs - 1;\n    }\n    return __r;\n}\n\n// move construct [__f, __l) to [__r, __r + (__l-__f)).\n// If __vt points into [__f, __l), then add (__r - __f) to __vt.\ntemplate <class _Tp, class _Allocator>\nvoid\ndeque<_Tp, _Allocator>::__move_construct_and_check(iterator __f, iterator __l,\n                                                   iterator __r, const_pointer& __vt)\n{\n    allocator_type& __a = __base::__alloc();\n    // as if\n    //   for (; __f != __l; ++__r, ++__f, ++__base::size())\n    //       __alloc_traits::construct(__a, _VSTD::addressof(*__r), _VSTD::move(*__f));\n    difference_type __n = __l - __f;\n    while (__n > 0)\n    {\n        pointer __fb = __f.__ptr_;\n        pointer __fe = *__f.__m_iter_ + __base::__block_size;\n        difference_type __bs = __fe - __fb;\n        if (__bs > __n)\n        {\n            __bs = __n;\n            __fe = __fb + __bs;\n        }\n        if (__fb <= __vt && __vt < __fe)\n            __vt = (const_iterator(static_cast<__map_const_pointer>(__f.__m_iter_), __vt) += __r - __f).__ptr_;\n        for (; __fb != __fe; ++__fb, ++__r, ++__base::size())\n            __alloc_traits::construct(__a, _VSTD::addressof(*__r), _VSTD::move(*__fb));\n        __n -= __bs;\n        __f += __bs;\n    }\n}\n\n// move construct [__f, __l) to [__r - (__l-__f), __r) backwards.\n// If __vt points into [__f, __l), then subtract (__l - __r) from __vt.\ntemplate <class _Tp, class _Allocator>\nvoid\ndeque<_Tp, _Allocator>::__move_construct_backward_and_check(iterator __f, iterator __l,\n                                                            iterator __r, const_pointer& __vt)\n{\n    allocator_type& __a = __base::__alloc();\n    // as if\n    //   for (iterator __j = __l; __j != __f;)\n    //   {\n    //       __alloc_traitsconstruct(__a, _VSTD::addressof(*--__r), _VSTD::move(*--__j));\n    //       --__base::__start_;\n    //       ++__base::size();\n    //   }\n    difference_type __n = __l - __f;\n    while (__n > 0)\n    {\n        --__l;\n        pointer __lb = *__l.__m_iter_;\n        pointer __le = __l.__ptr_ + 1;\n        difference_type __bs = __le - __lb;\n        if (__bs > __n)\n        {\n            __bs = __n;\n            __lb = __le - __bs;\n        }\n        if (__lb <= __vt && __vt < __le)\n            __vt = (const_iterator(static_cast<__map_const_pointer>(__l.__m_iter_), __vt) -= __l - __r + 1).__ptr_;\n        while (__le != __lb)\n        {\n            __alloc_traits::construct(__a, _VSTD::addressof(*--__r), _VSTD::move(*--__le));\n            --__base::__start_;\n            ++__base::size();\n        }\n        __n -= __bs;\n        __l -= __bs - 1;\n    }\n}\n\ntemplate <class _Tp, class _Allocator>\ntypename deque<_Tp, _Allocator>::iterator\ndeque<_Tp, _Allocator>::erase(const_iterator __f)\n{\n    iterator __b = __base::begin();\n    difference_type __pos = __f - __b;\n    iterator __p = __b + __pos;\n    allocator_type& __a = __base::__alloc();\n    if (static_cast<size_t>(__pos) <= (__base::size() - 1) / 2)\n    {   // erase from front\n        _VSTD::move_backward(__b, __p, _VSTD::next(__p));\n        __alloc_traits::destroy(__a, _VSTD::addressof(*__b));\n        --__base::size();\n        ++__base::__start_;\n        if (__front_spare() >= 2 * __base::__block_size)\n        {\n            __alloc_traits::deallocate(__a, __base::__map_.front(), __base::__block_size);\n            __base::__map_.pop_front();\n            __base::__start_ -= __base::__block_size;\n        }\n    }\n    else\n    {   // erase from back\n        iterator __i = _VSTD::move(_VSTD::next(__p), __base::end(), __p);\n        __alloc_traits::destroy(__a, _VSTD::addressof(*__i));\n        --__base::size();\n        if (__back_spare() >= 2 * __base::__block_size)\n        {\n            __alloc_traits::deallocate(__a, __base::__map_.back(), __base::__block_size);\n            __base::__map_.pop_back();\n        }\n    }\n    return __base::begin() + __pos;\n}\n\ntemplate <class _Tp, class _Allocator>\ntypename deque<_Tp, _Allocator>::iterator\ndeque<_Tp, _Allocator>::erase(const_iterator __f, const_iterator __l)\n{\n    difference_type __n = __l - __f;\n    iterator __b = __base::begin();\n    difference_type __pos = __f - __b;\n    iterator __p = __b + __pos;\n    if (__n > 0)\n    {\n        allocator_type& __a = __base::__alloc();\n        if (static_cast<size_t>(__pos) <= (__base::size() - __n) / 2)\n        {   // erase from front\n            iterator __i = _VSTD::move_backward(__b, __p, __p + __n);\n            for (; __b != __i; ++__b)\n                __alloc_traits::destroy(__a, _VSTD::addressof(*__b));\n            __base::size() -= __n;\n            __base::__start_ += __n;\n            while (__front_spare() >= 2 * __base::__block_size)\n            {\n                __alloc_traits::deallocate(__a, __base::__map_.front(), __base::__block_size);\n                __base::__map_.pop_front();\n                __base::__start_ -= __base::__block_size;\n            }\n        }\n        else\n        {   // erase from back\n            iterator __i = _VSTD::move(__p + __n, __base::end(), __p);\n            for (iterator __e = __base::end(); __i != __e; ++__i)\n                __alloc_traits::destroy(__a, _VSTD::addressof(*__i));\n            __base::size() -= __n;\n            while (__back_spare() >= 2 * __base::__block_size)\n            {\n                __alloc_traits::deallocate(__a, __base::__map_.back(), __base::__block_size);\n                __base::__map_.pop_back();\n            }\n        }\n    }\n    return __base::begin() + __pos;\n}\n\ntemplate <class _Tp, class _Allocator>\nvoid\ndeque<_Tp, _Allocator>::__erase_to_end(const_iterator __f)\n{\n    iterator __e = __base::end();\n    difference_type __n = __e - __f;\n    if (__n > 0)\n    {\n        allocator_type& __a = __base::__alloc();\n        iterator __b = __base::begin();\n        difference_type __pos = __f - __b;\n        for (iterator __p = __b + __pos; __p != __e; ++__p)\n            __alloc_traits::destroy(__a, _VSTD::addressof(*__p));\n        __base::size() -= __n;\n        while (__back_spare() >= 2 * __base::__block_size)\n        {\n            __alloc_traits::deallocate(__a, __base::__map_.back(), __base::__block_size);\n            __base::__map_.pop_back();\n        }\n    }\n}\n\ntemplate <class _Tp, class _Allocator>\ninline\nvoid\ndeque<_Tp, _Allocator>::swap(deque& __c)\n#if _LIBCPP_STD_VER >= 14\n        _NOEXCEPT\n#else\n        _NOEXCEPT_(!__alloc_traits::propagate_on_container_swap::value || \n                    __is_nothrow_swappable<allocator_type>::value)\n#endif\n{\n    __base::swap(__c);\n}\n\ntemplate <class _Tp, class _Allocator>\ninline\nvoid\ndeque<_Tp, _Allocator>::clear() _NOEXCEPT\n{\n    __base::clear();\n}\n\ntemplate <class _Tp, class _Allocator>\ninline _LIBCPP_INLINE_VISIBILITY\nbool\noperator==(const deque<_Tp, _Allocator>& __x, const deque<_Tp, _Allocator>& __y)\n{\n    const typename deque<_Tp, _Allocator>::size_type __sz = __x.size();\n    return __sz == __y.size() && _VSTD::equal(__x.begin(), __x.end(), __y.begin());\n}\n\ntemplate <class _Tp, class _Allocator>\ninline _LIBCPP_INLINE_VISIBILITY\nbool\noperator!=(const deque<_Tp, _Allocator>& __x, const deque<_Tp, _Allocator>& __y)\n{\n    return !(__x == __y);\n}\n\ntemplate <class _Tp, class _Allocator>\ninline _LIBCPP_INLINE_VISIBILITY\nbool\noperator< (const deque<_Tp, _Allocator>& __x, const deque<_Tp, _Allocator>& __y)\n{\n    return _VSTD::lexicographical_compare(__x.begin(), __x.end(), __y.begin(), __y.end());\n}\n\ntemplate <class _Tp, class _Allocator>\ninline _LIBCPP_INLINE_VISIBILITY\nbool\noperator> (const deque<_Tp, _Allocator>& __x, const deque<_Tp, _Allocator>& __y)\n{\n    return __y < __x;\n}\n\ntemplate <class _Tp, class _Allocator>\ninline _LIBCPP_INLINE_VISIBILITY\nbool\noperator>=(const deque<_Tp, _Allocator>& __x, const deque<_Tp, _Allocator>& __y)\n{\n    return !(__x < __y);\n}\n\ntemplate <class _Tp, class _Allocator>\ninline _LIBCPP_INLINE_VISIBILITY\nbool\noperator<=(const deque<_Tp, _Allocator>& __x, const deque<_Tp, _Allocator>& __y)\n{\n    return !(__y < __x);\n}\n\ntemplate <class _Tp, class _Allocator>\ninline _LIBCPP_INLINE_VISIBILITY\nvoid\nswap(deque<_Tp, _Allocator>& __x, deque<_Tp, _Allocator>& __y)\n    _NOEXCEPT_(_NOEXCEPT_(__x.swap(__y)))\n{\n    __x.swap(__y);\n}\n\n_LIBCPP_END_NAMESPACE_STD\n\n#endif  // _LIBCPP_DEQUE\n","// -*- C++ -*-\n//===-------------------------- algorithm ---------------------------------===//\n//\n//                     The LLVM Compiler Infrastructure\n//\n// This file is dual licensed under the MIT and the University of Illinois Open\n// Source Licenses. See LICENSE.TXT for details.\n//\n//===----------------------------------------------------------------------===//\n\n#ifndef _LIBCPP_ALGORITHM\n#define _LIBCPP_ALGORITHM\n\n/*\n    algorithm synopsis\n\n#include <initializer_list>\n\nnamespace std\n{\n\ntemplate <class InputIterator, class Predicate>\n    bool\n    all_of(InputIterator first, InputIterator last, Predicate pred);\n\ntemplate <class InputIterator, class Predicate>\n    bool\n    any_of(InputIterator first, InputIterator last, Predicate pred);\n\ntemplate <class InputIterator, class Predicate>\n    bool\n    none_of(InputIterator first, InputIterator last, Predicate pred);\n\ntemplate <class InputIterator, class Function>\n    Function\n    for_each(InputIterator first, InputIterator last, Function f);\n\ntemplate <class InputIterator, class T>\n    InputIterator\n    find(InputIterator first, InputIterator last, const T& value);\n\ntemplate <class InputIterator, class Predicate>\n    InputIterator\n    find_if(InputIterator first, InputIterator last, Predicate pred);\n\ntemplate<class InputIterator, class Predicate>\n    InputIterator\n    find_if_not(InputIterator first, InputIterator last, Predicate pred);\n\ntemplate <class ForwardIterator1, class ForwardIterator2>\n    ForwardIterator1\n    find_end(ForwardIterator1 first1, ForwardIterator1 last1,\n             ForwardIterator2 first2, ForwardIterator2 last2);\n\ntemplate <class ForwardIterator1, class ForwardIterator2, class BinaryPredicate>\n    ForwardIterator1\n    find_end(ForwardIterator1 first1, ForwardIterator1 last1,\n             ForwardIterator2 first2, ForwardIterator2 last2, BinaryPredicate pred);\n\ntemplate <class ForwardIterator1, class ForwardIterator2>\n    ForwardIterator1\n    find_first_of(ForwardIterator1 first1, ForwardIterator1 last1,\n                  ForwardIterator2 first2, ForwardIterator2 last2);\n\ntemplate <class ForwardIterator1, class ForwardIterator2, class BinaryPredicate>\n    ForwardIterator1\n    find_first_of(ForwardIterator1 first1, ForwardIterator1 last1,\n                  ForwardIterator2 first2, ForwardIterator2 last2, BinaryPredicate pred);\n\ntemplate <class ForwardIterator>\n    ForwardIterator\n    adjacent_find(ForwardIterator first, ForwardIterator last);\n\ntemplate <class ForwardIterator, class BinaryPredicate>\n    ForwardIterator\n    adjacent_find(ForwardIterator first, ForwardIterator last, BinaryPredicate pred);\n\ntemplate <class InputIterator, class T>\n    typename iterator_traits<InputIterator>::difference_type\n    count(InputIterator first, InputIterator last, const T& value);\n\ntemplate <class InputIterator, class Predicate>\n    typename iterator_traits<InputIterator>::difference_type\n    count_if(InputIterator first, InputIterator last, Predicate pred);\n\ntemplate <class InputIterator1, class InputIterator2>\n    pair<InputIterator1, InputIterator2>\n    mismatch(InputIterator1 first1, InputIterator1 last1, InputIterator2 first2);\n\ntemplate <class InputIterator1, class InputIterator2>\n    pair<InputIterator1, InputIterator2>\n    mismatch(InputIterator1 first1, InputIterator1 last1,\n             InputIterator2 first2, InputIterator2 last2); // **C++14**\n\ntemplate <class InputIterator1, class InputIterator2, class BinaryPredicate>\n    pair<InputIterator1, InputIterator2>\n    mismatch(InputIterator1 first1, InputIterator1 last1,\n             InputIterator2 first2, BinaryPredicate pred);\n\ntemplate <class InputIterator1, class InputIterator2, class BinaryPredicate>\n    pair<InputIterator1, InputIterator2>\n    mismatch(InputIterator1 first1, InputIterator1 last1,\n             InputIterator2 first2, InputIterator2 last2,\n             BinaryPredicate pred); // **C++14**\n\ntemplate <class InputIterator1, class InputIterator2>\n    bool\n    equal(InputIterator1 first1, InputIterator1 last1, InputIterator2 first2);\n\ntemplate <class InputIterator1, class InputIterator2>\n    bool\n    equal(InputIterator1 first1, InputIterator1 last1,\n          InputIterator2 first2, InputIterator2 last2); // **C++14**\n\ntemplate <class InputIterator1, class InputIterator2, class BinaryPredicate>\n    bool\n    equal(InputIterator1 first1, InputIterator1 last1,\n          InputIterator2 first2, BinaryPredicate pred);\n\ntemplate <class InputIterator1, class InputIterator2, class BinaryPredicate>\n    bool\n    equal(InputIterator1 first1, InputIterator1 last1,\n          InputIterator2 first2, InputIterator2 last2,\n          BinaryPredicate pred); // **C++14**\n\ntemplate<class ForwardIterator1, class ForwardIterator2>\n    bool\n    is_permutation(ForwardIterator1 first1, ForwardIterator1 last1,\n                   ForwardIterator2 first2);\n\ntemplate<class ForwardIterator1, class ForwardIterator2>\n    bool\n    is_permutation(ForwardIterator1 first1, ForwardIterator1 last1,\n                   ForwardIterator2 first2, ForwardIterator2 last2); // **C++14**\n\ntemplate<class ForwardIterator1, class ForwardIterator2, class BinaryPredicate>\n    bool\n    is_permutation(ForwardIterator1 first1, ForwardIterator1 last1,\n                   ForwardIterator2 first2, BinaryPredicate pred);\n\ntemplate<class ForwardIterator1, class ForwardIterator2, class BinaryPredicate>\n    bool\n    is_permutation(ForwardIterator1 first1, ForwardIterator1 last1,\n                   ForwardIterator2 first2, ForwardIterator2 last2,\n                   BinaryPredicate pred);  // **C++14**\n\ntemplate <class ForwardIterator1, class ForwardIterator2>\n    ForwardIterator1\n    search(ForwardIterator1 first1, ForwardIterator1 last1,\n           ForwardIterator2 first2, ForwardIterator2 last2);\n\ntemplate <class ForwardIterator1, class ForwardIterator2, class BinaryPredicate>\n    ForwardIterator1\n    search(ForwardIterator1 first1, ForwardIterator1 last1,\n           ForwardIterator2 first2, ForwardIterator2 last2, BinaryPredicate pred);\n\ntemplate <class ForwardIterator, class Size, class T>\n    ForwardIterator\n    search_n(ForwardIterator first, ForwardIterator last, Size count, const T& value);\n\ntemplate <class ForwardIterator, class Size, class T, class BinaryPredicate>\n    ForwardIterator\n    search_n(ForwardIterator first, ForwardIterator last,\n             Size count, const T& value, BinaryPredicate pred);\n\ntemplate <class InputIterator, class OutputIterator>\n    OutputIterator\n    copy(InputIterator first, InputIterator last, OutputIterator result);\n\ntemplate<class InputIterator, class OutputIterator, class Predicate>\n    OutputIterator\n    copy_if(InputIterator first, InputIterator last,\n            OutputIterator result, Predicate pred);\n\ntemplate<class InputIterator, class Size, class OutputIterator>\n    OutputIterator\n    copy_n(InputIterator first, Size n, OutputIterator result);\n\ntemplate <class BidirectionalIterator1, class BidirectionalIterator2>\n    BidirectionalIterator2\n    copy_backward(BidirectionalIterator1 first, BidirectionalIterator1 last,\n                  BidirectionalIterator2 result);\n\ntemplate <class ForwardIterator1, class ForwardIterator2>\n    ForwardIterator2\n    swap_ranges(ForwardIterator1 first1, ForwardIterator1 last1, ForwardIterator2 first2);\n\ntemplate <class ForwardIterator1, class ForwardIterator2>\n    void\n    iter_swap(ForwardIterator1 a, ForwardIterator2 b);\n\ntemplate <class InputIterator, class OutputIterator, class UnaryOperation>\n    OutputIterator\n    transform(InputIterator first, InputIterator last, OutputIterator result, UnaryOperation op);\n\ntemplate <class InputIterator1, class InputIterator2, class OutputIterator, class BinaryOperation>\n    OutputIterator\n    transform(InputIterator1 first1, InputIterator1 last1, InputIterator2 first2,\n              OutputIterator result, BinaryOperation binary_op);\n\ntemplate <class ForwardIterator, class T>\n    void\n    replace(ForwardIterator first, ForwardIterator last, const T& old_value, const T& new_value);\n\ntemplate <class ForwardIterator, class Predicate, class T>\n    void\n    replace_if(ForwardIterator first, ForwardIterator last, Predicate pred, const T& new_value);\n\ntemplate <class InputIterator, class OutputIterator, class T>\n    OutputIterator\n    replace_copy(InputIterator first, InputIterator last, OutputIterator result,\n                 const T& old_value, const T& new_value);\n\ntemplate <class InputIterator, class OutputIterator, class Predicate, class T>\n    OutputIterator\n    replace_copy_if(InputIterator first, InputIterator last, OutputIterator result, Predicate pred, const T& new_value);\n\ntemplate <class ForwardIterator, class T>\n    void\n    fill(ForwardIterator first, ForwardIterator last, const T& value);\n\ntemplate <class OutputIterator, class Size, class T>\n    OutputIterator\n    fill_n(OutputIterator first, Size n, const T& value);\n\ntemplate <class ForwardIterator, class Generator>\n    void\n    generate(ForwardIterator first, ForwardIterator last, Generator gen);\n\ntemplate <class OutputIterator, class Size, class Generator>\n    OutputIterator\n    generate_n(OutputIterator first, Size n, Generator gen);\n\ntemplate <class ForwardIterator, class T>\n    ForwardIterator\n    remove(ForwardIterator first, ForwardIterator last, const T& value);\n\ntemplate <class ForwardIterator, class Predicate>\n    ForwardIterator\n    remove_if(ForwardIterator first, ForwardIterator last, Predicate pred);\n\ntemplate <class InputIterator, class OutputIterator, class T>\n    OutputIterator\n    remove_copy(InputIterator first, InputIterator last, OutputIterator result, const T& value);\n\ntemplate <class InputIterator, class OutputIterator, class Predicate>\n    OutputIterator\n    remove_copy_if(InputIterator first, InputIterator last, OutputIterator result, Predicate pred);\n\ntemplate <class ForwardIterator>\n    ForwardIterator\n    unique(ForwardIterator first, ForwardIterator last);\n\ntemplate <class ForwardIterator, class BinaryPredicate>\n    ForwardIterator\n    unique(ForwardIterator first, ForwardIterator last, BinaryPredicate pred);\n\ntemplate <class InputIterator, class OutputIterator>\n    OutputIterator\n    unique_copy(InputIterator first, InputIterator last, OutputIterator result);\n\ntemplate <class InputIterator, class OutputIterator, class BinaryPredicate>\n    OutputIterator\n    unique_copy(InputIterator first, InputIterator last, OutputIterator result, BinaryPredicate pred);\n\ntemplate <class BidirectionalIterator>\n    void\n    reverse(BidirectionalIterator first, BidirectionalIterator last);\n\ntemplate <class BidirectionalIterator, class OutputIterator>\n    OutputIterator\n    reverse_copy(BidirectionalIterator first, BidirectionalIterator last, OutputIterator result);\n\ntemplate <class ForwardIterator>\n    ForwardIterator\n    rotate(ForwardIterator first, ForwardIterator middle, ForwardIterator last);\n\ntemplate <class ForwardIterator, class OutputIterator>\n    OutputIterator\n    rotate_copy(ForwardIterator first, ForwardIterator middle, ForwardIterator last, OutputIterator result);\n\ntemplate <class RandomAccessIterator>\n    void\n    random_shuffle(RandomAccessIterator first, RandomAccessIterator last); // deprecated in C++14\n\ntemplate <class RandomAccessIterator, class RandomNumberGenerator>\n    void\n    random_shuffle(RandomAccessIterator first, RandomAccessIterator last,\n                   RandomNumberGenerator& rand);  // deprecated in C++14\n\ntemplate<class PopulationIterator, class SampleIterator,\n         class Distance, class UniformRandomBitGenerator>\n    SampleIterator sample(PopulationIterator first, PopulationIterator last,\n                          SampleIterator out, Distance n,\n                          UniformRandomBitGenerator&& g); // C++17\n\ntemplate<class RandomAccessIterator, class UniformRandomNumberGenerator>\n    void shuffle(RandomAccessIterator first, RandomAccessIterator last,\n                 UniformRandomNumberGenerator&& g);\n\ntemplate <class InputIterator, class Predicate>\n    bool\n    is_partitioned(InputIterator first, InputIterator last, Predicate pred);\n\ntemplate <class ForwardIterator, class Predicate>\n    ForwardIterator\n    partition(ForwardIterator first, ForwardIterator last, Predicate pred);\n\ntemplate <class InputIterator, class OutputIterator1,\n          class OutputIterator2, class Predicate>\n    pair<OutputIterator1, OutputIterator2>\n    partition_copy(InputIterator first, InputIterator last,\n                   OutputIterator1 out_true, OutputIterator2 out_false,\n                   Predicate pred);\n\ntemplate <class ForwardIterator, class Predicate>\n    ForwardIterator\n    stable_partition(ForwardIterator first, ForwardIterator last, Predicate pred);\n\ntemplate<class ForwardIterator, class Predicate>\n    ForwardIterator\n    partition_point(ForwardIterator first, ForwardIterator last, Predicate pred);\n\ntemplate <class ForwardIterator>\n    bool\n    is_sorted(ForwardIterator first, ForwardIterator last);\n\ntemplate <class ForwardIterator, class Compare>\n    bool\n    is_sorted(ForwardIterator first, ForwardIterator last, Compare comp);\n\ntemplate<class ForwardIterator>\n    ForwardIterator\n    is_sorted_until(ForwardIterator first, ForwardIterator last);\n\ntemplate <class ForwardIterator, class Compare>\n    ForwardIterator\n    is_sorted_until(ForwardIterator first, ForwardIterator last, Compare comp);\n\ntemplate <class RandomAccessIterator>\n    void\n    sort(RandomAccessIterator first, RandomAccessIterator last);\n\ntemplate <class RandomAccessIterator, class Compare>\n    void\n    sort(RandomAccessIterator first, RandomAccessIterator last, Compare comp);\n\ntemplate <class RandomAccessIterator>\n    void\n    stable_sort(RandomAccessIterator first, RandomAccessIterator last);\n\ntemplate <class RandomAccessIterator, class Compare>\n    void\n    stable_sort(RandomAccessIterator first, RandomAccessIterator last, Compare comp);\n\ntemplate <class RandomAccessIterator>\n    void\n    partial_sort(RandomAccessIterator first, RandomAccessIterator middle, RandomAccessIterator last);\n\ntemplate <class RandomAccessIterator, class Compare>\n    void\n    partial_sort(RandomAccessIterator first, RandomAccessIterator middle, RandomAccessIterator last, Compare comp);\n\ntemplate <class InputIterator, class RandomAccessIterator>\n    RandomAccessIterator\n    partial_sort_copy(InputIterator first, InputIterator last,\n                      RandomAccessIterator result_first, RandomAccessIterator result_last);\n\ntemplate <class InputIterator, class RandomAccessIterator, class Compare>\n    RandomAccessIterator\n    partial_sort_copy(InputIterator first, InputIterator last,\n                      RandomAccessIterator result_first, RandomAccessIterator result_last, Compare comp);\n\ntemplate <class RandomAccessIterator>\n    void\n    nth_element(RandomAccessIterator first, RandomAccessIterator nth, RandomAccessIterator last);\n\ntemplate <class RandomAccessIterator, class Compare>\n    void\n    nth_element(RandomAccessIterator first, RandomAccessIterator nth, RandomAccessIterator last, Compare comp);\n\ntemplate <class ForwardIterator, class T>\n    ForwardIterator\n    lower_bound(ForwardIterator first, ForwardIterator last, const T& value);\n\ntemplate <class ForwardIterator, class T, class Compare>\n    ForwardIterator\n    lower_bound(ForwardIterator first, ForwardIterator last, const T& value, Compare comp);\n\ntemplate <class ForwardIterator, class T>\n    ForwardIterator\n    upper_bound(ForwardIterator first, ForwardIterator last, const T& value);\n\ntemplate <class ForwardIterator, class T, class Compare>\n    ForwardIterator\n    upper_bound(ForwardIterator first, ForwardIterator last, const T& value, Compare comp);\n\ntemplate <class ForwardIterator, class T>\n    pair<ForwardIterator, ForwardIterator>\n    equal_range(ForwardIterator first, ForwardIterator last, const T& value);\n\ntemplate <class ForwardIterator, class T, class Compare>\n    pair<ForwardIterator, ForwardIterator>\n    equal_range(ForwardIterator first, ForwardIterator last, const T& value, Compare comp);\n\ntemplate <class ForwardIterator, class T>\n    bool\n    binary_search(ForwardIterator first, ForwardIterator last, const T& value);\n\ntemplate <class ForwardIterator, class T, class Compare>\n    bool\n    binary_search(ForwardIterator first, ForwardIterator last, const T& value, Compare comp);\n\ntemplate <class InputIterator1, class InputIterator2, class OutputIterator>\n    OutputIterator\n    merge(InputIterator1 first1, InputIterator1 last1,\n          InputIterator2 first2, InputIterator2 last2, OutputIterator result);\n\ntemplate <class InputIterator1, class InputIterator2, class OutputIterator, class Compare>\n    OutputIterator\n    merge(InputIterator1 first1, InputIterator1 last1,\n          InputIterator2 first2, InputIterator2 last2, OutputIterator result, Compare comp);\n\ntemplate <class BidirectionalIterator>\n    void\n    inplace_merge(BidirectionalIterator first, BidirectionalIterator middle, BidirectionalIterator last);\n\ntemplate <class BidirectionalIterator, class Compare>\n    void\n    inplace_merge(BidirectionalIterator first, BidirectionalIterator middle, BidirectionalIterator last, Compare comp);\n\ntemplate <class InputIterator1, class InputIterator2>\n    bool\n    includes(InputIterator1 first1, InputIterator1 last1, InputIterator2 first2, InputIterator2 last2);\n\ntemplate <class InputIterator1, class InputIterator2, class Compare>\n    bool\n    includes(InputIterator1 first1, InputIterator1 last1, InputIterator2 first2, InputIterator2 last2, Compare comp);\n\ntemplate <class InputIterator1, class InputIterator2, class OutputIterator>\n    OutputIterator\n    set_union(InputIterator1 first1, InputIterator1 last1,\n              InputIterator2 first2, InputIterator2 last2, OutputIterator result);\n\ntemplate <class InputIterator1, class InputIterator2, class OutputIterator, class Compare>\n    OutputIterator\n    set_union(InputIterator1 first1, InputIterator1 last1,\n              InputIterator2 first2, InputIterator2 last2, OutputIterator result, Compare comp);\n\ntemplate <class InputIterator1, class InputIterator2, class OutputIterator>\n    OutputIterator\n    set_intersection(InputIterator1 first1, InputIterator1 last1,\n                     InputIterator2 first2, InputIterator2 last2, OutputIterator result);\n\ntemplate <class InputIterator1, class InputIterator2, class OutputIterator, class Compare>\n    OutputIterator\n    set_intersection(InputIterator1 first1, InputIterator1 last1,\n                     InputIterator2 first2, InputIterator2 last2, OutputIterator result, Compare comp);\n\ntemplate <class InputIterator1, class InputIterator2, class OutputIterator>\n    OutputIterator\n    set_difference(InputIterator1 first1, InputIterator1 last1,\n                   InputIterator2 first2, InputIterator2 last2, OutputIterator result);\n\ntemplate <class InputIterator1, class InputIterator2, class OutputIterator, class Compare>\n    OutputIterator\n    set_difference(InputIterator1 first1, InputIterator1 last1,\n                   InputIterator2 first2, InputIterator2 last2, OutputIterator result, Compare comp);\n\ntemplate <class InputIterator1, class InputIterator2, class OutputIterator>\n    OutputIterator\n    set_symmetric_difference(InputIterator1 first1, InputIterator1 last1,\n                             InputIterator2 first2, InputIterator2 last2, OutputIterator result);\n\ntemplate <class InputIterator1, class InputIterator2, class OutputIterator, class Compare>\n    OutputIterator\n    set_symmetric_difference(InputIterator1 first1, InputIterator1 last1,\n                             InputIterator2 first2, InputIterator2 last2, OutputIterator result, Compare comp);\n\ntemplate <class RandomAccessIterator>\n    void\n    push_heap(RandomAccessIterator first, RandomAccessIterator last);\n\ntemplate <class RandomAccessIterator, class Compare>\n    void\n    push_heap(RandomAccessIterator first, RandomAccessIterator last, Compare comp);\n\ntemplate <class RandomAccessIterator>\n    void\n    pop_heap(RandomAccessIterator first, RandomAccessIterator last);\n\ntemplate <class RandomAccessIterator, class Compare>\n    void\n    pop_heap(RandomAccessIterator first, RandomAccessIterator last, Compare comp);\n\ntemplate <class RandomAccessIterator>\n    void\n    make_heap(RandomAccessIterator first, RandomAccessIterator last);\n\ntemplate <class RandomAccessIterator, class Compare>\n    void\n    make_heap(RandomAccessIterator first, RandomAccessIterator last, Compare comp);\n\ntemplate <class RandomAccessIterator>\n    void\n    sort_heap(RandomAccessIterator first, RandomAccessIterator last);\n\ntemplate <class RandomAccessIterator, class Compare>\n    void\n    sort_heap(RandomAccessIterator first, RandomAccessIterator last, Compare comp);\n\ntemplate <class RandomAccessIterator>\n    bool\n    is_heap(RandomAccessIterator first, RandomAccessiterator last);\n\ntemplate <class RandomAccessIterator, class Compare>\n    bool\n    is_heap(RandomAccessIterator first, RandomAccessiterator last, Compare comp);\n\ntemplate <class RandomAccessIterator>\n    RandomAccessIterator\n    is_heap_until(RandomAccessIterator first, RandomAccessiterator last);\n\ntemplate <class RandomAccessIterator, class Compare>\n    RandomAccessIterator\n    is_heap_until(RandomAccessIterator first, RandomAccessiterator last, Compare comp);\n\ntemplate <class ForwardIterator>\n    ForwardIterator\n    min_element(ForwardIterator first, ForwardIterator last);  // constexpr in C++14\n\ntemplate <class ForwardIterator, class Compare>\n    ForwardIterator\n    min_element(ForwardIterator first, ForwardIterator last, Compare comp);  // constexpr in C++14\n\ntemplate <class T>\n    const T&\n    min(const T& a, const T& b);  // constexpr in C++14\n\ntemplate <class T, class Compare>\n    const T&\n    min(const T& a, const T& b, Compare comp);  // constexpr in C++14\n\ntemplate<class T>\n    T\n    min(initializer_list<T> t);  // constexpr in C++14\n\ntemplate<class T, class Compare>\n    T\n    min(initializer_list<T> t, Compare comp);  // constexpr in C++14\n\ntemplate<class T>\n    constexpr const T& clamp( const T& v, const T& lo, const T& hi );               // C++17\n\ntemplate<class T, class Compare>\n    constexpr const T& clamp( const T& v, const T& lo, const T& hi, Compare comp ); // C++17\n\ntemplate <class ForwardIterator>\n    ForwardIterator\n    max_element(ForwardIterator first, ForwardIterator last);  // constexpr in C++14\n\ntemplate <class ForwardIterator, class Compare>\n    ForwardIterator\n    max_element(ForwardIterator first, ForwardIterator last, Compare comp);  // constexpr in C++14\n\ntemplate <class T>\n    const T&\n    max(const T& a, const T& b); // constexpr in C++14\n\ntemplate <class T, class Compare>\n    const T&\n    max(const T& a, const T& b, Compare comp);  // constexpr in C++14\n\ntemplate<class T>\n    T\n    max(initializer_list<T> t);  // constexpr in C++14\n\ntemplate<class T, class Compare>\n    T\n    max(initializer_list<T> t, Compare comp);  // constexpr in C++14\n\ntemplate<class ForwardIterator>\n    pair<ForwardIterator, ForwardIterator>\n    minmax_element(ForwardIterator first, ForwardIterator last);   // constexpr in C++14\n\ntemplate<class ForwardIterator, class Compare>\n    pair<ForwardIterator, ForwardIterator>\n    minmax_element(ForwardIterator first, ForwardIterator last, Compare comp);   // constexpr in C++14\n\ntemplate<class T>\n    pair<const T&, const T&>\n    minmax(const T& a, const T& b);  // constexpr in C++14\n\ntemplate<class T, class Compare>\n    pair<const T&, const T&>\n    minmax(const T& a, const T& b, Compare comp);  // constexpr in C++14\n\ntemplate<class T>\n    pair<T, T>\n    minmax(initializer_list<T> t);  // constexpr in C++14\n\ntemplate<class T, class Compare>\n    pair<T, T>\n    minmax(initializer_list<T> t, Compare comp);  // constexpr in C++14\n\ntemplate <class InputIterator1, class InputIterator2>\n    bool\n    lexicographical_compare(InputIterator1 first1, InputIterator1 last1, InputIterator2 first2, InputIterator2 last2);\n\ntemplate <class InputIterator1, class InputIterator2, class Compare>\n    bool\n    lexicographical_compare(InputIterator1 first1, InputIterator1 last1,\n                            InputIterator2 first2, InputIterator2 last2, Compare comp);\n\ntemplate <class BidirectionalIterator>\n    bool\n    next_permutation(BidirectionalIterator first, BidirectionalIterator last);\n\ntemplate <class BidirectionalIterator, class Compare>\n    bool\n    next_permutation(BidirectionalIterator first, BidirectionalIterator last, Compare comp);\n\ntemplate <class BidirectionalIterator>\n    bool\n    prev_permutation(BidirectionalIterator first, BidirectionalIterator last);\n\ntemplate <class BidirectionalIterator, class Compare>\n    bool\n    prev_permutation(BidirectionalIterator first, BidirectionalIterator last, Compare comp);\n\n}  // std\n\n*/\n\n#include <__config>\n#include <initializer_list>\n#include <type_traits>\n#include <cstring>\n#include <utility> // needed to provide swap_ranges.\n#include <memory>\n#include <iterator>\n#include <cstddef>\n\n#if defined(__IBMCPP__)\n#include \"support/ibm/support.h\"\n#endif\n#if defined(_LIBCPP_MSVCRT) || defined(__MINGW32__)\n#include \"support/win32/support.h\"\n#endif\n\n#include <__undef_min_max>\n\n#include <__debug>\n\n#if !defined(_LIBCPP_HAS_NO_PRAGMA_SYSTEM_HEADER)\n#pragma GCC system_header\n#endif\n\n_LIBCPP_BEGIN_NAMESPACE_STD\n\n// I'd like to replace these with _VSTD::equal_to<void>, but can't because:\n//   * That only works with C++14 and later, and\n//   * We haven't included <functional> here.\ntemplate <class _T1, class _T2 = _T1>\nstruct __equal_to\n{\n    _LIBCPP_INLINE_VISIBILITY bool operator()(const _T1& __x, const _T1& __y) const {return __x == __y;}\n    _LIBCPP_INLINE_VISIBILITY bool operator()(const _T1& __x, const _T2& __y) const {return __x == __y;}\n    _LIBCPP_INLINE_VISIBILITY bool operator()(const _T2& __x, const _T1& __y) const {return __x == __y;}\n    _LIBCPP_INLINE_VISIBILITY bool operator()(const _T2& __x, const _T2& __y) const {return __x == __y;}\n};\n\ntemplate <class _T1>\nstruct __equal_to<_T1, _T1>\n{\n    _LIBCPP_INLINE_VISIBILITY _LIBCPP_CONSTEXPR_AFTER_CXX11\n    bool operator()(const _T1& __x, const _T1& __y) const {return __x == __y;}\n};\n\ntemplate <class _T1>\nstruct __equal_to<const _T1, _T1>\n{\n    _LIBCPP_INLINE_VISIBILITY _LIBCPP_CONSTEXPR_AFTER_CXX11\n    bool operator()(const _T1& __x, const _T1& __y) const {return __x == __y;}\n};\n\ntemplate <class _T1>\nstruct __equal_to<_T1, const _T1>\n{\n    _LIBCPP_INLINE_VISIBILITY _LIBCPP_CONSTEXPR_AFTER_CXX11\n    bool operator()(const _T1& __x, const _T1& __y) const {return __x == __y;}\n};\n\ntemplate <class _T1, class _T2 = _T1>\nstruct __less\n{\n    _LIBCPP_INLINE_VISIBILITY _LIBCPP_CONSTEXPR_AFTER_CXX11\n    bool operator()(const _T1& __x, const _T1& __y) const {return __x < __y;}\n\n    _LIBCPP_INLINE_VISIBILITY _LIBCPP_CONSTEXPR_AFTER_CXX11\n    bool operator()(const _T1& __x, const _T2& __y) const {return __x < __y;}\n\n    _LIBCPP_INLINE_VISIBILITY _LIBCPP_CONSTEXPR_AFTER_CXX11\n    bool operator()(const _T2& __x, const _T1& __y) const {return __x < __y;}\n\n    _LIBCPP_INLINE_VISIBILITY _LIBCPP_CONSTEXPR_AFTER_CXX11\n    bool operator()(const _T2& __x, const _T2& __y) const {return __x < __y;}\n};\n\ntemplate <class _T1>\nstruct __less<_T1, _T1>\n{\n    _LIBCPP_INLINE_VISIBILITY _LIBCPP_CONSTEXPR_AFTER_CXX11\n    bool operator()(const _T1& __x, const _T1& __y) const {return __x < __y;}\n};\n\ntemplate <class _T1>\nstruct __less<const _T1, _T1>\n{\n    _LIBCPP_INLINE_VISIBILITY _LIBCPP_CONSTEXPR_AFTER_CXX11\n    bool operator()(const _T1& __x, const _T1& __y) const {return __x < __y;}\n};\n\ntemplate <class _T1>\nstruct __less<_T1, const _T1>\n{\n    _LIBCPP_INLINE_VISIBILITY _LIBCPP_CONSTEXPR_AFTER_CXX11\n    bool operator()(const _T1& __x, const _T1& __y) const {return __x < __y;}\n};\n\ntemplate <class _Predicate>\nclass __negate\n{\nprivate:\n    _Predicate __p_;\npublic:\n    _LIBCPP_INLINE_VISIBILITY __negate() {}\n\n    _LIBCPP_INLINE_VISIBILITY\n    explicit __negate(_Predicate __p) : __p_(__p) {}\n\n    template <class _T1>\n    _LIBCPP_INLINE_VISIBILITY\n    bool operator()(const _T1& __x) {return !__p_(__x);}\n\n    template <class _T1, class _T2>\n    _LIBCPP_INLINE_VISIBILITY\n    bool operator()(const _T1& __x, const _T2& __y) {return !__p_(__x, __y);}\n};\n\n#ifdef _LIBCPP_DEBUG\n\ntemplate <class _Compare>\nstruct __debug_less\n{\n    _Compare __comp_;\n    __debug_less(_Compare& __c) : __comp_(__c) {}\n\n    template <class _Tp, class _Up>\n    bool operator()(const _Tp& __x, const _Up& __y)\n    {\n        bool __r = __comp_(__x, __y);\n        if (__r)\n            __do_compare_assert(0, __y, __x);\n        return __r;\n    }\n\n    template <class _LHS, class _RHS>\n    inline _LIBCPP_INLINE_VISIBILITY\n    decltype((void)_VSTD::declval<_Compare&>()(\n        _VSTD::declval<_LHS const&>(), _VSTD::declval<_RHS const&>()))\n    __do_compare_assert(int, _LHS const& __l, _RHS const& __r) {\n        _LIBCPP_ASSERT(!__comp_(__l, __r),\n            \"Comparator does not induce a strict weak ordering\");\n    }\n\n    template <class _LHS, class _RHS>\n    inline _LIBCPP_INLINE_VISIBILITY\n    void __do_compare_assert(long, _LHS const&, _RHS const&) {}\n};\n\n#endif  // _LIBCPP_DEBUG\n\n// Precondition:  __x != 0\ninline _LIBCPP_INLINE_VISIBILITY\nunsigned\n__ctz(unsigned __x)\n{\n    return static_cast<unsigned>(__builtin_ctz(__x));\n}\n\ninline _LIBCPP_INLINE_VISIBILITY\nunsigned long\n__ctz(unsigned long __x)\n{\n    return static_cast<unsigned long>(__builtin_ctzl(__x));\n}\n\ninline _LIBCPP_INLINE_VISIBILITY\nunsigned long long\n__ctz(unsigned long long __x)\n{\n    return static_cast<unsigned long long>(__builtin_ctzll(__x));\n}\n\n// Precondition:  __x != 0\ninline _LIBCPP_INLINE_VISIBILITY\nunsigned\n__clz(unsigned __x)\n{\n    return static_cast<unsigned>(__builtin_clz(__x));\n}\n\ninline _LIBCPP_INLINE_VISIBILITY\nunsigned long\n__clz(unsigned long __x)\n{\n    return static_cast<unsigned long>(__builtin_clzl (__x));\n}\n\ninline _LIBCPP_INLINE_VISIBILITY\nunsigned long long\n__clz(unsigned long long __x)\n{\n    return static_cast<unsigned long long>(__builtin_clzll(__x));\n}\n\ninline _LIBCPP_INLINE_VISIBILITY int __pop_count(unsigned           __x) {return __builtin_popcount  (__x);}\ninline _LIBCPP_INLINE_VISIBILITY int __pop_count(unsigned      long __x) {return __builtin_popcountl (__x);}\ninline _LIBCPP_INLINE_VISIBILITY int __pop_count(unsigned long long __x) {return __builtin_popcountll(__x);}\n\n// all_of\n\ntemplate <class _InputIterator, class _Predicate>\ninline _LIBCPP_INLINE_VISIBILITY\nbool\nall_of(_InputIterator __first, _InputIterator __last, _Predicate __pred)\n{\n    for (; __first != __last; ++__first)\n        if (!__pred(*__first))\n            return false;\n    return true;\n}\n\n// any_of\n\ntemplate <class _InputIterator, class _Predicate>\ninline _LIBCPP_INLINE_VISIBILITY\nbool\nany_of(_InputIterator __first, _InputIterator __last, _Predicate __pred)\n{\n    for (; __first != __last; ++__first)\n        if (__pred(*__first))\n            return true;\n    return false;\n}\n\n// none_of\n\ntemplate <class _InputIterator, class _Predicate>\ninline _LIBCPP_INLINE_VISIBILITY\nbool\nnone_of(_InputIterator __first, _InputIterator __last, _Predicate __pred)\n{\n    for (; __first != __last; ++__first)\n        if (__pred(*__first))\n            return false;\n    return true;\n}\n\n// for_each\n\ntemplate <class _InputIterator, class _Function>\ninline _LIBCPP_INLINE_VISIBILITY\n_Function\nfor_each(_InputIterator __first, _InputIterator __last, _Function __f)\n{\n    for (; __first != __last; ++__first)\n        __f(*__first);\n    return __f;\n}\n\n// find\n\ntemplate <class _InputIterator, class _Tp>\ninline _LIBCPP_INLINE_VISIBILITY\n_InputIterator\nfind(_InputIterator __first, _InputIterator __last, const _Tp& __value_)\n{\n    for (; __first != __last; ++__first)\n        if (*__first == __value_)\n            break;\n    return __first;\n}\n\n// find_if\n\ntemplate <class _InputIterator, class _Predicate>\ninline _LIBCPP_INLINE_VISIBILITY\n_InputIterator\nfind_if(_InputIterator __first, _InputIterator __last, _Predicate __pred)\n{\n    for (; __first != __last; ++__first)\n        if (__pred(*__first))\n            break;\n    return __first;\n}\n\n// find_if_not\n\ntemplate<class _InputIterator, class _Predicate>\ninline _LIBCPP_INLINE_VISIBILITY\n_InputIterator\nfind_if_not(_InputIterator __first, _InputIterator __last, _Predicate __pred)\n{\n    for (; __first != __last; ++__first)\n        if (!__pred(*__first))\n            break;\n    return __first;\n}\n\n// find_end\n\ntemplate <class _BinaryPredicate, class _ForwardIterator1, class _ForwardIterator2>\n_ForwardIterator1\n__find_end(_ForwardIterator1 __first1, _ForwardIterator1 __last1,\n           _ForwardIterator2 __first2, _ForwardIterator2 __last2, _BinaryPredicate __pred,\n           forward_iterator_tag, forward_iterator_tag)\n{\n    // modeled after search algorithm\n    _ForwardIterator1 __r = __last1;  // __last1 is the \"default\" answer\n    if (__first2 == __last2)\n        return __r;\n    while (true)\n    {\n        while (true)\n        {\n            if (__first1 == __last1)         // if source exhausted return last correct answer\n                return __r;                  //    (or __last1 if never found)\n            if (__pred(*__first1, *__first2))\n                break;\n            ++__first1;\n        }\n        // *__first1 matches *__first2, now match elements after here\n        _ForwardIterator1 __m1 = __first1;\n        _ForwardIterator2 __m2 = __first2;\n        while (true)\n        {\n            if (++__m2 == __last2)\n            {                         // Pattern exhaused, record answer and search for another one\n                __r = __first1;\n                ++__first1;\n                break;\n            }\n            if (++__m1 == __last1)     // Source exhausted, return last answer\n                return __r;\n            if (!__pred(*__m1, *__m2))  // mismatch, restart with a new __first\n            {\n                ++__first1;\n                break;\n            }  // else there is a match, check next elements\n        }\n    }\n}\n\ntemplate <class _BinaryPredicate, class _BidirectionalIterator1, class _BidirectionalIterator2>\n_BidirectionalIterator1\n__find_end(_BidirectionalIterator1 __first1, _BidirectionalIterator1 __last1,\n           _BidirectionalIterator2 __first2, _BidirectionalIterator2 __last2, _BinaryPredicate __pred,\n           bidirectional_iterator_tag, bidirectional_iterator_tag)\n{\n    // modeled after search algorithm (in reverse)\n    if (__first2 == __last2)\n        return __last1;  // Everything matches an empty sequence\n    _BidirectionalIterator1 __l1 = __last1;\n    _BidirectionalIterator2 __l2 = __last2;\n    --__l2;\n    while (true)\n    {\n        // Find last element in sequence 1 that matchs *(__last2-1), with a mininum of loop checks\n        while (true)\n        {\n            if (__first1 == __l1)  // return __last1 if no element matches *__first2\n                return __last1;\n            if (__pred(*--__l1, *__l2))\n                break;\n        }\n        // *__l1 matches *__l2, now match elements before here\n        _BidirectionalIterator1 __m1 = __l1;\n        _BidirectionalIterator2 __m2 = __l2;\n        while (true)\n        {\n            if (__m2 == __first2)  // If pattern exhausted, __m1 is the answer (works for 1 element pattern)\n                return __m1;\n            if (__m1 == __first1)  // Otherwise if source exhaused, pattern not found\n                return __last1;\n            if (!__pred(*--__m1, *--__m2))  // if there is a mismatch, restart with a new __l1\n            {\n                break;\n            }  // else there is a match, check next elements\n        }\n    }\n}\n\ntemplate <class _BinaryPredicate, class _RandomAccessIterator1, class _RandomAccessIterator2>\n_LIBCPP_CONSTEXPR_AFTER_CXX11 _RandomAccessIterator1\n__find_end(_RandomAccessIterator1 __first1, _RandomAccessIterator1 __last1,\n           _RandomAccessIterator2 __first2, _RandomAccessIterator2 __last2, _BinaryPredicate __pred,\n           random_access_iterator_tag, random_access_iterator_tag)\n{\n    // Take advantage of knowing source and pattern lengths.  Stop short when source is smaller than pattern\n    typename iterator_traits<_RandomAccessIterator2>::difference_type __len2 = __last2 - __first2;\n    if (__len2 == 0)\n        return __last1;\n    typename iterator_traits<_RandomAccessIterator1>::difference_type __len1 = __last1 - __first1;\n    if (__len1 < __len2)\n        return __last1;\n    const _RandomAccessIterator1 __s = __first1 + (__len2 - 1);  // End of pattern match can't go before here\n    _RandomAccessIterator1 __l1 = __last1;\n    _RandomAccessIterator2 __l2 = __last2;\n    --__l2;\n    while (true)\n    {\n        while (true)\n        {\n            if (__s == __l1)\n                return __last1;\n            if (__pred(*--__l1, *__l2))\n                break;\n        }\n        _RandomAccessIterator1 __m1 = __l1;\n        _RandomAccessIterator2 __m2 = __l2;\n        while (true)\n        {\n            if (__m2 == __first2)\n                return __m1;\n                                 // no need to check range on __m1 because __s guarantees we have enough source\n            if (!__pred(*--__m1, *--__m2))\n            {\n                break;\n            }\n        }\n    }\n}\n\ntemplate <class _ForwardIterator1, class _ForwardIterator2, class _BinaryPredicate>\ninline _LIBCPP_INLINE_VISIBILITY\n_ForwardIterator1\nfind_end(_ForwardIterator1 __first1, _ForwardIterator1 __last1,\n         _ForwardIterator2 __first2, _ForwardIterator2 __last2, _BinaryPredicate __pred)\n{\n    return _VSTD::__find_end<typename add_lvalue_reference<_BinaryPredicate>::type>\n                         (__first1, __last1, __first2, __last2, __pred,\n                          typename iterator_traits<_ForwardIterator1>::iterator_category(),\n                          typename iterator_traits<_ForwardIterator2>::iterator_category());\n}\n\ntemplate <class _ForwardIterator1, class _ForwardIterator2>\ninline _LIBCPP_INLINE_VISIBILITY\n_ForwardIterator1\nfind_end(_ForwardIterator1 __first1, _ForwardIterator1 __last1,\n         _ForwardIterator2 __first2, _ForwardIterator2 __last2)\n{\n    typedef typename iterator_traits<_ForwardIterator1>::value_type __v1;\n    typedef typename iterator_traits<_ForwardIterator2>::value_type __v2;\n    return _VSTD::find_end(__first1, __last1, __first2, __last2, __equal_to<__v1, __v2>());\n}\n\n// find_first_of\n\ntemplate <class _ForwardIterator1, class _ForwardIterator2, class _BinaryPredicate>\n_LIBCPP_CONSTEXPR_AFTER_CXX11 _ForwardIterator1\n__find_first_of_ce(_ForwardIterator1 __first1, _ForwardIterator1 __last1,\n              _ForwardIterator2 __first2, _ForwardIterator2 __last2, _BinaryPredicate __pred)\n{\n    for (; __first1 != __last1; ++__first1)\n        for (_ForwardIterator2 __j = __first2; __j != __last2; ++__j)\n            if (__pred(*__first1, *__j))\n                return __first1;\n    return __last1;\n}\n\n\ntemplate <class _ForwardIterator1, class _ForwardIterator2, class _BinaryPredicate>\ninline _LIBCPP_INLINE_VISIBILITY\n_ForwardIterator1\nfind_first_of(_ForwardIterator1 __first1, _ForwardIterator1 __last1,\n              _ForwardIterator2 __first2, _ForwardIterator2 __last2, _BinaryPredicate __pred)\n{\n    return _VSTD::__find_first_of_ce(__first1, __last1, __first2, __last2, __pred);\n}\n\ntemplate <class _ForwardIterator1, class _ForwardIterator2>\ninline _LIBCPP_INLINE_VISIBILITY\n_ForwardIterator1\nfind_first_of(_ForwardIterator1 __first1, _ForwardIterator1 __last1,\n              _ForwardIterator2 __first2, _ForwardIterator2 __last2)\n{\n    typedef typename iterator_traits<_ForwardIterator1>::value_type __v1;\n    typedef typename iterator_traits<_ForwardIterator2>::value_type __v2;\n    return _VSTD::__find_first_of_ce(__first1, __last1, __first2, __last2, __equal_to<__v1, __v2>());\n}\n\n// adjacent_find\n\ntemplate <class _ForwardIterator, class _BinaryPredicate>\ninline _LIBCPP_INLINE_VISIBILITY\n_ForwardIterator\nadjacent_find(_ForwardIterator __first, _ForwardIterator __last, _BinaryPredicate __pred)\n{\n    if (__first != __last)\n    {\n        _ForwardIterator __i = __first;\n        while (++__i != __last)\n        {\n            if (__pred(*__first, *__i))\n                return __first;\n            __first = __i;\n        }\n    }\n    return __last;\n}\n\ntemplate <class _ForwardIterator>\ninline _LIBCPP_INLINE_VISIBILITY\n_ForwardIterator\nadjacent_find(_ForwardIterator __first, _ForwardIterator __last)\n{\n    typedef typename iterator_traits<_ForwardIterator>::value_type __v;\n    return _VSTD::adjacent_find(__first, __last, __equal_to<__v>());\n}\n\n// count\n\ntemplate <class _InputIterator, class _Tp>\ninline _LIBCPP_INLINE_VISIBILITY\ntypename iterator_traits<_InputIterator>::difference_type\ncount(_InputIterator __first, _InputIterator __last, const _Tp& __value_)\n{\n    typename iterator_traits<_InputIterator>::difference_type __r(0);\n    for (; __first != __last; ++__first)\n        if (*__first == __value_)\n            ++__r;\n    return __r;\n}\n\n// count_if\n\ntemplate <class _InputIterator, class _Predicate>\ninline _LIBCPP_INLINE_VISIBILITY\ntypename iterator_traits<_InputIterator>::difference_type\ncount_if(_InputIterator __first, _InputIterator __last, _Predicate __pred)\n{\n    typename iterator_traits<_InputIterator>::difference_type __r(0);\n    for (; __first != __last; ++__first)\n        if (__pred(*__first))\n            ++__r;\n    return __r;\n}\n\n// mismatch\n\ntemplate <class _InputIterator1, class _InputIterator2, class _BinaryPredicate>\ninline _LIBCPP_INLINE_VISIBILITY\npair<_InputIterator1, _InputIterator2>\nmismatch(_InputIterator1 __first1, _InputIterator1 __last1,\n         _InputIterator2 __first2, _BinaryPredicate __pred)\n{\n    for (; __first1 != __last1; ++__first1, (void) ++__first2)\n        if (!__pred(*__first1, *__first2))\n            break;\n    return pair<_InputIterator1, _InputIterator2>(__first1, __first2);\n}\n\ntemplate <class _InputIterator1, class _InputIterator2>\ninline _LIBCPP_INLINE_VISIBILITY\npair<_InputIterator1, _InputIterator2>\nmismatch(_InputIterator1 __first1, _InputIterator1 __last1, _InputIterator2 __first2)\n{\n    typedef typename iterator_traits<_InputIterator1>::value_type __v1;\n    typedef typename iterator_traits<_InputIterator2>::value_type __v2;\n    return _VSTD::mismatch(__first1, __last1, __first2, __equal_to<__v1, __v2>());\n}\n\n#if _LIBCPP_STD_VER > 11\ntemplate <class _InputIterator1, class _InputIterator2, class _BinaryPredicate>\ninline _LIBCPP_INLINE_VISIBILITY\npair<_InputIterator1, _InputIterator2>\nmismatch(_InputIterator1 __first1, _InputIterator1 __last1,\n         _InputIterator2 __first2, _InputIterator2 __last2,\n         _BinaryPredicate __pred)\n{\n    for (; __first1 != __last1 && __first2 != __last2; ++__first1, (void) ++__first2)\n        if (!__pred(*__first1, *__first2))\n            break;\n    return pair<_InputIterator1, _InputIterator2>(__first1, __first2);\n}\n\ntemplate <class _InputIterator1, class _InputIterator2>\ninline _LIBCPP_INLINE_VISIBILITY\npair<_InputIterator1, _InputIterator2>\nmismatch(_InputIterator1 __first1, _InputIterator1 __last1,\n         _InputIterator2 __first2, _InputIterator2 __last2)\n{\n    typedef typename iterator_traits<_InputIterator1>::value_type __v1;\n    typedef typename iterator_traits<_InputIterator2>::value_type __v2;\n    return _VSTD::mismatch(__first1, __last1, __first2, __last2, __equal_to<__v1, __v2>());\n}\n#endif\n\n// equal\n\ntemplate <class _InputIterator1, class _InputIterator2, class _BinaryPredicate>\ninline _LIBCPP_INLINE_VISIBILITY\nbool\nequal(_InputIterator1 __first1, _InputIterator1 __last1, _InputIterator2 __first2, _BinaryPredicate __pred)\n{\n    for (; __first1 != __last1; ++__first1, (void) ++__first2)\n        if (!__pred(*__first1, *__first2))\n            return false;\n    return true;\n}\n\ntemplate <class _InputIterator1, class _InputIterator2>\ninline _LIBCPP_INLINE_VISIBILITY\nbool\nequal(_InputIterator1 __first1, _InputIterator1 __last1, _InputIterator2 __first2)\n{\n    typedef typename iterator_traits<_InputIterator1>::value_type __v1;\n    typedef typename iterator_traits<_InputIterator2>::value_type __v2;\n    return _VSTD::equal(__first1, __last1, __first2, __equal_to<__v1, __v2>());\n}\n\n#if _LIBCPP_STD_VER > 11\ntemplate <class _BinaryPredicate, class _InputIterator1, class _InputIterator2>\ninline _LIBCPP_INLINE_VISIBILITY\nbool\n__equal(_InputIterator1 __first1, _InputIterator1 __last1,\n        _InputIterator2 __first2, _InputIterator2 __last2, _BinaryPredicate __pred,\n        input_iterator_tag, input_iterator_tag )\n{\n    for (; __first1 != __last1 && __first2 != __last2; ++__first1, (void) ++__first2)\n        if (!__pred(*__first1, *__first2))\n            return false;\n    return __first1 == __last1 && __first2 == __last2;\n}\n\ntemplate <class _BinaryPredicate, class _RandomAccessIterator1, class _RandomAccessIterator2>\ninline _LIBCPP_INLINE_VISIBILITY\nbool\n__equal(_RandomAccessIterator1 __first1, _RandomAccessIterator1 __last1,\n        _RandomAccessIterator2 __first2, _RandomAccessIterator2 __last2, _BinaryPredicate __pred,\n      random_access_iterator_tag, random_access_iterator_tag )\n{\n    if ( _VSTD::distance(__first1, __last1) != _VSTD::distance(__first2, __last2))\n        return false;\n    return _VSTD::equal<_RandomAccessIterator1, _RandomAccessIterator2,\n                        typename add_lvalue_reference<_BinaryPredicate>::type>\n                       (__first1, __last1, __first2, __pred );\n}\n\ntemplate <class _InputIterator1, class _InputIterator2, class _BinaryPredicate>\ninline _LIBCPP_INLINE_VISIBILITY\nbool\nequal(_InputIterator1 __first1, _InputIterator1 __last1,\n      _InputIterator2 __first2, _InputIterator2 __last2, _BinaryPredicate __pred )\n{\n    return _VSTD::__equal<typename add_lvalue_reference<_BinaryPredicate>::type>\n       (__first1, __last1, __first2, __last2, __pred,\n        typename iterator_traits<_InputIterator1>::iterator_category(),\n        typename iterator_traits<_InputIterator2>::iterator_category());\n}\n\ntemplate <class _InputIterator1, class _InputIterator2>\ninline _LIBCPP_INLINE_VISIBILITY\nbool\nequal(_InputIterator1 __first1, _InputIterator1 __last1,\n      _InputIterator2 __first2, _InputIterator2 __last2)\n{\n    typedef typename iterator_traits<_InputIterator1>::value_type __v1;\n    typedef typename iterator_traits<_InputIterator2>::value_type __v2;\n    return _VSTD::__equal(__first1, __last1, __first2, __last2, __equal_to<__v1, __v2>(),\n        typename iterator_traits<_InputIterator1>::iterator_category(),\n        typename iterator_traits<_InputIterator2>::iterator_category());\n}\n#endif\n\n// is_permutation\n\ntemplate<class _ForwardIterator1, class _ForwardIterator2, class _BinaryPredicate>\nbool\nis_permutation(_ForwardIterator1 __first1, _ForwardIterator1 __last1,\n               _ForwardIterator2 __first2, _BinaryPredicate __pred)\n{\n    // shorten sequences as much as possible by lopping of any equal parts\n    for (; __first1 != __last1; ++__first1, (void) ++__first2)\n        if (!__pred(*__first1, *__first2))\n            goto __not_done;\n    return true;\n__not_done:\n    // __first1 != __last1 && *__first1 != *__first2\n    typedef typename iterator_traits<_ForwardIterator1>::difference_type _D1;\n    _D1 __l1 = _VSTD::distance(__first1, __last1);\n    if (__l1 == _D1(1))\n        return false;\n    _ForwardIterator2 __last2 = _VSTD::next(__first2, __l1);\n    // For each element in [f1, l1) see if there are the same number of\n    //    equal elements in [f2, l2)\n    for (_ForwardIterator1 __i = __first1; __i != __last1; ++__i)\n    {\n        // Have we already counted the number of *__i in [f1, l1)?\n        for (_ForwardIterator1 __j = __first1; __j != __i; ++__j)\n            if (__pred(*__j, *__i))\n                goto __next_iter;\n        {\n            // Count number of *__i in [f2, l2)\n            _D1 __c2 = 0;\n            for (_ForwardIterator2 __j = __first2; __j != __last2; ++__j)\n                if (__pred(*__i, *__j))\n                    ++__c2;\n            if (__c2 == 0)\n                return false;\n            // Count number of *__i in [__i, l1) (we can start with 1)\n            _D1 __c1 = 1;\n            for (_ForwardIterator1 __j = _VSTD::next(__i); __j != __last1; ++__j)\n                if (__pred(*__i, *__j))\n                    ++__c1;\n            if (__c1 != __c2)\n                return false;\n        }\n__next_iter:;\n    }\n    return true;\n}\n\ntemplate<class _ForwardIterator1, class _ForwardIterator2>\ninline _LIBCPP_INLINE_VISIBILITY\nbool\nis_permutation(_ForwardIterator1 __first1, _ForwardIterator1 __last1,\n               _ForwardIterator2 __first2)\n{\n    typedef typename iterator_traits<_ForwardIterator1>::value_type __v1;\n    typedef typename iterator_traits<_ForwardIterator2>::value_type __v2;\n    return _VSTD::is_permutation(__first1, __last1, __first2, __equal_to<__v1, __v2>());\n}\n\n#if _LIBCPP_STD_VER > 11\ntemplate<class _BinaryPredicate, class _ForwardIterator1, class _ForwardIterator2>\nbool\n__is_permutation(_ForwardIterator1 __first1, _ForwardIterator1 __last1,\n                 _ForwardIterator2 __first2, _ForwardIterator2 __last2,\n                 _BinaryPredicate __pred,\n                 forward_iterator_tag, forward_iterator_tag )\n{\n    // shorten sequences as much as possible by lopping of any equal parts\n    for (; __first1 != __last1 && __first2 != __last2; ++__first1, (void) ++__first2)\n        if (!__pred(*__first1, *__first2))\n            goto __not_done;\n    return __first1 == __last1 && __first2 == __last2;\n__not_done:\n    // __first1 != __last1 && __first2 != __last2 && *__first1 != *__first2\n    typedef typename iterator_traits<_ForwardIterator1>::difference_type _D1;\n    _D1 __l1 = _VSTD::distance(__first1, __last1);\n\n    typedef typename iterator_traits<_ForwardIterator2>::difference_type _D2;\n    _D2 __l2 = _VSTD::distance(__first2, __last2);\n    if (__l1 != __l2)\n        return false;\n\n    // For each element in [f1, l1) see if there are the same number of\n    //    equal elements in [f2, l2)\n    for (_ForwardIterator1 __i = __first1; __i != __last1; ++__i)\n    {\n        // Have we already counted the number of *__i in [f1, l1)?\n        for (_ForwardIterator1 __j = __first1; __j != __i; ++__j)\n            if (__pred(*__j, *__i))\n                goto __next_iter;\n        {\n            // Count number of *__i in [f2, l2)\n            _D1 __c2 = 0;\n            for (_ForwardIterator2 __j = __first2; __j != __last2; ++__j)\n                if (__pred(*__i, *__j))\n                    ++__c2;\n            if (__c2 == 0)\n                return false;\n            // Count number of *__i in [__i, l1) (we can start with 1)\n            _D1 __c1 = 1;\n            for (_ForwardIterator1 __j = _VSTD::next(__i); __j != __last1; ++__j)\n                if (__pred(*__i, *__j))\n                    ++__c1;\n            if (__c1 != __c2)\n                return false;\n        }\n__next_iter:;\n    }\n    return true;\n}\n\ntemplate<class _BinaryPredicate, class _RandomAccessIterator1, class _RandomAccessIterator2>\nbool\n__is_permutation(_RandomAccessIterator1 __first1, _RandomAccessIterator2 __last1,\n               _RandomAccessIterator1 __first2, _RandomAccessIterator2 __last2,\n               _BinaryPredicate __pred,\n               random_access_iterator_tag, random_access_iterator_tag )\n{\n    if ( _VSTD::distance(__first1, __last1) != _VSTD::distance(__first2, __last2))\n        return false;\n    return _VSTD::is_permutation<_RandomAccessIterator1, _RandomAccessIterator2,\n                                 typename add_lvalue_reference<_BinaryPredicate>::type>\n                                (__first1, __last1, __first2, __pred );\n}\n\ntemplate<class _ForwardIterator1, class _ForwardIterator2, class _BinaryPredicate>\ninline _LIBCPP_INLINE_VISIBILITY\nbool\nis_permutation(_ForwardIterator1 __first1, _ForwardIterator1 __last1,\n               _ForwardIterator2 __first2, _ForwardIterator2 __last2,\n               _BinaryPredicate __pred )\n{\n    return _VSTD::__is_permutation<typename add_lvalue_reference<_BinaryPredicate>::type>\n       (__first1, __last1, __first2, __last2, __pred,\n        typename iterator_traits<_ForwardIterator1>::iterator_category(),\n        typename iterator_traits<_ForwardIterator2>::iterator_category());\n}\n\ntemplate<class _ForwardIterator1, class _ForwardIterator2>\ninline _LIBCPP_INLINE_VISIBILITY\nbool\nis_permutation(_ForwardIterator1 __first1, _ForwardIterator1 __last1,\n               _ForwardIterator2 __first2, _ForwardIterator2 __last2)\n{\n    typedef typename iterator_traits<_ForwardIterator1>::value_type __v1;\n    typedef typename iterator_traits<_ForwardIterator2>::value_type __v2;\n    return _VSTD::__is_permutation(__first1, __last1, __first2, __last2,\n        __equal_to<__v1, __v2>(),\n        typename iterator_traits<_ForwardIterator1>::iterator_category(),\n        typename iterator_traits<_ForwardIterator2>::iterator_category());\n}\n#endif\n\n// search\n\ntemplate <class _BinaryPredicate, class _ForwardIterator1, class _ForwardIterator2>\npair<_ForwardIterator1, _ForwardIterator1>\n__search(_ForwardIterator1 __first1, _ForwardIterator1 __last1,\n         _ForwardIterator2 __first2, _ForwardIterator2 __last2, _BinaryPredicate __pred,\n         forward_iterator_tag, forward_iterator_tag)\n{\n    if (__first2 == __last2)\n        return make_pair(__first1, __first1);  // Everything matches an empty sequence\n    while (true)\n    {\n        // Find first element in sequence 1 that matchs *__first2, with a mininum of loop checks\n        while (true)\n        {\n            if (__first1 == __last1)  // return __last1 if no element matches *__first2\n                return make_pair(__last1, __last1);\n            if (__pred(*__first1, *__first2))\n                break;\n            ++__first1;\n        }\n        // *__first1 matches *__first2, now match elements after here\n        _ForwardIterator1 __m1 = __first1;\n        _ForwardIterator2 __m2 = __first2;\n        while (true)\n        {\n            if (++__m2 == __last2)  // If pattern exhausted, __first1 is the answer (works for 1 element pattern)\n                return make_pair(__first1, __m1);\n            if (++__m1 == __last1)  // Otherwise if source exhaused, pattern not found\n                return make_pair(__last1, __last1);\n            if (!__pred(*__m1, *__m2))  // if there is a mismatch, restart with a new __first1\n            {\n                ++__first1;\n                break;\n            }  // else there is a match, check next elements\n        }\n    }\n}\n\ntemplate <class _BinaryPredicate, class _RandomAccessIterator1, class _RandomAccessIterator2>\n_LIBCPP_CONSTEXPR_AFTER_CXX11\npair<_RandomAccessIterator1, _RandomAccessIterator1>\n__search(_RandomAccessIterator1 __first1, _RandomAccessIterator1 __last1,\n         _RandomAccessIterator2 __first2, _RandomAccessIterator2 __last2, _BinaryPredicate __pred,\n           random_access_iterator_tag, random_access_iterator_tag)\n{\n    typedef typename iterator_traits<_RandomAccessIterator1>::difference_type _D1;\n    typedef typename iterator_traits<_RandomAccessIterator2>::difference_type _D2;\n    // Take advantage of knowing source and pattern lengths.  Stop short when source is smaller than pattern\n    const _D2 __len2 = __last2 - __first2;\n    if (__len2 == 0)\n        return make_pair(__first1, __first1);\n    const _D1 __len1 = __last1 - __first1;\n    if (__len1 < __len2)\n        return make_pair(__last1, __last1);\n    const _RandomAccessIterator1 __s = __last1 - (__len2 - 1);  // Start of pattern match can't go beyond here\n\n    while (true)\n    {\n        while (true)\n        {\n            if (__first1 == __s)\n                return make_pair(__last1, __last1);\n            if (__pred(*__first1, *__first2))\n                break;\n            ++__first1;\n        }\n\n        _RandomAccessIterator1 __m1 = __first1;\n        _RandomAccessIterator2 __m2 = __first2;\n         while (true)\n         {\n             if (++__m2 == __last2)\n                 return make_pair(__first1, __first1 + __len2);\n             ++__m1;          // no need to check range on __m1 because __s guarantees we have enough source\n             if (!__pred(*__m1, *__m2))\n             {\n                 ++__first1;\n                 break;\n             }\n         }\n    }\n}\n\ntemplate <class _ForwardIterator1, class _ForwardIterator2, class _BinaryPredicate>\ninline _LIBCPP_INLINE_VISIBILITY\n_ForwardIterator1\nsearch(_ForwardIterator1 __first1, _ForwardIterator1 __last1,\n       _ForwardIterator2 __first2, _ForwardIterator2 __last2, _BinaryPredicate __pred)\n{\n    return _VSTD::__search<typename add_lvalue_reference<_BinaryPredicate>::type>\n                         (__first1, __last1, __first2, __last2, __pred,\n                          typename iterator_traits<_ForwardIterator1>::iterator_category(),\n                          typename iterator_traits<_ForwardIterator2>::iterator_category())\n            .first;\n}\n\ntemplate <class _ForwardIterator1, class _ForwardIterator2>\ninline _LIBCPP_INLINE_VISIBILITY\n_ForwardIterator1\nsearch(_ForwardIterator1 __first1, _ForwardIterator1 __last1,\n       _ForwardIterator2 __first2, _ForwardIterator2 __last2)\n{\n    typedef typename iterator_traits<_ForwardIterator1>::value_type __v1;\n    typedef typename iterator_traits<_ForwardIterator2>::value_type __v2;\n    return _VSTD::search(__first1, __last1, __first2, __last2, __equal_to<__v1, __v2>());\n}\n\n// search_n\n\ntemplate <class _BinaryPredicate, class _ForwardIterator, class _Size, class _Tp>\n_ForwardIterator\n__search_n(_ForwardIterator __first, _ForwardIterator __last,\n           _Size __count, const _Tp& __value_, _BinaryPredicate __pred, forward_iterator_tag)\n{\n    if (__count <= 0)\n        return __first;\n    while (true)\n    {\n        // Find first element in sequence that matchs __value_, with a mininum of loop checks\n        while (true)\n        {\n            if (__first == __last)  // return __last if no element matches __value_\n                return __last;\n            if (__pred(*__first, __value_))\n                break;\n            ++__first;\n        }\n        // *__first matches __value_, now match elements after here\n        _ForwardIterator __m = __first;\n        _Size __c(0);\n        while (true)\n        {\n            if (++__c == __count)  // If pattern exhausted, __first is the answer (works for 1 element pattern)\n                return __first;\n            if (++__m == __last)  // Otherwise if source exhaused, pattern not found\n                return __last;\n            if (!__pred(*__m, __value_))  // if there is a mismatch, restart with a new __first\n            {\n                __first = __m;\n                ++__first;\n                break;\n            }  // else there is a match, check next elements\n        }\n    }\n}\n\ntemplate <class _BinaryPredicate, class _RandomAccessIterator, class _Size, class _Tp>\n_RandomAccessIterator\n__search_n(_RandomAccessIterator __first, _RandomAccessIterator __last,\n           _Size __count, const _Tp& __value_, _BinaryPredicate __pred, random_access_iterator_tag)\n{\n    if (__count <= 0)\n        return __first;\n    _Size __len = static_cast<_Size>(__last - __first);\n    if (__len < __count)\n        return __last;\n    const _RandomAccessIterator __s = __last - (__count - 1);  // Start of pattern match can't go beyond here\n    while (true)\n    {\n        // Find first element in sequence that matchs __value_, with a mininum of loop checks\n        while (true)\n        {\n            if (__first >= __s)  // return __last if no element matches __value_\n                return __last;\n            if (__pred(*__first, __value_))\n                break;\n            ++__first;\n        }\n        // *__first matches __value_, now match elements after here\n        _RandomAccessIterator __m = __first;\n        _Size __c(0);\n        while (true)\n        {\n            if (++__c == __count)  // If pattern exhausted, __first is the answer (works for 1 element pattern)\n                return __first;\n             ++__m;          // no need to check range on __m because __s guarantees we have enough source\n            if (!__pred(*__m, __value_))  // if there is a mismatch, restart with a new __first\n            {\n                __first = __m;\n                ++__first;\n                break;\n            }  // else there is a match, check next elements\n        }\n    }\n}\n\ntemplate <class _ForwardIterator, class _Size, class _Tp, class _BinaryPredicate>\ninline _LIBCPP_INLINE_VISIBILITY\n_ForwardIterator\nsearch_n(_ForwardIterator __first, _ForwardIterator __last,\n         _Size __count, const _Tp& __value_, _BinaryPredicate __pred)\n{\n    return _VSTD::__search_n<typename add_lvalue_reference<_BinaryPredicate>::type>\n           (__first, __last, __convert_to_integral(__count), __value_, __pred,\n           typename iterator_traits<_ForwardIterator>::iterator_category());\n}\n\ntemplate <class _ForwardIterator, class _Size, class _Tp>\ninline _LIBCPP_INLINE_VISIBILITY\n_ForwardIterator\nsearch_n(_ForwardIterator __first, _ForwardIterator __last, _Size __count, const _Tp& __value_)\n{\n    typedef typename iterator_traits<_ForwardIterator>::value_type __v;\n    return _VSTD::search_n(__first, __last, __convert_to_integral(__count),\n                           __value_, __equal_to<__v, _Tp>());\n}\n\n// copy\ntemplate <class _Iter>\ninline _LIBCPP_INLINE_VISIBILITY\n_Iter\n__unwrap_iter(_Iter __i)\n{\n    return __i;\n}\n\ntemplate <class _Tp>\ninline _LIBCPP_INLINE_VISIBILITY\ntypename enable_if\n<\n    is_trivially_copy_assignable<_Tp>::value,\n    _Tp*\n>::type\n__unwrap_iter(move_iterator<_Tp*> __i)\n{\n    return __i.base();\n}\n\n#if _LIBCPP_DEBUG_LEVEL < 2\n\ntemplate <class _Tp>\ninline _LIBCPP_INLINE_VISIBILITY\ntypename enable_if\n<\n    is_trivially_copy_assignable<_Tp>::value,\n    _Tp*\n>::type\n__unwrap_iter(__wrap_iter<_Tp*> __i)\n{\n    return __i.base();\n}\n\n#else\n\ntemplate <class _Tp>\ninline _LIBCPP_INLINE_VISIBILITY\ntypename enable_if\n<\n    is_trivially_copy_assignable<_Tp>::value,\n    __wrap_iter<_Tp*>\n>::type\n__unwrap_iter(__wrap_iter<_Tp*> __i)\n{\n    return __i;\n}\n\n#endif  // _LIBCPP_DEBUG_LEVEL < 2\n\ntemplate <class _InputIterator, class _OutputIterator>\ninline _LIBCPP_INLINE_VISIBILITY\n_OutputIterator\n__copy(_InputIterator __first, _InputIterator __last, _OutputIterator __result)\n{\n    for (; __first != __last; ++__first, (void) ++__result)\n        *__result = *__first;\n    return __result;\n}\n\ntemplate <class _Tp, class _Up>\ninline _LIBCPP_INLINE_VISIBILITY\ntypename enable_if\n<\n    is_same<typename remove_const<_Tp>::type, _Up>::value &&\n    is_trivially_copy_assignable<_Up>::value,\n    _Up*\n>::type\n__copy(_Tp* __first, _Tp* __last, _Up* __result)\n{\n    const size_t __n = static_cast<size_t>(__last - __first);\n    if (__n > 0)\n        _VSTD::memmove(__result, __first, __n * sizeof(_Up));\n    return __result + __n;\n}\n\ntemplate <class _InputIterator, class _OutputIterator>\ninline _LIBCPP_INLINE_VISIBILITY\n_OutputIterator\ncopy(_InputIterator __first, _InputIterator __last, _OutputIterator __result)\n{\n    return _VSTD::__copy(__unwrap_iter(__first), __unwrap_iter(__last), __unwrap_iter(__result));\n}\n\n// copy_backward\n\ntemplate <class _BidirectionalIterator, class _OutputIterator>\ninline _LIBCPP_INLINE_VISIBILITY\n_OutputIterator\n__copy_backward(_BidirectionalIterator __first, _BidirectionalIterator __last, _OutputIterator __result)\n{\n    while (__first != __last)\n        *--__result = *--__last;\n    return __result;\n}\n\ntemplate <class _Tp, class _Up>\ninline _LIBCPP_INLINE_VISIBILITY\ntypename enable_if\n<\n    is_same<typename remove_const<_Tp>::type, _Up>::value &&\n    is_trivially_copy_assignable<_Up>::value,\n    _Up*\n>::type\n__copy_backward(_Tp* __first, _Tp* __last, _Up* __result)\n{\n    const size_t __n = static_cast<size_t>(__last - __first);\n    if (__n > 0)\n    {\n        __result -= __n;\n        _VSTD::memmove(__result, __first, __n * sizeof(_Up));\n    }\n    return __result;\n}\n\ntemplate <class _BidirectionalIterator1, class _BidirectionalIterator2>\ninline _LIBCPP_INLINE_VISIBILITY\n_BidirectionalIterator2\ncopy_backward(_BidirectionalIterator1 __first, _BidirectionalIterator1 __last,\n              _BidirectionalIterator2 __result)\n{\n    return _VSTD::__copy_backward(__unwrap_iter(__first),\n                                  __unwrap_iter(__last),\n                                  __unwrap_iter(__result));\n}\n\n// copy_if\n\ntemplate<class _InputIterator, class _OutputIterator, class _Predicate>\ninline _LIBCPP_INLINE_VISIBILITY\n_OutputIterator\ncopy_if(_InputIterator __first, _InputIterator __last,\n        _OutputIterator __result, _Predicate __pred)\n{\n    for (; __first != __last; ++__first)\n    {\n        if (__pred(*__first))\n        {\n            *__result = *__first;\n            ++__result;\n        }\n    }\n    return __result;\n}\n\n// copy_n\n\ntemplate<class _InputIterator, class _Size, class _OutputIterator>\ninline _LIBCPP_INLINE_VISIBILITY\ntypename enable_if\n<\n    __is_input_iterator<_InputIterator>::value &&\n   !__is_random_access_iterator<_InputIterator>::value,\n    _OutputIterator\n>::type\ncopy_n(_InputIterator __first, _Size __orig_n, _OutputIterator __result)\n{\n    typedef decltype(__convert_to_integral(__orig_n)) _IntegralSize;\n    _IntegralSize __n = __orig_n;\n    if (__n > 0)\n    {\n        *__result = *__first;\n        ++__result;\n        for (--__n; __n > 0; --__n)\n        {\n            ++__first;\n            *__result = *__first;\n            ++__result;\n        }\n    }\n    return __result;\n}\n\ntemplate<class _InputIterator, class _Size, class _OutputIterator>\ninline _LIBCPP_INLINE_VISIBILITY\ntypename enable_if\n<\n    __is_random_access_iterator<_InputIterator>::value,\n    _OutputIterator\n>::type\ncopy_n(_InputIterator __first, _Size __orig_n, _OutputIterator __result)\n{\n    typedef decltype(__convert_to_integral(__orig_n)) _IntegralSize;\n    _IntegralSize __n = __orig_n;\n    return _VSTD::copy(__first, __first + __n, __result);\n}\n\n// move\n\ntemplate <class _InputIterator, class _OutputIterator>\ninline _LIBCPP_INLINE_VISIBILITY\n_OutputIterator\n__move(_InputIterator __first, _InputIterator __last, _OutputIterator __result)\n{\n    for (; __first != __last; ++__first, (void) ++__result)\n        *__result = _VSTD::move(*__first);\n    return __result;\n}\n\ntemplate <class _Tp, class _Up>\ninline _LIBCPP_INLINE_VISIBILITY\ntypename enable_if\n<\n    is_same<typename remove_const<_Tp>::type, _Up>::value &&\n    is_trivially_copy_assignable<_Up>::value,\n    _Up*\n>::type\n__move(_Tp* __first, _Tp* __last, _Up* __result)\n{\n    const size_t __n = static_cast<size_t>(__last - __first);\n    if (__n > 0)\n        _VSTD::memmove(__result, __first, __n * sizeof(_Up));\n    return __result + __n;\n}\n\ntemplate <class _InputIterator, class _OutputIterator>\ninline _LIBCPP_INLINE_VISIBILITY\n_OutputIterator\nmove(_InputIterator __first, _InputIterator __last, _OutputIterator __result)\n{\n    return _VSTD::__move(__unwrap_iter(__first), __unwrap_iter(__last), __unwrap_iter(__result));\n}\n\n// move_backward\n\ntemplate <class _InputIterator, class _OutputIterator>\ninline _LIBCPP_INLINE_VISIBILITY\n_OutputIterator\n__move_backward(_InputIterator __first, _InputIterator __last, _OutputIterator __result)\n{\n    while (__first != __last)\n        *--__result = _VSTD::move(*--__last);\n    return __result;\n}\n\ntemplate <class _Tp, class _Up>\ninline _LIBCPP_INLINE_VISIBILITY\ntypename enable_if\n<\n    is_same<typename remove_const<_Tp>::type, _Up>::value &&\n    is_trivially_copy_assignable<_Up>::value,\n    _Up*\n>::type\n__move_backward(_Tp* __first, _Tp* __last, _Up* __result)\n{\n    const size_t __n = static_cast<size_t>(__last - __first);\n    if (__n > 0)\n    {\n        __result -= __n;\n        _VSTD::memmove(__result, __first, __n * sizeof(_Up));\n    }\n    return __result;\n}\n\ntemplate <class _BidirectionalIterator1, class _BidirectionalIterator2>\ninline _LIBCPP_INLINE_VISIBILITY\n_BidirectionalIterator2\nmove_backward(_BidirectionalIterator1 __first, _BidirectionalIterator1 __last,\n              _BidirectionalIterator2 __result)\n{\n    return _VSTD::__move_backward(__unwrap_iter(__first), __unwrap_iter(__last), __unwrap_iter(__result));\n}\n\n// iter_swap\n\n// moved to <type_traits> for better swap / noexcept support\n\n// transform\n\ntemplate <class _InputIterator, class _OutputIterator, class _UnaryOperation>\ninline _LIBCPP_INLINE_VISIBILITY\n_OutputIterator\ntransform(_InputIterator __first, _InputIterator __last, _OutputIterator __result, _UnaryOperation __op)\n{\n    for (; __first != __last; ++__first, (void) ++__result)\n        *__result = __op(*__first);\n    return __result;\n}\n\ntemplate <class _InputIterator1, class _InputIterator2, class _OutputIterator, class _BinaryOperation>\ninline _LIBCPP_INLINE_VISIBILITY\n_OutputIterator\ntransform(_InputIterator1 __first1, _InputIterator1 __last1, _InputIterator2 __first2,\n          _OutputIterator __result, _BinaryOperation __binary_op)\n{\n    for (; __first1 != __last1; ++__first1, (void) ++__first2, ++__result)\n        *__result = __binary_op(*__first1, *__first2);\n    return __result;\n}\n\n// replace\n\ntemplate <class _ForwardIterator, class _Tp>\ninline _LIBCPP_INLINE_VISIBILITY\nvoid\nreplace(_ForwardIterator __first, _ForwardIterator __last, const _Tp& __old_value, const _Tp& __new_value)\n{\n    for (; __first != __last; ++__first)\n        if (*__first == __old_value)\n            *__first = __new_value;\n}\n\n// replace_if\n\ntemplate <class _ForwardIterator, class _Predicate, class _Tp>\ninline _LIBCPP_INLINE_VISIBILITY\nvoid\nreplace_if(_ForwardIterator __first, _ForwardIterator __last, _Predicate __pred, const _Tp& __new_value)\n{\n    for (; __first != __last; ++__first)\n        if (__pred(*__first))\n            *__first = __new_value;\n}\n\n// replace_copy\n\ntemplate <class _InputIterator, class _OutputIterator, class _Tp>\ninline _LIBCPP_INLINE_VISIBILITY\n_OutputIterator\nreplace_copy(_InputIterator __first, _InputIterator __last, _OutputIterator __result,\n             const _Tp& __old_value, const _Tp& __new_value)\n{\n    for (; __first != __last; ++__first, (void) ++__result)\n        if (*__first == __old_value)\n            *__result = __new_value;\n        else\n            *__result = *__first;\n    return __result;\n}\n\n// replace_copy_if\n\ntemplate <class _InputIterator, class _OutputIterator, class _Predicate, class _Tp>\ninline _LIBCPP_INLINE_VISIBILITY\n_OutputIterator\nreplace_copy_if(_InputIterator __first, _InputIterator __last, _OutputIterator __result,\n                _Predicate __pred, const _Tp& __new_value)\n{\n    for (; __first != __last; ++__first, (void) ++__result)\n        if (__pred(*__first))\n            *__result = __new_value;\n        else\n            *__result = *__first;\n    return __result;\n}\n\n// fill_n\n\ntemplate <class _OutputIterator, class _Size, class _Tp>\ninline _LIBCPP_INLINE_VISIBILITY\n_OutputIterator\n__fill_n(_OutputIterator __first, _Size __n, const _Tp& __value_)\n{\n    for (; __n > 0; ++__first, (void) --__n)\n        *__first = __value_;\n    return __first;\n}\n\ntemplate <class _Tp, class _Size, class _Up>\ninline _LIBCPP_INLINE_VISIBILITY\ntypename enable_if\n<\n    is_integral<_Tp>::value && sizeof(_Tp) == 1 &&\n    !is_same<_Tp, bool>::value &&\n    is_integral<_Up>::value && sizeof(_Up) == 1,\n    _Tp*\n>::type\n__fill_n(_Tp* __first, _Size __n,_Up __value_)\n{\n    if (__n > 0)\n        _VSTD::memset(__first, (unsigned char)__value_, (size_t)(__n));\n    return __first + __n;\n}\n\ntemplate <class _OutputIterator, class _Size, class _Tp>\ninline _LIBCPP_INLINE_VISIBILITY\n_OutputIterator\nfill_n(_OutputIterator __first, _Size __n, const _Tp& __value_)\n{\n   return _VSTD::__fill_n(__first, __convert_to_integral(__n), __value_);\n}\n\n// fill\n\ntemplate <class _ForwardIterator, class _Tp>\ninline _LIBCPP_INLINE_VISIBILITY\nvoid\n__fill(_ForwardIterator __first, _ForwardIterator __last, const _Tp& __value_, forward_iterator_tag)\n{\n    for (; __first != __last; ++__first)\n        *__first = __value_;\n}\n\ntemplate <class _RandomAccessIterator, class _Tp>\ninline _LIBCPP_INLINE_VISIBILITY\nvoid\n__fill(_RandomAccessIterator __first, _RandomAccessIterator __last, const _Tp& __value_, random_access_iterator_tag)\n{\n    _VSTD::fill_n(__first, __last - __first, __value_);\n}\n\ntemplate <class _ForwardIterator, class _Tp>\ninline _LIBCPP_INLINE_VISIBILITY\nvoid\nfill(_ForwardIterator __first, _ForwardIterator __last, const _Tp& __value_)\n{\n    _VSTD::__fill(__first, __last, __value_, typename iterator_traits<_ForwardIterator>::iterator_category());\n}\n\n// generate\n\ntemplate <class _ForwardIterator, class _Generator>\ninline _LIBCPP_INLINE_VISIBILITY\nvoid\ngenerate(_ForwardIterator __first, _ForwardIterator __last, _Generator __gen)\n{\n    for (; __first != __last; ++__first)\n        *__first = __gen();\n}\n\n// generate_n\n\ntemplate <class _OutputIterator, class _Size, class _Generator>\ninline _LIBCPP_INLINE_VISIBILITY\n_OutputIterator\ngenerate_n(_OutputIterator __first, _Size __orig_n, _Generator __gen)\n{\n    typedef decltype(__convert_to_integral(__orig_n)) _IntegralSize;\n    _IntegralSize __n = __orig_n;\n    for (; __n > 0; ++__first, (void) --__n)\n        *__first = __gen();\n    return __first;\n}\n\n// remove\n\ntemplate <class _ForwardIterator, class _Tp>\n_ForwardIterator\nremove(_ForwardIterator __first, _ForwardIterator __last, const _Tp& __value_)\n{\n    __first = _VSTD::find(__first, __last, __value_);\n    if (__first != __last)\n    {\n        _ForwardIterator __i = __first;\n        while (++__i != __last)\n        {\n            if (!(*__i == __value_))\n            {\n                *__first = _VSTD::move(*__i);\n                ++__first;\n            }\n        }\n    }\n    return __first;\n}\n\n// remove_if\n\ntemplate <class _ForwardIterator, class _Predicate>\n_ForwardIterator\nremove_if(_ForwardIterator __first, _ForwardIterator __last, _Predicate __pred)\n{\n    __first = _VSTD::find_if<_ForwardIterator, typename add_lvalue_reference<_Predicate>::type>\n                           (__first, __last, __pred);\n    if (__first != __last)\n    {\n        _ForwardIterator __i = __first;\n        while (++__i != __last)\n        {\n            if (!__pred(*__i))\n            {\n                *__first = _VSTD::move(*__i);\n                ++__first;\n            }\n        }\n    }\n    return __first;\n}\n\n// remove_copy\n\ntemplate <class _InputIterator, class _OutputIterator, class _Tp>\ninline _LIBCPP_INLINE_VISIBILITY\n_OutputIterator\nremove_copy(_InputIterator __first, _InputIterator __last, _OutputIterator __result, const _Tp& __value_)\n{\n    for (; __first != __last; ++__first)\n    {\n        if (!(*__first == __value_))\n        {\n            *__result = *__first;\n            ++__result;\n        }\n    }\n    return __result;\n}\n\n// remove_copy_if\n\ntemplate <class _InputIterator, class _OutputIterator, class _Predicate>\ninline _LIBCPP_INLINE_VISIBILITY\n_OutputIterator\nremove_copy_if(_InputIterator __first, _InputIterator __last, _OutputIterator __result, _Predicate __pred)\n{\n    for (; __first != __last; ++__first)\n    {\n        if (!__pred(*__first))\n        {\n            *__result = *__first;\n            ++__result;\n        }\n    }\n    return __result;\n}\n\n// unique\n\ntemplate <class _ForwardIterator, class _BinaryPredicate>\n_ForwardIterator\nunique(_ForwardIterator __first, _ForwardIterator __last, _BinaryPredicate __pred)\n{\n    __first = _VSTD::adjacent_find<_ForwardIterator, typename add_lvalue_reference<_BinaryPredicate>::type>\n                                 (__first, __last, __pred);\n    if (__first != __last)\n    {\n        // ...  a  a  ?  ...\n        //      f     i\n        _ForwardIterator __i = __first;\n        for (++__i; ++__i != __last;)\n            if (!__pred(*__first, *__i))\n                *++__first = _VSTD::move(*__i);\n        ++__first;\n    }\n    return __first;\n}\n\ntemplate <class _ForwardIterator>\ninline _LIBCPP_INLINE_VISIBILITY\n_ForwardIterator\nunique(_ForwardIterator __first, _ForwardIterator __last)\n{\n    typedef typename iterator_traits<_ForwardIterator>::value_type __v;\n    return _VSTD::unique(__first, __last, __equal_to<__v>());\n}\n\n// unique_copy\n\ntemplate <class _BinaryPredicate, class _InputIterator, class _OutputIterator>\n_OutputIterator\n__unique_copy(_InputIterator __first, _InputIterator __last, _OutputIterator __result, _BinaryPredicate __pred,\n              input_iterator_tag, output_iterator_tag)\n{\n    if (__first != __last)\n    {\n        typename iterator_traits<_InputIterator>::value_type __t(*__first);\n        *__result = __t;\n        ++__result;\n        while (++__first != __last)\n        {\n            if (!__pred(__t, *__first))\n            {\n                __t = *__first;\n                *__result = __t;\n                ++__result;\n            }\n        }\n    }\n    return __result;\n}\n\ntemplate <class _BinaryPredicate, class _ForwardIterator, class _OutputIterator>\n_OutputIterator\n__unique_copy(_ForwardIterator __first, _ForwardIterator __last, _OutputIterator __result, _BinaryPredicate __pred,\n              forward_iterator_tag, output_iterator_tag)\n{\n    if (__first != __last)\n    {\n        _ForwardIterator __i = __first;\n        *__result = *__i;\n        ++__result;\n        while (++__first != __last)\n        {\n            if (!__pred(*__i, *__first))\n            {\n                *__result = *__first;\n                ++__result;\n                __i = __first;\n            }\n        }\n    }\n    return __result;\n}\n\ntemplate <class _BinaryPredicate, class _InputIterator, class _ForwardIterator>\n_ForwardIterator\n__unique_copy(_InputIterator __first, _InputIterator __last, _ForwardIterator __result, _BinaryPredicate __pred,\n              input_iterator_tag, forward_iterator_tag)\n{\n    if (__first != __last)\n    {\n        *__result = *__first;\n        while (++__first != __last)\n            if (!__pred(*__result, *__first))\n                *++__result = *__first;\n        ++__result;\n    }\n    return __result;\n}\n\ntemplate <class _InputIterator, class _OutputIterator, class _BinaryPredicate>\ninline _LIBCPP_INLINE_VISIBILITY\n_OutputIterator\nunique_copy(_InputIterator __first, _InputIterator __last, _OutputIterator __result, _BinaryPredicate __pred)\n{\n    return _VSTD::__unique_copy<typename add_lvalue_reference<_BinaryPredicate>::type>\n                              (__first, __last, __result, __pred,\n                               typename iterator_traits<_InputIterator>::iterator_category(),\n                               typename iterator_traits<_OutputIterator>::iterator_category());\n}\n\ntemplate <class _InputIterator, class _OutputIterator>\ninline _LIBCPP_INLINE_VISIBILITY\n_OutputIterator\nunique_copy(_InputIterator __first, _InputIterator __last, _OutputIterator __result)\n{\n    typedef typename iterator_traits<_InputIterator>::value_type __v;\n    return _VSTD::unique_copy(__first, __last, __result, __equal_to<__v>());\n}\n\n// reverse\n\ntemplate <class _BidirectionalIterator>\ninline _LIBCPP_INLINE_VISIBILITY\nvoid\n__reverse(_BidirectionalIterator __first, _BidirectionalIterator __last, bidirectional_iterator_tag)\n{\n    while (__first != __last)\n    {\n        if (__first == --__last)\n            break;\n        _VSTD::iter_swap(__first, __last);\n        ++__first;\n    }\n}\n\ntemplate <class _RandomAccessIterator>\ninline _LIBCPP_INLINE_VISIBILITY\nvoid\n__reverse(_RandomAccessIterator __first, _RandomAccessIterator __last, random_access_iterator_tag)\n{\n    if (__first != __last)\n        for (; __first < --__last; ++__first)\n            _VSTD::iter_swap(__first, __last);\n}\n\ntemplate <class _BidirectionalIterator>\ninline _LIBCPP_INLINE_VISIBILITY\nvoid\nreverse(_BidirectionalIterator __first, _BidirectionalIterator __last)\n{\n    _VSTD::__reverse(__first, __last, typename iterator_traits<_BidirectionalIterator>::iterator_category());\n}\n\n// reverse_copy\n\ntemplate <class _BidirectionalIterator, class _OutputIterator>\ninline _LIBCPP_INLINE_VISIBILITY\n_OutputIterator\nreverse_copy(_BidirectionalIterator __first, _BidirectionalIterator __last, _OutputIterator __result)\n{\n    for (; __first != __last; ++__result)\n        *__result = *--__last;\n    return __result;\n}\n\n// rotate\n\ntemplate <class _ForwardIterator>\n_ForwardIterator\n__rotate_left(_ForwardIterator __first, _ForwardIterator __last)\n{\n    typedef typename iterator_traits<_ForwardIterator>::value_type value_type;\n    value_type __tmp = _VSTD::move(*__first);\n    _ForwardIterator __lm1 = _VSTD::move(_VSTD::next(__first), __last, __first);\n    *__lm1 = _VSTD::move(__tmp);\n    return __lm1;\n}\n\ntemplate <class _BidirectionalIterator>\n_BidirectionalIterator\n__rotate_right(_BidirectionalIterator __first, _BidirectionalIterator __last)\n{\n    typedef typename iterator_traits<_BidirectionalIterator>::value_type value_type;\n    _BidirectionalIterator __lm1 = _VSTD::prev(__last);\n    value_type __tmp = _VSTD::move(*__lm1);\n    _BidirectionalIterator __fp1 = _VSTD::move_backward(__first, __lm1, __last);\n    *__first = _VSTD::move(__tmp);\n    return __fp1;\n}\n\ntemplate <class _ForwardIterator>\n_ForwardIterator\n__rotate_forward(_ForwardIterator __first, _ForwardIterator __middle, _ForwardIterator __last)\n{\n    _ForwardIterator __i = __middle;\n    while (true)\n    {\n        swap(*__first, *__i);\n        ++__first;\n        if (++__i == __last)\n            break;\n        if (__first == __middle)\n            __middle = __i;\n    }\n    _ForwardIterator __r = __first;\n    if (__first != __middle)\n    {\n        __i = __middle;\n        while (true)\n        {\n            swap(*__first, *__i);\n            ++__first;\n            if (++__i == __last)\n            {\n                if (__first == __middle)\n                    break;\n                __i = __middle;\n            }\n            else if (__first == __middle)\n                __middle = __i;\n        }\n    }\n    return __r;\n}\n\ntemplate<typename _Integral>\ninline _LIBCPP_INLINE_VISIBILITY\n_Integral\n__algo_gcd(_Integral __x, _Integral __y)\n{\n    do\n    {\n        _Integral __t = __x % __y;\n        __x = __y;\n        __y = __t;\n    } while (__y);\n    return __x;\n}\n\ntemplate<typename _RandomAccessIterator>\n_RandomAccessIterator\n__rotate_gcd(_RandomAccessIterator __first, _RandomAccessIterator __middle, _RandomAccessIterator __last)\n{\n    typedef typename iterator_traits<_RandomAccessIterator>::difference_type difference_type;\n    typedef typename iterator_traits<_RandomAccessIterator>::value_type value_type;\n\n    const difference_type __m1 = __middle - __first;\n    const difference_type __m2 = __last - __middle;\n    if (__m1 == __m2)\n    {\n        _VSTD::swap_ranges(__first, __middle, __middle);\n        return __middle;\n    }\n    const difference_type __g = _VSTD::__algo_gcd(__m1, __m2);\n    for (_RandomAccessIterator __p = __first + __g; __p != __first;)\n    {\n        value_type __t(_VSTD::move(*--__p));\n        _RandomAccessIterator __p1 = __p;\n        _RandomAccessIterator __p2 = __p1 + __m1;\n        do\n        {\n            *__p1 = _VSTD::move(*__p2);\n            __p1 = __p2;\n            const difference_type __d = __last - __p2;\n            if (__m1 < __d)\n                __p2 += __m1;\n            else\n                __p2 = __first + (__m1 - __d);\n        } while (__p2 != __p);\n        *__p1 = _VSTD::move(__t);\n    }\n    return __first + __m2;\n}\n\ntemplate <class _ForwardIterator>\ninline _LIBCPP_INLINE_VISIBILITY\n_ForwardIterator\n__rotate(_ForwardIterator __first, _ForwardIterator __middle, _ForwardIterator __last,\n         _VSTD::forward_iterator_tag)\n{\n    typedef typename _VSTD::iterator_traits<_ForwardIterator>::value_type value_type;\n    if (_VSTD::is_trivially_move_assignable<value_type>::value)\n    {\n        if (_VSTD::next(__first) == __middle)\n            return _VSTD::__rotate_left(__first, __last);\n    }\n    return _VSTD::__rotate_forward(__first, __middle, __last);\n}\n\ntemplate <class _BidirectionalIterator>\ninline _LIBCPP_INLINE_VISIBILITY\n_BidirectionalIterator\n__rotate(_BidirectionalIterator __first, _BidirectionalIterator __middle, _BidirectionalIterator __last,\n         _VSTD::bidirectional_iterator_tag)\n{\n    typedef typename _VSTD::iterator_traits<_BidirectionalIterator>::value_type value_type;\n    if (_VSTD::is_trivially_move_assignable<value_type>::value)\n    {\n        if (_VSTD::next(__first) == __middle)\n            return _VSTD::__rotate_left(__first, __last);\n        if (_VSTD::next(__middle) == __last)\n            return _VSTD::__rotate_right(__first, __last);\n    }\n    return _VSTD::__rotate_forward(__first, __middle, __last);\n}\n\ntemplate <class _RandomAccessIterator>\ninline _LIBCPP_INLINE_VISIBILITY\n_RandomAccessIterator\n__rotate(_RandomAccessIterator __first, _RandomAccessIterator __middle, _RandomAccessIterator __last,\n         _VSTD::random_access_iterator_tag)\n{\n    typedef typename _VSTD::iterator_traits<_RandomAccessIterator>::value_type value_type;\n    if (_VSTD::is_trivially_move_assignable<value_type>::value)\n    {\n        if (_VSTD::next(__first) == __middle)\n            return _VSTD::__rotate_left(__first, __last);\n        if (_VSTD::next(__middle) == __last)\n            return _VSTD::__rotate_right(__first, __last);\n        return _VSTD::__rotate_gcd(__first, __middle, __last);\n    }\n    return _VSTD::__rotate_forward(__first, __middle, __last);\n}\n\ntemplate <class _ForwardIterator>\ninline _LIBCPP_INLINE_VISIBILITY\n_ForwardIterator\nrotate(_ForwardIterator __first, _ForwardIterator __middle, _ForwardIterator __last)\n{\n    if (__first == __middle)\n        return __last;\n    if (__middle == __last)\n        return __first;\n    return _VSTD::__rotate(__first, __middle, __last,\n                           typename _VSTD::iterator_traits<_ForwardIterator>::iterator_category());\n}\n\n// rotate_copy\n\ntemplate <class _ForwardIterator, class _OutputIterator>\ninline _LIBCPP_INLINE_VISIBILITY\n_OutputIterator\nrotate_copy(_ForwardIterator __first, _ForwardIterator __middle, _ForwardIterator __last, _OutputIterator __result)\n{\n    return _VSTD::copy(__first, __middle, _VSTD::copy(__middle, __last, __result));\n}\n\n// min_element\n\ntemplate <class _ForwardIterator, class _Compare>\ninline _LIBCPP_INLINE_VISIBILITY _LIBCPP_CONSTEXPR_AFTER_CXX11\n_ForwardIterator\nmin_element(_ForwardIterator __first, _ForwardIterator __last, _Compare __comp)\n{\n    if (__first != __last)\n    {\n        _ForwardIterator __i = __first;\n        while (++__i != __last)\n            if (__comp(*__i, *__first))\n                __first = __i;\n    }\n    return __first;\n}\n\ntemplate <class _ForwardIterator>\ninline _LIBCPP_INLINE_VISIBILITY _LIBCPP_CONSTEXPR_AFTER_CXX11\n_ForwardIterator\nmin_element(_ForwardIterator __first, _ForwardIterator __last)\n{\n    return _VSTD::min_element(__first, __last,\n              __less<typename iterator_traits<_ForwardIterator>::value_type>());\n}\n\n// min\n\ntemplate <class _Tp, class _Compare>\ninline _LIBCPP_INLINE_VISIBILITY _LIBCPP_CONSTEXPR_AFTER_CXX11\nconst _Tp&\nmin(const _Tp& __a, const _Tp& __b, _Compare __comp)\n{\n    return __comp(__b, __a) ? __b : __a;\n}\n\ntemplate <class _Tp>\ninline _LIBCPP_INLINE_VISIBILITY _LIBCPP_CONSTEXPR_AFTER_CXX11\nconst _Tp&\nmin(const _Tp& __a, const _Tp& __b)\n{\n    return _VSTD::min(__a, __b, __less<_Tp>());\n}\n\n#ifndef _LIBCPP_HAS_NO_GENERALIZED_INITIALIZERS\n\ntemplate<class _Tp, class _Compare>\ninline _LIBCPP_INLINE_VISIBILITY _LIBCPP_CONSTEXPR_AFTER_CXX11\n_Tp\nmin(initializer_list<_Tp> __t, _Compare __comp)\n{\n    return *_VSTD::min_element(__t.begin(), __t.end(), __comp);\n}\n\ntemplate<class _Tp>\ninline _LIBCPP_INLINE_VISIBILITY _LIBCPP_CONSTEXPR_AFTER_CXX11\n_Tp\nmin(initializer_list<_Tp> __t)\n{\n    return *_VSTD::min_element(__t.begin(), __t.end(), __less<_Tp>());\n}\n\n#endif  // _LIBCPP_HAS_NO_GENERALIZED_INITIALIZERS\n\n// max_element\n\ntemplate <class _ForwardIterator, class _Compare>\ninline _LIBCPP_INLINE_VISIBILITY _LIBCPP_CONSTEXPR_AFTER_CXX11\n_ForwardIterator\nmax_element(_ForwardIterator __first, _ForwardIterator __last, _Compare __comp)\n{\n    if (__first != __last)\n    {\n        _ForwardIterator __i = __first;\n        while (++__i != __last)\n            if (__comp(*__first, *__i))\n                __first = __i;\n    }\n    return __first;\n}\n\n\ntemplate <class _ForwardIterator>\ninline _LIBCPP_INLINE_VISIBILITY _LIBCPP_CONSTEXPR_AFTER_CXX11\n_ForwardIterator\nmax_element(_ForwardIterator __first, _ForwardIterator __last)\n{\n    return _VSTD::max_element(__first, __last,\n              __less<typename iterator_traits<_ForwardIterator>::value_type>());\n}\n\n// max\n\ntemplate <class _Tp, class _Compare>\ninline _LIBCPP_INLINE_VISIBILITY _LIBCPP_CONSTEXPR_AFTER_CXX11\nconst _Tp&\nmax(const _Tp& __a, const _Tp& __b, _Compare __comp)\n{\n    return __comp(__a, __b) ? __b : __a;\n}\n\ntemplate <class _Tp>\ninline _LIBCPP_INLINE_VISIBILITY _LIBCPP_CONSTEXPR_AFTER_CXX11\nconst _Tp&\nmax(const _Tp& __a, const _Tp& __b)\n{\n    return _VSTD::max(__a, __b, __less<_Tp>());\n}\n\n#ifndef _LIBCPP_HAS_NO_GENERALIZED_INITIALIZERS\n\ntemplate<class _Tp, class _Compare>\ninline _LIBCPP_INLINE_VISIBILITY _LIBCPP_CONSTEXPR_AFTER_CXX11\n_Tp\nmax(initializer_list<_Tp> __t, _Compare __comp)\n{\n    return *_VSTD::max_element(__t.begin(), __t.end(), __comp);\n}\n\ntemplate<class _Tp>\ninline _LIBCPP_INLINE_VISIBILITY _LIBCPP_CONSTEXPR_AFTER_CXX11\n_Tp\nmax(initializer_list<_Tp> __t)\n{\n    return *_VSTD::max_element(__t.begin(), __t.end(), __less<_Tp>());\n}\n\n#endif  // _LIBCPP_HAS_NO_GENERALIZED_INITIALIZERS\n\n#if _LIBCPP_STD_VER > 14\n// clamp\ntemplate<class _Tp, class _Compare>\ninline _LIBCPP_INLINE_VISIBILITY _LIBCPP_CONSTEXPR\nconst _Tp&\nclamp(const _Tp& __v, const _Tp& __lo, const _Tp& __hi, _Compare __comp)\n{\n    _LIBCPP_ASSERT(!__comp(__hi, __lo), \"Bad bounds passed to std::clamp\");\n    return __comp(__v, __lo) ? __lo : __comp(__hi, __v) ? __hi : __v;\n\n}\n\ntemplate<class _Tp>\ninline _LIBCPP_INLINE_VISIBILITY _LIBCPP_CONSTEXPR\nconst _Tp&\nclamp(const _Tp& __v, const _Tp& __lo, const _Tp& __hi)\n{\n    return _VSTD::clamp(__v, __lo, __hi, __less<_Tp>());\n}\n#endif\n\n// minmax_element\n\ntemplate <class _ForwardIterator, class _Compare>\n_LIBCPP_CONSTEXPR_AFTER_CXX11\nstd::pair<_ForwardIterator, _ForwardIterator>\nminmax_element(_ForwardIterator __first, _ForwardIterator __last, _Compare __comp)\n{\n  std::pair<_ForwardIterator, _ForwardIterator> __result(__first, __first);\n  if (__first != __last)\n  {\n      if (++__first != __last)\n      {\n          if (__comp(*__first, *__result.first))\n              __result.first = __first;\n          else\n              __result.second = __first;\n          while (++__first != __last)\n          {\n              _ForwardIterator __i = __first;\n              if (++__first == __last)\n              {\n                  if (__comp(*__i, *__result.first))\n                      __result.first = __i;\n                  else if (!__comp(*__i, *__result.second))\n                      __result.second = __i;\n                  break;\n              }\n              else\n              {\n                  if (__comp(*__first, *__i))\n                  {\n                      if (__comp(*__first, *__result.first))\n                          __result.first = __first;\n                      if (!__comp(*__i, *__result.second))\n                          __result.second = __i;\n                  }\n                  else\n                  {\n                      if (__comp(*__i, *__result.first))\n                          __result.first = __i;\n                      if (!__comp(*__first, *__result.second))\n                          __result.second = __first;\n                  }\n              }\n          }\n      }\n  }\n  return __result;\n}\n\ntemplate <class _ForwardIterator>\ninline _LIBCPP_INLINE_VISIBILITY _LIBCPP_CONSTEXPR_AFTER_CXX11\nstd::pair<_ForwardIterator, _ForwardIterator>\nminmax_element(_ForwardIterator __first, _ForwardIterator __last)\n{\n    return _VSTD::minmax_element(__first, __last,\n              __less<typename iterator_traits<_ForwardIterator>::value_type>());\n}\n\n// minmax\n\ntemplate<class _Tp, class _Compare>\ninline _LIBCPP_INLINE_VISIBILITY _LIBCPP_CONSTEXPR_AFTER_CXX11\npair<const _Tp&, const _Tp&>\nminmax(const _Tp& __a, const _Tp& __b, _Compare __comp)\n{\n    return __comp(__b, __a) ? pair<const _Tp&, const _Tp&>(__b, __a) :\n                              pair<const _Tp&, const _Tp&>(__a, __b);\n}\n\ntemplate<class _Tp>\ninline _LIBCPP_INLINE_VISIBILITY _LIBCPP_CONSTEXPR_AFTER_CXX11\npair<const _Tp&, const _Tp&>\nminmax(const _Tp& __a, const _Tp& __b)\n{\n    return _VSTD::minmax(__a, __b, __less<_Tp>());\n}\n\n#ifndef _LIBCPP_HAS_NO_GENERALIZED_INITIALIZERS\n\ntemplate<class _Tp, class _Compare>\ninline _LIBCPP_INLINE_VISIBILITY _LIBCPP_CONSTEXPR_AFTER_CXX11\npair<_Tp, _Tp>\nminmax(initializer_list<_Tp> __t, _Compare __comp)\n{\n    typedef typename initializer_list<_Tp>::const_iterator _Iter;\n    _Iter __first = __t.begin();\n    _Iter __last  = __t.end();\n    std::pair<_Tp, _Tp> __result(*__first, *__first);\n\n    ++__first;\n    if (__t.size() % 2 == 0)\n    {\n        if (__comp(*__first,  __result.first))\n            __result.first  = *__first;\n        else\n            __result.second = *__first;\n        ++__first;\n    }\n\n    while (__first != __last)\n    {\n        _Tp __prev = *__first++;\n        if (__comp(*__first, __prev)) {\n            if ( __comp(*__first, __result.first)) __result.first  = *__first;\n            if (!__comp(__prev, __result.second))  __result.second = __prev;\n            }\n        else {\n            if ( __comp(__prev, __result.first))    __result.first  = __prev;\n            if (!__comp(*__first, __result.second)) __result.second = *__first;\n            }\n\n        __first++;\n    }\n    return __result;\n}\n\ntemplate<class _Tp>\ninline _LIBCPP_INLINE_VISIBILITY _LIBCPP_CONSTEXPR_AFTER_CXX11\npair<_Tp, _Tp>\nminmax(initializer_list<_Tp> __t)\n{\n    return _VSTD::minmax(__t, __less<_Tp>());\n}\n\n#endif  // _LIBCPP_HAS_NO_GENERALIZED_INITIALIZERS\n\n// random_shuffle\n\n// __independent_bits_engine\n\ntemplate <unsigned long long _Xp, size_t _Rp>\nstruct __log2_imp\n{\n    static const size_t value = _Xp & ((unsigned long long)(1) << _Rp) ? _Rp\n                                           : __log2_imp<_Xp, _Rp - 1>::value;\n};\n\ntemplate <unsigned long long _Xp>\nstruct __log2_imp<_Xp, 0>\n{\n    static const size_t value = 0;\n};\n\ntemplate <size_t _Rp>\nstruct __log2_imp<0, _Rp>\n{\n    static const size_t value = _Rp + 1;\n};\n\ntemplate <class _UI, _UI _Xp>\nstruct __log2\n{\n    static const size_t value = __log2_imp<_Xp,\n                                         sizeof(_UI) * __CHAR_BIT__ - 1>::value;\n};\n\ntemplate<class _Engine, class _UIntType>\nclass __independent_bits_engine\n{\npublic:\n    // types\n    typedef _UIntType result_type;\n\nprivate:\n    typedef typename _Engine::result_type _Engine_result_type;\n    typedef typename conditional\n        <\n            sizeof(_Engine_result_type) <= sizeof(result_type),\n                result_type,\n                _Engine_result_type\n        >::type _Working_result_type;\n\n    _Engine& __e_;\n    size_t __w_;\n    size_t __w0_;\n    size_t __n_;\n    size_t __n0_;\n    _Working_result_type __y0_;\n    _Working_result_type __y1_;\n    _Engine_result_type __mask0_;\n    _Engine_result_type __mask1_;\n\n#ifdef _LIBCPP_HAS_NO_CONSTEXPR\n    static const _Working_result_type _Rp = _Engine::_Max - _Engine::_Min\n                                          + _Working_result_type(1);\n#else\n    static _LIBCPP_CONSTEXPR const _Working_result_type _Rp = _Engine::max() - _Engine::min()\n                                                      + _Working_result_type(1);\n#endif\n    static _LIBCPP_CONSTEXPR const size_t __m = __log2<_Working_result_type, _Rp>::value;\n    static _LIBCPP_CONSTEXPR const size_t _WDt = numeric_limits<_Working_result_type>::digits;\n    static _LIBCPP_CONSTEXPR const size_t _EDt = numeric_limits<_Engine_result_type>::digits;\n\npublic:\n    // constructors and seeding functions\n    __independent_bits_engine(_Engine& __e, size_t __w);\n\n    // generating functions\n    result_type operator()() {return __eval(integral_constant<bool, _Rp != 0>());}\n\nprivate:\n    result_type __eval(false_type);\n    result_type __eval(true_type);\n};\n\ntemplate<class _Engine, class _UIntType>\n__independent_bits_engine<_Engine, _UIntType>\n    ::__independent_bits_engine(_Engine& __e, size_t __w)\n        : __e_(__e),\n          __w_(__w)\n{\n    __n_ = __w_ / __m + (__w_ % __m != 0);\n    __w0_ = __w_ / __n_;\n    if (_Rp == 0)\n        __y0_ = _Rp;\n    else if (__w0_ < _WDt)\n        __y0_ = (_Rp >> __w0_) << __w0_;\n    else\n        __y0_ = 0;\n    if (_Rp - __y0_ > __y0_ / __n_)\n    {\n        ++__n_;\n        __w0_ = __w_ / __n_;\n        if (__w0_ < _WDt)\n            __y0_ = (_Rp >> __w0_) << __w0_;\n        else\n            __y0_ = 0;\n    }\n    __n0_ = __n_ - __w_ % __n_;\n    if (__w0_ < _WDt - 1)\n        __y1_ = (_Rp >> (__w0_ + 1)) << (__w0_ + 1);\n    else\n        __y1_ = 0;\n    __mask0_ = __w0_ > 0 ? _Engine_result_type(~0) >> (_EDt - __w0_) :\n                          _Engine_result_type(0);\n    __mask1_ = __w0_ < _EDt - 1 ?\n                               _Engine_result_type(~0) >> (_EDt - (__w0_ + 1)) :\n                               _Engine_result_type(~0);\n}\n\ntemplate<class _Engine, class _UIntType>\ninline\n_UIntType\n__independent_bits_engine<_Engine, _UIntType>::__eval(false_type)\n{\n    return static_cast<result_type>(__e_() & __mask0_);\n}\n\ntemplate<class _Engine, class _UIntType>\n_UIntType\n__independent_bits_engine<_Engine, _UIntType>::__eval(true_type)\n{\n    result_type _Sp = 0;\n    for (size_t __k = 0; __k < __n0_; ++__k)\n    {\n        _Engine_result_type __u;\n        do\n        {\n            __u = __e_() - _Engine::min();\n        } while (__u >= __y0_);\n        if (__w0_ < _WDt)\n            _Sp <<= __w0_;\n        else\n            _Sp = 0;\n        _Sp += __u & __mask0_;\n    }\n    for (size_t __k = __n0_; __k < __n_; ++__k)\n    {\n        _Engine_result_type __u;\n        do\n        {\n            __u = __e_() - _Engine::min();\n        } while (__u >= __y1_);\n        if (__w0_ < _WDt - 1)\n            _Sp <<= __w0_ + 1;\n        else\n            _Sp = 0;\n        _Sp += __u & __mask1_;\n    }\n    return _Sp;\n}\n\n// uniform_int_distribution\n\ntemplate<class _IntType = int>\nclass uniform_int_distribution\n{\npublic:\n    // types\n    typedef _IntType result_type;\n\n    class param_type\n    {\n        result_type __a_;\n        result_type __b_;\n    public:\n        typedef uniform_int_distribution distribution_type;\n\n        explicit param_type(result_type __a = 0,\n                            result_type __b = numeric_limits<result_type>::max())\n            : __a_(__a), __b_(__b) {}\n\n        result_type a() const {return __a_;}\n        result_type b() const {return __b_;}\n\n        friend bool operator==(const param_type& __x, const param_type& __y)\n            {return __x.__a_ == __y.__a_ && __x.__b_ == __y.__b_;}\n        friend bool operator!=(const param_type& __x, const param_type& __y)\n            {return !(__x == __y);}\n    };\n\nprivate:\n    param_type __p_;\n\npublic:\n    // constructors and reset functions\n    explicit uniform_int_distribution(result_type __a = 0,\n                                      result_type __b = numeric_limits<result_type>::max())\n        : __p_(param_type(__a, __b)) {}\n    explicit uniform_int_distribution(const param_type& __p) : __p_(__p) {}\n    void reset() {}\n\n    // generating functions\n    template<class _URNG> result_type operator()(_URNG& __g)\n        {return (*this)(__g, __p_);}\n    template<class _URNG> result_type operator()(_URNG& __g, const param_type& __p);\n\n    // property functions\n    result_type a() const {return __p_.a();}\n    result_type b() const {return __p_.b();}\n\n    param_type param() const {return __p_;}\n    void param(const param_type& __p) {__p_ = __p;}\n\n    result_type min() const {return a();}\n    result_type max() const {return b();}\n\n    friend bool operator==(const uniform_int_distribution& __x,\n                           const uniform_int_distribution& __y)\n        {return __x.__p_ == __y.__p_;}\n    friend bool operator!=(const uniform_int_distribution& __x,\n                           const uniform_int_distribution& __y)\n            {return !(__x == __y);}\n};\n\ntemplate<class _IntType>\ntemplate<class _URNG>\ntypename uniform_int_distribution<_IntType>::result_type\nuniform_int_distribution<_IntType>::operator()(_URNG& __g, const param_type& __p)\n{\n    typedef typename conditional<sizeof(result_type) <= sizeof(uint32_t),\n                                            uint32_t, uint64_t>::type _UIntType;\n    const _UIntType _Rp = __p.b() - __p.a() + _UIntType(1);\n    if (_Rp == 1)\n        return __p.a();\n    const size_t _Dt = numeric_limits<_UIntType>::digits;\n    typedef __independent_bits_engine<_URNG, _UIntType> _Eng;\n    if (_Rp == 0)\n        return static_cast<result_type>(_Eng(__g, _Dt)());\n    size_t __w = _Dt - __clz(_Rp) - 1;\n    if ((_Rp & (std::numeric_limits<_UIntType>::max() >> (_Dt - __w))) != 0)\n        ++__w;\n    _Eng __e(__g, __w);\n    _UIntType __u;\n    do\n    {\n        __u = __e();\n    } while (__u >= _Rp);\n    return static_cast<result_type>(__u + __p.a());\n}\n\nclass _LIBCPP_TYPE_VIS __rs_default;\n\n_LIBCPP_FUNC_VIS __rs_default __rs_get();\n\nclass _LIBCPP_TYPE_VIS __rs_default\n{\n    static unsigned __c_;\n\n    __rs_default();\npublic:\n    typedef uint_fast32_t result_type;\n\n    static const result_type _Min = 0;\n    static const result_type _Max = 0xFFFFFFFF;\n\n    __rs_default(const __rs_default&);\n    ~__rs_default();\n\n    result_type operator()();\n\n    static _LIBCPP_CONSTEXPR result_type min() {return _Min;}\n    static _LIBCPP_CONSTEXPR result_type max() {return _Max;}\n\n    friend _LIBCPP_FUNC_VIS __rs_default __rs_get();\n};\n\n_LIBCPP_FUNC_VIS __rs_default __rs_get();\n\ntemplate <class _RandomAccessIterator>\nvoid\nrandom_shuffle(_RandomAccessIterator __first, _RandomAccessIterator __last)\n{\n    typedef typename iterator_traits<_RandomAccessIterator>::difference_type difference_type;\n    typedef uniform_int_distribution<ptrdiff_t> _Dp;\n    typedef typename _Dp::param_type _Pp;\n    difference_type __d = __last - __first;\n    if (__d > 1)\n    {\n        _Dp __uid;\n        __rs_default __g = __rs_get();\n        for (--__last, --__d; __first < __last; ++__first, --__d)\n        {\n            difference_type __i = __uid(__g, _Pp(0, __d));\n            if (__i != difference_type(0))\n                swap(*__first, *(__first + __i));\n        }\n    }\n}\n\ntemplate <class _RandomAccessIterator, class _RandomNumberGenerator>\nvoid\nrandom_shuffle(_RandomAccessIterator __first, _RandomAccessIterator __last,\n#ifndef _LIBCPP_HAS_NO_RVALUE_REFERENCES\n               _RandomNumberGenerator&& __rand)\n#else\n               _RandomNumberGenerator& __rand)\n#endif\n{\n    typedef typename iterator_traits<_RandomAccessIterator>::difference_type difference_type;\n    difference_type __d = __last - __first;\n    if (__d > 1)\n    {\n        for (--__last; __first < __last; ++__first, --__d)\n        {\n            difference_type __i = __rand(__d);\n            swap(*__first, *(__first + __i));\n        }\n    }\n}\n\ntemplate <class _PopulationIterator, class _SampleIterator, class _Distance,\n          class _UniformRandomNumberGenerator>\n_LIBCPP_INLINE_VISIBILITY\n_SampleIterator __sample(_PopulationIterator __first,\n                         _PopulationIterator __last, _SampleIterator __output,\n                         _Distance __n,\n                         _UniformRandomNumberGenerator & __g,\n                         input_iterator_tag) {\n\n  _Distance __k = 0;\n  for (; __first != __last && __k < __n; ++__first, (void)++__k)\n    __output[__k] = *__first;\n  _Distance __sz = __k;\n  for (; __first != __last; ++__first, (void)++__k) {\n    _Distance __r = _VSTD::uniform_int_distribution<_Distance>(0, __k)(__g);\n    if (__r < __sz)\n      __output[__r] = *__first;\n  }\n  return __output + _VSTD::min(__n, __k);\n}\n\ntemplate <class _PopulationIterator, class _SampleIterator, class _Distance,\n          class _UniformRandomNumberGenerator>\n_LIBCPP_INLINE_VISIBILITY\n_SampleIterator __sample(_PopulationIterator __first,\n                         _PopulationIterator __last, _SampleIterator __output,\n                         _Distance __n,\n                         _UniformRandomNumberGenerator& __g,\n                         forward_iterator_tag) {\n  _Distance __unsampled_sz = _VSTD::distance(__first, __last);\n  for (__n = _VSTD::min(__n, __unsampled_sz); __n != 0; ++__first) {\n    _Distance __r =\n        _VSTD::uniform_int_distribution<_Distance>(0, --__unsampled_sz)(__g);\n    if (__r < __n) {\n      *__output++ = *__first;\n      --__n;\n    }\n  }\n  return __output;\n}\n\ntemplate <class _PopulationIterator, class _SampleIterator, class _Distance,\n          class _UniformRandomNumberGenerator>\n_LIBCPP_INLINE_VISIBILITY\n_SampleIterator __sample(_PopulationIterator __first,\n                         _PopulationIterator __last, _SampleIterator __output,\n                         _Distance __n, _UniformRandomNumberGenerator& __g) {\n  typedef typename iterator_traits<_PopulationIterator>::iterator_category\n        _PopCategory;\n  typedef typename iterator_traits<_PopulationIterator>::difference_type\n        _Difference;\n  static_assert(__is_forward_iterator<_PopulationIterator>::value ||\n                __is_random_access_iterator<_SampleIterator>::value,\n                \"SampleIterator must meet the requirements of RandomAccessIterator\");\n  typedef typename common_type<_Distance, _Difference>::type _CommonType;\n  _LIBCPP_ASSERT(__n >= 0, \"N must be a positive number.\");\n  return _VSTD::__sample(\n      __first, __last, __output, _CommonType(__n),\n      __g, _PopCategory());\n}\n\n#if _LIBCPP_STD_VER > 14\ntemplate <class _PopulationIterator, class _SampleIterator, class _Distance,\n          class _UniformRandomNumberGenerator>\ninline _LIBCPP_INLINE_VISIBILITY\n_SampleIterator sample(_PopulationIterator __first,\n                       _PopulationIterator __last, _SampleIterator __output,\n                       _Distance __n, _UniformRandomNumberGenerator&& __g) {\n    return _VSTD::__sample(__first, __last, __output, __n, __g);\n}\n#endif // _LIBCPP_STD_VER > 14\n\ntemplate<class _RandomAccessIterator, class _UniformRandomNumberGenerator>\n    void shuffle(_RandomAccessIterator __first, _RandomAccessIterator __last,\n#ifndef _LIBCPP_HAS_NO_RVALUE_REFERENCES\n                 _UniformRandomNumberGenerator&& __g)\n#else\n                 _UniformRandomNumberGenerator& __g)\n#endif\n{\n    typedef typename iterator_traits<_RandomAccessIterator>::difference_type difference_type;\n    typedef uniform_int_distribution<ptrdiff_t> _Dp;\n    typedef typename _Dp::param_type _Pp;\n    difference_type __d = __last - __first;\n    if (__d > 1)\n    {\n        _Dp __uid;\n        for (--__last, --__d; __first < __last; ++__first, --__d)\n        {\n            difference_type __i = __uid(__g, _Pp(0, __d));\n            if (__i != difference_type(0))\n                swap(*__first, *(__first + __i));\n        }\n    }\n}\n\ntemplate <class _InputIterator, class _Predicate>\nbool\nis_partitioned(_InputIterator __first, _InputIterator __last, _Predicate __pred)\n{\n    for (; __first != __last; ++__first)\n        if (!__pred(*__first))\n            break;\n    if ( __first == __last )\n        return true;\n    ++__first;\n    for (; __first != __last; ++__first)\n        if (__pred(*__first))\n            return false;\n    return true;\n}\n\n// partition\n\ntemplate <class _Predicate, class _ForwardIterator>\n_ForwardIterator\n__partition(_ForwardIterator __first, _ForwardIterator __last, _Predicate __pred, forward_iterator_tag)\n{\n    while (true)\n    {\n        if (__first == __last)\n            return __first;\n        if (!__pred(*__first))\n            break;\n        ++__first;\n    }\n    for (_ForwardIterator __p = __first; ++__p != __last;)\n    {\n        if (__pred(*__p))\n        {\n            swap(*__first, *__p);\n            ++__first;\n        }\n    }\n    return __first;\n}\n\ntemplate <class _Predicate, class _BidirectionalIterator>\n_BidirectionalIterator\n__partition(_BidirectionalIterator __first, _BidirectionalIterator __last, _Predicate __pred,\n            bidirectional_iterator_tag)\n{\n    while (true)\n    {\n        while (true)\n        {\n            if (__first == __last)\n                return __first;\n            if (!__pred(*__first))\n                break;\n            ++__first;\n        }\n        do\n        {\n            if (__first == --__last)\n                return __first;\n        } while (!__pred(*__last));\n        swap(*__first, *__last);\n        ++__first;\n    }\n}\n\ntemplate <class _ForwardIterator, class _Predicate>\ninline _LIBCPP_INLINE_VISIBILITY\n_ForwardIterator\npartition(_ForwardIterator __first, _ForwardIterator __last, _Predicate __pred)\n{\n    return _VSTD::__partition<typename add_lvalue_reference<_Predicate>::type>\n                            (__first, __last, __pred, typename iterator_traits<_ForwardIterator>::iterator_category());\n}\n\n// partition_copy\n\ntemplate <class _InputIterator, class _OutputIterator1,\n          class _OutputIterator2, class _Predicate>\npair<_OutputIterator1, _OutputIterator2>\npartition_copy(_InputIterator __first, _InputIterator __last,\n               _OutputIterator1 __out_true, _OutputIterator2 __out_false,\n               _Predicate __pred)\n{\n    for (; __first != __last; ++__first)\n    {\n        if (__pred(*__first))\n        {\n            *__out_true = *__first;\n            ++__out_true;\n        }\n        else\n        {\n            *__out_false = *__first;\n            ++__out_false;\n        }\n    }\n    return pair<_OutputIterator1, _OutputIterator2>(__out_true, __out_false);\n}\n\n// partition_point\n\ntemplate<class _ForwardIterator, class _Predicate>\n_ForwardIterator\npartition_point(_ForwardIterator __first, _ForwardIterator __last, _Predicate __pred)\n{\n    typedef typename iterator_traits<_ForwardIterator>::difference_type difference_type;\n    difference_type __len = _VSTD::distance(__first, __last);\n    while (__len != 0)\n    {\n        difference_type __l2 = __len / 2;\n        _ForwardIterator __m = __first;\n        _VSTD::advance(__m, __l2);\n        if (__pred(*__m))\n        {\n            __first = ++__m;\n            __len -= __l2 + 1;\n        }\n        else\n            __len = __l2;\n    }\n    return __first;\n}\n\n// stable_partition\n\ntemplate <class _Predicate, class _ForwardIterator, class _Distance, class _Pair>\n_ForwardIterator\n__stable_partition(_ForwardIterator __first, _ForwardIterator __last, _Predicate __pred,\n                   _Distance __len, _Pair __p, forward_iterator_tag __fit)\n{\n    // *__first is known to be false\n    // __len >= 1\n    if (__len == 1)\n        return __first;\n    if (__len == 2)\n    {\n        _ForwardIterator __m = __first;\n        if (__pred(*++__m))\n        {\n            swap(*__first, *__m);\n            return __m;\n        }\n        return __first;\n    }\n    if (__len <= __p.second)\n    {   // The buffer is big enough to use\n        typedef typename iterator_traits<_ForwardIterator>::value_type value_type;\n        __destruct_n __d(0);\n        unique_ptr<value_type, __destruct_n&> __h(__p.first, __d);\n        // Move the falses into the temporary buffer, and the trues to the front of the line\n        // Update __first to always point to the end of the trues\n        value_type* __t = __p.first;\n        ::new(__t) value_type(_VSTD::move(*__first));\n        __d.__incr((value_type*)0);\n        ++__t;\n        _ForwardIterator __i = __first;\n        while (++__i != __last)\n        {\n            if (__pred(*__i))\n            {\n                *__first = _VSTD::move(*__i);\n                ++__first;\n            }\n            else\n            {\n                ::new(__t) value_type(_VSTD::move(*__i));\n                __d.__incr((value_type*)0);\n                ++__t;\n            }\n        }\n        // All trues now at start of range, all falses in buffer\n        // Move falses back into range, but don't mess up __first which points to first false\n        __i = __first;\n        for (value_type* __t2 = __p.first; __t2 < __t; ++__t2, ++__i)\n            *__i = _VSTD::move(*__t2);\n        // __h destructs moved-from values out of the temp buffer, but doesn't deallocate buffer\n        return __first;\n    }\n    // Else not enough buffer, do in place\n    // __len >= 3\n    _ForwardIterator __m = __first;\n    _Distance __len2 = __len / 2;  // __len2 >= 2\n    _VSTD::advance(__m, __len2);\n    // recurse on [__first, __m), *__first know to be false\n    // F?????????????????\n    // f       m         l\n    typedef typename add_lvalue_reference<_Predicate>::type _PredRef;\n    _ForwardIterator __first_false = __stable_partition<_PredRef>(__first, __m, __pred, __len2, __p, __fit);\n    // TTTFFFFF??????????\n    // f  ff   m         l\n    // recurse on [__m, __last], except increase __m until *(__m) is false, *__last know to be true\n    _ForwardIterator __m1 = __m;\n    _ForwardIterator __second_false = __last;\n    _Distance __len_half = __len - __len2;\n    while (__pred(*__m1))\n    {\n        if (++__m1 == __last)\n            goto __second_half_done;\n        --__len_half;\n    }\n    // TTTFFFFFTTTF??????\n    // f  ff   m  m1     l\n    __second_false = __stable_partition<_PredRef>(__m1, __last, __pred, __len_half, __p, __fit);\n__second_half_done:\n    // TTTFFFFFTTTTTFFFFF\n    // f  ff   m    sf   l\n    return _VSTD::rotate(__first_false, __m, __second_false);\n    // TTTTTTTTFFFFFFFFFF\n    //         |\n}\n\nstruct __return_temporary_buffer\n{\n    template <class _Tp>\n    _LIBCPP_INLINE_VISIBILITY void operator()(_Tp* __p) const {_VSTD::return_temporary_buffer(__p);}\n};\n\ntemplate <class _Predicate, class _ForwardIterator>\n_ForwardIterator\n__stable_partition(_ForwardIterator __first, _ForwardIterator __last, _Predicate __pred,\n                   forward_iterator_tag)\n{\n    const unsigned __alloc_limit = 3;  // might want to make this a function of trivial assignment\n    // Either prove all true and return __first or point to first false\n    while (true)\n    {\n        if (__first == __last)\n            return __first;\n        if (!__pred(*__first))\n            break;\n        ++__first;\n    }\n    // We now have a reduced range [__first, __last)\n    // *__first is known to be false\n    typedef typename iterator_traits<_ForwardIterator>::difference_type difference_type;\n    typedef typename iterator_traits<_ForwardIterator>::value_type value_type;\n    difference_type __len = _VSTD::distance(__first, __last);\n    pair<value_type*, ptrdiff_t> __p(0, 0);\n    unique_ptr<value_type, __return_temporary_buffer> __h;\n    if (__len >= __alloc_limit)\n    {\n        __p = _VSTD::get_temporary_buffer<value_type>(__len);\n        __h.reset(__p.first);\n    }\n    return __stable_partition<typename add_lvalue_reference<_Predicate>::type>\n                             (__first, __last, __pred, __len, __p, forward_iterator_tag());\n}\n\ntemplate <class _Predicate, class _BidirectionalIterator, class _Distance, class _Pair>\n_BidirectionalIterator\n__stable_partition(_BidirectionalIterator __first, _BidirectionalIterator __last, _Predicate __pred,\n                   _Distance __len, _Pair __p, bidirectional_iterator_tag __bit)\n{\n    // *__first is known to be false\n    // *__last is known to be true\n    // __len >= 2\n    if (__len == 2)\n    {\n        swap(*__first, *__last);\n        return __last;\n    }\n    if (__len == 3)\n    {\n        _BidirectionalIterator __m = __first;\n        if (__pred(*++__m))\n        {\n            swap(*__first, *__m);\n            swap(*__m, *__last);\n            return __last;\n        }\n        swap(*__m, *__last);\n        swap(*__first, *__m);\n        return __m;\n    }\n    if (__len <= __p.second)\n    {   // The buffer is big enough to use\n        typedef typename iterator_traits<_BidirectionalIterator>::value_type value_type;\n        __destruct_n __d(0);\n        unique_ptr<value_type, __destruct_n&> __h(__p.first, __d);\n        // Move the falses into the temporary buffer, and the trues to the front of the line\n        // Update __first to always point to the end of the trues\n        value_type* __t = __p.first;\n        ::new(__t) value_type(_VSTD::move(*__first));\n        __d.__incr((value_type*)0);\n        ++__t;\n        _BidirectionalIterator __i = __first;\n        while (++__i != __last)\n        {\n            if (__pred(*__i))\n            {\n                *__first = _VSTD::move(*__i);\n                ++__first;\n            }\n            else\n            {\n                ::new(__t) value_type(_VSTD::move(*__i));\n                __d.__incr((value_type*)0);\n                ++__t;\n            }\n        }\n        // move *__last, known to be true\n        *__first = _VSTD::move(*__i);\n        __i = ++__first;\n        // All trues now at start of range, all falses in buffer\n        // Move falses back into range, but don't mess up __first which points to first false\n        for (value_type* __t2 = __p.first; __t2 < __t; ++__t2, ++__i)\n            *__i = _VSTD::move(*__t2);\n        // __h destructs moved-from values out of the temp buffer, but doesn't deallocate buffer\n        return __first;\n    }\n    // Else not enough buffer, do in place\n    // __len >= 4\n    _BidirectionalIterator __m = __first;\n    _Distance __len2 = __len / 2;  // __len2 >= 2\n    _VSTD::advance(__m, __len2);\n    // recurse on [__first, __m-1], except reduce __m-1 until *(__m-1) is true, *__first know to be false\n    // F????????????????T\n    // f       m        l\n    _BidirectionalIterator __m1 = __m;\n    _BidirectionalIterator __first_false = __first;\n    _Distance __len_half = __len2;\n    while (!__pred(*--__m1))\n    {\n        if (__m1 == __first)\n            goto __first_half_done;\n        --__len_half;\n    }\n    // F???TFFF?????????T\n    // f   m1  m        l\n    typedef typename add_lvalue_reference<_Predicate>::type _PredRef;\n    __first_false = __stable_partition<_PredRef>(__first, __m1, __pred, __len_half, __p, __bit);\n__first_half_done:\n    // TTTFFFFF?????????T\n    // f  ff   m        l\n    // recurse on [__m, __last], except increase __m until *(__m) is false, *__last know to be true\n    __m1 = __m;\n    _BidirectionalIterator __second_false = __last;\n    ++__second_false;\n    __len_half = __len - __len2;\n    while (__pred(*__m1))\n    {\n        if (++__m1 == __last)\n            goto __second_half_done;\n        --__len_half;\n    }\n    // TTTFFFFFTTTF?????T\n    // f  ff   m  m1    l\n    __second_false = __stable_partition<_PredRef>(__m1, __last, __pred, __len_half, __p, __bit);\n__second_half_done:\n    // TTTFFFFFTTTTTFFFFF\n    // f  ff   m    sf  l\n    return _VSTD::rotate(__first_false, __m, __second_false);\n    // TTTTTTTTFFFFFFFFFF\n    //         |\n}\n\ntemplate <class _Predicate, class _BidirectionalIterator>\n_BidirectionalIterator\n__stable_partition(_BidirectionalIterator __first, _BidirectionalIterator __last, _Predicate __pred,\n                   bidirectional_iterator_tag)\n{\n    typedef typename iterator_traits<_BidirectionalIterator>::difference_type difference_type;\n    typedef typename iterator_traits<_BidirectionalIterator>::value_type value_type;\n    const difference_type __alloc_limit = 4;  // might want to make this a function of trivial assignment\n    // Either prove all true and return __first or point to first false\n    while (true)\n    {\n        if (__first == __last)\n            return __first;\n        if (!__pred(*__first))\n            break;\n        ++__first;\n    }\n    // __first points to first false, everything prior to __first is already set.\n    // Either prove [__first, __last) is all false and return __first, or point __last to last true\n    do\n    {\n        if (__first == --__last)\n            return __first;\n    } while (!__pred(*__last));\n    // We now have a reduced range [__first, __last]\n    // *__first is known to be false\n    // *__last is known to be true\n    // __len >= 2\n    difference_type __len = _VSTD::distance(__first, __last) + 1;\n    pair<value_type*, ptrdiff_t> __p(0, 0);\n    unique_ptr<value_type, __return_temporary_buffer> __h;\n    if (__len >= __alloc_limit)\n    {\n        __p = _VSTD::get_temporary_buffer<value_type>(__len);\n        __h.reset(__p.first);\n    }\n    return __stable_partition<typename add_lvalue_reference<_Predicate>::type>\n                             (__first, __last, __pred, __len, __p, bidirectional_iterator_tag());\n}\n\ntemplate <class _ForwardIterator, class _Predicate>\ninline _LIBCPP_INLINE_VISIBILITY\n_ForwardIterator\nstable_partition(_ForwardIterator __first, _ForwardIterator __last, _Predicate __pred)\n{\n    return __stable_partition<typename add_lvalue_reference<_Predicate>::type>\n                             (__first, __last, __pred, typename iterator_traits<_ForwardIterator>::iterator_category());\n}\n\n// is_sorted_until\n\ntemplate <class _ForwardIterator, class _Compare>\n_ForwardIterator\nis_sorted_until(_ForwardIterator __first, _ForwardIterator __last, _Compare __comp)\n{\n    if (__first != __last)\n    {\n        _ForwardIterator __i = __first;\n        while (++__i != __last)\n        {\n            if (__comp(*__i, *__first))\n                return __i;\n            __first = __i;\n        }\n    }\n    return __last;\n}\n\ntemplate<class _ForwardIterator>\ninline _LIBCPP_INLINE_VISIBILITY\n_ForwardIterator\nis_sorted_until(_ForwardIterator __first, _ForwardIterator __last)\n{\n    return _VSTD::is_sorted_until(__first, __last, __less<typename iterator_traits<_ForwardIterator>::value_type>());\n}\n\n// is_sorted\n\ntemplate <class _ForwardIterator, class _Compare>\ninline _LIBCPP_INLINE_VISIBILITY\nbool\nis_sorted(_ForwardIterator __first, _ForwardIterator __last, _Compare __comp)\n{\n    return _VSTD::is_sorted_until(__first, __last, __comp) == __last;\n}\n\ntemplate<class _ForwardIterator>\ninline _LIBCPP_INLINE_VISIBILITY\nbool\nis_sorted(_ForwardIterator __first, _ForwardIterator __last)\n{\n    return _VSTD::is_sorted(__first, __last, __less<typename iterator_traits<_ForwardIterator>::value_type>());\n}\n\n// sort\n\n// stable, 2-3 compares, 0-2 swaps\n\ntemplate <class _Compare, class _ForwardIterator>\nunsigned\n__sort3(_ForwardIterator __x, _ForwardIterator __y, _ForwardIterator __z, _Compare __c)\n{\n    unsigned __r = 0;\n    if (!__c(*__y, *__x))          // if x <= y\n    {\n        if (!__c(*__z, *__y))      // if y <= z\n            return __r;            // x <= y && y <= z\n                                   // x <= y && y > z\n        swap(*__y, *__z);          // x <= z && y < z\n        __r = 1;\n        if (__c(*__y, *__x))       // if x > y\n        {\n            swap(*__x, *__y);      // x < y && y <= z\n            __r = 2;\n        }\n        return __r;                // x <= y && y < z\n    }\n    if (__c(*__z, *__y))           // x > y, if y > z\n    {\n        swap(*__x, *__z);          // x < y && y < z\n        __r = 1;\n        return __r;\n    }\n    swap(*__x, *__y);              // x > y && y <= z\n    __r = 1;                       // x < y && x <= z\n    if (__c(*__z, *__y))           // if y > z\n    {\n        swap(*__y, *__z);          // x <= y && y < z\n        __r = 2;\n    }\n    return __r;\n}                                  // x <= y && y <= z\n\n// stable, 3-6 compares, 0-5 swaps\n\ntemplate <class _Compare, class _ForwardIterator>\nunsigned\n__sort4(_ForwardIterator __x1, _ForwardIterator __x2, _ForwardIterator __x3,\n            _ForwardIterator __x4, _Compare __c)\n{\n    unsigned __r = __sort3<_Compare>(__x1, __x2, __x3, __c);\n    if (__c(*__x4, *__x3))\n    {\n        swap(*__x3, *__x4);\n        ++__r;\n        if (__c(*__x3, *__x2))\n        {\n            swap(*__x2, *__x3);\n            ++__r;\n            if (__c(*__x2, *__x1))\n            {\n                swap(*__x1, *__x2);\n                ++__r;\n            }\n        }\n    }\n    return __r;\n}\n\n// stable, 4-10 compares, 0-9 swaps\n\ntemplate <class _Compare, class _ForwardIterator>\nunsigned\n__sort5(_ForwardIterator __x1, _ForwardIterator __x2, _ForwardIterator __x3,\n            _ForwardIterator __x4, _ForwardIterator __x5, _Compare __c)\n{\n    unsigned __r = __sort4<_Compare>(__x1, __x2, __x3, __x4, __c);\n    if (__c(*__x5, *__x4))\n    {\n        swap(*__x4, *__x5);\n        ++__r;\n        if (__c(*__x4, *__x3))\n        {\n            swap(*__x3, *__x4);\n            ++__r;\n            if (__c(*__x3, *__x2))\n            {\n                swap(*__x2, *__x3);\n                ++__r;\n                if (__c(*__x2, *__x1))\n                {\n                    swap(*__x1, *__x2);\n                    ++__r;\n                }\n            }\n        }\n    }\n    return __r;\n}\n\n// Assumes size > 0\ntemplate <class _Compare, class _BirdirectionalIterator>\nvoid\n__selection_sort(_BirdirectionalIterator __first, _BirdirectionalIterator __last, _Compare __comp)\n{\n    _BirdirectionalIterator __lm1 = __last;\n    for (--__lm1; __first != __lm1; ++__first)\n    {\n        _BirdirectionalIterator __i = _VSTD::min_element<_BirdirectionalIterator,\n                                                        typename add_lvalue_reference<_Compare>::type>\n                                                       (__first, __last, __comp);\n        if (__i != __first)\n            swap(*__first, *__i);\n    }\n}\n\ntemplate <class _Compare, class _BirdirectionalIterator>\nvoid\n__insertion_sort(_BirdirectionalIterator __first, _BirdirectionalIterator __last, _Compare __comp)\n{\n    typedef typename iterator_traits<_BirdirectionalIterator>::value_type value_type;\n    if (__first != __last)\n    {\n        _BirdirectionalIterator __i = __first;\n        for (++__i; __i != __last; ++__i)\n        {\n            _BirdirectionalIterator __j = __i;\n            value_type __t(_VSTD::move(*__j));\n            for (_BirdirectionalIterator __k = __i; __k != __first && __comp(__t,  *--__k); --__j)\n                *__j = _VSTD::move(*__k);\n            *__j = _VSTD::move(__t);\n        }\n    }\n}\n\ntemplate <class _Compare, class _RandomAccessIterator>\nvoid\n__insertion_sort_3(_RandomAccessIterator __first, _RandomAccessIterator __last, _Compare __comp)\n{\n    typedef typename iterator_traits<_RandomAccessIterator>::value_type value_type;\n    _RandomAccessIterator __j = __first+2;\n    __sort3<_Compare>(__first, __first+1, __j, __comp);\n    for (_RandomAccessIterator __i = __j+1; __i != __last; ++__i)\n    {\n        if (__comp(*__i, *__j))\n        {\n            value_type __t(_VSTD::move(*__i));\n            _RandomAccessIterator __k = __j;\n            __j = __i;\n            do\n            {\n                *__j = _VSTD::move(*__k);\n                __j = __k;\n            } while (__j != __first && __comp(__t, *--__k));\n            *__j = _VSTD::move(__t);\n        }\n        __j = __i;\n    }\n}\n\ntemplate <class _Compare, class _RandomAccessIterator>\nbool\n__insertion_sort_incomplete(_RandomAccessIterator __first, _RandomAccessIterator __last, _Compare __comp)\n{\n    switch (__last - __first)\n    {\n    case 0:\n    case 1:\n        return true;\n    case 2:\n        if (__comp(*--__last, *__first))\n            swap(*__first, *__last);\n        return true;\n    case 3:\n        _VSTD::__sort3<_Compare>(__first, __first+1, --__last, __comp);\n        return true;\n    case 4:\n        _VSTD::__sort4<_Compare>(__first, __first+1, __first+2, --__last, __comp);\n        return true;\n    case 5:\n        _VSTD::__sort5<_Compare>(__first, __first+1, __first+2, __first+3, --__last, __comp);\n        return true;\n    }\n    typedef typename iterator_traits<_RandomAccessIterator>::value_type value_type;\n    _RandomAccessIterator __j = __first+2;\n    __sort3<_Compare>(__first, __first+1, __j, __comp);\n    const unsigned __limit = 8;\n    unsigned __count = 0;\n    for (_RandomAccessIterator __i = __j+1; __i != __last; ++__i)\n    {\n        if (__comp(*__i, *__j))\n        {\n            value_type __t(_VSTD::move(*__i));\n            _RandomAccessIterator __k = __j;\n            __j = __i;\n            do\n            {\n                *__j = _VSTD::move(*__k);\n                __j = __k;\n            } while (__j != __first && __comp(__t, *--__k));\n            *__j = _VSTD::move(__t);\n            if (++__count == __limit)\n                return ++__i == __last;\n        }\n        __j = __i;\n    }\n    return true;\n}\n\ntemplate <class _Compare, class _BirdirectionalIterator>\nvoid\n__insertion_sort_move(_BirdirectionalIterator __first1, _BirdirectionalIterator __last1,\n                      typename iterator_traits<_BirdirectionalIterator>::value_type* __first2, _Compare __comp)\n{\n    typedef typename iterator_traits<_BirdirectionalIterator>::value_type value_type;\n    if (__first1 != __last1)\n    {\n        __destruct_n __d(0);\n        unique_ptr<value_type, __destruct_n&> __h(__first2, __d);\n        value_type* __last2 = __first2;\n        ::new(__last2) value_type(_VSTD::move(*__first1));\n        __d.__incr((value_type*)0);\n        for (++__last2; ++__first1 != __last1; ++__last2)\n        {\n            value_type* __j2 = __last2;\n            value_type* __i2 = __j2;\n            if (__comp(*__first1, *--__i2))\n            {\n                ::new(__j2) value_type(_VSTD::move(*__i2));\n                __d.__incr((value_type*)0);\n                for (--__j2; __i2 != __first2 && __comp(*__first1,  *--__i2); --__j2)\n                    *__j2 = _VSTD::move(*__i2);\n                *__j2 = _VSTD::move(*__first1);\n            }\n            else\n            {\n                ::new(__j2) value_type(_VSTD::move(*__first1));\n                __d.__incr((value_type*)0);\n            }\n        }\n        __h.release();\n    }\n}\n\ntemplate <class _Compare, class _RandomAccessIterator>\nvoid\n__sort(_RandomAccessIterator __first, _RandomAccessIterator __last, _Compare __comp)\n{\n    // _Compare is known to be a reference type\n    typedef typename iterator_traits<_RandomAccessIterator>::difference_type difference_type;\n    typedef typename iterator_traits<_RandomAccessIterator>::value_type value_type;\n    const difference_type __limit = is_trivially_copy_constructible<value_type>::value &&\n                                    is_trivially_copy_assignable<value_type>::value ? 30 : 6;\n    while (true)\n    {\n    __restart:\n        difference_type __len = __last - __first;\n        switch (__len)\n        {\n        case 0:\n        case 1:\n            return;\n        case 2:\n            if (__comp(*--__last, *__first))\n                swap(*__first, *__last);\n            return;\n        case 3:\n            _VSTD::__sort3<_Compare>(__first, __first+1, --__last, __comp);\n            return;\n        case 4:\n            _VSTD::__sort4<_Compare>(__first, __first+1, __first+2, --__last, __comp);\n            return;\n        case 5:\n            _VSTD::__sort5<_Compare>(__first, __first+1, __first+2, __first+3, --__last, __comp);\n            return;\n        }\n        if (__len <= __limit)\n        {\n            _VSTD::__insertion_sort_3<_Compare>(__first, __last, __comp);\n            return;\n        }\n        // __len > 5\n        _RandomAccessIterator __m = __first;\n        _RandomAccessIterator __lm1 = __last;\n        --__lm1;\n        unsigned __n_swaps;\n        {\n        difference_type __delta;\n        if (__len >= 1000)\n        {\n            __delta = __len/2;\n            __m += __delta;\n            __delta /= 2;\n            __n_swaps = _VSTD::__sort5<_Compare>(__first, __first + __delta, __m, __m+__delta, __lm1, __comp);\n        }\n        else\n        {\n            __delta = __len/2;\n            __m += __delta;\n            __n_swaps = _VSTD::__sort3<_Compare>(__first, __m, __lm1, __comp);\n        }\n        }\n        // *__m is median\n        // partition [__first, __m) < *__m and *__m <= [__m, __last)\n        // (this inhibits tossing elements equivalent to __m around unnecessarily)\n        _RandomAccessIterator __i = __first;\n        _RandomAccessIterator __j = __lm1;\n        // j points beyond range to be tested, *__m is known to be <= *__lm1\n        // The search going up is known to be guarded but the search coming down isn't.\n        // Prime the downward search with a guard.\n        if (!__comp(*__i, *__m))  // if *__first == *__m\n        {\n            // *__first == *__m, *__first doesn't go in first part\n            // manually guard downward moving __j against __i\n            while (true)\n            {\n                if (__i == --__j)\n                {\n                    // *__first == *__m, *__m <= all other elements\n                    // Parition instead into [__first, __i) == *__first and *__first < [__i, __last)\n                    ++__i;  // __first + 1\n                    __j = __last;\n                    if (!__comp(*__first, *--__j))  // we need a guard if *__first == *(__last-1)\n                    {\n                        while (true)\n                        {\n                            if (__i == __j)\n                                return;  // [__first, __last) all equivalent elements\n                            if (__comp(*__first, *__i))\n                            {\n                                swap(*__i, *__j);\n                                ++__n_swaps;\n                                ++__i;\n                                break;\n                            }\n                            ++__i;\n                        }\n                    }\n                    // [__first, __i) == *__first and *__first < [__j, __last) and __j == __last - 1\n                    if (__i == __j)\n                        return;\n                    while (true)\n                    {\n                        while (!__comp(*__first, *__i))\n                            ++__i;\n                        while (__comp(*__first, *--__j))\n                            ;\n                        if (__i >= __j)\n                            break;\n                        swap(*__i, *__j);\n                        ++__n_swaps;\n                        ++__i;\n                    }\n                    // [__first, __i) == *__first and *__first < [__i, __last)\n                    // The first part is sorted, sort the secod part\n                    // _VSTD::__sort<_Compare>(__i, __last, __comp);\n                    __first = __i;\n                    goto __restart;\n                }\n                if (__comp(*__j, *__m))\n                {\n                    swap(*__i, *__j);\n                    ++__n_swaps;\n                    break;  // found guard for downward moving __j, now use unguarded partition\n                }\n            }\n        }\n        // It is known that *__i < *__m\n        ++__i;\n        // j points beyond range to be tested, *__m is known to be <= *__lm1\n        // if not yet partitioned...\n        if (__i < __j)\n        {\n            // known that *(__i - 1) < *__m\n            // known that __i <= __m\n            while (true)\n            {\n                // __m still guards upward moving __i\n                while (__comp(*__i, *__m))\n                    ++__i;\n                // It is now known that a guard exists for downward moving __j\n                while (!__comp(*--__j, *__m))\n                    ;\n                if (__i > __j)\n                    break;\n                swap(*__i, *__j);\n                ++__n_swaps;\n                // It is known that __m != __j\n                // If __m just moved, follow it\n                if (__m == __i)\n                    __m = __j;\n                ++__i;\n            }\n        }\n        // [__first, __i) < *__m and *__m <= [__i, __last)\n        if (__i != __m && __comp(*__m, *__i))\n        {\n            swap(*__i, *__m);\n            ++__n_swaps;\n        }\n        // [__first, __i) < *__i and *__i <= [__i+1, __last)\n        // If we were given a perfect partition, see if insertion sort is quick...\n        if (__n_swaps == 0)\n        {\n            bool __fs = _VSTD::__insertion_sort_incomplete<_Compare>(__first, __i, __comp);\n            if (_VSTD::__insertion_sort_incomplete<_Compare>(__i+1, __last, __comp))\n            {\n                if (__fs)\n                    return;\n                __last = __i;\n                continue;\n            }\n            else\n            {\n                if (__fs)\n                {\n                    __first = ++__i;\n                    continue;\n                }\n            }\n        }\n        // sort smaller range with recursive call and larger with tail recursion elimination\n        if (__i - __first < __last - __i)\n        {\n            _VSTD::__sort<_Compare>(__first, __i, __comp);\n            // _VSTD::__sort<_Compare>(__i+1, __last, __comp);\n            __first = ++__i;\n        }\n        else\n        {\n            _VSTD::__sort<_Compare>(__i+1, __last, __comp);\n            // _VSTD::__sort<_Compare>(__first, __i, __comp);\n            __last = __i;\n        }\n    }\n}\n\n// This forwarder keeps the top call and the recursive calls using the same instantiation, forcing a reference _Compare\ntemplate <class _RandomAccessIterator, class _Compare>\ninline _LIBCPP_INLINE_VISIBILITY\nvoid\nsort(_RandomAccessIterator __first, _RandomAccessIterator __last, _Compare __comp)\n{\n#ifdef _LIBCPP_DEBUG\n    typedef typename add_lvalue_reference<__debug_less<_Compare> >::type _Comp_ref;\n    __debug_less<_Compare> __c(__comp);\n    __sort<_Comp_ref>(__first, __last, __c);\n#else  // _LIBCPP_DEBUG\n    typedef typename add_lvalue_reference<_Compare>::type _Comp_ref;\n    __sort<_Comp_ref>(__first, __last, __comp);\n#endif  // _LIBCPP_DEBUG\n}\n\ntemplate <class _RandomAccessIterator>\ninline _LIBCPP_INLINE_VISIBILITY\nvoid\nsort(_RandomAccessIterator __first, _RandomAccessIterator __last)\n{\n    _VSTD::sort(__first, __last, __less<typename iterator_traits<_RandomAccessIterator>::value_type>());\n}\n\ntemplate <class _Tp>\ninline _LIBCPP_INLINE_VISIBILITY\nvoid\nsort(_Tp** __first, _Tp** __last)\n{\n    _VSTD::sort((size_t*)__first, (size_t*)__last, __less<size_t>());\n}\n\ntemplate <class _Tp>\ninline _LIBCPP_INLINE_VISIBILITY\nvoid\nsort(__wrap_iter<_Tp*> __first, __wrap_iter<_Tp*> __last)\n{\n    _VSTD::sort(__first.base(), __last.base());\n}\n\ntemplate <class _Tp, class _Compare>\ninline _LIBCPP_INLINE_VISIBILITY\nvoid\nsort(__wrap_iter<_Tp*> __first, __wrap_iter<_Tp*> __last, _Compare __comp)\n{\n    typedef typename add_lvalue_reference<_Compare>::type _Comp_ref;\n    _VSTD::sort<_Tp*, _Comp_ref>(__first.base(), __last.base(), __comp);\n}\n\n#ifdef _LIBCPP_MSVC\n#pragma warning( push )\n#pragma warning( disable: 4231)\n#endif // _LIBCPP_MSVC\n_LIBCPP_EXTERN_TEMPLATE(_LIBCPP_FUNC_VIS void __sort<__less<char>&, char*>(char*, char*, __less<char>&))\n_LIBCPP_EXTERN_TEMPLATE(_LIBCPP_FUNC_VIS void __sort<__less<wchar_t>&, wchar_t*>(wchar_t*, wchar_t*, __less<wchar_t>&))\n_LIBCPP_EXTERN_TEMPLATE(_LIBCPP_FUNC_VIS void __sort<__less<signed char>&, signed char*>(signed char*, signed char*, __less<signed char>&))\n_LIBCPP_EXTERN_TEMPLATE(_LIBCPP_FUNC_VIS void __sort<__less<unsigned char>&, unsigned char*>(unsigned char*, unsigned char*, __less<unsigned char>&))\n_LIBCPP_EXTERN_TEMPLATE(_LIBCPP_FUNC_VIS void __sort<__less<short>&, short*>(short*, short*, __less<short>&))\n_LIBCPP_EXTERN_TEMPLATE(_LIBCPP_FUNC_VIS void __sort<__less<unsigned short>&, unsigned short*>(unsigned short*, unsigned short*, __less<unsigned short>&))\n_LIBCPP_EXTERN_TEMPLATE(_LIBCPP_FUNC_VIS void __sort<__less<int>&, int*>(int*, int*, __less<int>&))\n_LIBCPP_EXTERN_TEMPLATE(_LIBCPP_FUNC_VIS void __sort<__less<unsigned>&, unsigned*>(unsigned*, unsigned*, __less<unsigned>&))\n_LIBCPP_EXTERN_TEMPLATE(_LIBCPP_FUNC_VIS void __sort<__less<long>&, long*>(long*, long*, __less<long>&))\n_LIBCPP_EXTERN_TEMPLATE(_LIBCPP_FUNC_VIS void __sort<__less<unsigned long>&, unsigned long*>(unsigned long*, unsigned long*, __less<unsigned long>&))\n_LIBCPP_EXTERN_TEMPLATE(_LIBCPP_FUNC_VIS void __sort<__less<long long>&, long long*>(long long*, long long*, __less<long long>&))\n_LIBCPP_EXTERN_TEMPLATE(_LIBCPP_FUNC_VIS void __sort<__less<unsigned long long>&, unsigned long long*>(unsigned long long*, unsigned long long*, __less<unsigned long long>&))\n_LIBCPP_EXTERN_TEMPLATE(_LIBCPP_FUNC_VIS void __sort<__less<float>&, float*>(float*, float*, __less<float>&))\n_LIBCPP_EXTERN_TEMPLATE(_LIBCPP_FUNC_VIS void __sort<__less<double>&, double*>(double*, double*, __less<double>&))\n_LIBCPP_EXTERN_TEMPLATE(_LIBCPP_FUNC_VIS void __sort<__less<long double>&, long double*>(long double*, long double*, __less<long double>&))\n\n_LIBCPP_EXTERN_TEMPLATE(_LIBCPP_FUNC_VIS bool __insertion_sort_incomplete<__less<char>&, char*>(char*, char*, __less<char>&))\n_LIBCPP_EXTERN_TEMPLATE(_LIBCPP_FUNC_VIS bool __insertion_sort_incomplete<__less<wchar_t>&, wchar_t*>(wchar_t*, wchar_t*, __less<wchar_t>&))\n_LIBCPP_EXTERN_TEMPLATE(_LIBCPP_FUNC_VIS bool __insertion_sort_incomplete<__less<signed char>&, signed char*>(signed char*, signed char*, __less<signed char>&))\n_LIBCPP_EXTERN_TEMPLATE(_LIBCPP_FUNC_VIS bool __insertion_sort_incomplete<__less<unsigned char>&, unsigned char*>(unsigned char*, unsigned char*, __less<unsigned char>&))\n_LIBCPP_EXTERN_TEMPLATE(_LIBCPP_FUNC_VIS bool __insertion_sort_incomplete<__less<short>&, short*>(short*, short*, __less<short>&))\n_LIBCPP_EXTERN_TEMPLATE(_LIBCPP_FUNC_VIS bool __insertion_sort_incomplete<__less<unsigned short>&, unsigned short*>(unsigned short*, unsigned short*, __less<unsigned short>&))\n_LIBCPP_EXTERN_TEMPLATE(_LIBCPP_FUNC_VIS bool __insertion_sort_incomplete<__less<int>&, int*>(int*, int*, __less<int>&))\n_LIBCPP_EXTERN_TEMPLATE(_LIBCPP_FUNC_VIS bool __insertion_sort_incomplete<__less<unsigned>&, unsigned*>(unsigned*, unsigned*, __less<unsigned>&))\n_LIBCPP_EXTERN_TEMPLATE(_LIBCPP_FUNC_VIS bool __insertion_sort_incomplete<__less<long>&, long*>(long*, long*, __less<long>&))\n_LIBCPP_EXTERN_TEMPLATE(_LIBCPP_FUNC_VIS bool __insertion_sort_incomplete<__less<unsigned long>&, unsigned long*>(unsigned long*, unsigned long*, __less<unsigned long>&))\n_LIBCPP_EXTERN_TEMPLATE(_LIBCPP_FUNC_VIS bool __insertion_sort_incomplete<__less<long long>&, long long*>(long long*, long long*, __less<long long>&))\n_LIBCPP_EXTERN_TEMPLATE(_LIBCPP_FUNC_VIS bool __insertion_sort_incomplete<__less<unsigned long long>&, unsigned long long*>(unsigned long long*, unsigned long long*, __less<unsigned long long>&))\n_LIBCPP_EXTERN_TEMPLATE(_LIBCPP_FUNC_VIS bool __insertion_sort_incomplete<__less<float>&, float*>(float*, float*, __less<float>&))\n_LIBCPP_EXTERN_TEMPLATE(_LIBCPP_FUNC_VIS bool __insertion_sort_incomplete<__less<double>&, double*>(double*, double*, __less<double>&))\n_LIBCPP_EXTERN_TEMPLATE(_LIBCPP_FUNC_VIS bool __insertion_sort_incomplete<__less<long double>&, long double*>(long double*, long double*, __less<long double>&))\n\n_LIBCPP_EXTERN_TEMPLATE(_LIBCPP_FUNC_VIS unsigned __sort5<__less<long double>&, long double*>(long double*, long double*, long double*, long double*, long double*, __less<long double>&))\n#ifdef _LIBCPP_MSVC\n#pragma warning( pop )\n#endif  // _LIBCPP_MSVC\n\n// lower_bound\n\ntemplate <class _Compare, class _ForwardIterator, class _Tp>\n_ForwardIterator\n__lower_bound(_ForwardIterator __first, _ForwardIterator __last, const _Tp& __value_, _Compare __comp)\n{\n    typedef typename iterator_traits<_ForwardIterator>::difference_type difference_type;\n    difference_type __len = _VSTD::distance(__first, __last);\n    while (__len != 0)\n    {\n        difference_type __l2 = __len / 2;\n        _ForwardIterator __m = __first;\n        _VSTD::advance(__m, __l2);\n        if (__comp(*__m, __value_))\n        {\n            __first = ++__m;\n            __len -= __l2 + 1;\n        }\n        else\n            __len = __l2;\n    }\n    return __first;\n}\n\ntemplate <class _ForwardIterator, class _Tp, class _Compare>\ninline _LIBCPP_INLINE_VISIBILITY\n_ForwardIterator\nlower_bound(_ForwardIterator __first, _ForwardIterator __last, const _Tp& __value_, _Compare __comp)\n{\n#ifdef _LIBCPP_DEBUG\n    typedef typename add_lvalue_reference<__debug_less<_Compare> >::type _Comp_ref;\n    __debug_less<_Compare> __c(__comp);\n    return __lower_bound<_Comp_ref>(__first, __last, __value_, __c);\n#else  // _LIBCPP_DEBUG\n    typedef typename add_lvalue_reference<_Compare>::type _Comp_ref;\n    return __lower_bound<_Comp_ref>(__first, __last, __value_, __comp);\n#endif  // _LIBCPP_DEBUG\n}\n\ntemplate <class _ForwardIterator, class _Tp>\ninline _LIBCPP_INLINE_VISIBILITY\n_ForwardIterator\nlower_bound(_ForwardIterator __first, _ForwardIterator __last, const _Tp& __value_)\n{\n    return _VSTD::lower_bound(__first, __last, __value_,\n                             __less<typename iterator_traits<_ForwardIterator>::value_type, _Tp>());\n}\n\n// upper_bound\n\ntemplate <class _Compare, class _ForwardIterator, class _Tp>\n_ForwardIterator\n__upper_bound(_ForwardIterator __first, _ForwardIterator __last, const _Tp& __value_, _Compare __comp)\n{\n    typedef typename iterator_traits<_ForwardIterator>::difference_type difference_type;\n    difference_type __len = _VSTD::distance(__first, __last);\n    while (__len != 0)\n    {\n        difference_type __l2 = __len / 2;\n        _ForwardIterator __m = __first;\n        _VSTD::advance(__m, __l2);\n        if (__comp(__value_, *__m))\n            __len = __l2;\n        else\n        {\n            __first = ++__m;\n            __len -= __l2 + 1;\n        }\n    }\n    return __first;\n}\n\ntemplate <class _ForwardIterator, class _Tp, class _Compare>\ninline _LIBCPP_INLINE_VISIBILITY\n_ForwardIterator\nupper_bound(_ForwardIterator __first, _ForwardIterator __last, const _Tp& __value_, _Compare __comp)\n{\n#ifdef _LIBCPP_DEBUG\n    typedef typename add_lvalue_reference<__debug_less<_Compare> >::type _Comp_ref;\n    __debug_less<_Compare> __c(__comp);\n    return __upper_bound<_Comp_ref>(__first, __last, __value_, __c);\n#else  // _LIBCPP_DEBUG\n    typedef typename add_lvalue_reference<_Compare>::type _Comp_ref;\n    return __upper_bound<_Comp_ref>(__first, __last, __value_, __comp);\n#endif  // _LIBCPP_DEBUG\n}\n\ntemplate <class _ForwardIterator, class _Tp>\ninline _LIBCPP_INLINE_VISIBILITY\n_ForwardIterator\nupper_bound(_ForwardIterator __first, _ForwardIterator __last, const _Tp& __value_)\n{\n    return _VSTD::upper_bound(__first, __last, __value_,\n                             __less<_Tp, typename iterator_traits<_ForwardIterator>::value_type>());\n}\n\n// equal_range\n\ntemplate <class _Compare, class _ForwardIterator, class _Tp>\npair<_ForwardIterator, _ForwardIterator>\n__equal_range(_ForwardIterator __first, _ForwardIterator __last, const _Tp& __value_, _Compare __comp)\n{\n    typedef typename iterator_traits<_ForwardIterator>::difference_type difference_type;\n    difference_type __len = _VSTD::distance(__first, __last);\n    while (__len != 0)\n    {\n        difference_type __l2 = __len / 2;\n        _ForwardIterator __m = __first;\n        _VSTD::advance(__m, __l2);\n        if (__comp(*__m, __value_))\n        {\n            __first = ++__m;\n            __len -= __l2 + 1;\n        }\n        else if (__comp(__value_, *__m))\n        {\n            __last = __m;\n            __len = __l2;\n        }\n        else\n        {\n            _ForwardIterator __mp1 = __m;\n            return pair<_ForwardIterator, _ForwardIterator>\n                   (\n                      __lower_bound<_Compare>(__first, __m, __value_, __comp),\n                      __upper_bound<_Compare>(++__mp1, __last, __value_, __comp)\n                   );\n        }\n    }\n    return pair<_ForwardIterator, _ForwardIterator>(__first, __first);\n}\n\ntemplate <class _ForwardIterator, class _Tp, class _Compare>\ninline _LIBCPP_INLINE_VISIBILITY\npair<_ForwardIterator, _ForwardIterator>\nequal_range(_ForwardIterator __first, _ForwardIterator __last, const _Tp& __value_, _Compare __comp)\n{\n#ifdef _LIBCPP_DEBUG\n    typedef typename add_lvalue_reference<__debug_less<_Compare> >::type _Comp_ref;\n    __debug_less<_Compare> __c(__comp);\n    return __equal_range<_Comp_ref>(__first, __last, __value_, __c);\n#else  // _LIBCPP_DEBUG\n    typedef typename add_lvalue_reference<_Compare>::type _Comp_ref;\n    return __equal_range<_Comp_ref>(__first, __last, __value_, __comp);\n#endif  // _LIBCPP_DEBUG\n}\n\ntemplate <class _ForwardIterator, class _Tp>\ninline _LIBCPP_INLINE_VISIBILITY\npair<_ForwardIterator, _ForwardIterator>\nequal_range(_ForwardIterator __first, _ForwardIterator __last, const _Tp& __value_)\n{\n    return _VSTD::equal_range(__first, __last, __value_,\n                             __less<typename iterator_traits<_ForwardIterator>::value_type, _Tp>());\n}\n\n// binary_search\n\ntemplate <class _Compare, class _ForwardIterator, class _Tp>\ninline _LIBCPP_INLINE_VISIBILITY\nbool\n__binary_search(_ForwardIterator __first, _ForwardIterator __last, const _Tp& __value_, _Compare __comp)\n{\n    __first = __lower_bound<_Compare>(__first, __last, __value_, __comp);\n    return __first != __last && !__comp(__value_, *__first);\n}\n\ntemplate <class _ForwardIterator, class _Tp, class _Compare>\ninline _LIBCPP_INLINE_VISIBILITY\nbool\nbinary_search(_ForwardIterator __first, _ForwardIterator __last, const _Tp& __value_, _Compare __comp)\n{\n#ifdef _LIBCPP_DEBUG\n    typedef typename add_lvalue_reference<__debug_less<_Compare> >::type _Comp_ref;\n    __debug_less<_Compare> __c(__comp);\n    return __binary_search<_Comp_ref>(__first, __last, __value_, __c);\n#else  // _LIBCPP_DEBUG\n    typedef typename add_lvalue_reference<_Compare>::type _Comp_ref;\n    return __binary_search<_Comp_ref>(__first, __last, __value_, __comp);\n#endif  // _LIBCPP_DEBUG\n}\n\ntemplate <class _ForwardIterator, class _Tp>\ninline _LIBCPP_INLINE_VISIBILITY\nbool\nbinary_search(_ForwardIterator __first, _ForwardIterator __last, const _Tp& __value_)\n{\n    return _VSTD::binary_search(__first, __last, __value_,\n                             __less<typename iterator_traits<_ForwardIterator>::value_type, _Tp>());\n}\n\n// merge\n\ntemplate <class _Compare, class _InputIterator1, class _InputIterator2, class _OutputIterator>\n_OutputIterator\n__merge(_InputIterator1 __first1, _InputIterator1 __last1,\n        _InputIterator2 __first2, _InputIterator2 __last2, _OutputIterator __result, _Compare __comp)\n{\n    for (; __first1 != __last1; ++__result)\n    {\n        if (__first2 == __last2)\n            return _VSTD::copy(__first1, __last1, __result);\n        if (__comp(*__first2, *__first1))\n        {\n            *__result = *__first2;\n            ++__first2;\n        }\n        else\n        {\n            *__result = *__first1;\n            ++__first1;\n        }\n    }\n    return _VSTD::copy(__first2, __last2, __result);\n}\n\ntemplate <class _InputIterator1, class _InputIterator2, class _OutputIterator, class _Compare>\ninline _LIBCPP_INLINE_VISIBILITY\n_OutputIterator\nmerge(_InputIterator1 __first1, _InputIterator1 __last1,\n      _InputIterator2 __first2, _InputIterator2 __last2, _OutputIterator __result, _Compare __comp)\n{\n#ifdef _LIBCPP_DEBUG\n    typedef typename add_lvalue_reference<__debug_less<_Compare> >::type _Comp_ref;\n    __debug_less<_Compare> __c(__comp);\n    return _VSTD::__merge<_Comp_ref>(__first1, __last1, __first2, __last2, __result, __c);\n#else  // _LIBCPP_DEBUG\n    typedef typename add_lvalue_reference<_Compare>::type _Comp_ref;\n    return _VSTD::__merge<_Comp_ref>(__first1, __last1, __first2, __last2, __result, __comp);\n#endif  // _LIBCPP_DEBUG\n}\n\ntemplate <class _InputIterator1, class _InputIterator2, class _OutputIterator>\ninline _LIBCPP_INLINE_VISIBILITY\n_OutputIterator\nmerge(_InputIterator1 __first1, _InputIterator1 __last1,\n      _InputIterator2 __first2, _InputIterator2 __last2, _OutputIterator __result)\n{\n    typedef typename iterator_traits<_InputIterator1>::value_type __v1;\n    typedef typename iterator_traits<_InputIterator2>::value_type __v2;\n    return merge(__first1, __last1, __first2, __last2, __result, __less<__v1, __v2>());\n}\n\n// inplace_merge\n\ntemplate <class _Compare, class _InputIterator1, class _InputIterator2,\n          class _OutputIterator>\nvoid __half_inplace_merge(_InputIterator1 __first1, _InputIterator1 __last1,\n                          _InputIterator2 __first2, _InputIterator2 __last2,\n                          _OutputIterator __result, _Compare __comp)\n{\n    for (; __first1 != __last1; ++__result)\n    {\n        if (__first2 == __last2)\n        {\n            _VSTD::move(__first1, __last1, __result);\n            return;\n        }\n\n        if (__comp(*__first2, *__first1))\n        {\n            *__result = _VSTD::move(*__first2);\n            ++__first2;\n        }\n        else\n        {\n            *__result = _VSTD::move(*__first1);\n            ++__first1;\n        }\n    }\n    // __first2 through __last2 are already in the right spot.\n}\n\ntemplate <class _Compare, class _BidirectionalIterator>\nvoid\n__buffered_inplace_merge(_BidirectionalIterator __first, _BidirectionalIterator __middle, _BidirectionalIterator __last,\n                _Compare __comp, typename iterator_traits<_BidirectionalIterator>::difference_type __len1,\n                                 typename iterator_traits<_BidirectionalIterator>::difference_type __len2,\n                typename iterator_traits<_BidirectionalIterator>::value_type* __buff)\n{\n    typedef typename iterator_traits<_BidirectionalIterator>::value_type value_type;\n    __destruct_n __d(0);\n    unique_ptr<value_type, __destruct_n&> __h2(__buff, __d);\n    if (__len1 <= __len2)\n    {\n        value_type* __p = __buff;\n        for (_BidirectionalIterator __i = __first; __i != __middle; __d.__incr((value_type*)0), (void) ++__i, ++__p)\n            ::new(__p) value_type(_VSTD::move(*__i));\n        __half_inplace_merge(__buff, __p, __middle, __last, __first, __comp);\n    }\n    else\n    {\n        value_type* __p = __buff;\n        for (_BidirectionalIterator __i = __middle; __i != __last; __d.__incr((value_type*)0), (void) ++__i, ++__p)\n            ::new(__p) value_type(_VSTD::move(*__i));\n        typedef reverse_iterator<_BidirectionalIterator> _RBi;\n        typedef reverse_iterator<value_type*> _Rv;\n        __half_inplace_merge(_Rv(__p), _Rv(__buff),\n                             _RBi(__middle), _RBi(__first),\n                             _RBi(__last), __negate<_Compare>(__comp));\n    }\n}\n\ntemplate <class _Compare, class _BidirectionalIterator>\nvoid\n__inplace_merge(_BidirectionalIterator __first, _BidirectionalIterator __middle, _BidirectionalIterator __last,\n                _Compare __comp, typename iterator_traits<_BidirectionalIterator>::difference_type __len1,\n                                 typename iterator_traits<_BidirectionalIterator>::difference_type __len2,\n                typename iterator_traits<_BidirectionalIterator>::value_type* __buff, ptrdiff_t __buff_size)\n{\n    typedef typename iterator_traits<_BidirectionalIterator>::difference_type difference_type;\n    while (true)\n    {\n        // if __middle == __last, we're done\n        if (__len2 == 0)\n            return;\n        if (__len1 <= __buff_size || __len2 <= __buff_size)\n            return __buffered_inplace_merge<_Compare>\n                   (__first, __middle, __last, __comp, __len1, __len2, __buff);\n        // shrink [__first, __middle) as much as possible (with no moves), returning if it shrinks to 0\n        for (; true; ++__first, (void) --__len1)\n        {\n            if (__len1 == 0)\n                return;\n            if (__comp(*__middle, *__first))\n                break;\n        }\n        // __first < __middle < __last\n        // *__first > *__middle\n        // partition [__first, __m1) [__m1, __middle) [__middle, __m2) [__m2, __last) such that\n        //     all elements in:\n        //         [__first, __m1)  <= [__middle, __m2)\n        //         [__middle, __m2) <  [__m1, __middle)\n        //         [__m1, __middle) <= [__m2, __last)\n        //     and __m1 or __m2 is in the middle of its range\n        _BidirectionalIterator __m1;  // \"median\" of [__first, __middle)\n        _BidirectionalIterator __m2;  // \"median\" of [__middle, __last)\n        difference_type __len11;      // distance(__first, __m1)\n        difference_type __len21;      // distance(__middle, __m2)\n        // binary search smaller range\n        if (__len1 < __len2)\n        {   // __len >= 1, __len2 >= 2\n            __len21 = __len2 / 2;\n            __m2 = __middle;\n            _VSTD::advance(__m2, __len21);\n            __m1 = __upper_bound<_Compare>(__first, __middle, *__m2, __comp);\n            __len11 = _VSTD::distance(__first, __m1);\n        }\n        else\n        {\n            if (__len1 == 1)\n            {   // __len1 >= __len2 && __len2 > 0, therefore __len2 == 1\n                // It is known *__first > *__middle\n                swap(*__first, *__middle);\n                return;\n            }\n            // __len1 >= 2, __len2 >= 1\n            __len11 = __len1 / 2;\n            __m1 = __first;\n            _VSTD::advance(__m1, __len11);\n            __m2 = __lower_bound<_Compare>(__middle, __last, *__m1, __comp);\n            __len21 = _VSTD::distance(__middle, __m2);\n        }\n        difference_type __len12 = __len1 - __len11;  // distance(__m1, __middle)\n        difference_type __len22 = __len2 - __len21;  // distance(__m2, __last)\n        // [__first, __m1) [__m1, __middle) [__middle, __m2) [__m2, __last)\n        // swap middle two partitions\n        __middle = _VSTD::rotate(__m1, __middle, __m2);\n        // __len12 and __len21 now have swapped meanings\n        // merge smaller range with recurisve call and larger with tail recursion elimination\n        if (__len11 + __len21 < __len12 + __len22)\n        {\n            __inplace_merge<_Compare>(__first, __m1, __middle, __comp, __len11, __len21, __buff, __buff_size);\n//          __inplace_merge<_Compare>(__middle, __m2, __last, __comp, __len12, __len22, __buff, __buff_size);\n            __first = __middle;\n            __middle = __m2;\n            __len1 = __len12;\n            __len2 = __len22;\n        }\n        else\n        {\n            __inplace_merge<_Compare>(__middle, __m2, __last, __comp, __len12, __len22, __buff, __buff_size);\n//          __inplace_merge<_Compare>(__first, __m1, __middle, __comp, __len11, __len21, __buff, __buff_size);\n            __last = __middle;\n            __middle = __m1;\n            __len1 = __len11;\n            __len2 = __len21;\n        }\n    }\n}\n\ntemplate <class _BidirectionalIterator, class _Compare>\ninline _LIBCPP_INLINE_VISIBILITY\nvoid\ninplace_merge(_BidirectionalIterator __first, _BidirectionalIterator __middle, _BidirectionalIterator __last,\n              _Compare __comp)\n{\n    typedef typename iterator_traits<_BidirectionalIterator>::value_type value_type;\n    typedef typename iterator_traits<_BidirectionalIterator>::difference_type difference_type;\n    difference_type __len1 = _VSTD::distance(__first, __middle);\n    difference_type __len2 = _VSTD::distance(__middle, __last);\n    difference_type __buf_size = _VSTD::min(__len1, __len2);\n    pair<value_type*, ptrdiff_t> __buf = _VSTD::get_temporary_buffer<value_type>(__buf_size);\n    unique_ptr<value_type, __return_temporary_buffer> __h(__buf.first);\n\n#ifdef _LIBCPP_DEBUG\n    typedef typename add_lvalue_reference<__debug_less<_Compare> >::type _Comp_ref;\n    __debug_less<_Compare> __c(__comp);\n    return _VSTD::__inplace_merge<_Comp_ref>(__first, __middle, __last, __c, __len1, __len2,\n                                            __buf.first, __buf.second);\n#else  // _LIBCPP_DEBUG\n    typedef typename add_lvalue_reference<_Compare>::type _Comp_ref;\n    return _VSTD::__inplace_merge<_Comp_ref>(__first, __middle, __last, __comp, __len1, __len2,\n                                            __buf.first, __buf.second);\n#endif  // _LIBCPP_DEBUG\n}\n\ntemplate <class _BidirectionalIterator>\ninline _LIBCPP_INLINE_VISIBILITY\nvoid\ninplace_merge(_BidirectionalIterator __first, _BidirectionalIterator __middle, _BidirectionalIterator __last)\n{\n    _VSTD::inplace_merge(__first, __middle, __last,\n                        __less<typename iterator_traits<_BidirectionalIterator>::value_type>());\n}\n\n// stable_sort\n\ntemplate <class _Compare, class _InputIterator1, class _InputIterator2>\nvoid\n__merge_move_construct(_InputIterator1 __first1, _InputIterator1 __last1,\n        _InputIterator2 __first2, _InputIterator2 __last2,\n        typename iterator_traits<_InputIterator1>::value_type* __result, _Compare __comp)\n{\n    typedef typename iterator_traits<_InputIterator1>::value_type value_type;\n    __destruct_n __d(0);\n    unique_ptr<value_type, __destruct_n&> __h(__result, __d);\n    for (; true; ++__result)\n    {\n        if (__first1 == __last1)\n        {\n            for (; __first2 != __last2; ++__first2, ++__result, __d.__incr((value_type*)0))\n                ::new (__result) value_type(_VSTD::move(*__first2));\n            __h.release();\n            return;\n        }\n        if (__first2 == __last2)\n        {\n            for (; __first1 != __last1; ++__first1, ++__result, __d.__incr((value_type*)0))\n                ::new (__result) value_type(_VSTD::move(*__first1));\n            __h.release();\n            return;\n        }\n        if (__comp(*__first2, *__first1))\n        {\n            ::new (__result) value_type(_VSTD::move(*__first2));\n            __d.__incr((value_type*)0);\n            ++__first2;\n        }\n        else\n        {\n            ::new (__result) value_type(_VSTD::move(*__first1));\n            __d.__incr((value_type*)0);\n            ++__first1;\n        }\n    }\n}\n\ntemplate <class _Compare, class _InputIterator1, class _InputIterator2, class _OutputIterator>\nvoid\n__merge_move_assign(_InputIterator1 __first1, _InputIterator1 __last1,\n        _InputIterator2 __first2, _InputIterator2 __last2,\n        _OutputIterator __result, _Compare __comp)\n{\n    for (; __first1 != __last1; ++__result)\n    {\n        if (__first2 == __last2)\n        {\n            for (; __first1 != __last1; ++__first1, ++__result)\n                *__result = _VSTD::move(*__first1);\n            return;\n        }\n        if (__comp(*__first2, *__first1))\n        {\n            *__result = _VSTD::move(*__first2);\n            ++__first2;\n        }\n        else\n        {\n            *__result = _VSTD::move(*__first1);\n            ++__first1;\n        }\n    }\n    for (; __first2 != __last2; ++__first2, ++__result)\n        *__result = _VSTD::move(*__first2);\n}\n\ntemplate <class _Compare, class _RandomAccessIterator>\nvoid\n__stable_sort(_RandomAccessIterator __first, _RandomAccessIterator __last, _Compare __comp,\n              typename iterator_traits<_RandomAccessIterator>::difference_type __len,\n              typename iterator_traits<_RandomAccessIterator>::value_type* __buff, ptrdiff_t __buff_size);\n\ntemplate <class _Compare, class _RandomAccessIterator>\nvoid\n__stable_sort_move(_RandomAccessIterator __first1, _RandomAccessIterator __last1, _Compare __comp,\n                   typename iterator_traits<_RandomAccessIterator>::difference_type __len,\n                   typename iterator_traits<_RandomAccessIterator>::value_type* __first2)\n{\n    typedef typename iterator_traits<_RandomAccessIterator>::value_type value_type;\n    switch (__len)\n    {\n    case 0:\n        return;\n    case 1:\n        ::new(__first2) value_type(_VSTD::move(*__first1));\n        return;\n    case 2:\n       __destruct_n __d(0);\n        unique_ptr<value_type, __destruct_n&> __h2(__first2, __d);\n         if (__comp(*--__last1, *__first1))\n        {\n            ::new(__first2) value_type(_VSTD::move(*__last1));\n            __d.__incr((value_type*)0);\n            ++__first2;\n            ::new(__first2) value_type(_VSTD::move(*__first1));\n        }\n        else\n        {\n            ::new(__first2) value_type(_VSTD::move(*__first1));\n            __d.__incr((value_type*)0);\n            ++__first2;\n            ::new(__first2) value_type(_VSTD::move(*__last1));\n        }\n        __h2.release();\n        return;\n    }\n    if (__len <= 8)\n    {\n        __insertion_sort_move<_Compare>(__first1, __last1, __first2, __comp);\n        return;\n    }\n    typename iterator_traits<_RandomAccessIterator>::difference_type __l2 = __len / 2;\n    _RandomAccessIterator __m = __first1 + __l2;\n    __stable_sort<_Compare>(__first1, __m, __comp, __l2, __first2, __l2);\n    __stable_sort<_Compare>(__m, __last1, __comp, __len - __l2, __first2 + __l2, __len - __l2);\n    __merge_move_construct<_Compare>(__first1, __m, __m, __last1, __first2, __comp);\n}\n\ntemplate <class _Tp>\nstruct __stable_sort_switch\n{\n    static const unsigned value = 128*is_trivially_copy_assignable<_Tp>::value;\n};\n\ntemplate <class _Compare, class _RandomAccessIterator>\nvoid\n__stable_sort(_RandomAccessIterator __first, _RandomAccessIterator __last, _Compare __comp,\n              typename iterator_traits<_RandomAccessIterator>::difference_type __len,\n              typename iterator_traits<_RandomAccessIterator>::value_type* __buff, ptrdiff_t __buff_size)\n{\n    typedef typename iterator_traits<_RandomAccessIterator>::value_type value_type;\n    typedef typename iterator_traits<_RandomAccessIterator>::difference_type difference_type;\n    switch (__len)\n    {\n    case 0:\n    case 1:\n        return;\n    case 2:\n        if (__comp(*--__last, *__first))\n            swap(*__first, *__last);\n        return;\n    }\n    if (__len <= static_cast<difference_type>(__stable_sort_switch<value_type>::value))\n    {\n        __insertion_sort<_Compare>(__first, __last, __comp);\n        return;\n    }\n    typename iterator_traits<_RandomAccessIterator>::difference_type __l2 = __len / 2;\n    _RandomAccessIterator __m = __first + __l2;\n    if (__len <= __buff_size)\n    {\n        __destruct_n __d(0);\n        unique_ptr<value_type, __destruct_n&> __h2(__buff, __d);\n        __stable_sort_move<_Compare>(__first, __m, __comp, __l2, __buff);\n        __d.__set(__l2, (value_type*)0);\n        __stable_sort_move<_Compare>(__m, __last, __comp, __len - __l2, __buff + __l2);\n        __d.__set(__len, (value_type*)0);\n        __merge_move_assign<_Compare>(__buff, __buff + __l2, __buff + __l2, __buff + __len, __first, __comp);\n//         __merge<_Compare>(move_iterator<value_type*>(__buff),\n//                           move_iterator<value_type*>(__buff + __l2),\n//                           move_iterator<_RandomAccessIterator>(__buff + __l2),\n//                           move_iterator<_RandomAccessIterator>(__buff + __len),\n//                           __first, __comp);\n        return;\n    }\n    __stable_sort<_Compare>(__first, __m, __comp, __l2, __buff, __buff_size);\n    __stable_sort<_Compare>(__m, __last, __comp, __len - __l2, __buff, __buff_size);\n    __inplace_merge<_Compare>(__first, __m, __last, __comp, __l2, __len - __l2, __buff, __buff_size);\n}\n\ntemplate <class _RandomAccessIterator, class _Compare>\ninline _LIBCPP_INLINE_VISIBILITY\nvoid\nstable_sort(_RandomAccessIterator __first, _RandomAccessIterator __last, _Compare __comp)\n{\n    typedef typename iterator_traits<_RandomAccessIterator>::value_type value_type;\n    typedef typename iterator_traits<_RandomAccessIterator>::difference_type difference_type;\n    difference_type __len = __last - __first;\n    pair<value_type*, ptrdiff_t> __buf(0, 0);\n    unique_ptr<value_type, __return_temporary_buffer> __h;\n    if (__len > static_cast<difference_type>(__stable_sort_switch<value_type>::value))\n    {\n        __buf = _VSTD::get_temporary_buffer<value_type>(__len);\n        __h.reset(__buf.first);\n    }\n#ifdef _LIBCPP_DEBUG\n    typedef typename add_lvalue_reference<__debug_less<_Compare> >::type _Comp_ref;\n    __debug_less<_Compare> __c(__comp);\n    __stable_sort<_Comp_ref>(__first, __last, __c, __len, __buf.first, __buf.second);\n#else  // _LIBCPP_DEBUG\n    typedef typename add_lvalue_reference<_Compare>::type _Comp_ref;\n    __stable_sort<_Comp_ref>(__first, __last, __comp, __len, __buf.first, __buf.second);\n#endif  // _LIBCPP_DEBUG\n}\n\ntemplate <class _RandomAccessIterator>\ninline _LIBCPP_INLINE_VISIBILITY\nvoid\nstable_sort(_RandomAccessIterator __first, _RandomAccessIterator __last)\n{\n    _VSTD::stable_sort(__first, __last, __less<typename iterator_traits<_RandomAccessIterator>::value_type>());\n}\n\n// is_heap_until\n\ntemplate <class _RandomAccessIterator, class _Compare>\n_RandomAccessIterator\nis_heap_until(_RandomAccessIterator __first, _RandomAccessIterator __last, _Compare __comp)\n{\n    typedef typename _VSTD::iterator_traits<_RandomAccessIterator>::difference_type difference_type;\n    difference_type __len = __last - __first;\n    difference_type __p = 0;\n    difference_type __c = 1;\n    _RandomAccessIterator __pp = __first;\n    while (__c < __len)\n    {\n        _RandomAccessIterator __cp = __first + __c;\n        if (__comp(*__pp, *__cp))\n            return __cp;\n        ++__c;\n        ++__cp;\n        if (__c == __len)\n            return __last;\n        if (__comp(*__pp, *__cp))\n            return __cp;\n        ++__p;\n        ++__pp;\n        __c = 2 * __p + 1;\n    }\n    return __last;\n}\n\ntemplate<class _RandomAccessIterator>\ninline _LIBCPP_INLINE_VISIBILITY\n_RandomAccessIterator\nis_heap_until(_RandomAccessIterator __first, _RandomAccessIterator __last)\n{\n    return _VSTD::is_heap_until(__first, __last, __less<typename iterator_traits<_RandomAccessIterator>::value_type>());\n}\n\n// is_heap\n\ntemplate <class _RandomAccessIterator, class _Compare>\ninline _LIBCPP_INLINE_VISIBILITY\nbool\nis_heap(_RandomAccessIterator __first, _RandomAccessIterator __last, _Compare __comp)\n{\n    return _VSTD::is_heap_until(__first, __last, __comp) == __last;\n}\n\ntemplate<class _RandomAccessIterator>\ninline _LIBCPP_INLINE_VISIBILITY\nbool\nis_heap(_RandomAccessIterator __first, _RandomAccessIterator __last)\n{\n    return _VSTD::is_heap(__first, __last, __less<typename iterator_traits<_RandomAccessIterator>::value_type>());\n}\n\n// push_heap\n\ntemplate <class _Compare, class _RandomAccessIterator>\nvoid\n__sift_up(_RandomAccessIterator __first, _RandomAccessIterator __last, _Compare __comp,\n          typename iterator_traits<_RandomAccessIterator>::difference_type __len)\n{\n    typedef typename iterator_traits<_RandomAccessIterator>::value_type value_type;\n    if (__len > 1)\n    {\n        __len = (__len - 2) / 2;\n        _RandomAccessIterator __ptr = __first + __len;\n        if (__comp(*__ptr, *--__last))\n        {\n            value_type __t(_VSTD::move(*__last));\n            do\n            {\n                *__last = _VSTD::move(*__ptr);\n                __last = __ptr;\n                if (__len == 0)\n                    break;\n                __len = (__len - 1) / 2;\n                __ptr = __first + __len;\n            } while (__comp(*__ptr, __t));\n            *__last = _VSTD::move(__t);\n        }\n    }\n}\n\ntemplate <class _RandomAccessIterator, class _Compare>\ninline _LIBCPP_INLINE_VISIBILITY\nvoid\npush_heap(_RandomAccessIterator __first, _RandomAccessIterator __last, _Compare __comp)\n{\n#ifdef _LIBCPP_DEBUG\n    typedef typename add_lvalue_reference<__debug_less<_Compare> >::type _Comp_ref;\n    __debug_less<_Compare> __c(__comp);\n    __sift_up<_Comp_ref>(__first, __last, __c, __last - __first);\n#else  // _LIBCPP_DEBUG\n    typedef typename add_lvalue_reference<_Compare>::type _Comp_ref;\n    __sift_up<_Comp_ref>(__first, __last, __comp, __last - __first);\n#endif  // _LIBCPP_DEBUG\n}\n\ntemplate <class _RandomAccessIterator>\ninline _LIBCPP_INLINE_VISIBILITY\nvoid\npush_heap(_RandomAccessIterator __first, _RandomAccessIterator __last)\n{\n    _VSTD::push_heap(__first, __last, __less<typename iterator_traits<_RandomAccessIterator>::value_type>());\n}\n\n// pop_heap\n\ntemplate <class _Compare, class _RandomAccessIterator>\nvoid\n__sift_down(_RandomAccessIterator __first, _RandomAccessIterator /*__last*/,\n            _Compare __comp,\n            typename iterator_traits<_RandomAccessIterator>::difference_type __len,\n            _RandomAccessIterator __start)\n{\n    typedef typename iterator_traits<_RandomAccessIterator>::difference_type difference_type;\n    typedef typename iterator_traits<_RandomAccessIterator>::value_type value_type;\n    // left-child of __start is at 2 * __start + 1\n    // right-child of __start is at 2 * __start + 2\n    difference_type __child = __start - __first;\n\n    if (__len < 2 || (__len - 2) / 2 < __child)\n        return;\n\n    __child = 2 * __child + 1;\n    _RandomAccessIterator __child_i = __first + __child;\n\n    if ((__child + 1) < __len && __comp(*__child_i, *(__child_i + 1))) {\n        // right-child exists and is greater than left-child\n        ++__child_i;\n        ++__child;\n    }\n\n    // check if we are in heap-order\n    if (__comp(*__child_i, *__start))\n        // we are, __start is larger than it's largest child\n        return;\n\n    value_type __top(_VSTD::move(*__start));\n    do\n    {\n        // we are not in heap-order, swap the parent with it's largest child\n        *__start = _VSTD::move(*__child_i);\n        __start = __child_i;\n\n        if ((__len - 2) / 2 < __child)\n            break;\n\n        // recompute the child based off of the updated parent\n        __child = 2 * __child + 1;\n        __child_i = __first + __child;\n\n        if ((__child + 1) < __len && __comp(*__child_i, *(__child_i + 1))) {\n            // right-child exists and is greater than left-child\n            ++__child_i;\n            ++__child;\n        }\n\n        // check if we are in heap-order\n    } while (!__comp(*__child_i, __top));\n    *__start = _VSTD::move(__top);\n}\n\ntemplate <class _Compare, class _RandomAccessIterator>\ninline _LIBCPP_INLINE_VISIBILITY\nvoid\n__pop_heap(_RandomAccessIterator __first, _RandomAccessIterator __last, _Compare __comp,\n           typename iterator_traits<_RandomAccessIterator>::difference_type __len)\n{\n    if (__len > 1)\n    {\n        swap(*__first, *--__last);\n        __sift_down<_Compare>(__first, __last, __comp, __len - 1, __first);\n    }\n}\n\ntemplate <class _RandomAccessIterator, class _Compare>\ninline _LIBCPP_INLINE_VISIBILITY\nvoid\npop_heap(_RandomAccessIterator __first, _RandomAccessIterator __last, _Compare __comp)\n{\n#ifdef _LIBCPP_DEBUG\n    typedef typename add_lvalue_reference<__debug_less<_Compare> >::type _Comp_ref;\n    __debug_less<_Compare> __c(__comp);\n    __pop_heap<_Comp_ref>(__first, __last, __c, __last - __first);\n#else  // _LIBCPP_DEBUG\n    typedef typename add_lvalue_reference<_Compare>::type _Comp_ref;\n    __pop_heap<_Comp_ref>(__first, __last, __comp, __last - __first);\n#endif  // _LIBCPP_DEBUG\n}\n\ntemplate <class _RandomAccessIterator>\ninline _LIBCPP_INLINE_VISIBILITY\nvoid\npop_heap(_RandomAccessIterator __first, _RandomAccessIterator __last)\n{\n    _VSTD::pop_heap(__first, __last, __less<typename iterator_traits<_RandomAccessIterator>::value_type>());\n}\n\n// make_heap\n\ntemplate <class _Compare, class _RandomAccessIterator>\nvoid\n__make_heap(_RandomAccessIterator __first, _RandomAccessIterator __last, _Compare __comp)\n{\n    typedef typename iterator_traits<_RandomAccessIterator>::difference_type difference_type;\n    difference_type __n = __last - __first;\n    if (__n > 1)\n    {\n        // start from the first parent, there is no need to consider children\n        for (difference_type __start = (__n - 2) / 2; __start >= 0; --__start)\n        {\n            __sift_down<_Compare>(__first, __last, __comp, __n, __first + __start);\n        }\n    }\n}\n\ntemplate <class _RandomAccessIterator, class _Compare>\ninline _LIBCPP_INLINE_VISIBILITY\nvoid\nmake_heap(_RandomAccessIterator __first, _RandomAccessIterator __last, _Compare __comp)\n{\n#ifdef _LIBCPP_DEBUG\n    typedef typename add_lvalue_reference<__debug_less<_Compare> >::type _Comp_ref;\n    __debug_less<_Compare> __c(__comp);\n    __make_heap<_Comp_ref>(__first, __last, __c);\n#else  // _LIBCPP_DEBUG\n    typedef typename add_lvalue_reference<_Compare>::type _Comp_ref;\n    __make_heap<_Comp_ref>(__first, __last, __comp);\n#endif  // _LIBCPP_DEBUG\n}\n\ntemplate <class _RandomAccessIterator>\ninline _LIBCPP_INLINE_VISIBILITY\nvoid\nmake_heap(_RandomAccessIterator __first, _RandomAccessIterator __last)\n{\n    _VSTD::make_heap(__first, __last, __less<typename iterator_traits<_RandomAccessIterator>::value_type>());\n}\n\n// sort_heap\n\ntemplate <class _Compare, class _RandomAccessIterator>\nvoid\n__sort_heap(_RandomAccessIterator __first, _RandomAccessIterator __last, _Compare __comp)\n{\n    typedef typename iterator_traits<_RandomAccessIterator>::difference_type difference_type;\n    for (difference_type __n = __last - __first; __n > 1; --__last, --__n)\n        __pop_heap<_Compare>(__first, __last, __comp, __n);\n}\n\ntemplate <class _RandomAccessIterator, class _Compare>\ninline _LIBCPP_INLINE_VISIBILITY\nvoid\nsort_heap(_RandomAccessIterator __first, _RandomAccessIterator __last, _Compare __comp)\n{\n#ifdef _LIBCPP_DEBUG\n    typedef typename add_lvalue_reference<__debug_less<_Compare> >::type _Comp_ref;\n    __debug_less<_Compare> __c(__comp);\n    __sort_heap<_Comp_ref>(__first, __last, __c);\n#else  // _LIBCPP_DEBUG\n    typedef typename add_lvalue_reference<_Compare>::type _Comp_ref;\n    __sort_heap<_Comp_ref>(__first, __last, __comp);\n#endif  // _LIBCPP_DEBUG\n}\n\ntemplate <class _RandomAccessIterator>\ninline _LIBCPP_INLINE_VISIBILITY\nvoid\nsort_heap(_RandomAccessIterator __first, _RandomAccessIterator __last)\n{\n    _VSTD::sort_heap(__first, __last, __less<typename iterator_traits<_RandomAccessIterator>::value_type>());\n}\n\n// partial_sort\n\ntemplate <class _Compare, class _RandomAccessIterator>\nvoid\n__partial_sort(_RandomAccessIterator __first, _RandomAccessIterator __middle, _RandomAccessIterator __last,\n             _Compare __comp)\n{\n    __make_heap<_Compare>(__first, __middle, __comp);\n    typename iterator_traits<_RandomAccessIterator>::difference_type __len = __middle - __first;\n    for (_RandomAccessIterator __i = __middle; __i != __last; ++__i)\n    {\n        if (__comp(*__i, *__first))\n        {\n            swap(*__i, *__first);\n            __sift_down<_Compare>(__first, __middle, __comp, __len, __first);\n        }\n    }\n    __sort_heap<_Compare>(__first, __middle, __comp);\n}\n\ntemplate <class _RandomAccessIterator, class _Compare>\ninline _LIBCPP_INLINE_VISIBILITY\nvoid\npartial_sort(_RandomAccessIterator __first, _RandomAccessIterator __middle, _RandomAccessIterator __last,\n             _Compare __comp)\n{\n#ifdef _LIBCPP_DEBUG\n    typedef typename add_lvalue_reference<__debug_less<_Compare> >::type _Comp_ref;\n    __debug_less<_Compare> __c(__comp);\n    __partial_sort<_Comp_ref>(__first, __middle, __last, __c);\n#else  // _LIBCPP_DEBUG\n    typedef typename add_lvalue_reference<_Compare>::type _Comp_ref;\n    __partial_sort<_Comp_ref>(__first, __middle, __last, __comp);\n#endif  // _LIBCPP_DEBUG\n}\n\ntemplate <class _RandomAccessIterator>\ninline _LIBCPP_INLINE_VISIBILITY\nvoid\npartial_sort(_RandomAccessIterator __first, _RandomAccessIterator __middle, _RandomAccessIterator __last)\n{\n    _VSTD::partial_sort(__first, __middle, __last,\n                       __less<typename iterator_traits<_RandomAccessIterator>::value_type>());\n}\n\n// partial_sort_copy\n\ntemplate <class _Compare, class _InputIterator, class _RandomAccessIterator>\n_RandomAccessIterator\n__partial_sort_copy(_InputIterator __first, _InputIterator __last,\n                    _RandomAccessIterator __result_first, _RandomAccessIterator __result_last, _Compare __comp)\n{\n    _RandomAccessIterator __r = __result_first;\n    if (__r != __result_last)\n    {\n        for (; __first != __last && __r != __result_last; (void) ++__first, ++__r)\n            *__r = *__first;\n        __make_heap<_Compare>(__result_first, __r, __comp);\n        typename iterator_traits<_RandomAccessIterator>::difference_type __len = __r - __result_first;\n        for (; __first != __last; ++__first)\n            if (__comp(*__first, *__result_first))\n            {\n                *__result_first = *__first;\n                __sift_down<_Compare>(__result_first, __r, __comp, __len, __result_first);\n            }\n        __sort_heap<_Compare>(__result_first, __r, __comp);\n    }\n    return __r;\n}\n\ntemplate <class _InputIterator, class _RandomAccessIterator, class _Compare>\ninline _LIBCPP_INLINE_VISIBILITY\n_RandomAccessIterator\npartial_sort_copy(_InputIterator __first, _InputIterator __last,\n                  _RandomAccessIterator __result_first, _RandomAccessIterator __result_last, _Compare __comp)\n{\n#ifdef _LIBCPP_DEBUG\n    typedef typename add_lvalue_reference<__debug_less<_Compare> >::type _Comp_ref;\n    __debug_less<_Compare> __c(__comp);\n    return __partial_sort_copy<_Comp_ref>(__first, __last, __result_first, __result_last, __c);\n#else  // _LIBCPP_DEBUG\n    typedef typename add_lvalue_reference<_Compare>::type _Comp_ref;\n    return __partial_sort_copy<_Comp_ref>(__first, __last, __result_first, __result_last, __comp);\n#endif  // _LIBCPP_DEBUG\n}\n\ntemplate <class _InputIterator, class _RandomAccessIterator>\ninline _LIBCPP_INLINE_VISIBILITY\n_RandomAccessIterator\npartial_sort_copy(_InputIterator __first, _InputIterator __last,\n                  _RandomAccessIterator __result_first, _RandomAccessIterator __result_last)\n{\n    return _VSTD::partial_sort_copy(__first, __last, __result_first, __result_last,\n                                   __less<typename iterator_traits<_RandomAccessIterator>::value_type>());\n}\n\n// nth_element\n\ntemplate <class _Compare, class _RandomAccessIterator>\nvoid\n__nth_element(_RandomAccessIterator __first, _RandomAccessIterator __nth, _RandomAccessIterator __last, _Compare __comp)\n{\n    // _Compare is known to be a reference type\n    typedef typename iterator_traits<_RandomAccessIterator>::difference_type difference_type;\n    const difference_type __limit = 7;\n    while (true)\n    {\n    __restart:\n        if (__nth == __last)\n            return;\n        difference_type __len = __last - __first;\n        switch (__len)\n        {\n        case 0:\n        case 1:\n            return;\n        case 2:\n            if (__comp(*--__last, *__first))\n                swap(*__first, *__last);\n            return;\n        case 3:\n            {\n            _RandomAccessIterator __m = __first;\n            _VSTD::__sort3<_Compare>(__first, ++__m, --__last, __comp);\n            return;\n            }\n        }\n        if (__len <= __limit)\n        {\n            __selection_sort<_Compare>(__first, __last, __comp);\n            return;\n        }\n        // __len > __limit >= 3\n        _RandomAccessIterator __m = __first + __len/2;\n        _RandomAccessIterator __lm1 = __last;\n        unsigned __n_swaps = _VSTD::__sort3<_Compare>(__first, __m, --__lm1, __comp);\n        // *__m is median\n        // partition [__first, __m) < *__m and *__m <= [__m, __last)\n        // (this inhibits tossing elements equivalent to __m around unnecessarily)\n        _RandomAccessIterator __i = __first;\n        _RandomAccessIterator __j = __lm1;\n        // j points beyond range to be tested, *__lm1 is known to be <= *__m\n        // The search going up is known to be guarded but the search coming down isn't.\n        // Prime the downward search with a guard.\n        if (!__comp(*__i, *__m))  // if *__first == *__m\n        {\n            // *__first == *__m, *__first doesn't go in first part\n            // manually guard downward moving __j against __i\n            while (true)\n            {\n                if (__i == --__j)\n                {\n                    // *__first == *__m, *__m <= all other elements\n                    // Parition instead into [__first, __i) == *__first and *__first < [__i, __last)\n                    ++__i;  // __first + 1\n                    __j = __last;\n                    if (!__comp(*__first, *--__j))  // we need a guard if *__first == *(__last-1)\n                    {\n                        while (true)\n                        {\n                            if (__i == __j)\n                                return;  // [__first, __last) all equivalent elements\n                            if (__comp(*__first, *__i))\n                            {\n                                swap(*__i, *__j);\n                                ++__n_swaps;\n                                ++__i;\n                                break;\n                            }\n                            ++__i;\n                        }\n                    }\n                    // [__first, __i) == *__first and *__first < [__j, __last) and __j == __last - 1\n                    if (__i == __j)\n                        return;\n                    while (true)\n                    {\n                        while (!__comp(*__first, *__i))\n                            ++__i;\n                        while (__comp(*__first, *--__j))\n                            ;\n                        if (__i >= __j)\n                            break;\n                        swap(*__i, *__j);\n                        ++__n_swaps;\n                        ++__i;\n                    }\n                    // [__first, __i) == *__first and *__first < [__i, __last)\n                    // The first part is sorted,\n                    if (__nth < __i)\n                        return;\n                    // __nth_element the secod part\n                    // __nth_element<_Compare>(__i, __nth, __last, __comp);\n                    __first = __i;\n                    goto __restart;\n                }\n                if (__comp(*__j, *__m))\n                {\n                    swap(*__i, *__j);\n                    ++__n_swaps;\n                    break;  // found guard for downward moving __j, now use unguarded partition\n                }\n            }\n        }\n        ++__i;\n        // j points beyond range to be tested, *__lm1 is known to be <= *__m\n        // if not yet partitioned...\n        if (__i < __j)\n        {\n            // known that *(__i - 1) < *__m\n            while (true)\n            {\n                // __m still guards upward moving __i\n                while (__comp(*__i, *__m))\n                    ++__i;\n                // It is now known that a guard exists for downward moving __j\n                while (!__comp(*--__j, *__m))\n                    ;\n                if (__i >= __j)\n                    break;\n                swap(*__i, *__j);\n                ++__n_swaps;\n                // It is known that __m != __j\n                // If __m just moved, follow it\n                if (__m == __i)\n                    __m = __j;\n                ++__i;\n            }\n        }\n        // [__first, __i) < *__m and *__m <= [__i, __last)\n        if (__i != __m && __comp(*__m, *__i))\n        {\n            swap(*__i, *__m);\n            ++__n_swaps;\n        }\n        // [__first, __i) < *__i and *__i <= [__i+1, __last)\n        if (__nth == __i)\n            return;\n        if (__n_swaps == 0)\n        {\n            // We were given a perfectly partitioned sequence.  Coincidence?\n            if (__nth < __i)\n            {\n                // Check for [__first, __i) already sorted\n                __j = __m = __first;\n                while (++__j != __i)\n                {\n                    if (__comp(*__j, *__m))\n                        // not yet sorted, so sort\n                        goto not_sorted;\n                    __m = __j;\n                }\n                // [__first, __i) sorted\n                return;\n            }\n            else\n            {\n                // Check for [__i, __last) already sorted\n                __j = __m = __i;\n                while (++__j != __last)\n                {\n                    if (__comp(*__j, *__m))\n                        // not yet sorted, so sort\n                        goto not_sorted;\n                    __m = __j;\n                }\n                // [__i, __last) sorted\n                return;\n            }\n        }\nnot_sorted:\n        // __nth_element on range containing __nth\n        if (__nth < __i)\n        {\n            // __nth_element<_Compare>(__first, __nth, __i, __comp);\n            __last = __i;\n        }\n        else\n        {\n            // __nth_element<_Compare>(__i+1, __nth, __last, __comp);\n            __first = ++__i;\n        }\n    }\n}\n\ntemplate <class _RandomAccessIterator, class _Compare>\ninline _LIBCPP_INLINE_VISIBILITY\nvoid\nnth_element(_RandomAccessIterator __first, _RandomAccessIterator __nth, _RandomAccessIterator __last, _Compare __comp)\n{\n#ifdef _LIBCPP_DEBUG\n    typedef typename add_lvalue_reference<__debug_less<_Compare> >::type _Comp_ref;\n    __debug_less<_Compare> __c(__comp);\n    __nth_element<_Comp_ref>(__first, __nth, __last, __c);\n#else  // _LIBCPP_DEBUG\n    typedef typename add_lvalue_reference<_Compare>::type _Comp_ref;\n    __nth_element<_Comp_ref>(__first, __nth, __last, __comp);\n#endif  // _LIBCPP_DEBUG\n}\n\ntemplate <class _RandomAccessIterator>\ninline _LIBCPP_INLINE_VISIBILITY\nvoid\nnth_element(_RandomAccessIterator __first, _RandomAccessIterator __nth, _RandomAccessIterator __last)\n{\n    _VSTD::nth_element(__first, __nth, __last, __less<typename iterator_traits<_RandomAccessIterator>::value_type>());\n}\n\n// includes\n\ntemplate <class _Compare, class _InputIterator1, class _InputIterator2>\nbool\n__includes(_InputIterator1 __first1, _InputIterator1 __last1, _InputIterator2 __first2, _InputIterator2 __last2,\n           _Compare __comp)\n{\n    for (; __first2 != __last2; ++__first1)\n    {\n        if (__first1 == __last1 || __comp(*__first2, *__first1))\n            return false;\n        if (!__comp(*__first1, *__first2))\n            ++__first2;\n    }\n    return true;\n}\n\ntemplate <class _InputIterator1, class _InputIterator2, class _Compare>\ninline _LIBCPP_INLINE_VISIBILITY\nbool\nincludes(_InputIterator1 __first1, _InputIterator1 __last1, _InputIterator2 __first2, _InputIterator2 __last2,\n         _Compare __comp)\n{\n#ifdef _LIBCPP_DEBUG\n    typedef typename add_lvalue_reference<__debug_less<_Compare> >::type _Comp_ref;\n    __debug_less<_Compare> __c(__comp);\n    return __includes<_Comp_ref>(__first1, __last1, __first2, __last2, __c);\n#else  // _LIBCPP_DEBUG\n    typedef typename add_lvalue_reference<_Compare>::type _Comp_ref;\n    return __includes<_Comp_ref>(__first1, __last1, __first2, __last2, __comp);\n#endif  // _LIBCPP_DEBUG\n}\n\ntemplate <class _InputIterator1, class _InputIterator2>\ninline _LIBCPP_INLINE_VISIBILITY\nbool\nincludes(_InputIterator1 __first1, _InputIterator1 __last1, _InputIterator2 __first2, _InputIterator2 __last2)\n{\n    return _VSTD::includes(__first1, __last1, __first2, __last2,\n                          __less<typename iterator_traits<_InputIterator1>::value_type,\n                                 typename iterator_traits<_InputIterator2>::value_type>());\n}\n\n// set_union\n\ntemplate <class _Compare, class _InputIterator1, class _InputIterator2, class _OutputIterator>\n_OutputIterator\n__set_union(_InputIterator1 __first1, _InputIterator1 __last1,\n            _InputIterator2 __first2, _InputIterator2 __last2, _OutputIterator __result, _Compare __comp)\n{\n    for (; __first1 != __last1; ++__result)\n    {\n        if (__first2 == __last2)\n            return _VSTD::copy(__first1, __last1, __result);\n        if (__comp(*__first2, *__first1))\n        {\n            *__result = *__first2;\n            ++__first2;\n        }\n        else\n        {\n            *__result = *__first1;\n            if (!__comp(*__first1, *__first2))\n                ++__first2;\n            ++__first1;\n        }\n    }\n    return _VSTD::copy(__first2, __last2, __result);\n}\n\ntemplate <class _InputIterator1, class _InputIterator2, class _OutputIterator, class _Compare>\ninline _LIBCPP_INLINE_VISIBILITY\n_OutputIterator\nset_union(_InputIterator1 __first1, _InputIterator1 __last1,\n          _InputIterator2 __first2, _InputIterator2 __last2, _OutputIterator __result, _Compare __comp)\n{\n#ifdef _LIBCPP_DEBUG\n    typedef typename add_lvalue_reference<__debug_less<_Compare> >::type _Comp_ref;\n    __debug_less<_Compare> __c(__comp);\n    return __set_union<_Comp_ref>(__first1, __last1, __first2, __last2, __result, __c);\n#else  // _LIBCPP_DEBUG\n    typedef typename add_lvalue_reference<_Compare>::type _Comp_ref;\n    return __set_union<_Comp_ref>(__first1, __last1, __first2, __last2, __result, __comp);\n#endif  // _LIBCPP_DEBUG\n}\n\ntemplate <class _InputIterator1, class _InputIterator2, class _OutputIterator>\ninline _LIBCPP_INLINE_VISIBILITY\n_OutputIterator\nset_union(_InputIterator1 __first1, _InputIterator1 __last1,\n          _InputIterator2 __first2, _InputIterator2 __last2, _OutputIterator __result)\n{\n    return _VSTD::set_union(__first1, __last1, __first2, __last2, __result,\n                          __less<typename iterator_traits<_InputIterator1>::value_type,\n                                 typename iterator_traits<_InputIterator2>::value_type>());\n}\n\n// set_intersection\n\ntemplate <class _Compare, class _InputIterator1, class _InputIterator2, class _OutputIterator>\n_OutputIterator\n__set_intersection(_InputIterator1 __first1, _InputIterator1 __last1,\n                   _InputIterator2 __first2, _InputIterator2 __last2, _OutputIterator __result, _Compare __comp)\n{\n    while (__first1 != __last1 && __first2 != __last2)\n    {\n        if (__comp(*__first1, *__first2))\n            ++__first1;\n        else\n        {\n            if (!__comp(*__first2, *__first1))\n            {\n                *__result = *__first1;\n                ++__result;\n                ++__first1;\n            }\n            ++__first2;\n        }\n    }\n    return __result;\n}\n\ntemplate <class _InputIterator1, class _InputIterator2, class _OutputIterator, class _Compare>\ninline _LIBCPP_INLINE_VISIBILITY\n_OutputIterator\nset_intersection(_InputIterator1 __first1, _InputIterator1 __last1,\n                 _InputIterator2 __first2, _InputIterator2 __last2, _OutputIterator __result, _Compare __comp)\n{\n#ifdef _LIBCPP_DEBUG\n    typedef typename add_lvalue_reference<__debug_less<_Compare> >::type _Comp_ref;\n    __debug_less<_Compare> __c(__comp);\n    return __set_intersection<_Comp_ref>(__first1, __last1, __first2, __last2, __result, __c);\n#else  // _LIBCPP_DEBUG\n    typedef typename add_lvalue_reference<_Compare>::type _Comp_ref;\n    return __set_intersection<_Comp_ref>(__first1, __last1, __first2, __last2, __result, __comp);\n#endif  // _LIBCPP_DEBUG\n}\n\ntemplate <class _InputIterator1, class _InputIterator2, class _OutputIterator>\ninline _LIBCPP_INLINE_VISIBILITY\n_OutputIterator\nset_intersection(_InputIterator1 __first1, _InputIterator1 __last1,\n                 _InputIterator2 __first2, _InputIterator2 __last2, _OutputIterator __result)\n{\n    return _VSTD::set_intersection(__first1, __last1, __first2, __last2, __result,\n                                  __less<typename iterator_traits<_InputIterator1>::value_type,\n                                         typename iterator_traits<_InputIterator2>::value_type>());\n}\n\n// set_difference\n\ntemplate <class _Compare, class _InputIterator1, class _InputIterator2, class _OutputIterator>\n_OutputIterator\n__set_difference(_InputIterator1 __first1, _InputIterator1 __last1,\n                 _InputIterator2 __first2, _InputIterator2 __last2, _OutputIterator __result, _Compare __comp)\n{\n    while (__first1 != __last1)\n    {\n        if (__first2 == __last2)\n            return _VSTD::copy(__first1, __last1, __result);\n        if (__comp(*__first1, *__first2))\n        {\n            *__result = *__first1;\n            ++__result;\n            ++__first1;\n        }\n        else\n        {\n            if (!__comp(*__first2, *__first1))\n                ++__first1;\n            ++__first2;\n        }\n    }\n    return __result;\n}\n\ntemplate <class _InputIterator1, class _InputIterator2, class _OutputIterator, class _Compare>\ninline _LIBCPP_INLINE_VISIBILITY\n_OutputIterator\nset_difference(_InputIterator1 __first1, _InputIterator1 __last1,\n               _InputIterator2 __first2, _InputIterator2 __last2, _OutputIterator __result, _Compare __comp)\n{\n#ifdef _LIBCPP_DEBUG\n    typedef typename add_lvalue_reference<__debug_less<_Compare> >::type _Comp_ref;\n    __debug_less<_Compare> __c(__comp);\n    return __set_difference<_Comp_ref>(__first1, __last1, __first2, __last2, __result, __c);\n#else  // _LIBCPP_DEBUG\n    typedef typename add_lvalue_reference<_Compare>::type _Comp_ref;\n    return __set_difference<_Comp_ref>(__first1, __last1, __first2, __last2, __result, __comp);\n#endif  // _LIBCPP_DEBUG\n}\n\ntemplate <class _InputIterator1, class _InputIterator2, class _OutputIterator>\ninline _LIBCPP_INLINE_VISIBILITY\n_OutputIterator\nset_difference(_InputIterator1 __first1, _InputIterator1 __last1,\n               _InputIterator2 __first2, _InputIterator2 __last2, _OutputIterator __result)\n{\n    return _VSTD::set_difference(__first1, __last1, __first2, __last2, __result,\n                                __less<typename iterator_traits<_InputIterator1>::value_type,\n                                       typename iterator_traits<_InputIterator2>::value_type>());\n}\n\n// set_symmetric_difference\n\ntemplate <class _Compare, class _InputIterator1, class _InputIterator2, class _OutputIterator>\n_OutputIterator\n__set_symmetric_difference(_InputIterator1 __first1, _InputIterator1 __last1,\n                           _InputIterator2 __first2, _InputIterator2 __last2, _OutputIterator __result, _Compare __comp)\n{\n    while (__first1 != __last1)\n    {\n        if (__first2 == __last2)\n            return _VSTD::copy(__first1, __last1, __result);\n        if (__comp(*__first1, *__first2))\n        {\n            *__result = *__first1;\n            ++__result;\n            ++__first1;\n        }\n        else\n        {\n            if (__comp(*__first2, *__first1))\n            {\n                *__result = *__first2;\n                ++__result;\n            }\n            else\n                ++__first1;\n            ++__first2;\n        }\n    }\n    return _VSTD::copy(__first2, __last2, __result);\n}\n\ntemplate <class _InputIterator1, class _InputIterator2, class _OutputIterator, class _Compare>\ninline _LIBCPP_INLINE_VISIBILITY\n_OutputIterator\nset_symmetric_difference(_InputIterator1 __first1, _InputIterator1 __last1,\n                         _InputIterator2 __first2, _InputIterator2 __last2, _OutputIterator __result, _Compare __comp)\n{\n#ifdef _LIBCPP_DEBUG\n    typedef typename add_lvalue_reference<__debug_less<_Compare> >::type _Comp_ref;\n    __debug_less<_Compare> __c(__comp);\n    return __set_symmetric_difference<_Comp_ref>(__first1, __last1, __first2, __last2, __result, __c);\n#else  // _LIBCPP_DEBUG\n    typedef typename add_lvalue_reference<_Compare>::type _Comp_ref;\n    return __set_symmetric_difference<_Comp_ref>(__first1, __last1, __first2, __last2, __result, __comp);\n#endif  // _LIBCPP_DEBUG\n}\n\ntemplate <class _InputIterator1, class _InputIterator2, class _OutputIterator>\ninline _LIBCPP_INLINE_VISIBILITY\n_OutputIterator\nset_symmetric_difference(_InputIterator1 __first1, _InputIterator1 __last1,\n                         _InputIterator2 __first2, _InputIterator2 __last2, _OutputIterator __result)\n{\n    return _VSTD::set_symmetric_difference(__first1, __last1, __first2, __last2, __result,\n                                          __less<typename iterator_traits<_InputIterator1>::value_type,\n                                                 typename iterator_traits<_InputIterator2>::value_type>());\n}\n\n// lexicographical_compare\n\ntemplate <class _Compare, class _InputIterator1, class _InputIterator2>\nbool\n__lexicographical_compare(_InputIterator1 __first1, _InputIterator1 __last1,\n                          _InputIterator2 __first2, _InputIterator2 __last2, _Compare __comp)\n{\n    for (; __first2 != __last2; ++__first1, (void) ++__first2)\n    {\n        if (__first1 == __last1 || __comp(*__first1, *__first2))\n            return true;\n        if (__comp(*__first2, *__first1))\n            return false;\n    }\n    return false;\n}\n\ntemplate <class _InputIterator1, class _InputIterator2, class _Compare>\ninline _LIBCPP_INLINE_VISIBILITY\nbool\nlexicographical_compare(_InputIterator1 __first1, _InputIterator1 __last1,\n                        _InputIterator2 __first2, _InputIterator2 __last2, _Compare __comp)\n{\n#ifdef _LIBCPP_DEBUG\n    typedef typename add_lvalue_reference<__debug_less<_Compare> >::type _Comp_ref;\n    __debug_less<_Compare> __c(__comp);\n    return __lexicographical_compare<_Comp_ref>(__first1, __last1, __first2, __last2, __c);\n#else  // _LIBCPP_DEBUG\n    typedef typename add_lvalue_reference<_Compare>::type _Comp_ref;\n    return __lexicographical_compare<_Comp_ref>(__first1, __last1, __first2, __last2, __comp);\n#endif  // _LIBCPP_DEBUG\n}\n\ntemplate <class _InputIterator1, class _InputIterator2>\ninline _LIBCPP_INLINE_VISIBILITY\nbool\nlexicographical_compare(_InputIterator1 __first1, _InputIterator1 __last1,\n                        _InputIterator2 __first2, _InputIterator2 __last2)\n{\n    return _VSTD::lexicographical_compare(__first1, __last1, __first2, __last2,\n                                         __less<typename iterator_traits<_InputIterator1>::value_type,\n                                                typename iterator_traits<_InputIterator2>::value_type>());\n}\n\n// next_permutation\n\ntemplate <class _Compare, class _BidirectionalIterator>\nbool\n__next_permutation(_BidirectionalIterator __first, _BidirectionalIterator __last, _Compare __comp)\n{\n    _BidirectionalIterator __i = __last;\n    if (__first == __last || __first == --__i)\n        return false;\n    while (true)\n    {\n        _BidirectionalIterator __ip1 = __i;\n        if (__comp(*--__i, *__ip1))\n        {\n            _BidirectionalIterator __j = __last;\n            while (!__comp(*__i, *--__j))\n                ;\n            swap(*__i, *__j);\n            _VSTD::reverse(__ip1, __last);\n            return true;\n        }\n        if (__i == __first)\n        {\n            _VSTD::reverse(__first, __last);\n            return false;\n        }\n    }\n}\n\ntemplate <class _BidirectionalIterator, class _Compare>\ninline _LIBCPP_INLINE_VISIBILITY\nbool\nnext_permutation(_BidirectionalIterator __first, _BidirectionalIterator __last, _Compare __comp)\n{\n#ifdef _LIBCPP_DEBUG\n    typedef typename add_lvalue_reference<__debug_less<_Compare> >::type _Comp_ref;\n    __debug_less<_Compare> __c(__comp);\n    return __next_permutation<_Comp_ref>(__first, __last, __c);\n#else  // _LIBCPP_DEBUG\n    typedef typename add_lvalue_reference<_Compare>::type _Comp_ref;\n    return __next_permutation<_Comp_ref>(__first, __last, __comp);\n#endif  // _LIBCPP_DEBUG\n}\n\ntemplate <class _BidirectionalIterator>\ninline _LIBCPP_INLINE_VISIBILITY\nbool\nnext_permutation(_BidirectionalIterator __first, _BidirectionalIterator __last)\n{\n    return _VSTD::next_permutation(__first, __last,\n                                  __less<typename iterator_traits<_BidirectionalIterator>::value_type>());\n}\n\n// prev_permutation\n\ntemplate <class _Compare, class _BidirectionalIterator>\nbool\n__prev_permutation(_BidirectionalIterator __first, _BidirectionalIterator __last, _Compare __comp)\n{\n    _BidirectionalIterator __i = __last;\n    if (__first == __last || __first == --__i)\n        return false;\n    while (true)\n    {\n        _BidirectionalIterator __ip1 = __i;\n        if (__comp(*__ip1, *--__i))\n        {\n            _BidirectionalIterator __j = __last;\n            while (!__comp(*--__j, *__i))\n                ;\n            swap(*__i, *__j);\n            _VSTD::reverse(__ip1, __last);\n            return true;\n        }\n        if (__i == __first)\n        {\n            _VSTD::reverse(__first, __last);\n            return false;\n        }\n    }\n}\n\ntemplate <class _BidirectionalIterator, class _Compare>\ninline _LIBCPP_INLINE_VISIBILITY\nbool\nprev_permutation(_BidirectionalIterator __first, _BidirectionalIterator __last, _Compare __comp)\n{\n#ifdef _LIBCPP_DEBUG\n    typedef typename add_lvalue_reference<__debug_less<_Compare> >::type _Comp_ref;\n    __debug_less<_Compare> __c(__comp);\n    return __prev_permutation<_Comp_ref>(__first, __last, __c);\n#else  // _LIBCPP_DEBUG\n    typedef typename add_lvalue_reference<_Compare>::type _Comp_ref;\n    return __prev_permutation<_Comp_ref>(__first, __last, __comp);\n#endif  // _LIBCPP_DEBUG\n}\n\ntemplate <class _BidirectionalIterator>\ninline _LIBCPP_INLINE_VISIBILITY\nbool\nprev_permutation(_BidirectionalIterator __first, _BidirectionalIterator __last)\n{\n    return _VSTD::prev_permutation(__first, __last,\n                                  __less<typename iterator_traits<_BidirectionalIterator>::value_type>());\n}\n\n_LIBCPP_END_NAMESPACE_STD\n\n#endif  // _LIBCPP_ALGORITHM\n","// -*- C++ -*-\n//===--------------------------- stdexcept --------------------------------===//\n//\n//                     The LLVM Compiler Infrastructure\n//\n// This file is dual licensed under the MIT and the University of Illinois Open\n// Source Licenses. See LICENSE.TXT for details.\n//\n//===----------------------------------------------------------------------===//\n\n#ifndef _LIBCPP_STDEXCEPT\n#define _LIBCPP_STDEXCEPT\n\n/*\n    stdexcept synopsis\n\nnamespace std\n{\n\nclass logic_error;\n    class domain_error;\n    class invalid_argument;\n    class length_error;\n    class out_of_range;\nclass runtime_error;\n    class range_error;\n    class overflow_error;\n    class underflow_error;\n\nfor each class xxx_error:\n\nclass xxx_error : public exception // at least indirectly\n{\npublic:\n    explicit xxx_error(const string& what_arg);\n    explicit xxx_error(const char*   what_arg);\n\n    virtual const char* what() const noexcept // returns what_arg\n};\n\n}  // std\n\n*/\n\n#include <__config>\n#include <exception>\n#include <iosfwd>  // for string forward decl\n#ifdef _LIBCPP_NO_EXCEPTIONS\n#include <cstdlib>\n#endif\n\n#if !defined(_LIBCPP_HAS_NO_PRAGMA_SYSTEM_HEADER)\n#pragma GCC system_header\n#endif\n\n_LIBCPP_BEGIN_NAMESPACE_STD\n\nclass _LIBCPP_HIDDEN __libcpp_refstring\n{\n    const char* __imp_;\n\n    bool __uses_refcount() const;\npublic:\n    explicit __libcpp_refstring(const char* msg);\n    __libcpp_refstring(const __libcpp_refstring& s) _NOEXCEPT;\n    __libcpp_refstring& operator=(const __libcpp_refstring& s) _NOEXCEPT;\n    ~__libcpp_refstring();\n\n    const char* c_str() const _NOEXCEPT {return __imp_;}\n};\n\n_LIBCPP_END_NAMESPACE_STD\n\nnamespace std  // purposefully not using versioning namespace\n{\n\nclass _LIBCPP_EXCEPTION_ABI logic_error\n    : public exception\n{\nprivate:\n    _VSTD::__libcpp_refstring __imp_;\npublic:\n    explicit logic_error(const string&);\n    explicit logic_error(const char*);\n\n    logic_error(const logic_error&) _NOEXCEPT;\n    logic_error& operator=(const logic_error&) _NOEXCEPT;\n\n    virtual ~logic_error() _NOEXCEPT;\n\n    virtual const char* what() const _NOEXCEPT;\n};\n\nclass _LIBCPP_EXCEPTION_ABI runtime_error\n    : public exception\n{\nprivate:\n    _VSTD::__libcpp_refstring __imp_;\npublic:\n    explicit runtime_error(const string&);\n    explicit runtime_error(const char*);\n\n    runtime_error(const runtime_error&) _NOEXCEPT;\n    runtime_error& operator=(const runtime_error&) _NOEXCEPT;\n\n    virtual ~runtime_error() _NOEXCEPT;\n\n    virtual const char* what() const _NOEXCEPT;\n};\n\nclass _LIBCPP_EXCEPTION_ABI domain_error\n    : public logic_error\n{\npublic:\n    _LIBCPP_INLINE_VISIBILITY explicit domain_error(const string& __s) : logic_error(__s) {}\n    _LIBCPP_INLINE_VISIBILITY explicit domain_error(const char* __s)   : logic_error(__s) {}\n\n    virtual ~domain_error() _NOEXCEPT;\n};\n\nclass _LIBCPP_EXCEPTION_ABI invalid_argument\n    : public logic_error\n{\npublic:\n    _LIBCPP_INLINE_VISIBILITY explicit invalid_argument(const string& __s) : logic_error(__s) {}\n    _LIBCPP_INLINE_VISIBILITY explicit invalid_argument(const char* __s)   : logic_error(__s) {}\n\n    virtual ~invalid_argument() _NOEXCEPT;\n};\n\nclass _LIBCPP_EXCEPTION_ABI length_error\n    : public logic_error\n{\npublic:\n    _LIBCPP_INLINE_VISIBILITY explicit length_error(const string& __s) : logic_error(__s) {}\n    _LIBCPP_INLINE_VISIBILITY explicit length_error(const char* __s)   : logic_error(__s) {}\n\n    virtual ~length_error() _NOEXCEPT;\n};\n\nclass _LIBCPP_EXCEPTION_ABI out_of_range\n    : public logic_error\n{\npublic:\n    _LIBCPP_INLINE_VISIBILITY explicit out_of_range(const string& __s) : logic_error(__s) {}\n    _LIBCPP_INLINE_VISIBILITY explicit out_of_range(const char* __s)   : logic_error(__s) {}\n\n    virtual ~out_of_range() _NOEXCEPT;\n};\n\nclass _LIBCPP_EXCEPTION_ABI range_error\n    : public runtime_error\n{\npublic:\n    _LIBCPP_INLINE_VISIBILITY explicit range_error(const string& __s) : runtime_error(__s) {}\n    _LIBCPP_INLINE_VISIBILITY explicit range_error(const char* __s)   : runtime_error(__s) {}\n\n    virtual ~range_error() _NOEXCEPT;\n};\n\nclass _LIBCPP_EXCEPTION_ABI overflow_error\n    : public runtime_error\n{\npublic:\n    _LIBCPP_INLINE_VISIBILITY explicit overflow_error(const string& __s) : runtime_error(__s) {}\n    _LIBCPP_INLINE_VISIBILITY explicit overflow_error(const char* __s)   : runtime_error(__s) {}\n\n    virtual ~overflow_error() _NOEXCEPT;\n};\n\nclass _LIBCPP_EXCEPTION_ABI underflow_error\n    : public runtime_error\n{\npublic:\n    _LIBCPP_INLINE_VISIBILITY explicit underflow_error(const string& __s) : runtime_error(__s) {}\n    _LIBCPP_INLINE_VISIBILITY explicit underflow_error(const char* __s)   : runtime_error(__s) {}\n\n    virtual ~underflow_error() _NOEXCEPT;\n};\n\n}  // std\n\n_LIBCPP_BEGIN_NAMESPACE_STD\n\n// in the dylib\n_LIBCPP_NORETURN _LIBCPP_FUNC_VIS void __throw_runtime_error(const char*);\n\n_LIBCPP_NORETURN inline _LIBCPP_ALWAYS_INLINE\nvoid __throw_logic_error(const char*__msg)\n{\n#ifndef _LIBCPP_NO_EXCEPTIONS\n    throw logic_error(__msg);\n#else\n    ((void)__msg);\n\t  _VSTD::abort();\n#endif\n}\n\n_LIBCPP_NORETURN inline _LIBCPP_ALWAYS_INLINE\nvoid __throw_domain_error(const char*__msg)\n{\n#ifndef _LIBCPP_NO_EXCEPTIONS\n    throw domain_error(__msg);\n#else\n    ((void)__msg);\n\t  _VSTD::abort();\n#endif\n}\n\n_LIBCPP_NORETURN inline _LIBCPP_ALWAYS_INLINE\nvoid __throw_invalid_argument(const char*__msg)\n{\n#ifndef _LIBCPP_NO_EXCEPTIONS\n    throw invalid_argument(__msg);\n#else\n    ((void)__msg);\n\t  _VSTD::abort();\n#endif\n}\n\n_LIBCPP_NORETURN inline _LIBCPP_ALWAYS_INLINE\nvoid __throw_length_error(const char*__msg)\n{\n#ifndef _LIBCPP_NO_EXCEPTIONS\n    throw length_error(__msg);\n#else\n    ((void)__msg);\n\t  _VSTD::abort();\n#endif\n}\n\n_LIBCPP_NORETURN inline _LIBCPP_ALWAYS_INLINE\nvoid __throw_out_of_range(const char*__msg)\n{\n#ifndef _LIBCPP_NO_EXCEPTIONS\n    throw out_of_range(__msg);\n#else\n    ((void)__msg);\n\t  _VSTD::abort();\n#endif\n}\n\n_LIBCPP_NORETURN inline _LIBCPP_ALWAYS_INLINE\nvoid __throw_range_error(const char*__msg)\n{\n#ifndef _LIBCPP_NO_EXCEPTIONS\n    throw range_error(__msg);\n#else\n    ((void)__msg);\n\t  _VSTD::abort();\n#endif\n}\n\n_LIBCPP_NORETURN inline _LIBCPP_ALWAYS_INLINE\nvoid __throw_overflow_error(const char*__msg)\n{\n#ifndef _LIBCPP_NO_EXCEPTIONS\n    throw overflow_error(__msg);\n#else\n    ((void)__msg);\n    _VSTD::abort();\n#endif\n}\n\n_LIBCPP_NORETURN inline _LIBCPP_ALWAYS_INLINE\nvoid __throw_underflow_error(const char*__msg)\n{\n#ifndef _LIBCPP_NO_EXCEPTIONS\n    throw underflow_error(__msg);\n#else\n    ((void)__msg);\n    _VSTD::abort();\n#endif\n}\n\n_LIBCPP_END_NAMESPACE_STD\n\n#endif  // _LIBCPP_STDEXCEPT\n","// -*- C++ -*-\n//===------------------------ type_traits ---------------------------------===//\n//\n//                     The LLVM Compiler Infrastructure\n//\n// This file is dual licensed under the MIT and the University of Illinois Open\n// Source Licenses. See LICENSE.TXT for details.\n//\n//===----------------------------------------------------------------------===//\n\n#ifndef _LIBCPP_TYPE_TRAITS\n#define _LIBCPP_TYPE_TRAITS\n\n/*\n    type_traits synopsis\n\nnamespace std\n{\n\n    // helper class:\n    template <class T, T v> struct integral_constant;\n    typedef integral_constant<bool, true>  true_type;   // C++11\n    typedef integral_constant<bool, false> false_type;  // C++11\n    \n    template <bool B>                                   // C++14\n    using bool_constant = integral_constant<bool, B>;   // C++14\n    typedef bool_constant<true> true_type;              // C++14\n    typedef bool_constant<false> false_type;            // C++14\n\n    // helper traits\n    template <bool, class T = void> struct enable_if;\n    template <bool, class T, class F> struct conditional;\n\n    // Primary classification traits:\n    template <class T> struct is_void;\n    template <class T> struct is_null_pointer;  // C++14\n    template <class T> struct is_integral;\n    template <class T> struct is_floating_point;\n    template <class T> struct is_array;\n    template <class T> struct is_pointer;\n    template <class T> struct is_lvalue_reference;\n    template <class T> struct is_rvalue_reference;\n    template <class T> struct is_member_object_pointer;\n    template <class T> struct is_member_function_pointer;\n    template <class T> struct is_enum;\n    template <class T> struct is_union;\n    template <class T> struct is_class;\n    template <class T> struct is_function;\n\n    // Secondary classification traits:\n    template <class T> struct is_reference;\n    template <class T> struct is_arithmetic;\n    template <class T> struct is_fundamental;\n    template <class T> struct is_member_pointer;\n    template <class T> struct is_scalar;\n    template <class T> struct is_object;\n    template <class T> struct is_compound;\n\n    // Const-volatile properties and transformations:\n    template <class T> struct is_const;\n    template <class T> struct is_volatile;\n    template <class T> struct remove_const;\n    template <class T> struct remove_volatile;\n    template <class T> struct remove_cv;\n    template <class T> struct add_const;\n    template <class T> struct add_volatile;\n    template <class T> struct add_cv;\n\n    // Reference transformations:\n    template <class T> struct remove_reference;\n    template <class T> struct add_lvalue_reference;\n    template <class T> struct add_rvalue_reference;\n\n    // Pointer transformations:\n    template <class T> struct remove_pointer;\n    template <class T> struct add_pointer;\n\n    // Integral properties:\n    template <class T> struct is_signed;\n    template <class T> struct is_unsigned;\n    template <class T> struct make_signed;\n    template <class T> struct make_unsigned;\n\n    // Array properties and transformations:\n    template <class T> struct rank;\n    template <class T, unsigned I = 0> struct extent;\n    template <class T> struct remove_extent;\n    template <class T> struct remove_all_extents;\n\n    // Member introspection:\n    template <class T> struct is_pod;\n    template <class T> struct is_trivial;\n    template <class T> struct is_trivially_copyable;\n    template <class T> struct is_standard_layout;\n    template <class T> struct is_literal_type;\n    template <class T> struct is_empty;\n    template <class T> struct is_polymorphic;\n    template <class T> struct is_abstract;\n    template <class T> struct is_final; // C++14\n\n    template <class T, class... Args> struct is_constructible;\n    template <class T>                struct is_default_constructible;\n    template <class T>                struct is_copy_constructible;\n    template <class T>                struct is_move_constructible;\n    template <class T, class U>       struct is_assignable;\n    template <class T>                struct is_copy_assignable;\n    template <class T>                struct is_move_assignable;\n    template <class T, class U>       struct is_swappable_with;       // C++17\n    template <class T>                struct is_swappable;            // C++17\n    template <class T>                struct is_destructible;\n\n    template <class T, class... Args> struct is_trivially_constructible;\n    template <class T>                struct is_trivially_default_constructible;\n    template <class T>                struct is_trivially_copy_constructible;\n    template <class T>                struct is_trivially_move_constructible;\n    template <class T, class U>       struct is_trivially_assignable;\n    template <class T>                struct is_trivially_copy_assignable;\n    template <class T>                struct is_trivially_move_assignable;\n    template <class T>                struct is_trivially_destructible;\n\n    template <class T, class... Args> struct is_nothrow_constructible;\n    template <class T>                struct is_nothrow_default_constructible;\n    template <class T>                struct is_nothrow_copy_constructible;\n    template <class T>                struct is_nothrow_move_constructible;\n    template <class T, class U>       struct is_nothrow_assignable;\n    template <class T>                struct is_nothrow_copy_assignable;\n    template <class T>                struct is_nothrow_move_assignable;\n    template <class T, class U>       struct is_nothrow_swappable_with; // C++17\n    template <class T>                struct is_nothrow_swappable;      // C++17\n    template <class T>                struct is_nothrow_destructible;\n\n    template <class T> struct has_virtual_destructor;\n\n    // Relationships between types:\n    template <class T, class U> struct is_same;\n    template <class Base, class Derived> struct is_base_of;\n    template <class From, class To> struct is_convertible;\n\n    template <class, class R = void> struct is_callable; // not defined\n    template <class Fn, class... ArgTypes, class R>\n      struct is_callable<Fn(ArgTypes...), R>;\n\n    template <class, class R = void> struct is_nothrow_callable; // not defined\n    template <class Fn, class... ArgTypes, class R>\n      struct is_nothrow_callable<Fn(ArgTypes...), R>;\n\n    // Alignment properties and transformations:\n    template <class T> struct alignment_of;\n    template <size_t Len, size_t Align = most_stringent_alignment_requirement>\n        struct aligned_storage;\n    template <size_t Len, class... Types> struct aligned_union;\n\n    template <class T> struct decay;\n    template <class... T> struct common_type;\n    template <class T> struct underlying_type;\n    template <class> class result_of; // undefined\n    template <class Fn, class... ArgTypes> class result_of<Fn(ArgTypes...)>;\n\n    // const-volatile modifications:\n    template <class T>\n      using remove_const_t    = typename remove_const<T>::type;  // C++14\n    template <class T>\n      using remove_volatile_t = typename remove_volatile<T>::type;  // C++14\n    template <class T>\n      using remove_cv_t       = typename remove_cv<T>::type;  // C++14\n    template <class T>\n      using add_const_t       = typename add_const<T>::type;  // C++14\n    template <class T>\n      using add_volatile_t    = typename add_volatile<T>::type;  // C++14\n    template <class T>\n      using add_cv_t          = typename add_cv<T>::type;  // C++14\n  \n    // reference modifications:\n    template <class T>\n      using remove_reference_t     = typename remove_reference<T>::type;  // C++14\n    template <class T>\n      using add_lvalue_reference_t = typename add_lvalue_reference<T>::type;  // C++14\n    template <class T>\n      using add_rvalue_reference_t = typename add_rvalue_reference<T>::type;  // C++14\n  \n    // sign modifications:\n    template <class T>\n      using make_signed_t   = typename make_signed<T>::type;  // C++14\n    template <class T>\n      using make_unsigned_t = typename make_unsigned<T>::type;  // C++14\n  \n    // array modifications:\n    template <class T>\n      using remove_extent_t      = typename remove_extent<T>::type;  // C++14\n    template <class T>\n      using remove_all_extents_t = typename remove_all_extents<T>::type;  // C++14\n\n    // pointer modifications:\n    template <class T>\n      using remove_pointer_t = typename remove_pointer<T>::type;  // C++14\n    template <class T>\n      using add_pointer_t    = typename add_pointer<T>::type;  // C++14\n\n    // other transformations:\n    template <size_t Len, std::size_t Align=default-alignment>\n      using aligned_storage_t = typename aligned_storage<Len,Align>::type;  // C++14\n    template <std::size_t Len, class... Types>\n      using aligned_union_t   = typename aligned_union<Len,Types...>::type;  // C++14\n    template <class T>\n      using decay_t           = typename decay<T>::type;  // C++14\n    template <bool b, class T=void>\n      using enable_if_t       = typename enable_if<b,T>::type;  // C++14\n    template <bool b, class T, class F>\n      using conditional_t     = typename conditional<b,T,F>::type;  // C++14\n    template <class... T>\n      using common_type_t     = typename common_type<T...>::type;  // C++14\n    template <class T>\n      using underlying_type_t = typename underlying_type<T>::type;  // C++14\n    template <class F, class... ArgTypes>\n      using result_of_t       = typename result_of<F(ArgTypes...)>::type;  // C++14\n\n    template <class...>\n      using void_t = void;   // C++17\n      \n      // See C++14 20.10.4.1, primary type categories\n      template <class T> constexpr bool is_void_v\n        = is_void<T>::value;                                             // C++17\n      template <class T> constexpr bool is_null_pointer_v\n        = is_null_pointer<T>::value;                                     // C++17\n      template <class T> constexpr bool is_integral_v\n        = is_integral<T>::value;                                         // C++17\n      template <class T> constexpr bool is_floating_point_v\n        = is_floating_point<T>::value;                                   // C++17\n      template <class T> constexpr bool is_array_v\n        = is_array<T>::value;                                            // C++17\n      template <class T> constexpr bool is_pointer_v\n        = is_pointer<T>::value;                                          // C++17\n      template <class T> constexpr bool is_lvalue_reference_v\n        = is_lvalue_reference<T>::value;                                 // C++17\n      template <class T> constexpr bool is_rvalue_reference_v\n        = is_rvalue_reference<T>::value;                                 // C++17\n      template <class T> constexpr bool is_member_object_pointer_v\n        = is_member_object_pointer<T>::value;                            // C++17\n      template <class T> constexpr bool is_member_function_pointer_v\n        = is_member_function_pointer<T>::value;                          // C++17\n      template <class T> constexpr bool is_enum_v\n        = is_enum<T>::value;                                             // C++17\n      template <class T> constexpr bool is_union_v\n        = is_union<T>::value;                                            // C++17\n      template <class T> constexpr bool is_class_v\n        = is_class<T>::value;                                            // C++17\n      template <class T> constexpr bool is_function_v\n        = is_function<T>::value;                                         // C++17\n\n      // See C++14 20.10.4.2, composite type categories\n      template <class T> constexpr bool is_reference_v\n        = is_reference<T>::value;                                        // C++17\n      template <class T> constexpr bool is_arithmetic_v\n        = is_arithmetic<T>::value;                                       // C++17\n      template <class T> constexpr bool is_fundamental_v\n        = is_fundamental<T>::value;                                      // C++17\n      template <class T> constexpr bool is_object_v\n        = is_object<T>::value;                                           // C++17\n      template <class T> constexpr bool is_scalar_v\n        = is_scalar<T>::value;                                           // C++17\n      template <class T> constexpr bool is_compound_v\n        = is_compound<T>::value;                                         // C++17\n      template <class T> constexpr bool is_member_pointer_v\n        = is_member_pointer<T>::value;                                   // C++17\n\n      // See C++14 20.10.4.3, type properties\n      template <class T> constexpr bool is_const_v\n        = is_const<T>::value;                                            // C++17\n      template <class T> constexpr bool is_volatile_v\n        = is_volatile<T>::value;                                         // C++17\n      template <class T> constexpr bool is_trivial_v\n        = is_trivial<T>::value;                                          // C++17\n      template <class T> constexpr bool is_trivially_copyable_v\n        = is_trivially_copyable<T>::value;                               // C++17\n      template <class T> constexpr bool is_standard_layout_v\n        = is_standard_layout<T>::value;                                  // C++17\n      template <class T> constexpr bool is_pod_v\n        = is_pod<T>::value;                                              // C++17\n      template <class T> constexpr bool is_literal_type_v\n        = is_literal_type<T>::value;                                     // C++17\n      template <class T> constexpr bool is_empty_v\n        = is_empty<T>::value;                                            // C++17\n      template <class T> constexpr bool is_polymorphic_v\n        = is_polymorphic<T>::value;                                      // C++17\n      template <class T> constexpr bool is_abstract_v\n        = is_abstract<T>::value;                                         // C++17\n      template <class T> constexpr bool is_final_v\n        = is_final<T>::value;                                            // C++17\n      template <class T> constexpr bool is_signed_v\n        = is_signed<T>::value;                                           // C++17\n      template <class T> constexpr bool is_unsigned_v\n        = is_unsigned<T>::value;                                         // C++17\n      template <class T, class... Args> constexpr bool is_constructible_v\n        = is_constructible<T, Args...>::value;                           // C++17\n      template <class T> constexpr bool is_default_constructible_v\n        = is_default_constructible<T>::value;                            // C++17\n      template <class T> constexpr bool is_copy_constructible_v\n        = is_copy_constructible<T>::value;                               // C++17\n      template <class T> constexpr bool is_move_constructible_v\n        = is_move_constructible<T>::value;                               // C++17\n      template <class T, class U> constexpr bool is_assignable_v\n        = is_assignable<T, U>::value;                                    // C++17\n      template <class T> constexpr bool is_copy_assignable_v\n        = is_copy_assignable<T>::value;                                  // C++17\n      template <class T> constexpr bool is_move_assignable_v\n        = is_move_assignable<T>::value;                                  // C++17\n      template <class T, class U> constexpr bool is_swappable_with_v\n        = is_swappable_with<T, U>::value;                                // C++17\n      template <class T> constexpr bool is_swappable_v\n        = is_swappable<T>::value;                                        // C++17\n      template <class T> constexpr bool is_destructible_v\n        = is_destructible<T>::value;                                     // C++17\n      template <class T, class... Args> constexpr bool is_trivially_constructible_v\n        = is_trivially_constructible<T, Args...>::value;                 // C++17\n      template <class T> constexpr bool is_trivially_default_constructible_v\n        = is_trivially_default_constructible<T>::value;                  // C++17\n      template <class T> constexpr bool is_trivially_copy_constructible_v\n        = is_trivially_copy_constructible<T>::value;                     // C++17\n      template <class T> constexpr bool is_trivially_move_constructible_v\n        = is_trivially_move_constructible<T>::value;                     // C++17\n      template <class T, class U> constexpr bool is_trivially_assignable_v\n        = is_trivially_assignable<T, U>::value;                          // C++17\n      template <class T> constexpr bool is_trivially_copy_assignable_v\n        = is_trivially_copy_assignable<T>::value;                        // C++17\n      template <class T> constexpr bool is_trivially_move_assignable_v\n        = is_trivially_move_assignable<T>::value;                        // C++17\n      template <class T> constexpr bool is_trivially_destructible_v\n        = is_trivially_destructible<T>::value;                           // C++17\n      template <class T, class... Args> constexpr bool is_nothrow_constructible_v\n        = is_nothrow_constructible<T, Args...>::value;                   // C++17\n      template <class T> constexpr bool is_nothrow_default_constructible_v\n        = is_nothrow_default_constructible<T>::value;                    // C++17\n      template <class T> constexpr bool is_nothrow_copy_constructible_v\n        = is_nothrow_copy_constructible<T>::value;                       // C++17\n      template <class T> constexpr bool is_nothrow_move_constructible_v\n        = is_nothrow_move_constructible<T>::value;                       // C++17\n      template <class T, class U> constexpr bool is_nothrow_assignable_v\n        = is_nothrow_assignable<T, U>::value;                            // C++17\n      template <class T> constexpr bool is_nothrow_copy_assignable_v\n        = is_nothrow_copy_assignable<T>::value;                          // C++17\n      template <class T> constexpr bool is_nothrow_move_assignable_v\n        = is_nothrow_move_assignable<T>::value;                          // C++17\n      template <class T, class U> constexpr bool is_nothrow_swappable_with_v\n        = is_nothrow_swappable_with<T, U>::value;                       // C++17\n      template <class T> constexpr bool is_nothrow_swappable_v\n        = is_nothrow_swappable<T>::value;                               // C++17\n      template <class T> constexpr bool is_nothrow_destructible_v\n        = is_nothrow_destructible<T>::value;                             // C++17\n      template <class T> constexpr bool has_virtual_destructor_v\n        = has_virtual_destructor<T>::value;                              // C++17\n\n      // See C++14 20.10.5, type property queries\n      template <class T> constexpr size_t alignment_of_v\n        = alignment_of<T>::value;                                        // C++17\n      template <class T> constexpr size_t rank_v\n        = rank<T>::value;                                                // C++17\n      template <class T, unsigned I = 0> constexpr size_t extent_v\n        = extent<T, I>::value;                                           // C++17\n\n      // See C++14 20.10.6, type relations\n      template <class T, class U> constexpr bool is_same_v\n        = is_same<T, U>::value;                                          // C++17\n      template <class Base, class Derived> constexpr bool is_base_of_v\n        = is_base_of<Base, Derived>::value;                              // C++17\n      template <class From, class To> constexpr bool is_convertible_v\n        = is_convertible<From, To>::value;                               // C++17\n      template <class T, class R = void> constexpr bool is_callable_v\n        = is_callable<T, R>::value;                                      // C++17\n      template <class T, class R = void> constexpr bool is_nothrow_callable_v\n        = is_nothrow_callable<T, R>::value;                              // C++17\n\n      // [meta.logical], logical operator traits:\n      template<class... B> struct conjunction;                           // C++17\n      template<class... B> \n        constexpr bool conjunction_v = conjunction<B...>::value;         // C++17\n      template<class... B> struct disjunction;                           // C++17\n      template<class... B>\n        constexpr bool disjunction_v = disjunction<B...>::value;         // C++17\n      template<class B> struct negation;                                 // C++17\n      template<class B> \n        constexpr bool negation_v = negation<B>::value;                  // C++17\n\n}\n\n*/\n#include <__config>\n#include <cstddef>\n\n#if !defined(_LIBCPP_HAS_NO_PRAGMA_SYSTEM_HEADER)\n#pragma GCC system_header\n#endif\n\n_LIBCPP_BEGIN_NAMESPACE_STD\n\ntemplate <class _T1, class _T2> struct _LIBCPP_TEMPLATE_VIS pair;\ntemplate <class _Tp> class _LIBCPP_TEMPLATE_VIS reference_wrapper;\ntemplate <class _Tp> struct _LIBCPP_TEMPLATE_VIS hash;\n\ntemplate <class>\nstruct __void_t { typedef void type; };\n\ntemplate <class _Tp>\nstruct __identity { typedef _Tp type; };\n\ntemplate <class _Tp, bool>\nstruct _LIBCPP_TEMPLATE_VIS __dependent_type : public _Tp {};\n\ntemplate <bool _Bp, class _If, class _Then>\n    struct _LIBCPP_TEMPLATE_VIS conditional {typedef _If type;};\ntemplate <class _If, class _Then>\n    struct _LIBCPP_TEMPLATE_VIS conditional<false, _If, _Then> {typedef _Then type;};\n\n#if _LIBCPP_STD_VER > 11\ntemplate <bool _Bp, class _If, class _Then> using conditional_t = typename conditional<_Bp, _If, _Then>::type;\n#endif\n\ntemplate <bool, class _Tp> struct _LIBCPP_TEMPLATE_VIS __lazy_enable_if {};\ntemplate <class _Tp> struct _LIBCPP_TEMPLATE_VIS __lazy_enable_if<true, _Tp> {typedef typename _Tp::type type;};\n\ntemplate <bool, class _Tp = void> struct _LIBCPP_TEMPLATE_VIS enable_if {};\ntemplate <class _Tp> struct _LIBCPP_TEMPLATE_VIS enable_if<true, _Tp> {typedef _Tp type;};\n\n#if _LIBCPP_STD_VER > 11\ntemplate <bool _Bp, class _Tp = void> using enable_if_t = typename enable_if<_Bp, _Tp>::type;\n#endif\n\n// addressof\n#ifndef _LIBCPP_HAS_NO_BUILTIN_ADDRESSOF\n\ntemplate <class _Tp>\ninline _LIBCPP_CONSTEXPR_AFTER_CXX14\n_LIBCPP_NO_CFI _LIBCPP_INLINE_VISIBILITY\n_Tp*\naddressof(_Tp& __x) _NOEXCEPT\n{\n    return __builtin_addressof(__x);\n}\n\n#else\n\ntemplate <class _Tp>\ninline _LIBCPP_NO_CFI _LIBCPP_INLINE_VISIBILITY\n_Tp*\naddressof(_Tp& __x) _NOEXCEPT\n{\n  return reinterpret_cast<_Tp *>(\n      const_cast<char *>(&reinterpret_cast<const volatile char &>(__x)));\n}\n\n#endif // _LIBCPP_HAS_NO_BUILTIN_ADDRESSOF\n\n#if defined(_LIBCPP_HAS_OBJC_ARC) && !defined(_LIBCPP_PREDEFINED_OBJC_ARC_ADDRESSOF)\n// Objective-C++ Automatic Reference Counting uses qualified pointers\n// that require special addressof() signatures. When\n// _LIBCPP_PREDEFINED_OBJC_ARC_ADDRESSOF is defined, the compiler\n// itself is providing these definitions. Otherwise, we provide them.\ntemplate <class _Tp>\ninline _LIBCPP_INLINE_VISIBILITY\n__strong _Tp*\naddressof(__strong _Tp& __x) _NOEXCEPT\n{\n  return &__x;\n}\n\n#ifdef _LIBCPP_HAS_OBJC_ARC_WEAK\ntemplate <class _Tp>\ninline _LIBCPP_INLINE_VISIBILITY\n__weak _Tp*\naddressof(__weak _Tp& __x) _NOEXCEPT\n{\n  return &__x;\n}\n#endif\n\ntemplate <class _Tp>\ninline _LIBCPP_INLINE_VISIBILITY\n__autoreleasing _Tp*\naddressof(__autoreleasing _Tp& __x) _NOEXCEPT\n{\n  return &__x;\n}\n\ntemplate <class _Tp>\ninline _LIBCPP_INLINE_VISIBILITY\n__unsafe_unretained _Tp*\naddressof(__unsafe_unretained _Tp& __x) _NOEXCEPT\n{\n  return &__x;\n}\n#endif\n\n#if !defined(_LIBCPP_CXX03_LANG)\ntemplate <class _Tp> _Tp* addressof(const _Tp&&) noexcept = delete;\n#endif\n\nstruct __two {char __lx[2];};\n\n// helper class:\n\ntemplate <class _Tp, _Tp __v>\nstruct _LIBCPP_TEMPLATE_VIS integral_constant\n{\n    static _LIBCPP_CONSTEXPR const _Tp      value = __v;\n    typedef _Tp               value_type;\n    typedef integral_constant type;\n    _LIBCPP_INLINE_VISIBILITY\n        _LIBCPP_CONSTEXPR operator value_type() const _NOEXCEPT {return value;}\n#if _LIBCPP_STD_VER > 11\n    _LIBCPP_INLINE_VISIBILITY\n         constexpr value_type operator ()() const _NOEXCEPT {return value;}\n#endif\n};\n\ntemplate <class _Tp, _Tp __v>\n_LIBCPP_CONSTEXPR const _Tp integral_constant<_Tp, __v>::value;\n\n#if _LIBCPP_STD_VER > 14\ntemplate <bool __b>\nusing bool_constant = integral_constant<bool, __b>;\n#define _LIBCPP_BOOL_CONSTANT(__b) bool_constant<(__b)>\n#else\n#define _LIBCPP_BOOL_CONSTANT(__b) integral_constant<bool,(__b)>\n#endif\n\ntypedef _LIBCPP_BOOL_CONSTANT(true)  true_type;\ntypedef _LIBCPP_BOOL_CONSTANT(false) false_type;\n\n#if !defined(_LIBCPP_CXX03_LANG)\n\n// __lazy_and\n\ntemplate <bool _Last, class ..._Preds>\nstruct __lazy_and_impl;\n\ntemplate <class ..._Preds>\nstruct __lazy_and_impl<false, _Preds...> : false_type {};\n\ntemplate <>\nstruct __lazy_and_impl<true> : true_type {};\n\ntemplate <class _Pred>\nstruct __lazy_and_impl<true, _Pred> : integral_constant<bool, _Pred::type::value> {};\n\ntemplate <class _Hp, class ..._Tp>\nstruct __lazy_and_impl<true, _Hp, _Tp...> : __lazy_and_impl<_Hp::type::value, _Tp...> {};\n\ntemplate <class _P1, class ..._Pr>\nstruct __lazy_and : __lazy_and_impl<_P1::type::value, _Pr...> {};\n\n// __lazy_or\n\ntemplate <bool _List, class ..._Preds>\nstruct __lazy_or_impl;\n\ntemplate <class ..._Preds>\nstruct __lazy_or_impl<true, _Preds...> : true_type {};\n\ntemplate <>\nstruct __lazy_or_impl<false> : false_type {};\n\ntemplate <class _Hp, class ..._Tp>\nstruct __lazy_or_impl<false, _Hp, _Tp...>\n        : __lazy_or_impl<_Hp::type::value, _Tp...> {};\n\ntemplate <class _P1, class ..._Pr>\nstruct __lazy_or : __lazy_or_impl<_P1::type::value, _Pr...> {};\n\n// __lazy_not\n\ntemplate <class _Pred>\nstruct __lazy_not : integral_constant<bool, !_Pred::type::value> {};\n\n// __and_\ntemplate<class...> struct __and_;\ntemplate<> struct __and_<> : true_type {};\n\ntemplate<class _B0> struct __and_<_B0> : _B0 {};\n\ntemplate<class _B0, class _B1>\nstruct __and_<_B0, _B1> : conditional<_B0::value, _B1, _B0>::type {};\n\ntemplate<class _B0, class _B1, class _B2, class... _Bn>\nstruct __and_<_B0, _B1, _B2, _Bn...> \n        : conditional<_B0::value, __and_<_B1, _B2, _Bn...>, _B0>::type {};\n\n// __or_\ntemplate<class...> struct __or_;\ntemplate<> struct __or_<> : false_type {};\n\ntemplate<class _B0> struct __or_<_B0> : _B0 {};\n\ntemplate<class _B0, class _B1>\nstruct __or_<_B0, _B1> : conditional<_B0::value, _B0, _B1>::type {};\n\ntemplate<class _B0, class _B1, class _B2, class... _Bn>\nstruct __or_<_B0, _B1, _B2, _Bn...> \n        : conditional<_B0::value, _B0, __or_<_B1, _B2, _Bn...> >::type {};\n\n// __not_\ntemplate<class _Tp> \nstruct __not_ : conditional<_Tp::value, false_type, true_type>::type {};\n\n#endif // !defined(_LIBCPP_CXX03_LANG)\n\n// is_const\n\ntemplate <class _Tp> struct _LIBCPP_TEMPLATE_VIS is_const            : public false_type {};\ntemplate <class _Tp> struct _LIBCPP_TEMPLATE_VIS is_const<_Tp const> : public true_type {};\n\n#if _LIBCPP_STD_VER > 14 && !defined(_LIBCPP_HAS_NO_VARIABLE_TEMPLATES)\ntemplate <class _Tp> _LIBCPP_CONSTEXPR bool is_const_v\n    = is_const<_Tp>::value;\n#endif\n\n// is_volatile\n\ntemplate <class _Tp> struct _LIBCPP_TEMPLATE_VIS is_volatile               : public false_type {};\ntemplate <class _Tp> struct _LIBCPP_TEMPLATE_VIS is_volatile<_Tp volatile> : public true_type {};\n\n#if _LIBCPP_STD_VER > 14 && !defined(_LIBCPP_HAS_NO_VARIABLE_TEMPLATES)\ntemplate <class _Tp> _LIBCPP_CONSTEXPR bool is_volatile_v\n    = is_volatile<_Tp>::value;\n#endif\n\n// remove_const\n\ntemplate <class _Tp> struct _LIBCPP_TEMPLATE_VIS remove_const            {typedef _Tp type;};\ntemplate <class _Tp> struct _LIBCPP_TEMPLATE_VIS remove_const<const _Tp> {typedef _Tp type;};\n#if _LIBCPP_STD_VER > 11\ntemplate <class _Tp> using remove_const_t = typename remove_const<_Tp>::type;\n#endif\n\n// remove_volatile\n\ntemplate <class _Tp> struct _LIBCPP_TEMPLATE_VIS remove_volatile               {typedef _Tp type;};\ntemplate <class _Tp> struct _LIBCPP_TEMPLATE_VIS remove_volatile<volatile _Tp> {typedef _Tp type;};\n#if _LIBCPP_STD_VER > 11\ntemplate <class _Tp> using remove_volatile_t = typename remove_volatile<_Tp>::type;\n#endif\n\n// remove_cv\n\ntemplate <class _Tp> struct _LIBCPP_TEMPLATE_VIS remove_cv\n{typedef typename remove_volatile<typename remove_const<_Tp>::type>::type type;};\n#if _LIBCPP_STD_VER > 11\ntemplate <class _Tp> using remove_cv_t = typename remove_cv<_Tp>::type;\n#endif\n\n// is_void\n\ntemplate <class _Tp> struct __libcpp_is_void       : public false_type {};\ntemplate <>          struct __libcpp_is_void<void> : public true_type {};\n\ntemplate <class _Tp> struct _LIBCPP_TEMPLATE_VIS is_void\n    : public __libcpp_is_void<typename remove_cv<_Tp>::type> {};\n\n#if _LIBCPP_STD_VER > 14 && !defined(_LIBCPP_HAS_NO_VARIABLE_TEMPLATES)\ntemplate <class _Tp> _LIBCPP_CONSTEXPR bool is_void_v\n    = is_void<_Tp>::value;\n#endif\n\n// __is_nullptr_t\n\ntemplate <class _Tp> struct __is_nullptr_t_impl       : public false_type {};\ntemplate <>          struct __is_nullptr_t_impl<nullptr_t> : public true_type {};\n\ntemplate <class _Tp> struct _LIBCPP_TEMPLATE_VIS __is_nullptr_t\n    : public __is_nullptr_t_impl<typename remove_cv<_Tp>::type> {};\n\n#if _LIBCPP_STD_VER > 11\ntemplate <class _Tp> struct _LIBCPP_TEMPLATE_VIS is_null_pointer\n    : public __is_nullptr_t_impl<typename remove_cv<_Tp>::type> {};\n\n#if _LIBCPP_STD_VER > 14 && !defined(_LIBCPP_HAS_NO_VARIABLE_TEMPLATES)\ntemplate <class _Tp> _LIBCPP_CONSTEXPR bool is_null_pointer_v\n    = is_null_pointer<_Tp>::value;\n#endif\n#endif\n\n// is_integral\n\ntemplate <class _Tp> struct __libcpp_is_integral                     : public false_type {};\ntemplate <>          struct __libcpp_is_integral<bool>               : public true_type {};\ntemplate <>          struct __libcpp_is_integral<char>               : public true_type {};\ntemplate <>          struct __libcpp_is_integral<signed char>        : public true_type {};\ntemplate <>          struct __libcpp_is_integral<unsigned char>      : public true_type {};\ntemplate <>          struct __libcpp_is_integral<wchar_t>            : public true_type {};\n#ifndef _LIBCPP_HAS_NO_UNICODE_CHARS\ntemplate <>          struct __libcpp_is_integral<char16_t>           : public true_type {};\ntemplate <>          struct __libcpp_is_integral<char32_t>           : public true_type {};\n#endif  // _LIBCPP_HAS_NO_UNICODE_CHARS\ntemplate <>          struct __libcpp_is_integral<short>              : public true_type {};\ntemplate <>          struct __libcpp_is_integral<unsigned short>     : public true_type {};\ntemplate <>          struct __libcpp_is_integral<int>                : public true_type {};\ntemplate <>          struct __libcpp_is_integral<unsigned int>       : public true_type {};\ntemplate <>          struct __libcpp_is_integral<long>               : public true_type {};\ntemplate <>          struct __libcpp_is_integral<unsigned long>      : public true_type {};\ntemplate <>          struct __libcpp_is_integral<long long>          : public true_type {};\ntemplate <>          struct __libcpp_is_integral<unsigned long long> : public true_type {};\n#ifndef _LIBCPP_HAS_NO_INT128\ntemplate <>          struct __libcpp_is_integral<__int128_t>         : public true_type {};\ntemplate <>          struct __libcpp_is_integral<__uint128_t>        : public true_type {};\n#endif\n\ntemplate <class _Tp> struct _LIBCPP_TEMPLATE_VIS is_integral\n    : public __libcpp_is_integral<typename remove_cv<_Tp>::type> {};\n\n#if _LIBCPP_STD_VER > 14 && !defined(_LIBCPP_HAS_NO_VARIABLE_TEMPLATES)\ntemplate <class _Tp> _LIBCPP_CONSTEXPR bool is_integral_v\n    = is_integral<_Tp>::value;\n#endif\n\n// is_floating_point\n\ntemplate <class _Tp> struct __libcpp_is_floating_point              : public false_type {};\ntemplate <>          struct __libcpp_is_floating_point<float>       : public true_type {};\ntemplate <>          struct __libcpp_is_floating_point<double>      : public true_type {};\ntemplate <>          struct __libcpp_is_floating_point<long double> : public true_type {};\n\ntemplate <class _Tp> struct _LIBCPP_TEMPLATE_VIS is_floating_point\n    : public __libcpp_is_floating_point<typename remove_cv<_Tp>::type> {};\n\n#if _LIBCPP_STD_VER > 14 && !defined(_LIBCPP_HAS_NO_VARIABLE_TEMPLATES)\ntemplate <class _Tp> _LIBCPP_CONSTEXPR bool is_floating_point_v\n    = is_floating_point<_Tp>::value;\n#endif\n\n// is_array\n\ntemplate <class _Tp> struct _LIBCPP_TEMPLATE_VIS is_array\n    : public false_type {};\ntemplate <class _Tp> struct _LIBCPP_TEMPLATE_VIS is_array<_Tp[]>\n    : public true_type {};\ntemplate <class _Tp, size_t _Np> struct _LIBCPP_TEMPLATE_VIS is_array<_Tp[_Np]>\n    : public true_type {};\n\n#if _LIBCPP_STD_VER > 14 && !defined(_LIBCPP_HAS_NO_VARIABLE_TEMPLATES)\ntemplate <class _Tp> _LIBCPP_CONSTEXPR bool is_array_v\n    = is_array<_Tp>::value;\n#endif\n\n// is_pointer\n\ntemplate <class _Tp> struct __libcpp_is_pointer       : public false_type {};\ntemplate <class _Tp> struct __libcpp_is_pointer<_Tp*> : public true_type {};\n\ntemplate <class _Tp> struct _LIBCPP_TEMPLATE_VIS is_pointer\n    : public __libcpp_is_pointer<typename remove_cv<_Tp>::type> {};\n\n#if _LIBCPP_STD_VER > 14 && !defined(_LIBCPP_HAS_NO_VARIABLE_TEMPLATES)\ntemplate <class _Tp> _LIBCPP_CONSTEXPR bool is_pointer_v\n    = is_pointer<_Tp>::value;\n#endif\n\n// is_reference\n\ntemplate <class _Tp> struct _LIBCPP_TEMPLATE_VIS is_lvalue_reference       : public false_type {};\ntemplate <class _Tp> struct _LIBCPP_TEMPLATE_VIS is_lvalue_reference<_Tp&> : public true_type {};\n\ntemplate <class _Tp> struct _LIBCPP_TEMPLATE_VIS is_rvalue_reference        : public false_type {};\n#ifndef _LIBCPP_HAS_NO_RVALUE_REFERENCES\ntemplate <class _Tp> struct _LIBCPP_TEMPLATE_VIS is_rvalue_reference<_Tp&&> : public true_type {};\n#endif\n\ntemplate <class _Tp> struct _LIBCPP_TEMPLATE_VIS is_reference        : public false_type {};\ntemplate <class _Tp> struct _LIBCPP_TEMPLATE_VIS is_reference<_Tp&>  : public true_type {};\n#ifndef _LIBCPP_HAS_NO_RVALUE_REFERENCES\ntemplate <class _Tp> struct _LIBCPP_TEMPLATE_VIS is_reference<_Tp&&> : public true_type {};\n#endif\n\n#if _LIBCPP_STD_VER > 14 && !defined(_LIBCPP_HAS_NO_VARIABLE_TEMPLATES)\ntemplate <class _Tp> _LIBCPP_CONSTEXPR bool is_reference_v\n    = is_reference<_Tp>::value;\n\ntemplate <class _Tp> _LIBCPP_CONSTEXPR bool is_lvalue_reference_v\n    = is_lvalue_reference<_Tp>::value;\n\ntemplate <class _Tp> _LIBCPP_CONSTEXPR bool is_rvalue_reference_v\n    = is_rvalue_reference<_Tp>::value;\n#endif\n// is_union\n\n#if __has_feature(is_union) || (_GNUC_VER >= 403)\n\ntemplate <class _Tp> struct _LIBCPP_TEMPLATE_VIS is_union\n    : public integral_constant<bool, __is_union(_Tp)> {};\n\n#else\n\ntemplate <class _Tp> struct __libcpp_union : public false_type {};\ntemplate <class _Tp> struct _LIBCPP_TEMPLATE_VIS is_union\n    : public __libcpp_union<typename remove_cv<_Tp>::type> {};\n\n#endif\n\n#if _LIBCPP_STD_VER > 14 && !defined(_LIBCPP_HAS_NO_VARIABLE_TEMPLATES)\ntemplate <class _Tp> _LIBCPP_CONSTEXPR bool is_union_v\n    = is_union<_Tp>::value;\n#endif\n\n// is_class\n\n#if __has_feature(is_class) || (_GNUC_VER >= 403)\n\ntemplate <class _Tp> struct _LIBCPP_TEMPLATE_VIS is_class\n    : public integral_constant<bool, __is_class(_Tp)> {};\n\n#else\n\nnamespace __is_class_imp\n{\ntemplate <class _Tp> char  __test(int _Tp::*);\ntemplate <class _Tp> __two __test(...);\n}\n\ntemplate <class _Tp> struct _LIBCPP_TEMPLATE_VIS is_class\n    : public integral_constant<bool, sizeof(__is_class_imp::__test<_Tp>(0)) == 1 && !is_union<_Tp>::value> {};\n\n#endif\n\n#if _LIBCPP_STD_VER > 14 && !defined(_LIBCPP_HAS_NO_VARIABLE_TEMPLATES)\ntemplate <class _Tp> _LIBCPP_CONSTEXPR bool is_class_v\n    = is_class<_Tp>::value;\n#endif\n\n// is_same\n\ntemplate <class _Tp, class _Up> struct _LIBCPP_TEMPLATE_VIS is_same           : public false_type {};\ntemplate <class _Tp>            struct _LIBCPP_TEMPLATE_VIS is_same<_Tp, _Tp> : public true_type {};\n\n#if _LIBCPP_STD_VER > 14 && !defined(_LIBCPP_HAS_NO_VARIABLE_TEMPLATES)\ntemplate <class _Tp, class _Up> _LIBCPP_CONSTEXPR bool is_same_v\n    = is_same<_Tp, _Up>::value;\n#endif\n\n// is_function\n\nnamespace __libcpp_is_function_imp\n{\nstruct __dummy_type {};\ntemplate <class _Tp> char  __test(_Tp*);\ntemplate <class _Tp> char __test(__dummy_type);\ntemplate <class _Tp> __two __test(...);\ntemplate <class _Tp> _Tp&  __source(int);\ntemplate <class _Tp> __dummy_type __source(...);\n}\n\ntemplate <class _Tp, bool = is_class<_Tp>::value ||\n                            is_union<_Tp>::value ||\n                            is_void<_Tp>::value  ||\n                            is_reference<_Tp>::value ||\n                            __is_nullptr_t<_Tp>::value >\nstruct __libcpp_is_function\n    : public integral_constant<bool, sizeof(__libcpp_is_function_imp::__test<_Tp>(__libcpp_is_function_imp::__source<_Tp>(0))) == 1>\n    {};\ntemplate <class _Tp> struct __libcpp_is_function<_Tp, true> : public false_type {};\n\ntemplate <class _Tp> struct _LIBCPP_TEMPLATE_VIS is_function\n    : public __libcpp_is_function<_Tp> {};\n\n#if _LIBCPP_STD_VER > 14 && !defined(_LIBCPP_HAS_NO_VARIABLE_TEMPLATES)\ntemplate <class _Tp> _LIBCPP_CONSTEXPR bool is_function_v\n    = is_function<_Tp>::value;\n#endif\n\n// is_member_function_pointer\n\n// template <class _Tp> struct            __libcpp_is_member_function_pointer             : public false_type {};\n// template <class _Tp, class _Up> struct __libcpp_is_member_function_pointer<_Tp _Up::*> : public is_function<_Tp> {};\n// \n\ntemplate <class _MP, bool _IsMemberFunctionPtr, bool _IsMemberObjectPtr>\nstruct __member_pointer_traits_imp\n{  // forward declaration; specializations later\n};\n\n\ntemplate <class _Tp> struct __libcpp_is_member_function_pointer\n    : public false_type {};\n\ntemplate <class _Ret, class _Class>\nstruct __libcpp_is_member_function_pointer<_Ret _Class::*>\n    : public is_function<_Ret> {};\n\ntemplate <class _Tp> struct _LIBCPP_TEMPLATE_VIS is_member_function_pointer\n    : public __libcpp_is_member_function_pointer<typename remove_cv<_Tp>::type>::type {};\n\n#if _LIBCPP_STD_VER > 14 && !defined(_LIBCPP_HAS_NO_VARIABLE_TEMPLATES)\ntemplate <class _Tp> _LIBCPP_CONSTEXPR bool is_member_function_pointer_v\n    = is_member_function_pointer<_Tp>::value;\n#endif\n\n// is_member_pointer\n\ntemplate <class _Tp>            struct __libcpp_is_member_pointer             : public false_type {};\ntemplate <class _Tp, class _Up> struct __libcpp_is_member_pointer<_Tp _Up::*> : public true_type {};\n\ntemplate <class _Tp> struct _LIBCPP_TEMPLATE_VIS is_member_pointer\n    : public __libcpp_is_member_pointer<typename remove_cv<_Tp>::type> {};\n\n#if _LIBCPP_STD_VER > 14 && !defined(_LIBCPP_HAS_NO_VARIABLE_TEMPLATES)\ntemplate <class _Tp> _LIBCPP_CONSTEXPR bool is_member_pointer_v\n    = is_member_pointer<_Tp>::value;\n#endif\n\n// is_member_object_pointer\n\ntemplate <class _Tp> struct _LIBCPP_TEMPLATE_VIS is_member_object_pointer\n    : public integral_constant<bool, is_member_pointer<_Tp>::value &&\n                                    !is_member_function_pointer<_Tp>::value> {};\n\n#if _LIBCPP_STD_VER > 14 && !defined(_LIBCPP_HAS_NO_VARIABLE_TEMPLATES)\ntemplate <class _Tp> _LIBCPP_CONSTEXPR bool is_member_object_pointer_v\n    = is_member_object_pointer<_Tp>::value;\n#endif\n\n// is_enum\n\n#if __has_feature(is_enum) || (_GNUC_VER >= 403)\n\ntemplate <class _Tp> struct _LIBCPP_TEMPLATE_VIS is_enum\n    : public integral_constant<bool, __is_enum(_Tp)> {};\n\n#else\n\ntemplate <class _Tp> struct _LIBCPP_TEMPLATE_VIS is_enum\n    : public integral_constant<bool, !is_void<_Tp>::value             &&\n                                     !is_integral<_Tp>::value         &&\n                                     !is_floating_point<_Tp>::value   &&\n                                     !is_array<_Tp>::value            &&\n                                     !is_pointer<_Tp>::value          &&\n                                     !is_reference<_Tp>::value        &&\n                                     !is_member_pointer<_Tp>::value   &&\n                                     !is_union<_Tp>::value            &&\n                                     !is_class<_Tp>::value            &&\n                                     !is_function<_Tp>::value         > {};\n\n#endif\n\n#if _LIBCPP_STD_VER > 14 && !defined(_LIBCPP_HAS_NO_VARIABLE_TEMPLATES)\ntemplate <class _Tp> _LIBCPP_CONSTEXPR bool is_enum_v\n    = is_enum<_Tp>::value;\n#endif\n\n// is_arithmetic\n\ntemplate <class _Tp> struct _LIBCPP_TEMPLATE_VIS is_arithmetic\n    : public integral_constant<bool, is_integral<_Tp>::value      ||\n                                     is_floating_point<_Tp>::value> {};\n\n#if _LIBCPP_STD_VER > 14 && !defined(_LIBCPP_HAS_NO_VARIABLE_TEMPLATES)\ntemplate <class _Tp> _LIBCPP_CONSTEXPR bool is_arithmetic_v\n    = is_arithmetic<_Tp>::value;\n#endif\n\n// is_fundamental\n\ntemplate <class _Tp> struct _LIBCPP_TEMPLATE_VIS is_fundamental\n    : public integral_constant<bool, is_void<_Tp>::value        ||\n                                     __is_nullptr_t<_Tp>::value ||\n                                     is_arithmetic<_Tp>::value> {};\n\n#if _LIBCPP_STD_VER > 14 && !defined(_LIBCPP_HAS_NO_VARIABLE_TEMPLATES)\ntemplate <class _Tp> _LIBCPP_CONSTEXPR bool is_fundamental_v\n    = is_fundamental<_Tp>::value;\n#endif\n\n// is_scalar\n\ntemplate <class _Tp> struct _LIBCPP_TEMPLATE_VIS is_scalar\n    : public integral_constant<bool, is_arithmetic<_Tp>::value     ||\n                                     is_member_pointer<_Tp>::value ||\n                                     is_pointer<_Tp>::value        ||\n                                     __is_nullptr_t<_Tp>::value    ||\n                                     is_enum<_Tp>::value           > {};\n\ntemplate <> struct _LIBCPP_TEMPLATE_VIS is_scalar<nullptr_t> : public true_type {};\n\n#if _LIBCPP_STD_VER > 14 && !defined(_LIBCPP_HAS_NO_VARIABLE_TEMPLATES)\ntemplate <class _Tp> _LIBCPP_CONSTEXPR bool is_scalar_v\n    = is_scalar<_Tp>::value;\n#endif\n\n// is_object\n\ntemplate <class _Tp> struct _LIBCPP_TEMPLATE_VIS is_object\n    : public integral_constant<bool, is_scalar<_Tp>::value ||\n                                     is_array<_Tp>::value  ||\n                                     is_union<_Tp>::value  ||\n                                     is_class<_Tp>::value  > {};\n\n#if _LIBCPP_STD_VER > 14 && !defined(_LIBCPP_HAS_NO_VARIABLE_TEMPLATES)\ntemplate <class _Tp> _LIBCPP_CONSTEXPR bool is_object_v\n    = is_object<_Tp>::value;\n#endif\n\n// is_compound\n\ntemplate <class _Tp> struct _LIBCPP_TEMPLATE_VIS is_compound\n    : public integral_constant<bool, !is_fundamental<_Tp>::value> {};\n\n#if _LIBCPP_STD_VER > 14 && !defined(_LIBCPP_HAS_NO_VARIABLE_TEMPLATES)\ntemplate <class _Tp> _LIBCPP_CONSTEXPR bool is_compound_v\n    = is_compound<_Tp>::value;\n#endif\n\n\n// __is_referenceable  [defns.referenceable]\n\nstruct __is_referenceable_impl {\n    template <class _Tp> static _Tp& __test(int);\n    template <class _Tp> static __two __test(...);\n};\n\ntemplate <class _Tp>\nstruct __is_referenceable : integral_constant<bool,\n    !is_same<decltype(__is_referenceable_impl::__test<_Tp>(0)), __two>::value> {};\n\n\n// add_const\n\ntemplate <class _Tp, bool = is_reference<_Tp>::value ||\n                            is_function<_Tp>::value  ||\n                            is_const<_Tp>::value     >\nstruct __add_const             {typedef _Tp type;};\n\ntemplate <class _Tp>\nstruct __add_const<_Tp, false> {typedef const _Tp type;};\n\ntemplate <class _Tp> struct _LIBCPP_TEMPLATE_VIS add_const\n    {typedef typename __add_const<_Tp>::type type;};\n\n#if _LIBCPP_STD_VER > 11\ntemplate <class _Tp> using add_const_t = typename add_const<_Tp>::type;\n#endif\n\n// add_volatile\n\ntemplate <class _Tp, bool = is_reference<_Tp>::value ||\n                            is_function<_Tp>::value  ||\n                            is_volatile<_Tp>::value  >\nstruct __add_volatile             {typedef _Tp type;};\n\ntemplate <class _Tp>\nstruct __add_volatile<_Tp, false> {typedef volatile _Tp type;};\n\ntemplate <class _Tp> struct _LIBCPP_TEMPLATE_VIS add_volatile\n    {typedef typename __add_volatile<_Tp>::type type;};\n\n#if _LIBCPP_STD_VER > 11\ntemplate <class _Tp> using add_volatile_t = typename add_volatile<_Tp>::type;\n#endif\n\n// add_cv\n\ntemplate <class _Tp> struct _LIBCPP_TEMPLATE_VIS add_cv\n    {typedef typename add_const<typename add_volatile<_Tp>::type>::type type;};\n\n#if _LIBCPP_STD_VER > 11\ntemplate <class _Tp> using add_cv_t = typename add_cv<_Tp>::type;\n#endif\n\n// remove_reference\n\ntemplate <class _Tp> struct _LIBCPP_TEMPLATE_VIS remove_reference        {typedef _Tp type;};\ntemplate <class _Tp> struct _LIBCPP_TEMPLATE_VIS remove_reference<_Tp&>  {typedef _Tp type;};\n#ifndef _LIBCPP_HAS_NO_RVALUE_REFERENCES\ntemplate <class _Tp> struct _LIBCPP_TEMPLATE_VIS remove_reference<_Tp&&> {typedef _Tp type;};\n#endif\n\n#if _LIBCPP_STD_VER > 11\ntemplate <class _Tp> using remove_reference_t = typename remove_reference<_Tp>::type;\n#endif\n\n// add_lvalue_reference\n\ntemplate <class _Tp, bool = __is_referenceable<_Tp>::value> struct __add_lvalue_reference_impl            { typedef _Tp  type; };\ntemplate <class _Tp                                       > struct __add_lvalue_reference_impl<_Tp, true> { typedef _Tp& type; };\n\ntemplate <class _Tp> struct _LIBCPP_TEMPLATE_VIS add_lvalue_reference\n{typedef typename __add_lvalue_reference_impl<_Tp>::type type;};\n\n#if _LIBCPP_STD_VER > 11\ntemplate <class _Tp> using add_lvalue_reference_t = typename add_lvalue_reference<_Tp>::type;\n#endif\n\n#ifndef _LIBCPP_HAS_NO_RVALUE_REFERENCES\n\ntemplate <class _Tp, bool = __is_referenceable<_Tp>::value> struct __add_rvalue_reference_impl            { typedef _Tp   type; };\ntemplate <class _Tp                                       > struct __add_rvalue_reference_impl<_Tp, true> { typedef _Tp&& type; };\n\ntemplate <class _Tp> struct _LIBCPP_TEMPLATE_VIS add_rvalue_reference\n{typedef typename __add_rvalue_reference_impl<_Tp>::type type;};\n\n#if _LIBCPP_STD_VER > 11\ntemplate <class _Tp> using add_rvalue_reference_t = typename add_rvalue_reference<_Tp>::type;\n#endif\n\n#endif  // _LIBCPP_HAS_NO_RVALUE_REFERENCES\n\n#ifndef _LIBCPP_HAS_NO_RVALUE_REFERENCES\n\ntemplate <class _Tp> _Tp&& __declval(int);\ntemplate <class _Tp> _Tp   __declval(long);\n\ntemplate <class _Tp>\ndecltype(_VSTD::__declval<_Tp>(0))\ndeclval() _NOEXCEPT;\n\n#else  // _LIBCPP_HAS_NO_RVALUE_REFERENCES\n\ntemplate <class _Tp>\ntypename add_lvalue_reference<_Tp>::type\ndeclval();\n\n#endif  // _LIBCPP_HAS_NO_RVALUE_REFERENCES\n\n// __uncvref\n\ntemplate <class _Tp>\nstruct __uncvref  {\n    typedef typename remove_cv<typename remove_reference<_Tp>::type>::type type;\n};\n\ntemplate <class _Tp>\nstruct __unconstref {\n    typedef typename remove_const<typename remove_reference<_Tp>::type>::type type;\n};\n\n#ifndef _LIBCPP_CXX03_LANG\ntemplate <class _Tp>\nusing __uncvref_t = typename __uncvref<_Tp>::type;\n#endif\n\n// __is_same_uncvref\n\ntemplate <class _Tp, class _Up>\nstruct __is_same_uncvref : is_same<typename __uncvref<_Tp>::type,\n                                   typename __uncvref<_Up>::type> {};\n\nstruct __any\n{\n    __any(...);\n};\n\n// remove_pointer\n\ntemplate <class _Tp> struct _LIBCPP_TEMPLATE_VIS remove_pointer                      {typedef _Tp type;};\ntemplate <class _Tp> struct _LIBCPP_TEMPLATE_VIS remove_pointer<_Tp*>                {typedef _Tp type;};\ntemplate <class _Tp> struct _LIBCPP_TEMPLATE_VIS remove_pointer<_Tp* const>          {typedef _Tp type;};\ntemplate <class _Tp> struct _LIBCPP_TEMPLATE_VIS remove_pointer<_Tp* volatile>       {typedef _Tp type;};\ntemplate <class _Tp> struct _LIBCPP_TEMPLATE_VIS remove_pointer<_Tp* const volatile> {typedef _Tp type;};\n\n#if _LIBCPP_STD_VER > 11\ntemplate <class _Tp> using remove_pointer_t = typename remove_pointer<_Tp>::type;\n#endif\n\n// add_pointer\n\ntemplate <class _Tp, \n        bool = __is_referenceable<_Tp>::value || \n                is_same<typename remove_cv<_Tp>::type, void>::value>\nstruct __add_pointer_impl\n    {typedef typename remove_reference<_Tp>::type* type;};\ntemplate <class _Tp> struct __add_pointer_impl<_Tp, false> \n    {typedef _Tp type;};\n\ntemplate <class _Tp> struct _LIBCPP_TEMPLATE_VIS add_pointer\n    {typedef typename __add_pointer_impl<_Tp>::type type;};\n\n#if _LIBCPP_STD_VER > 11\ntemplate <class _Tp> using add_pointer_t = typename add_pointer<_Tp>::type;\n#endif\n\n// is_signed\n\ntemplate <class _Tp, bool = is_integral<_Tp>::value>\nstruct __libcpp_is_signed_impl : public _LIBCPP_BOOL_CONSTANT(_Tp(-1) < _Tp(0)) {};\n\ntemplate <class _Tp>\nstruct __libcpp_is_signed_impl<_Tp, false> : public true_type {};  // floating point\n\ntemplate <class _Tp, bool = is_arithmetic<_Tp>::value>\nstruct __libcpp_is_signed : public __libcpp_is_signed_impl<_Tp> {};\n\ntemplate <class _Tp> struct __libcpp_is_signed<_Tp, false> : public false_type {};\n\ntemplate <class _Tp> struct _LIBCPP_TEMPLATE_VIS is_signed : public __libcpp_is_signed<_Tp> {};\n\n#if _LIBCPP_STD_VER > 14 && !defined(_LIBCPP_HAS_NO_VARIABLE_TEMPLATES)\ntemplate <class _Tp> _LIBCPP_CONSTEXPR bool is_signed_v\n    = is_signed<_Tp>::value;\n#endif\n\n// is_unsigned\n\ntemplate <class _Tp, bool = is_integral<_Tp>::value>\nstruct __libcpp_is_unsigned_impl : public _LIBCPP_BOOL_CONSTANT(_Tp(0) < _Tp(-1)) {};\n\ntemplate <class _Tp>\nstruct __libcpp_is_unsigned_impl<_Tp, false> : public false_type {};  // floating point\n\ntemplate <class _Tp, bool = is_arithmetic<_Tp>::value>\nstruct __libcpp_is_unsigned : public __libcpp_is_unsigned_impl<_Tp> {};\n\ntemplate <class _Tp> struct __libcpp_is_unsigned<_Tp, false> : public false_type {};\n\ntemplate <class _Tp> struct _LIBCPP_TEMPLATE_VIS is_unsigned : public __libcpp_is_unsigned<_Tp> {};\n\n#if _LIBCPP_STD_VER > 14 && !defined(_LIBCPP_HAS_NO_VARIABLE_TEMPLATES)\ntemplate <class _Tp> _LIBCPP_CONSTEXPR bool is_unsigned_v\n    = is_unsigned<_Tp>::value;\n#endif\n\n// rank\n\ntemplate <class _Tp> struct _LIBCPP_TEMPLATE_VIS rank\n    : public integral_constant<size_t, 0> {};\ntemplate <class _Tp> struct _LIBCPP_TEMPLATE_VIS rank<_Tp[]>\n    : public integral_constant<size_t, rank<_Tp>::value + 1> {};\ntemplate <class _Tp, size_t _Np> struct _LIBCPP_TEMPLATE_VIS rank<_Tp[_Np]>\n    : public integral_constant<size_t, rank<_Tp>::value + 1> {};\n\n#if _LIBCPP_STD_VER > 14 && !defined(_LIBCPP_HAS_NO_VARIABLE_TEMPLATES)\ntemplate <class _Tp> _LIBCPP_CONSTEXPR size_t rank_v\n    = rank<_Tp>::value;\n#endif\n\n// extent\n\ntemplate <class _Tp, unsigned _Ip = 0> struct _LIBCPP_TEMPLATE_VIS extent\n    : public integral_constant<size_t, 0> {};\ntemplate <class _Tp> struct _LIBCPP_TEMPLATE_VIS extent<_Tp[], 0>\n    : public integral_constant<size_t, 0> {};\ntemplate <class _Tp, unsigned _Ip> struct _LIBCPP_TEMPLATE_VIS extent<_Tp[], _Ip>\n    : public integral_constant<size_t, extent<_Tp, _Ip-1>::value> {};\ntemplate <class _Tp, size_t _Np> struct _LIBCPP_TEMPLATE_VIS extent<_Tp[_Np], 0>\n    : public integral_constant<size_t, _Np> {};\ntemplate <class _Tp, size_t _Np, unsigned _Ip> struct _LIBCPP_TEMPLATE_VIS extent<_Tp[_Np], _Ip>\n    : public integral_constant<size_t, extent<_Tp, _Ip-1>::value> {};\n\n#if _LIBCPP_STD_VER > 14 && !defined(_LIBCPP_HAS_NO_VARIABLE_TEMPLATES)\ntemplate <class _Tp, unsigned _Ip = 0> _LIBCPP_CONSTEXPR size_t extent_v\n    = extent<_Tp, _Ip>::value;\n#endif\n\n// remove_extent\n\ntemplate <class _Tp> struct _LIBCPP_TEMPLATE_VIS remove_extent\n    {typedef _Tp type;};\ntemplate <class _Tp> struct _LIBCPP_TEMPLATE_VIS remove_extent<_Tp[]>\n    {typedef _Tp type;};\ntemplate <class _Tp, size_t _Np> struct _LIBCPP_TEMPLATE_VIS remove_extent<_Tp[_Np]>\n    {typedef _Tp type;};\n\n#if _LIBCPP_STD_VER > 11\ntemplate <class _Tp> using remove_extent_t = typename remove_extent<_Tp>::type;\n#endif\n\n// remove_all_extents\n\ntemplate <class _Tp> struct _LIBCPP_TEMPLATE_VIS remove_all_extents\n    {typedef _Tp type;};\ntemplate <class _Tp> struct _LIBCPP_TEMPLATE_VIS remove_all_extents<_Tp[]>\n    {typedef typename remove_all_extents<_Tp>::type type;};\ntemplate <class _Tp, size_t _Np> struct _LIBCPP_TEMPLATE_VIS remove_all_extents<_Tp[_Np]>\n    {typedef typename remove_all_extents<_Tp>::type type;};\n\n#if _LIBCPP_STD_VER > 11\ntemplate <class _Tp> using remove_all_extents_t = typename remove_all_extents<_Tp>::type;\n#endif\n\n// decay\n\ntemplate <class _Tp>\nstruct _LIBCPP_TEMPLATE_VIS decay\n{\nprivate:\n    typedef typename remove_reference<_Tp>::type _Up;\npublic:\n    typedef typename conditional\n                     <\n                         is_array<_Up>::value,\n                         typename remove_extent<_Up>::type*,\n                         typename conditional\n                         <\n                              is_function<_Up>::value,\n                              typename add_pointer<_Up>::type,\n                              typename remove_cv<_Up>::type\n                         >::type\n                     >::type type;\n};\n\n#if _LIBCPP_STD_VER > 11\ntemplate <class _Tp> using decay_t = typename decay<_Tp>::type;\n#endif\n\n// is_abstract\n\ntemplate <class _Tp> struct _LIBCPP_TEMPLATE_VIS is_abstract\n    : public integral_constant<bool, __is_abstract(_Tp)> {};\n\n#if _LIBCPP_STD_VER > 14 && !defined(_LIBCPP_HAS_NO_VARIABLE_TEMPLATES)\ntemplate <class _Tp> _LIBCPP_CONSTEXPR bool is_abstract_v\n    = is_abstract<_Tp>::value;\n#endif\n\n// is_final\n\n#if defined(_LIBCPP_HAS_IS_FINAL)\ntemplate <class _Tp> struct _LIBCPP_TEMPLATE_VIS\n__libcpp_is_final : public integral_constant<bool, __is_final(_Tp)> {};\n#else\ntemplate <class _Tp> struct _LIBCPP_TEMPLATE_VIS\n__libcpp_is_final : public false_type {};\n#endif\n\n#if defined(_LIBCPP_HAS_IS_FINAL) && _LIBCPP_STD_VER > 11\ntemplate <class _Tp> struct _LIBCPP_TEMPLATE_VIS\nis_final : public integral_constant<bool, __is_final(_Tp)> {};\n#endif\n\n#if _LIBCPP_STD_VER > 14 && !defined(_LIBCPP_HAS_NO_VARIABLE_TEMPLATES)\ntemplate <class _Tp> _LIBCPP_CONSTEXPR bool is_final_v\n    = is_final<_Tp>::value;\n#endif\n\n// is_base_of\n\n#ifdef _LIBCPP_HAS_IS_BASE_OF\n\ntemplate <class _Bp, class _Dp>\nstruct _LIBCPP_TEMPLATE_VIS is_base_of\n    : public integral_constant<bool, __is_base_of(_Bp, _Dp)> {};\n\n#else  // _LIBCPP_HAS_IS_BASE_OF\n\nnamespace __is_base_of_imp\n{\ntemplate <class _Tp>\nstruct _Dst\n{\n    _Dst(const volatile _Tp &);\n};\ntemplate <class _Tp>\nstruct _Src\n{\n    operator const volatile _Tp &();\n    template <class _Up> operator const _Dst<_Up> &();\n};\ntemplate <size_t> struct __one { typedef char type; };\ntemplate <class _Bp, class _Dp> typename __one<sizeof(_Dst<_Bp>(declval<_Src<_Dp> >()))>::type __test(int);\ntemplate <class _Bp, class _Dp> __two __test(...);\n}\n\ntemplate <class _Bp, class _Dp>\nstruct _LIBCPP_TEMPLATE_VIS is_base_of\n    : public integral_constant<bool, is_class<_Bp>::value &&\n                                     sizeof(__is_base_of_imp::__test<_Bp, _Dp>(0)) == 2> {};\n\n#endif  // _LIBCPP_HAS_IS_BASE_OF\n\n#if _LIBCPP_STD_VER > 14 && !defined(_LIBCPP_HAS_NO_VARIABLE_TEMPLATES)\ntemplate <class _Bp, class _Dp> _LIBCPP_CONSTEXPR bool is_base_of_v\n    = is_base_of<_Bp, _Dp>::value;\n#endif\n\n// is_convertible\n\n#if __has_feature(is_convertible_to) && !defined(_LIBCPP_USE_IS_CONVERTIBLE_FALLBACK)\n\ntemplate <class _T1, class _T2> struct _LIBCPP_TEMPLATE_VIS is_convertible\n    : public integral_constant<bool, __is_convertible_to(_T1, _T2) &&\n                                     !is_abstract<_T2>::value> {};\n\n#else  // __has_feature(is_convertible_to)\n\nnamespace __is_convertible_imp\n{\ntemplate <class _Tp> void  __test_convert(_Tp);\n\ntemplate <class _From, class _To, class = void>\nstruct __is_convertible_test : public false_type {};\n\ntemplate <class _From, class _To>\nstruct __is_convertible_test<_From, _To,\n    decltype(_VSTD::__is_convertible_imp::__test_convert<_To>(_VSTD::declval<_From>()))> : public true_type\n{};\n\ntemplate <class _Tp, bool _IsArray =    is_array<_Tp>::value,\n                     bool _IsFunction = is_function<_Tp>::value,\n                     bool _IsVoid =     is_void<_Tp>::value>\n                     struct __is_array_function_or_void                          {enum {value = 0};};\ntemplate <class _Tp> struct __is_array_function_or_void<_Tp, true, false, false> {enum {value = 1};};\ntemplate <class _Tp> struct __is_array_function_or_void<_Tp, false, true, false> {enum {value = 2};};\ntemplate <class _Tp> struct __is_array_function_or_void<_Tp, false, false, true> {enum {value = 3};};\n}\n\ntemplate <class _Tp,\n    unsigned = __is_convertible_imp::__is_array_function_or_void<typename remove_reference<_Tp>::type>::value>\nstruct __is_convertible_check\n{\n    static const size_t __v = 0;\n};\n\ntemplate <class _Tp>\nstruct __is_convertible_check<_Tp, 0>\n{\n    static const size_t __v = sizeof(_Tp);\n};\n\ntemplate <class _T1, class _T2,\n    unsigned _T1_is_array_function_or_void = __is_convertible_imp::__is_array_function_or_void<_T1>::value,\n    unsigned _T2_is_array_function_or_void = __is_convertible_imp::__is_array_function_or_void<_T2>::value>\nstruct __is_convertible\n    : public integral_constant<bool,\n        __is_convertible_imp::__is_convertible_test<_T1, _T2>::value\n#if defined(_LIBCPP_HAS_NO_RVALUE_REFERENCES)\n         && !(!is_function<_T1>::value && !is_reference<_T1>::value && is_reference<_T2>::value\n              && (!is_const<typename remove_reference<_T2>::type>::value\n                  || is_volatile<typename remove_reference<_T2>::type>::value)\n                  && (is_same<typename remove_cv<_T1>::type,\n                              typename remove_cv<typename remove_reference<_T2>::type>::type>::value\n                      || is_base_of<typename remove_reference<_T2>::type, _T1>::value))\n#endif\n    >\n{};\n\ntemplate <class _T1, class _T2> struct __is_convertible<_T1, _T2, 0, 1> : public false_type {};\ntemplate <class _T1, class _T2> struct __is_convertible<_T1, _T2, 1, 1> : public false_type {};\ntemplate <class _T1, class _T2> struct __is_convertible<_T1, _T2, 2, 1> : public false_type {};\ntemplate <class _T1, class _T2> struct __is_convertible<_T1, _T2, 3, 1> : public false_type {};\n\ntemplate <class _T1, class _T2> struct __is_convertible<_T1, _T2, 0, 2> : public false_type {};\ntemplate <class _T1, class _T2> struct __is_convertible<_T1, _T2, 1, 2> : public false_type {};\ntemplate <class _T1, class _T2> struct __is_convertible<_T1, _T2, 2, 2> : public false_type {};\ntemplate <class _T1, class _T2> struct __is_convertible<_T1, _T2, 3, 2> : public false_type {};\n\ntemplate <class _T1, class _T2> struct __is_convertible<_T1, _T2, 0, 3> : public false_type {};\ntemplate <class _T1, class _T2> struct __is_convertible<_T1, _T2, 1, 3> : public false_type {};\ntemplate <class _T1, class _T2> struct __is_convertible<_T1, _T2, 2, 3> : public false_type {};\ntemplate <class _T1, class _T2> struct __is_convertible<_T1, _T2, 3, 3> : public true_type {};\n\ntemplate <class _T1, class _T2> struct _LIBCPP_TEMPLATE_VIS is_convertible\n    : public __is_convertible<_T1, _T2>\n{\n    static const size_t __complete_check1 = __is_convertible_check<_T1>::__v;\n    static const size_t __complete_check2 = __is_convertible_check<_T2>::__v;\n};\n\n#endif  // __has_feature(is_convertible_to)\n\n#if _LIBCPP_STD_VER > 14 && !defined(_LIBCPP_HAS_NO_VARIABLE_TEMPLATES)\ntemplate <class _From, class _To> _LIBCPP_CONSTEXPR bool is_convertible_v\n    = is_convertible<_From, _To>::value;\n#endif\n\n// is_empty\n\n#if __has_feature(is_empty) || (_GNUC_VER >= 407)\n\ntemplate <class _Tp>\nstruct _LIBCPP_TEMPLATE_VIS is_empty\n    : public integral_constant<bool, __is_empty(_Tp)> {};\n\n#else  // __has_feature(is_empty)\n\ntemplate <class _Tp>\nstruct __is_empty1\n    : public _Tp\n{\n    double __lx;\n};\n\nstruct __is_empty2\n{\n    double __lx;\n};\n\ntemplate <class _Tp, bool = is_class<_Tp>::value>\nstruct __libcpp_empty : public integral_constant<bool, sizeof(__is_empty1<_Tp>) == sizeof(__is_empty2)> {};\n\ntemplate <class _Tp> struct __libcpp_empty<_Tp, false> : public false_type {};\n\ntemplate <class _Tp> struct _LIBCPP_TEMPLATE_VIS is_empty : public __libcpp_empty<_Tp> {};\n\n#endif  // __has_feature(is_empty)\n\n#if _LIBCPP_STD_VER > 14 && !defined(_LIBCPP_HAS_NO_VARIABLE_TEMPLATES)\ntemplate <class _Tp> _LIBCPP_CONSTEXPR bool is_empty_v\n    = is_empty<_Tp>::value;\n#endif\n\n// is_polymorphic\n\n#if __has_feature(is_polymorphic) || defined(_LIBCPP_COMPILER_MSVC)\n\ntemplate <class _Tp>\nstruct _LIBCPP_TEMPLATE_VIS is_polymorphic\n    : public integral_constant<bool, __is_polymorphic(_Tp)> {};\n\n#else\n\ntemplate<typename _Tp> char &__is_polymorphic_impl(\n    typename enable_if<sizeof((_Tp*)dynamic_cast<const volatile void*>(declval<_Tp*>())) != 0,\n                       int>::type);\ntemplate<typename _Tp> __two &__is_polymorphic_impl(...);\n\ntemplate <class _Tp> struct _LIBCPP_TEMPLATE_VIS is_polymorphic\n    : public integral_constant<bool, sizeof(__is_polymorphic_impl<_Tp>(0)) == 1> {};\n\n#endif // __has_feature(is_polymorphic)\n\n#if _LIBCPP_STD_VER > 14 && !defined(_LIBCPP_HAS_NO_VARIABLE_TEMPLATES)\ntemplate <class _Tp> _LIBCPP_CONSTEXPR bool is_polymorphic_v\n    = is_polymorphic<_Tp>::value;\n#endif\n\n// has_virtual_destructor\n\n#if __has_feature(has_virtual_destructor) || (_GNUC_VER >= 403)\n\ntemplate <class _Tp> struct _LIBCPP_TEMPLATE_VIS has_virtual_destructor\n    : public integral_constant<bool, __has_virtual_destructor(_Tp)> {};\n\n#else\n\ntemplate <class _Tp> struct _LIBCPP_TEMPLATE_VIS has_virtual_destructor\n    : public false_type {};\n\n#endif\n\n#if _LIBCPP_STD_VER > 14 && !defined(_LIBCPP_HAS_NO_VARIABLE_TEMPLATES)\ntemplate <class _Tp> _LIBCPP_CONSTEXPR bool has_virtual_destructor_v\n    = has_virtual_destructor<_Tp>::value;\n#endif\n\n// alignment_of\n\ntemplate <class _Tp> struct _LIBCPP_TEMPLATE_VIS alignment_of\n    : public integral_constant<size_t, __alignof__(_Tp)> {};\n\n#if _LIBCPP_STD_VER > 14 && !defined(_LIBCPP_HAS_NO_VARIABLE_TEMPLATES)\ntemplate <class _Tp> _LIBCPP_CONSTEXPR size_t alignment_of_v\n    = alignment_of<_Tp>::value;\n#endif\n\n// aligned_storage\n\ntemplate <class _Hp, class _Tp>\nstruct __type_list\n{\n    typedef _Hp _Head;\n    typedef _Tp _Tail;\n};\n\nstruct __nat\n{\n#ifndef _LIBCPP_CXX03_LANG\n    __nat() = delete;\n    __nat(const __nat&) = delete;\n    __nat& operator=(const __nat&) = delete;\n    ~__nat() = delete;\n#endif\n};\n\ntemplate <class _Tp>\nstruct __align_type\n{\n    static const size_t value = alignment_of<_Tp>::value;\n    typedef _Tp type;\n};\n\nstruct __struct_double {long double __lx;};\nstruct __struct_double4 {double __lx[4];};\n\ntypedef\n    __type_list<__align_type<unsigned char>,\n    __type_list<__align_type<unsigned short>,\n    __type_list<__align_type<unsigned int>,\n    __type_list<__align_type<unsigned long>,\n    __type_list<__align_type<unsigned long long>,\n    __type_list<__align_type<double>,\n    __type_list<__align_type<long double>,\n    __type_list<__align_type<__struct_double>,\n    __type_list<__align_type<__struct_double4>,\n    __type_list<__align_type<int*>,\n    __nat\n    > > > > > > > > > > __all_types;\n\ntemplate <class _TL, size_t _Align> struct __find_pod;\n\ntemplate <class _Hp, size_t _Align>\nstruct __find_pod<__type_list<_Hp, __nat>, _Align>\n{\n    typedef typename conditional<\n                             _Align == _Hp::value,\n                             typename _Hp::type,\n                             void\n                         >::type type;\n};\n\ntemplate <class _Hp, class _Tp, size_t _Align>\nstruct __find_pod<__type_list<_Hp, _Tp>, _Align>\n{\n    typedef typename conditional<\n                             _Align == _Hp::value,\n                             typename _Hp::type,\n                             typename __find_pod<_Tp, _Align>::type\n                         >::type type;\n};\n\ntemplate <class _TL, size_t _Len> struct __find_max_align;\n\ntemplate <class _Hp, size_t _Len>\nstruct __find_max_align<__type_list<_Hp, __nat>, _Len> : public integral_constant<size_t, _Hp::value> {};\n\ntemplate <size_t _Len, size_t _A1, size_t _A2>\nstruct __select_align\n{\nprivate:\n    static const size_t __min = _A2 < _A1 ? _A2 : _A1;\n    static const size_t __max = _A1 < _A2 ? _A2 : _A1;\npublic:\n    static const size_t value = _Len < __max ? __min : __max;\n};\n\ntemplate <class _Hp, class _Tp, size_t _Len>\nstruct __find_max_align<__type_list<_Hp, _Tp>, _Len>\n    : public integral_constant<size_t, __select_align<_Len, _Hp::value, __find_max_align<_Tp, _Len>::value>::value> {};\n\ntemplate <size_t _Len, size_t _Align = __find_max_align<__all_types, _Len>::value>\nstruct _LIBCPP_TEMPLATE_VIS aligned_storage\n{\n    typedef typename __find_pod<__all_types, _Align>::type _Aligner;\n    static_assert(!is_void<_Aligner>::value, \"\");\n    union type\n    {\n        _Aligner __align;\n        unsigned char __data[(_Len + _Align - 1)/_Align * _Align];\n    };\n};\n\n#if _LIBCPP_STD_VER > 11\ntemplate <size_t _Len, size_t _Align = __find_max_align<__all_types, _Len>::value>\n    using aligned_storage_t = typename aligned_storage<_Len, _Align>::type;\n#endif\n\n#define _CREATE_ALIGNED_STORAGE_SPECIALIZATION(n) \\\ntemplate <size_t _Len>\\\nstruct _LIBCPP_TEMPLATE_VIS aligned_storage<_Len, n>\\\n{\\\n    struct _ALIGNAS(n) type\\\n    {\\\n        unsigned char __lx[(_Len + n - 1)/n * n];\\\n    };\\\n}\n\n_CREATE_ALIGNED_STORAGE_SPECIALIZATION(0x1);\n_CREATE_ALIGNED_STORAGE_SPECIALIZATION(0x2);\n_CREATE_ALIGNED_STORAGE_SPECIALIZATION(0x4);\n_CREATE_ALIGNED_STORAGE_SPECIALIZATION(0x8);\n_CREATE_ALIGNED_STORAGE_SPECIALIZATION(0x10);\n_CREATE_ALIGNED_STORAGE_SPECIALIZATION(0x20);\n_CREATE_ALIGNED_STORAGE_SPECIALIZATION(0x40);\n_CREATE_ALIGNED_STORAGE_SPECIALIZATION(0x80);\n_CREATE_ALIGNED_STORAGE_SPECIALIZATION(0x100);\n_CREATE_ALIGNED_STORAGE_SPECIALIZATION(0x200);\n_CREATE_ALIGNED_STORAGE_SPECIALIZATION(0x400);\n_CREATE_ALIGNED_STORAGE_SPECIALIZATION(0x800);\n_CREATE_ALIGNED_STORAGE_SPECIALIZATION(0x1000);\n_CREATE_ALIGNED_STORAGE_SPECIALIZATION(0x2000);\n// PE/COFF does not support alignment beyond 8192 (=0x2000)\n#if !defined(_LIBCPP_OBJECT_FORMAT_COFF)\n_CREATE_ALIGNED_STORAGE_SPECIALIZATION(0x4000);\n#endif // !defined(_LIBCPP_OBJECT_FORMAT_COFF)\n\n#undef _CREATE_ALIGNED_STORAGE_SPECIALIZATION\n\n#ifndef _LIBCPP_HAS_NO_VARIADICS\n\n// aligned_union\n\ntemplate <size_t _I0, size_t ..._In>\nstruct __static_max;\n\ntemplate <size_t _I0>\nstruct __static_max<_I0>\n{\n    static const size_t value = _I0;\n};\n\ntemplate <size_t _I0, size_t _I1, size_t ..._In>\nstruct __static_max<_I0, _I1, _In...>\n{\n    static const size_t value = _I0 >= _I1 ? __static_max<_I0, _In...>::value :\n                                             __static_max<_I1, _In...>::value;\n};\n\ntemplate <size_t _Len, class _Type0, class ..._Types>\nstruct aligned_union\n{\n    static const size_t alignment_value = __static_max<__alignof__(_Type0),\n                                                       __alignof__(_Types)...>::value;\n    static const size_t __len = __static_max<_Len, sizeof(_Type0),\n                                             sizeof(_Types)...>::value;\n    typedef typename aligned_storage<__len, alignment_value>::type type;\n};\n\n#if _LIBCPP_STD_VER > 11\ntemplate <size_t _Len, class ..._Types> using aligned_union_t = typename aligned_union<_Len, _Types...>::type;\n#endif\n\n#endif  // _LIBCPP_HAS_NO_VARIADICS\n\ntemplate <class _Tp>\nstruct __numeric_type\n{\n   static void __test(...);\n   static float __test(float);\n   static double __test(char);\n   static double __test(int);\n   static double __test(unsigned);\n   static double __test(long);\n   static double __test(unsigned long);\n   static double __test(long long);\n   static double __test(unsigned long long);\n   static double __test(double);\n   static long double __test(long double);\n\n   typedef decltype(__test(declval<_Tp>())) type;\n   static const bool value = !is_same<type, void>::value;\n};\n\ntemplate <>\nstruct __numeric_type<void>\n{\n   static const bool value = true;\n};\n\n// __promote\n\ntemplate <class _A1, class _A2 = void, class _A3 = void,\n          bool = __numeric_type<_A1>::value &&\n                 __numeric_type<_A2>::value &&\n                 __numeric_type<_A3>::value>\nclass __promote_imp\n{\npublic:\n    static const bool value = false;\n};\n\ntemplate <class _A1, class _A2, class _A3>\nclass __promote_imp<_A1, _A2, _A3, true>\n{\nprivate:\n    typedef typename __promote_imp<_A1>::type __type1;\n    typedef typename __promote_imp<_A2>::type __type2;\n    typedef typename __promote_imp<_A3>::type __type3;\npublic:\n    typedef decltype(__type1() + __type2() + __type3()) type;\n    static const bool value = true;\n};\n\ntemplate <class _A1, class _A2>\nclass __promote_imp<_A1, _A2, void, true>\n{\nprivate:\n    typedef typename __promote_imp<_A1>::type __type1;\n    typedef typename __promote_imp<_A2>::type __type2;\npublic:\n    typedef decltype(__type1() + __type2()) type;\n    static const bool value = true;\n};\n\ntemplate <class _A1>\nclass __promote_imp<_A1, void, void, true>\n{\npublic:\n    typedef typename __numeric_type<_A1>::type type;\n    static const bool value = true;\n};\n\ntemplate <class _A1, class _A2 = void, class _A3 = void>\nclass __promote : public __promote_imp<_A1, _A2, _A3> {};\n\n// make_signed / make_unsigned\n\ntypedef\n    __type_list<signed char,\n    __type_list<signed short,\n    __type_list<signed int,\n    __type_list<signed long,\n    __type_list<signed long long,\n#ifndef _LIBCPP_HAS_NO_INT128\n    __type_list<__int128_t,\n#endif\n    __nat\n#ifndef _LIBCPP_HAS_NO_INT128\n    >\n#endif\n    > > > > > __signed_types;\n\ntypedef\n    __type_list<unsigned char,\n    __type_list<unsigned short,\n    __type_list<unsigned int,\n    __type_list<unsigned long,\n    __type_list<unsigned long long,\n#ifndef _LIBCPP_HAS_NO_INT128\n    __type_list<__uint128_t,\n#endif\n    __nat\n#ifndef _LIBCPP_HAS_NO_INT128\n    >\n#endif\n    > > > > > __unsigned_types;\n\ntemplate <class _TypeList, size_t _Size, bool = _Size <= sizeof(typename _TypeList::_Head)> struct __find_first;\n\ntemplate <class _Hp, class _Tp, size_t _Size>\nstruct __find_first<__type_list<_Hp, _Tp>, _Size, true>\n{\n    typedef _Hp type;\n};\n\ntemplate <class _Hp, class _Tp, size_t _Size>\nstruct __find_first<__type_list<_Hp, _Tp>, _Size, false>\n{\n    typedef typename __find_first<_Tp, _Size>::type type;\n};\n\ntemplate <class _Tp, class _Up, bool = is_const<typename remove_reference<_Tp>::type>::value,\n                             bool = is_volatile<typename remove_reference<_Tp>::type>::value>\nstruct __apply_cv\n{\n    typedef _Up type;\n};\n\ntemplate <class _Tp, class _Up>\nstruct __apply_cv<_Tp, _Up, true, false>\n{\n    typedef const _Up type;\n};\n\ntemplate <class _Tp, class _Up>\nstruct __apply_cv<_Tp, _Up, false, true>\n{\n    typedef volatile _Up type;\n};\n\ntemplate <class _Tp, class _Up>\nstruct __apply_cv<_Tp, _Up, true, true>\n{\n    typedef const volatile _Up type;\n};\n\ntemplate <class _Tp, class _Up>\nstruct __apply_cv<_Tp&, _Up, false, false>\n{\n    typedef _Up& type;\n};\n\ntemplate <class _Tp, class _Up>\nstruct __apply_cv<_Tp&, _Up, true, false>\n{\n    typedef const _Up& type;\n};\n\ntemplate <class _Tp, class _Up>\nstruct __apply_cv<_Tp&, _Up, false, true>\n{\n    typedef volatile _Up& type;\n};\n\ntemplate <class _Tp, class _Up>\nstruct __apply_cv<_Tp&, _Up, true, true>\n{\n    typedef const volatile _Up& type;\n};\n\ntemplate <class _Tp, bool = is_integral<_Tp>::value || is_enum<_Tp>::value>\nstruct __make_signed {};\n\ntemplate <class _Tp>\nstruct __make_signed<_Tp, true>\n{\n    typedef typename __find_first<__signed_types, sizeof(_Tp)>::type type;\n};\n\ntemplate <> struct __make_signed<bool,               true> {};\ntemplate <> struct __make_signed<  signed short,     true> {typedef short     type;};\ntemplate <> struct __make_signed<unsigned short,     true> {typedef short     type;};\ntemplate <> struct __make_signed<  signed int,       true> {typedef int       type;};\ntemplate <> struct __make_signed<unsigned int,       true> {typedef int       type;};\ntemplate <> struct __make_signed<  signed long,      true> {typedef long      type;};\ntemplate <> struct __make_signed<unsigned long,      true> {typedef long      type;};\ntemplate <> struct __make_signed<  signed long long, true> {typedef long long type;};\ntemplate <> struct __make_signed<unsigned long long, true> {typedef long long type;};\n#ifndef _LIBCPP_HAS_NO_INT128\ntemplate <> struct __make_signed<__int128_t,         true> {typedef __int128_t type;};\ntemplate <> struct __make_signed<__uint128_t,        true> {typedef __int128_t type;};\n#endif\n\ntemplate <class _Tp>\nstruct _LIBCPP_TEMPLATE_VIS make_signed\n{\n    typedef typename __apply_cv<_Tp, typename __make_signed<typename remove_cv<_Tp>::type>::type>::type type;\n};\n\n#if _LIBCPP_STD_VER > 11\ntemplate <class _Tp> using make_signed_t = typename make_signed<_Tp>::type;\n#endif\n\ntemplate <class _Tp, bool = is_integral<_Tp>::value || is_enum<_Tp>::value>\nstruct __make_unsigned {};\n\ntemplate <class _Tp>\nstruct __make_unsigned<_Tp, true>\n{\n    typedef typename __find_first<__unsigned_types, sizeof(_Tp)>::type type;\n};\n\ntemplate <> struct __make_unsigned<bool,               true> {};\ntemplate <> struct __make_unsigned<  signed short,     true> {typedef unsigned short     type;};\ntemplate <> struct __make_unsigned<unsigned short,     true> {typedef unsigned short     type;};\ntemplate <> struct __make_unsigned<  signed int,       true> {typedef unsigned int       type;};\ntemplate <> struct __make_unsigned<unsigned int,       true> {typedef unsigned int       type;};\ntemplate <> struct __make_unsigned<  signed long,      true> {typedef unsigned long      type;};\ntemplate <> struct __make_unsigned<unsigned long,      true> {typedef unsigned long      type;};\ntemplate <> struct __make_unsigned<  signed long long, true> {typedef unsigned long long type;};\ntemplate <> struct __make_unsigned<unsigned long long, true> {typedef unsigned long long type;};\n#ifndef _LIBCPP_HAS_NO_INT128\ntemplate <> struct __make_unsigned<__int128_t,         true> {typedef __uint128_t        type;};\ntemplate <> struct __make_unsigned<__uint128_t,        true> {typedef __uint128_t        type;};\n#endif\n\ntemplate <class _Tp>\nstruct _LIBCPP_TEMPLATE_VIS make_unsigned\n{\n    typedef typename __apply_cv<_Tp, typename __make_unsigned<typename remove_cv<_Tp>::type>::type>::type type;\n};\n\n#if _LIBCPP_STD_VER > 11\ntemplate <class _Tp> using make_unsigned_t = typename make_unsigned<_Tp>::type;\n#endif\n\n#ifdef _LIBCPP_HAS_NO_VARIADICS\n\ntemplate <class _Tp, class _Up = void, class _Vp = void>\nstruct _LIBCPP_TEMPLATE_VIS common_type\n{\npublic:\n    typedef typename common_type<typename common_type<_Tp, _Up>::type, _Vp>::type type;\n};\n\ntemplate <class _Tp>\nstruct _LIBCPP_TEMPLATE_VIS common_type<_Tp, void, void>\n{\npublic:\n    typedef typename decay<_Tp>::type type;\n};\n\ntemplate <class _Tp, class _Up>\nstruct _LIBCPP_TEMPLATE_VIS common_type<_Tp, _Up, void>\n{\n    typedef typename decay<decltype(\n        true ? _VSTD::declval<_Tp>() : _VSTD::declval<_Up>()\n      )>::type type;\n};\n\n#else  // _LIBCPP_HAS_NO_VARIADICS\n\n// bullet 1 - sizeof...(Tp) == 0\n\ntemplate <class ..._Tp>\nstruct _LIBCPP_TEMPLATE_VIS common_type {};\n\n// bullet 2 - sizeof...(Tp) == 1\n\ntemplate <class _Tp>\nstruct _LIBCPP_TEMPLATE_VIS common_type<_Tp>\n{\n    typedef typename decay<_Tp>::type type;\n};\n\n// bullet 3 - sizeof...(Tp) == 2\n\ntemplate <class _Tp, class _Up, class = void>\nstruct __common_type2_imp {};\n\ntemplate <class _Tp, class _Up>\nstruct __common_type2_imp<_Tp, _Up,\n    typename __void_t<decltype(\n        true ? _VSTD::declval<_Tp>() : _VSTD::declval<_Up>()\n    )>::type>\n{\n    typedef typename decay<decltype(\n        true ? _VSTD::declval<_Tp>() : _VSTD::declval<_Up>()\n    )>::type type;\n};\n\ntemplate <class _Tp, class _Up,\n          class _DTp = typename decay<_Tp>::type,\n          class _DUp = typename decay<_Up>::type>\nusing __common_type2 =\n  typename conditional<\n    is_same<_Tp, _DTp>::value && is_same<_Up, _DUp>::value,\n    __common_type2_imp<_Tp, _Up>,\n    common_type<_DTp, _DUp>\n  >::type;\n\ntemplate <class _Tp, class _Up>\nstruct _LIBCPP_TEMPLATE_VIS common_type<_Tp, _Up>\n    : __common_type2<_Tp, _Up> {};\n\n// bullet 4 - sizeof...(Tp) > 2\n\ntemplate <class ...Tp> struct __common_types;\n\ntemplate <class, class = void>\nstruct __common_type_impl {};\n\ntemplate <class _Tp, class _Up>\nstruct __common_type_impl<\n    __common_types<_Tp, _Up>,\n    typename __void_t<typename common_type<_Tp, _Up>::type>::type>\n{\n  typedef typename common_type<_Tp, _Up>::type type;\n};\n\ntemplate <class _Tp, class _Up, class ..._Vp>\nstruct __common_type_impl<__common_types<_Tp, _Up, _Vp...>,\n    typename __void_t<typename common_type<_Tp, _Up>::type>::type>\n  : __common_type_impl<\n      __common_types<typename common_type<_Tp, _Up>::type, _Vp...> >\n{\n\n};\n\ntemplate <class _Tp, class _Up, class ..._Vp>\nstruct _LIBCPP_TEMPLATE_VIS common_type<_Tp, _Up, _Vp...>\n    : __common_type_impl<__common_types<_Tp, _Up, _Vp...> > {};\n\n#if _LIBCPP_STD_VER > 11\ntemplate <class ..._Tp> using common_type_t = typename common_type<_Tp...>::type;\n#endif\n\n#endif  // _LIBCPP_HAS_NO_VARIADICS\n\n// is_assignable\n\ntemplate<typename, typename _Tp> struct __select_2nd { typedef _Tp type; };\n\ntemplate <class _Tp, class _Arg>\ntypename __select_2nd<decltype((_VSTD::declval<_Tp>() = _VSTD::declval<_Arg>())), true_type>::type\n__is_assignable_test(int);\n\ntemplate <class, class>\nfalse_type __is_assignable_test(...);\n\n\ntemplate <class _Tp, class _Arg, bool = is_void<_Tp>::value || is_void<_Arg>::value>\nstruct __is_assignable_imp\n    : public decltype((_VSTD::__is_assignable_test<_Tp, _Arg>(0))) {};\n\ntemplate <class _Tp, class _Arg>\nstruct __is_assignable_imp<_Tp, _Arg, true>\n    : public false_type\n{\n};\n\ntemplate <class _Tp, class _Arg>\nstruct is_assignable\n    : public __is_assignable_imp<_Tp, _Arg> {};\n\n#if _LIBCPP_STD_VER > 14 && !defined(_LIBCPP_HAS_NO_VARIABLE_TEMPLATES)\ntemplate <class _Tp, class _Arg> _LIBCPP_CONSTEXPR bool is_assignable_v\n    = is_assignable<_Tp, _Arg>::value;\n#endif\n\n// is_copy_assignable\n\ntemplate <class _Tp> struct _LIBCPP_TEMPLATE_VIS is_copy_assignable\n    : public is_assignable<typename add_lvalue_reference<_Tp>::type,\n                  typename add_lvalue_reference<typename add_const<_Tp>::type>::type> {};\n\n#if _LIBCPP_STD_VER > 14 && !defined(_LIBCPP_HAS_NO_VARIABLE_TEMPLATES)\ntemplate <class _Tp> _LIBCPP_CONSTEXPR bool is_copy_assignable_v\n    = is_copy_assignable<_Tp>::value;\n#endif\n\n// is_move_assignable\n\ntemplate <class _Tp> struct _LIBCPP_TEMPLATE_VIS is_move_assignable\n#ifndef _LIBCPP_HAS_NO_RVALUE_REFERENCES\n    : public is_assignable<typename add_lvalue_reference<_Tp>::type,\n                           typename add_rvalue_reference<_Tp>::type> {};\n#else\n    : public is_copy_assignable<_Tp> {};\n#endif\n\n#if _LIBCPP_STD_VER > 14 && !defined(_LIBCPP_HAS_NO_VARIABLE_TEMPLATES)\ntemplate <class _Tp> _LIBCPP_CONSTEXPR bool is_move_assignable_v\n    = is_move_assignable<_Tp>::value;\n#endif\n\n// is_destructible\n\n//  if it's a reference, return true\n//  if it's a function, return false\n//  if it's   void,     return false\n//  if it's an array of unknown bound, return false\n//  Otherwise, return \"std::declval<_Up&>().~_Up()\" is well-formed\n//    where _Up is remove_all_extents<_Tp>::type\n\ntemplate <class>\nstruct __is_destructible_apply { typedef int type; };\n\ntemplate <typename _Tp>\nstruct __is_destructor_wellformed {\n    template <typename _Tp1>\n    static char  __test (\n        typename __is_destructible_apply<decltype(_VSTD::declval<_Tp1&>().~_Tp1())>::type\n    );\n\n    template <typename _Tp1>\n    static __two __test (...);\n    \n    static const bool value = sizeof(__test<_Tp>(12)) == sizeof(char);\n};\n\ntemplate <class _Tp, bool>\nstruct __destructible_imp;\n\ntemplate <class _Tp>\nstruct __destructible_imp<_Tp, false> \n   : public _VSTD::integral_constant<bool, \n        __is_destructor_wellformed<typename _VSTD::remove_all_extents<_Tp>::type>::value> {};\n\ntemplate <class _Tp>\nstruct __destructible_imp<_Tp, true>\n    : public _VSTD::true_type {};\n\ntemplate <class _Tp, bool>\nstruct __destructible_false;\n\ntemplate <class _Tp>\nstruct __destructible_false<_Tp, false> : public __destructible_imp<_Tp, _VSTD::is_reference<_Tp>::value> {};\n\ntemplate <class _Tp>\nstruct __destructible_false<_Tp, true> : public _VSTD::false_type {};\n\ntemplate <class _Tp>\nstruct is_destructible\n    : public __destructible_false<_Tp, _VSTD::is_function<_Tp>::value> {};\n\ntemplate <class _Tp>\nstruct is_destructible<_Tp[]>\n    : public _VSTD::false_type {};\n\ntemplate <>\nstruct is_destructible<void>\n    : public _VSTD::false_type {};\n\n#if _LIBCPP_STD_VER > 14 && !defined(_LIBCPP_HAS_NO_VARIABLE_TEMPLATES)\ntemplate <class _Tp> _LIBCPP_CONSTEXPR bool is_destructible_v\n    = is_destructible<_Tp>::value;\n#endif\n\n// move\n\n#ifndef _LIBCPP_HAS_NO_RVALUE_REFERENCES\n\ntemplate <class _Tp>\ninline _LIBCPP_INLINE_VISIBILITY _LIBCPP_CONSTEXPR\ntypename remove_reference<_Tp>::type&&\nmove(_Tp&& __t) _NOEXCEPT\n{\n    typedef typename remove_reference<_Tp>::type _Up;\n    return static_cast<_Up&&>(__t);\n}\n\ntemplate <class _Tp>\ninline _LIBCPP_INLINE_VISIBILITY _LIBCPP_CONSTEXPR\n_Tp&&\nforward(typename remove_reference<_Tp>::type& __t) _NOEXCEPT\n{\n    return static_cast<_Tp&&>(__t);\n}\n\ntemplate <class _Tp>\ninline _LIBCPP_INLINE_VISIBILITY _LIBCPP_CONSTEXPR\n_Tp&&\nforward(typename remove_reference<_Tp>::type&& __t) _NOEXCEPT\n{\n    static_assert(!is_lvalue_reference<_Tp>::value,\n                  \"can not forward an rvalue as an lvalue\");\n    return static_cast<_Tp&&>(__t);\n}\n\n#else  // _LIBCPP_HAS_NO_RVALUE_REFERENCES\n\ntemplate <class _Tp>\ninline _LIBCPP_INLINE_VISIBILITY\n_Tp&\nmove(_Tp& __t)\n{\n    return __t;\n}\n\ntemplate <class _Tp>\ninline _LIBCPP_INLINE_VISIBILITY\nconst _Tp&\nmove(const _Tp& __t)\n{\n    return __t;\n}\n\ntemplate <class _Tp>\ninline _LIBCPP_INLINE_VISIBILITY\n_Tp&\nforward(typename remove_reference<_Tp>::type& __t) _NOEXCEPT\n{\n    return __t;\n}\n\n\ntemplate <class _Tp>\nclass __rv\n{\n    typedef typename remove_reference<_Tp>::type _Trr;\n    _Trr& t_;\npublic:\n    _LIBCPP_INLINE_VISIBILITY\n    _Trr* operator->() {return &t_;}\n    _LIBCPP_INLINE_VISIBILITY\n    explicit __rv(_Trr& __t) : t_(__t) {}\n};\n\n#endif  // _LIBCPP_HAS_NO_RVALUE_REFERENCES\n\n#ifndef _LIBCPP_HAS_NO_RVALUE_REFERENCES\n\ntemplate <class _Tp>\ninline _LIBCPP_INLINE_VISIBILITY\ntypename decay<_Tp>::type\n__decay_copy(_Tp&& __t)\n{\n    return _VSTD::forward<_Tp>(__t);\n}\n\n#else\n\ntemplate <class _Tp>\ninline _LIBCPP_INLINE_VISIBILITY\ntypename decay<_Tp>::type\n__decay_copy(const _Tp& __t)\n{\n    return _VSTD::forward<_Tp>(__t);\n}\n\n#endif\n\n#ifndef _LIBCPP_HAS_NO_VARIADICS\n\ntemplate <class _Rp, class _Class, class ..._Param>\nstruct __member_pointer_traits_imp<_Rp (_Class::*)(_Param...), true, false>\n{\n    typedef _Class _ClassType;\n    typedef _Rp _ReturnType;\n    typedef _Rp (_FnType) (_Param...);\n};\n\ntemplate <class _Rp, class _Class, class ..._Param>\nstruct __member_pointer_traits_imp<_Rp (_Class::*)(_Param..., ...), true, false>\n{\n    typedef _Class _ClassType;\n    typedef _Rp _ReturnType;\n    typedef _Rp (_FnType) (_Param..., ...);\n};\n\ntemplate <class _Rp, class _Class, class ..._Param>\nstruct __member_pointer_traits_imp<_Rp (_Class::*)(_Param...) const, true, false>\n{\n    typedef _Class const _ClassType;\n    typedef _Rp _ReturnType;\n    typedef _Rp (_FnType) (_Param...);\n};\n\ntemplate <class _Rp, class _Class, class ..._Param>\nstruct __member_pointer_traits_imp<_Rp (_Class::*)(_Param..., ...) const, true, false>\n{\n    typedef _Class const _ClassType;\n    typedef _Rp _ReturnType;\n    typedef _Rp (_FnType) (_Param..., ...);\n};\n\ntemplate <class _Rp, class _Class, class ..._Param>\nstruct __member_pointer_traits_imp<_Rp (_Class::*)(_Param...) volatile, true, false>\n{\n    typedef _Class volatile _ClassType;\n    typedef _Rp _ReturnType;\n    typedef _Rp (_FnType) (_Param...);\n};\n\ntemplate <class _Rp, class _Class, class ..._Param>\nstruct __member_pointer_traits_imp<_Rp (_Class::*)(_Param..., ...) volatile, true, false>\n{\n    typedef _Class volatile _ClassType;\n    typedef _Rp _ReturnType;\n    typedef _Rp (_FnType) (_Param..., ...);\n};\n\ntemplate <class _Rp, class _Class, class ..._Param>\nstruct __member_pointer_traits_imp<_Rp (_Class::*)(_Param...) const volatile, true, false>\n{\n    typedef _Class const volatile _ClassType;\n    typedef _Rp _ReturnType;\n    typedef _Rp (_FnType) (_Param...);\n};\n\ntemplate <class _Rp, class _Class, class ..._Param>\nstruct __member_pointer_traits_imp<_Rp (_Class::*)(_Param..., ...) const volatile, true, false>\n{\n    typedef _Class const volatile _ClassType;\n    typedef _Rp _ReturnType;\n    typedef _Rp (_FnType) (_Param..., ...);\n};\n\n#if __has_feature(cxx_reference_qualified_functions) || \\\n    (defined(_GNUC_VER) && _GNUC_VER >= 409)\n\ntemplate <class _Rp, class _Class, class ..._Param>\nstruct __member_pointer_traits_imp<_Rp (_Class::*)(_Param...) &, true, false>\n{\n    typedef _Class& _ClassType;\n    typedef _Rp _ReturnType;\n    typedef _Rp (_FnType) (_Param...);\n};\n\ntemplate <class _Rp, class _Class, class ..._Param>\nstruct __member_pointer_traits_imp<_Rp (_Class::*)(_Param..., ...) &, true, false>\n{\n    typedef _Class& _ClassType;\n    typedef _Rp _ReturnType;\n    typedef _Rp (_FnType) (_Param..., ...);\n};\n\ntemplate <class _Rp, class _Class, class ..._Param>\nstruct __member_pointer_traits_imp<_Rp (_Class::*)(_Param...) const&, true, false>\n{\n    typedef _Class const& _ClassType;\n    typedef _Rp _ReturnType;\n    typedef _Rp (_FnType) (_Param...);\n};\n\ntemplate <class _Rp, class _Class, class ..._Param>\nstruct __member_pointer_traits_imp<_Rp (_Class::*)(_Param..., ...) const&, true, false>\n{\n    typedef _Class const& _ClassType;\n    typedef _Rp _ReturnType;\n    typedef _Rp (_FnType) (_Param..., ...);\n};\n\ntemplate <class _Rp, class _Class, class ..._Param>\nstruct __member_pointer_traits_imp<_Rp (_Class::*)(_Param...) volatile&, true, false>\n{\n    typedef _Class volatile& _ClassType;\n    typedef _Rp _ReturnType;\n    typedef _Rp (_FnType) (_Param...);\n};\n\ntemplate <class _Rp, class _Class, class ..._Param>\nstruct __member_pointer_traits_imp<_Rp (_Class::*)(_Param..., ...) volatile&, true, false>\n{\n    typedef _Class volatile& _ClassType;\n    typedef _Rp _ReturnType;\n    typedef _Rp (_FnType) (_Param..., ...);\n};\n\ntemplate <class _Rp, class _Class, class ..._Param>\nstruct __member_pointer_traits_imp<_Rp (_Class::*)(_Param...) const volatile&, true, false>\n{\n    typedef _Class const volatile& _ClassType;\n    typedef _Rp _ReturnType;\n    typedef _Rp (_FnType) (_Param...);\n};\n\ntemplate <class _Rp, class _Class, class ..._Param>\nstruct __member_pointer_traits_imp<_Rp (_Class::*)(_Param..., ...) const volatile&, true, false>\n{\n    typedef _Class const volatile& _ClassType;\n    typedef _Rp _ReturnType;\n    typedef _Rp (_FnType) (_Param..., ...);\n};\n\ntemplate <class _Rp, class _Class, class ..._Param>\nstruct __member_pointer_traits_imp<_Rp (_Class::*)(_Param...) &&, true, false>\n{\n    typedef _Class&& _ClassType;\n    typedef _Rp _ReturnType;\n    typedef _Rp (_FnType) (_Param...);\n};\n\ntemplate <class _Rp, class _Class, class ..._Param>\nstruct __member_pointer_traits_imp<_Rp (_Class::*)(_Param..., ...) &&, true, false>\n{\n    typedef _Class&& _ClassType;\n    typedef _Rp _ReturnType;\n    typedef _Rp (_FnType) (_Param..., ...);\n};\n\ntemplate <class _Rp, class _Class, class ..._Param>\nstruct __member_pointer_traits_imp<_Rp (_Class::*)(_Param...) const&&, true, false>\n{\n    typedef _Class const&& _ClassType;\n    typedef _Rp _ReturnType;\n    typedef _Rp (_FnType) (_Param...);\n};\n\ntemplate <class _Rp, class _Class, class ..._Param>\nstruct __member_pointer_traits_imp<_Rp (_Class::*)(_Param..., ...) const&&, true, false>\n{\n    typedef _Class const&& _ClassType;\n    typedef _Rp _ReturnType;\n    typedef _Rp (_FnType) (_Param..., ...);\n};\n\ntemplate <class _Rp, class _Class, class ..._Param>\nstruct __member_pointer_traits_imp<_Rp (_Class::*)(_Param...) volatile&&, true, false>\n{\n    typedef _Class volatile&& _ClassType;\n    typedef _Rp _ReturnType;\n    typedef _Rp (_FnType) (_Param...);\n};\n\ntemplate <class _Rp, class _Class, class ..._Param>\nstruct __member_pointer_traits_imp<_Rp (_Class::*)(_Param..., ...) volatile&&, true, false>\n{\n    typedef _Class volatile&& _ClassType;\n    typedef _Rp _ReturnType;\n    typedef _Rp (_FnType) (_Param..., ...);\n};\n\ntemplate <class _Rp, class _Class, class ..._Param>\nstruct __member_pointer_traits_imp<_Rp (_Class::*)(_Param...) const volatile&&, true, false>\n{\n    typedef _Class const volatile&& _ClassType;\n    typedef _Rp _ReturnType;\n    typedef _Rp (_FnType) (_Param...);\n};\n\ntemplate <class _Rp, class _Class, class ..._Param>\nstruct __member_pointer_traits_imp<_Rp (_Class::*)(_Param..., ...) const volatile&&, true, false>\n{\n    typedef _Class const volatile&& _ClassType;\n    typedef _Rp _ReturnType;\n    typedef _Rp (_FnType) (_Param..., ...);\n};\n\n#endif  // __has_feature(cxx_reference_qualified_functions) || _GNUC_VER >= 409\n\n#else  // _LIBCPP_HAS_NO_VARIADICS\n\ntemplate <class _Rp, class _Class>\nstruct __member_pointer_traits_imp<_Rp (_Class::*)(), true, false>\n{\n    typedef _Class _ClassType;\n    typedef _Rp _ReturnType;\n    typedef _Rp (_FnType) ();\n};\n\ntemplate <class _Rp, class _Class>\nstruct __member_pointer_traits_imp<_Rp (_Class::*)(...), true, false>\n{\n    typedef _Class _ClassType;\n    typedef _Rp _ReturnType;\n    typedef _Rp (_FnType) (...);\n};\n\ntemplate <class _Rp, class _Class, class _P0>\nstruct __member_pointer_traits_imp<_Rp (_Class::*)(_P0), true, false>\n{\n    typedef _Class _ClassType;\n    typedef _Rp _ReturnType;\n    typedef _Rp (_FnType) (_P0);\n};\n\ntemplate <class _Rp, class _Class, class _P0>\nstruct __member_pointer_traits_imp<_Rp (_Class::*)(_P0, ...), true, false>\n{\n    typedef _Class _ClassType;\n    typedef _Rp _ReturnType;\n    typedef _Rp (_FnType) (_P0, ...);\n};\n\ntemplate <class _Rp, class _Class, class _P0, class _P1>\nstruct __member_pointer_traits_imp<_Rp (_Class::*)(_P0, _P1), true, false>\n{\n    typedef _Class _ClassType;\n    typedef _Rp _ReturnType;\n    typedef _Rp (_FnType) (_P0, _P1);\n};\n\ntemplate <class _Rp, class _Class, class _P0, class _P1>\nstruct __member_pointer_traits_imp<_Rp (_Class::*)(_P0, _P1, ...), true, false>\n{\n    typedef _Class _ClassType;\n    typedef _Rp _ReturnType;\n    typedef _Rp (_FnType) (_P0, _P1, ...);\n};\n\ntemplate <class _Rp, class _Class, class _P0, class _P1, class _P2>\nstruct __member_pointer_traits_imp<_Rp (_Class::*)(_P0, _P1, _P2), true, false>\n{\n    typedef _Class _ClassType;\n    typedef _Rp _ReturnType;\n    typedef _Rp (_FnType) (_P0, _P1, _P2);\n};\n\ntemplate <class _Rp, class _Class, class _P0, class _P1, class _P2>\nstruct __member_pointer_traits_imp<_Rp (_Class::*)(_P0, _P1, _P2, ...), true, false>\n{\n    typedef _Class _ClassType;\n    typedef _Rp _ReturnType;\n    typedef _Rp (_FnType) (_P0, _P1, _P2, ...);\n};\n\ntemplate <class _Rp, class _Class>\nstruct __member_pointer_traits_imp<_Rp (_Class::*)() const, true, false>\n{\n    typedef _Class const _ClassType;\n    typedef _Rp _ReturnType;\n    typedef _Rp (_FnType) ();\n};\n\ntemplate <class _Rp, class _Class>\nstruct __member_pointer_traits_imp<_Rp (_Class::*)(...) const, true, false>\n{\n    typedef _Class const _ClassType;\n    typedef _Rp _ReturnType;\n    typedef _Rp (_FnType) (...);\n};\n\ntemplate <class _Rp, class _Class, class _P0>\nstruct __member_pointer_traits_imp<_Rp (_Class::*)(_P0) const, true, false>\n{\n    typedef _Class const _ClassType;\n    typedef _Rp _ReturnType;\n    typedef _Rp (_FnType) (_P0);\n};\n\ntemplate <class _Rp, class _Class, class _P0>\nstruct __member_pointer_traits_imp<_Rp (_Class::*)(_P0, ...) const, true, false>\n{\n    typedef _Class const _ClassType;\n    typedef _Rp _ReturnType;\n    typedef _Rp (_FnType) (_P0, ...);\n};\n\ntemplate <class _Rp, class _Class, class _P0, class _P1>\nstruct __member_pointer_traits_imp<_Rp (_Class::*)(_P0, _P1) const, true, false>\n{\n    typedef _Class const _ClassType;\n    typedef _Rp _ReturnType;\n    typedef _Rp (_FnType) (_P0, _P1);\n};\n\ntemplate <class _Rp, class _Class, class _P0, class _P1>\nstruct __member_pointer_traits_imp<_Rp (_Class::*)(_P0, _P1, ...) const, true, false>\n{\n    typedef _Class const _ClassType;\n    typedef _Rp _ReturnType;\n    typedef _Rp (_FnType) (_P0, _P1, ...);\n};\n\ntemplate <class _Rp, class _Class, class _P0, class _P1, class _P2>\nstruct __member_pointer_traits_imp<_Rp (_Class::*)(_P0, _P1, _P2) const, true, false>\n{\n    typedef _Class const _ClassType;\n    typedef _Rp _ReturnType;\n    typedef _Rp (_FnType) (_P0, _P1, _P2);\n};\n\ntemplate <class _Rp, class _Class, class _P0, class _P1, class _P2>\nstruct __member_pointer_traits_imp<_Rp (_Class::*)(_P0, _P1, _P2, ...) const, true, false>\n{\n    typedef _Class const _ClassType;\n    typedef _Rp _ReturnType;\n    typedef _Rp (_FnType) (_P0, _P1, _P2, ...);\n};\n\ntemplate <class _Rp, class _Class>\nstruct __member_pointer_traits_imp<_Rp (_Class::*)() volatile, true, false>\n{\n    typedef _Class volatile _ClassType;\n    typedef _Rp _ReturnType;\n    typedef _Rp (_FnType) ();\n};\n\ntemplate <class _Rp, class _Class>\nstruct __member_pointer_traits_imp<_Rp (_Class::*)(...) volatile, true, false>\n{\n    typedef _Class volatile _ClassType;\n    typedef _Rp _ReturnType;\n    typedef _Rp (_FnType) (...);\n};\n\ntemplate <class _Rp, class _Class, class _P0>\nstruct __member_pointer_traits_imp<_Rp (_Class::*)(_P0) volatile, true, false>\n{\n    typedef _Class volatile _ClassType;\n    typedef _Rp _ReturnType;\n    typedef _Rp (_FnType) (_P0);\n};\n\ntemplate <class _Rp, class _Class, class _P0>\nstruct __member_pointer_traits_imp<_Rp (_Class::*)(_P0, ...) volatile, true, false>\n{\n    typedef _Class volatile _ClassType;\n    typedef _Rp _ReturnType;\n    typedef _Rp (_FnType) (_P0, ...);\n};\n\ntemplate <class _Rp, class _Class, class _P0, class _P1>\nstruct __member_pointer_traits_imp<_Rp (_Class::*)(_P0, _P1) volatile, true, false>\n{\n    typedef _Class volatile _ClassType;\n    typedef _Rp _ReturnType;\n    typedef _Rp (_FnType) (_P0, _P1);\n};\n\ntemplate <class _Rp, class _Class, class _P0, class _P1>\nstruct __member_pointer_traits_imp<_Rp (_Class::*)(_P0, _P1, ...) volatile, true, false>\n{\n    typedef _Class volatile _ClassType;\n    typedef _Rp _ReturnType;\n    typedef _Rp (_FnType) (_P0, _P1, ...);\n};\n\ntemplate <class _Rp, class _Class, class _P0, class _P1, class _P2>\nstruct __member_pointer_traits_imp<_Rp (_Class::*)(_P0, _P1, _P2) volatile, true, false>\n{\n    typedef _Class volatile _ClassType;\n    typedef _Rp _ReturnType;\n    typedef _Rp (_FnType) (_P0, _P1, _P2);\n};\n\ntemplate <class _Rp, class _Class, class _P0, class _P1, class _P2>\nstruct __member_pointer_traits_imp<_Rp (_Class::*)(_P0, _P1, _P2, ...) volatile, true, false>\n{\n    typedef _Class volatile _ClassType;\n    typedef _Rp _ReturnType;\n    typedef _Rp (_FnType) (_P0, _P1, _P2, ...);\n};\n\ntemplate <class _Rp, class _Class>\nstruct __member_pointer_traits_imp<_Rp (_Class::*)() const volatile, true, false>\n{\n    typedef _Class const volatile _ClassType;\n    typedef _Rp _ReturnType;\n    typedef _Rp (_FnType) ();\n};\n\ntemplate <class _Rp, class _Class>\nstruct __member_pointer_traits_imp<_Rp (_Class::*)(...) const volatile, true, false>\n{\n    typedef _Class const volatile _ClassType;\n    typedef _Rp _ReturnType;\n    typedef _Rp (_FnType) (...);\n};\n\ntemplate <class _Rp, class _Class, class _P0>\nstruct __member_pointer_traits_imp<_Rp (_Class::*)(_P0) const volatile, true, false>\n{\n    typedef _Class const volatile _ClassType;\n    typedef _Rp _ReturnType;\n    typedef _Rp (_FnType) (_P0);\n};\n\ntemplate <class _Rp, class _Class, class _P0>\nstruct __member_pointer_traits_imp<_Rp (_Class::*)(_P0, ...) const volatile, true, false>\n{\n    typedef _Class const volatile _ClassType;\n    typedef _Rp _ReturnType;\n    typedef _Rp (_FnType) (_P0, ...);\n};\n\ntemplate <class _Rp, class _Class, class _P0, class _P1>\nstruct __member_pointer_traits_imp<_Rp (_Class::*)(_P0, _P1) const volatile, true, false>\n{\n    typedef _Class const volatile _ClassType;\n    typedef _Rp _ReturnType;\n    typedef _Rp (_FnType) (_P0, _P1);\n};\n\ntemplate <class _Rp, class _Class, class _P0, class _P1>\nstruct __member_pointer_traits_imp<_Rp (_Class::*)(_P0, _P1, ...) const volatile, true, false>\n{\n    typedef _Class const volatile _ClassType;\n    typedef _Rp _ReturnType;\n    typedef _Rp (_FnType) (_P0, _P1, ...);\n};\n\ntemplate <class _Rp, class _Class, class _P0, class _P1, class _P2>\nstruct __member_pointer_traits_imp<_Rp (_Class::*)(_P0, _P1, _P2) const volatile, true, false>\n{\n    typedef _Class const volatile _ClassType;\n    typedef _Rp _ReturnType;\n    typedef _Rp (_FnType) (_P0, _P1, _P2);\n};\n\ntemplate <class _Rp, class _Class, class _P0, class _P1, class _P2>\nstruct __member_pointer_traits_imp<_Rp (_Class::*)(_P0, _P1, _P2, ...) const volatile, true, false>\n{\n    typedef _Class const volatile _ClassType;\n    typedef _Rp _ReturnType;\n    typedef _Rp (_FnType) (_P0, _P1, _P2, ...);\n};\n\n#endif  // _LIBCPP_HAS_NO_VARIADICS\n\ntemplate <class _Rp, class _Class>\nstruct __member_pointer_traits_imp<_Rp _Class::*, false, true>\n{\n    typedef _Class _ClassType;\n    typedef _Rp _ReturnType;\n};\n\ntemplate <class _MP>\nstruct __member_pointer_traits\n    : public __member_pointer_traits_imp<typename remove_cv<_MP>::type,\n                    is_member_function_pointer<_MP>::value,\n                    is_member_object_pointer<_MP>::value>\n{\n//     typedef ... _ClassType;\n//     typedef ... _ReturnType;\n//     typedef ... _FnType;\n};\n\n\ntemplate <class _DecayedFp>\nstruct __member_pointer_class_type {};\n\ntemplate <class _Ret, class _ClassType>\nstruct __member_pointer_class_type<_Ret _ClassType::*> {\n  typedef _ClassType type;\n};\n\n// result_of\n\ntemplate <class _Callable> class result_of;\n\n#ifdef _LIBCPP_HAS_NO_VARIADICS\n\ntemplate <class _Fn, bool, bool>\nclass __result_of\n{\n};\n\ntemplate <class _Fn>\nclass __result_of<_Fn(), true, false>\n{\npublic:\n    typedef decltype(declval<_Fn>()()) type;\n};\n\ntemplate <class _Fn, class _A0>\nclass __result_of<_Fn(_A0), true, false>\n{\npublic:\n    typedef decltype(declval<_Fn>()(declval<_A0>())) type;\n};\n\ntemplate <class _Fn, class _A0, class _A1>\nclass __result_of<_Fn(_A0, _A1), true, false>\n{\npublic:\n    typedef decltype(declval<_Fn>()(declval<_A0>(), declval<_A1>())) type;\n};\n\ntemplate <class _Fn, class _A0, class _A1, class _A2>\nclass __result_of<_Fn(_A0, _A1, _A2), true, false>\n{\npublic:\n    typedef decltype(declval<_Fn>()(declval<_A0>(), declval<_A1>(), declval<_A2>())) type;\n};\n\ntemplate <class _MP, class _Tp, bool _IsMemberFunctionPtr>\nstruct __result_of_mp;\n\n// member function pointer\n\ntemplate <class _MP, class _Tp>\nstruct __result_of_mp<_MP, _Tp, true>\n    : public __identity<typename __member_pointer_traits<_MP>::_ReturnType>\n{\n};\n\n// member data pointer\n\ntemplate <class _MP, class _Tp, bool>\nstruct __result_of_mdp;\n\ntemplate <class _Rp, class _Class, class _Tp>\nstruct __result_of_mdp<_Rp _Class::*, _Tp, false>\n{\n    typedef typename __apply_cv<decltype(*_VSTD::declval<_Tp>()), _Rp>::type& type;\n};\n\ntemplate <class _Rp, class _Class, class _Tp>\nstruct __result_of_mdp<_Rp _Class::*, _Tp, true>\n{\n    typedef typename __apply_cv<_Tp, _Rp>::type& type;\n};\n\ntemplate <class _Rp, class _Class, class _Tp>\nstruct __result_of_mp<_Rp _Class::*, _Tp, false>\n    : public __result_of_mdp<_Rp _Class::*, _Tp,\n            is_base_of<_Class, typename remove_reference<_Tp>::type>::value>\n{\n};\n\n\n\ntemplate <class _Fn, class _Tp>\nclass __result_of<_Fn(_Tp), false, true>  // _Fn must be member pointer\n    : public __result_of_mp<typename remove_reference<_Fn>::type,\n                            _Tp,\n                            is_member_function_pointer<typename remove_reference<_Fn>::type>::value>\n{\n};\n\ntemplate <class _Fn, class _Tp, class _A0>\nclass __result_of<_Fn(_Tp, _A0), false, true>  // _Fn must be member pointer\n    : public __result_of_mp<typename remove_reference<_Fn>::type,\n                            _Tp,\n                            is_member_function_pointer<typename remove_reference<_Fn>::type>::value>\n{\n};\n\ntemplate <class _Fn, class _Tp, class _A0, class _A1>\nclass __result_of<_Fn(_Tp, _A0, _A1), false, true>  // _Fn must be member pointer\n    : public __result_of_mp<typename remove_reference<_Fn>::type,\n                            _Tp,\n                            is_member_function_pointer<typename remove_reference<_Fn>::type>::value>\n{\n};\n\ntemplate <class _Fn, class _Tp, class _A0, class _A1, class _A2>\nclass __result_of<_Fn(_Tp, _A0, _A1, _A2), false, true>  // _Fn must be member pointer\n    : public __result_of_mp<typename remove_reference<_Fn>::type,\n                            _Tp,\n                            is_member_function_pointer<typename remove_reference<_Fn>::type>::value>\n{\n};\n\n// result_of\n\ntemplate <class _Fn>\nclass _LIBCPP_TEMPLATE_VIS result_of<_Fn()>\n    : public __result_of<_Fn(),\n                         is_class<typename remove_reference<_Fn>::type>::value ||\n                         is_function<typename remove_pointer<typename remove_reference<_Fn>::type>::type>::value,\n                         is_member_pointer<typename remove_reference<_Fn>::type>::value\n                        >\n{\n};\n\ntemplate <class _Fn, class _A0>\nclass _LIBCPP_TEMPLATE_VIS result_of<_Fn(_A0)>\n    : public __result_of<_Fn(_A0),\n                         is_class<typename remove_reference<_Fn>::type>::value ||\n                         is_function<typename remove_pointer<typename remove_reference<_Fn>::type>::type>::value,\n                         is_member_pointer<typename remove_reference<_Fn>::type>::value\n                        >\n{\n};\n\ntemplate <class _Fn, class _A0, class _A1>\nclass _LIBCPP_TEMPLATE_VIS result_of<_Fn(_A0, _A1)>\n    : public __result_of<_Fn(_A0, _A1),\n                         is_class<typename remove_reference<_Fn>::type>::value ||\n                         is_function<typename remove_pointer<typename remove_reference<_Fn>::type>::type>::value,\n                         is_member_pointer<typename remove_reference<_Fn>::type>::value\n                        >\n{\n};\n\ntemplate <class _Fn, class _A0, class _A1, class _A2>\nclass _LIBCPP_TEMPLATE_VIS result_of<_Fn(_A0, _A1, _A2)>\n    : public __result_of<_Fn(_A0, _A1, _A2),\n                         is_class<typename remove_reference<_Fn>::type>::value ||\n                         is_function<typename remove_pointer<typename remove_reference<_Fn>::type>::type>::value,\n                         is_member_pointer<typename remove_reference<_Fn>::type>::value\n                        >\n{\n};\n\n#endif  // _LIBCPP_HAS_NO_VARIADICS\n\n// template <class T, class... Args> struct is_constructible;\n\nnamespace __is_construct\n{\nstruct __nat {};\n}\n\n#if !defined(_LIBCPP_CXX03_LANG) && (!__has_feature(is_constructible) || \\\n    defined(_LIBCPP_TESTING_FALLBACK_IS_CONSTRUCTIBLE))\n\ntemplate <class _Tp, class... _Args>\nstruct __libcpp_is_constructible;\n\ntemplate <class _To, class _From>\nstruct __is_invalid_base_to_derived_cast {\n  static_assert(is_reference<_To>::value, \"Wrong specialization\");\n  using _RawFrom = __uncvref_t<_From>;\n  using _RawTo = __uncvref_t<_To>;\n  static const bool value = __lazy_and<\n        __lazy_not<is_same<_RawFrom, _RawTo>>,\n        is_base_of<_RawFrom, _RawTo>,\n        __lazy_not<__libcpp_is_constructible<_RawTo, _From>>\n  >::value;\n};\n\ntemplate <class _To, class _From>\nstruct __is_invalid_lvalue_to_rvalue_cast : false_type {\n  static_assert(is_reference<_To>::value, \"Wrong specialization\");\n};\n\ntemplate <class _ToRef, class _FromRef>\nstruct __is_invalid_lvalue_to_rvalue_cast<_ToRef&&, _FromRef&> {\n  using _RawFrom = __uncvref_t<_FromRef>;\n  using _RawTo = __uncvref_t<_ToRef>;\n  static const bool value = __lazy_and<\n      __lazy_not<is_function<_RawTo>>,\n      __lazy_or<\n        is_same<_RawFrom, _RawTo>,\n        is_base_of<_RawTo, _RawFrom>>\n    >::value;\n};\n\nstruct __is_constructible_helper\n{\n    template <class _To>\n    static void __eat(_To);\n\n    // This overload is needed to work around a Clang bug that disallows\n    // static_cast<T&&>(e) for non-reference-compatible types.\n    // Example: static_cast<int&&>(declval<double>());\n    // NOTE: The static_cast implementation below is required to support\n    //  classes with explicit conversion operators.\n    template <class _To, class _From,\n              class = decltype(__eat<_To>(_VSTD::declval<_From>()))>\n    static true_type __test_cast(int);\n\n    template <class _To, class _From,\n              class = decltype(static_cast<_To>(_VSTD::declval<_From>()))>\n    static integral_constant<bool,\n        !__is_invalid_base_to_derived_cast<_To, _From>::value &&\n        !__is_invalid_lvalue_to_rvalue_cast<_To, _From>::value\n    > __test_cast(long);\n\n    template <class, class>\n    static false_type __test_cast(...);\n\n    template <class _Tp, class ..._Args,\n        class = decltype(_Tp(_VSTD::declval<_Args>()...))>\n    static true_type __test_nary(int);\n    template <class _Tp, class...>\n    static false_type __test_nary(...);\n\n    template <class _Tp, class _A0, class = decltype(::new _Tp(_VSTD::declval<_A0>()))>\n    static is_destructible<_Tp> __test_unary(int);\n    template <class, class>\n    static false_type __test_unary(...);\n};\n\ntemplate <class _Tp, bool = is_void<_Tp>::value>\nstruct __is_default_constructible\n    : decltype(__is_constructible_helper::__test_nary<_Tp>(0))\n{};\n\ntemplate <class _Tp>\nstruct __is_default_constructible<_Tp, true> : false_type {};\n\ntemplate <class _Tp>\nstruct __is_default_constructible<_Tp[], false> : false_type {};\n\ntemplate <class _Tp, size_t _Nx>\nstruct __is_default_constructible<_Tp[_Nx], false>\n    : __is_default_constructible<typename remove_all_extents<_Tp>::type>  {};\n\ntemplate <class _Tp, class... _Args>\nstruct __libcpp_is_constructible\n{\n  static_assert(sizeof...(_Args) > 1, \"Wrong specialization\");\n  typedef decltype(__is_constructible_helper::__test_nary<_Tp, _Args...>(0))\n      type;\n};\n\ntemplate <class _Tp>\nstruct __libcpp_is_constructible<_Tp> : __is_default_constructible<_Tp> {};\n\ntemplate <class _Tp, class _A0>\nstruct __libcpp_is_constructible<_Tp, _A0>\n    : public decltype(__is_constructible_helper::__test_unary<_Tp, _A0>(0))\n{};\n\ntemplate <class _Tp, class _A0>\nstruct __libcpp_is_constructible<_Tp&, _A0>\n    : public decltype(__is_constructible_helper::\n    __test_cast<_Tp&, _A0>(0))\n{};\n\ntemplate <class _Tp, class _A0>\nstruct __libcpp_is_constructible<_Tp&&, _A0>\n    : public decltype(__is_constructible_helper::\n    __test_cast<_Tp&&, _A0>(0))\n{};\n\n#endif\n\n#if __has_feature(is_constructible)\ntemplate <class _Tp, class ..._Args>\nstruct _LIBCPP_TEMPLATE_VIS is_constructible\n    : public integral_constant<bool, __is_constructible(_Tp, _Args...)>\n    {};\n#elif !defined(_LIBCPP_CXX03_LANG)\ntemplate <class _Tp, class... _Args>\nstruct _LIBCPP_TEMPLATE_VIS is_constructible\n    : public __libcpp_is_constructible<_Tp, _Args...>::type {};\n#else\n// template <class T> struct is_constructible0;\n\n//      main is_constructible0 test\n\ntemplate <class _Tp>\ndecltype((_Tp(), true_type()))\n__is_constructible0_test(_Tp&);\n\nfalse_type\n__is_constructible0_test(__any);\n\ntemplate <class _Tp, class _A0>\ndecltype((_Tp(_VSTD::declval<_A0>()), true_type()))\n__is_constructible1_test(_Tp&, _A0&);\n\ntemplate <class _A0>\nfalse_type\n__is_constructible1_test(__any, _A0&);\n\ntemplate <class _Tp, class _A0, class _A1>\ndecltype((_Tp(_VSTD::declval<_A0>(), _VSTD::declval<_A1>()), true_type()))\n__is_constructible2_test(_Tp&, _A0&, _A1&);\n\ntemplate <class _A0, class _A1>\nfalse_type\n__is_constructible2_test(__any, _A0&, _A1&);\n\ntemplate <bool, class _Tp>\nstruct __is_constructible0_imp // false, _Tp is not a scalar\n    : public common_type\n             <\n                 decltype(__is_constructible0_test(declval<_Tp&>()))\n             >::type\n    {};\n\ntemplate <bool, class _Tp, class _A0>\nstruct __is_constructible1_imp // false, _Tp is not a scalar\n    : public common_type\n             <\n                 decltype(__is_constructible1_test(declval<_Tp&>(), declval<_A0&>()))\n             >::type\n    {};\n\ntemplate <bool, class _Tp, class _A0, class _A1>\nstruct __is_constructible2_imp // false, _Tp is not a scalar\n    : public common_type\n             <\n                 decltype(__is_constructible2_test(declval<_Tp&>(), declval<_A0>(), declval<_A1>()))\n             >::type\n    {};\n\n//      handle scalars and reference types\n\n//      Scalars are default constructible, references are not\n\ntemplate <class _Tp>\nstruct __is_constructible0_imp<true, _Tp>\n    : public is_scalar<_Tp>\n    {};\n\ntemplate <class _Tp, class _A0>\nstruct __is_constructible1_imp<true, _Tp, _A0>\n    : public is_convertible<_A0, _Tp>\n    {};\n\ntemplate <class _Tp, class _A0, class _A1>\nstruct __is_constructible2_imp<true, _Tp, _A0, _A1>\n    : public false_type\n    {};\n\n//      Treat scalars and reference types separately\n\ntemplate <bool, class _Tp>\nstruct __is_constructible0_void_check\n    : public __is_constructible0_imp<is_scalar<_Tp>::value || is_reference<_Tp>::value,\n                                _Tp>\n    {};\n\ntemplate <bool, class _Tp, class _A0>\nstruct __is_constructible1_void_check\n    : public __is_constructible1_imp<is_scalar<_Tp>::value || is_reference<_Tp>::value,\n                                _Tp, _A0>\n    {};\n\ntemplate <bool, class _Tp, class _A0, class _A1>\nstruct __is_constructible2_void_check\n    : public __is_constructible2_imp<is_scalar<_Tp>::value || is_reference<_Tp>::value,\n                                _Tp, _A0, _A1>\n    {};\n\n//      If any of T or Args is void, is_constructible should be false\n\ntemplate <class _Tp>\nstruct __is_constructible0_void_check<true, _Tp>\n    : public false_type\n    {};\n\ntemplate <class _Tp, class _A0>\nstruct __is_constructible1_void_check<true, _Tp, _A0>\n    : public false_type\n    {};\n\ntemplate <class _Tp, class _A0, class _A1>\nstruct __is_constructible2_void_check<true, _Tp, _A0, _A1>\n    : public false_type\n    {};\n\n//      is_constructible entry point\n\ntemplate <class _Tp, class _A0 = __is_construct::__nat,\n                     class _A1 = __is_construct::__nat>\nstruct _LIBCPP_TEMPLATE_VIS is_constructible\n    : public __is_constructible2_void_check<is_void<_Tp>::value\n                                        || is_abstract<_Tp>::value\n                                        || is_function<_Tp>::value\n                                        || is_void<_A0>::value\n                                        || is_void<_A1>::value,\n                                           _Tp, _A0, _A1>\n    {};\n\ntemplate <class _Tp>\nstruct _LIBCPP_TEMPLATE_VIS is_constructible<_Tp, __is_construct::__nat, __is_construct::__nat>\n    : public __is_constructible0_void_check<is_void<_Tp>::value\n                                        || is_abstract<_Tp>::value\n                                        || is_function<_Tp>::value,\n                                           _Tp>\n    {};\n\ntemplate <class _Tp, class _A0>\nstruct _LIBCPP_TEMPLATE_VIS is_constructible<_Tp, _A0, __is_construct::__nat>\n    : public __is_constructible1_void_check<is_void<_Tp>::value\n                                        || is_abstract<_Tp>::value\n                                        || is_function<_Tp>::value\n                                        || is_void<_A0>::value,\n                                           _Tp, _A0>\n    {};\n\n//      Array types are default constructible if their element type\n//      is default constructible\n\ntemplate <class _Ap, size_t _Np>\nstruct __is_constructible0_imp<false, _Ap[_Np]>\n    : public is_constructible<typename remove_all_extents<_Ap>::type>\n    {};\n\ntemplate <class _Ap, size_t _Np, class _A0>\nstruct __is_constructible1_imp<false, _Ap[_Np], _A0>\n    : public false_type\n    {};\n\ntemplate <class _Ap, size_t _Np, class _A0, class _A1>\nstruct __is_constructible2_imp<false, _Ap[_Np], _A0, _A1>\n    : public false_type\n    {};\n\n//      Incomplete array types are not constructible\n\ntemplate <class _Ap>\nstruct __is_constructible0_imp<false, _Ap[]>\n    : public false_type\n    {};\n\ntemplate <class _Ap, class _A0>\nstruct __is_constructible1_imp<false, _Ap[], _A0>\n    : public false_type\n    {};\n\ntemplate <class _Ap, class _A0, class _A1>\nstruct __is_constructible2_imp<false, _Ap[], _A0, _A1>\n    : public false_type\n    {};\n\n#endif // __has_feature(is_constructible)\n\n\n#if _LIBCPP_STD_VER > 14 && !defined(_LIBCPP_HAS_NO_VARIABLE_TEMPLATES) && !defined(_LIBCPP_HAS_NO_VARIADICS)\ntemplate <class _Tp, class ..._Args> _LIBCPP_CONSTEXPR bool is_constructible_v\n    = is_constructible<_Tp, _Args...>::value;\n#endif\n\n// is_default_constructible\n\ntemplate <class _Tp>\nstruct _LIBCPP_TEMPLATE_VIS is_default_constructible\n    : public is_constructible<_Tp>\n    {};\n\n#if _LIBCPP_STD_VER > 14 && !defined(_LIBCPP_HAS_NO_VARIABLE_TEMPLATES)\ntemplate <class _Tp> _LIBCPP_CONSTEXPR bool is_default_constructible_v\n    = is_default_constructible<_Tp>::value;\n#endif\n\n// is_copy_constructible\n\ntemplate <class _Tp>\nstruct _LIBCPP_TEMPLATE_VIS is_copy_constructible\n    : public is_constructible<_Tp, \n                  typename add_lvalue_reference<typename add_const<_Tp>::type>::type> {};\n\n#if _LIBCPP_STD_VER > 14 && !defined(_LIBCPP_HAS_NO_VARIABLE_TEMPLATES)\ntemplate <class _Tp> _LIBCPP_CONSTEXPR bool is_copy_constructible_v\n    = is_copy_constructible<_Tp>::value;\n#endif\n\n// is_move_constructible\n\ntemplate <class _Tp>\nstruct _LIBCPP_TEMPLATE_VIS is_move_constructible\n#ifndef _LIBCPP_HAS_NO_RVALUE_REFERENCES\n    : public is_constructible<_Tp, typename add_rvalue_reference<_Tp>::type>\n#else\n    : public is_copy_constructible<_Tp>\n#endif\n    {};\n\n#if _LIBCPP_STD_VER > 14 && !defined(_LIBCPP_HAS_NO_VARIABLE_TEMPLATES)\ntemplate <class _Tp> _LIBCPP_CONSTEXPR bool is_move_constructible_v\n    = is_move_constructible<_Tp>::value;\n#endif\n\n// is_trivially_constructible\n\n#ifndef _LIBCPP_HAS_NO_VARIADICS\n\n#if __has_feature(is_trivially_constructible) || _GNUC_VER >= 501\n\ntemplate <class _Tp, class... _Args>\nstruct _LIBCPP_TEMPLATE_VIS is_trivially_constructible\n    : integral_constant<bool, __is_trivially_constructible(_Tp, _Args...)>\n{\n};\n\n#else  // !__has_feature(is_trivially_constructible)\n\ntemplate <class _Tp, class... _Args>\nstruct _LIBCPP_TEMPLATE_VIS is_trivially_constructible\n    : false_type\n{\n};\n\ntemplate <class _Tp>\nstruct _LIBCPP_TEMPLATE_VIS is_trivially_constructible<_Tp>\n#if __has_feature(has_trivial_constructor) || (_GNUC_VER >= 403)\n    : integral_constant<bool, __has_trivial_constructor(_Tp)>\n#else\n    : integral_constant<bool, is_scalar<_Tp>::value>\n#endif\n{\n};\n\ntemplate <class _Tp>\n#ifndef _LIBCPP_HAS_NO_RVALUE_REFERENCES\nstruct _LIBCPP_TEMPLATE_VIS is_trivially_constructible<_Tp, _Tp&&>\n#else\nstruct _LIBCPP_TEMPLATE_VIS is_trivially_constructible<_Tp, _Tp>\n#endif\n    : integral_constant<bool, is_scalar<_Tp>::value>\n{\n};\n\ntemplate <class _Tp>\nstruct _LIBCPP_TEMPLATE_VIS is_trivially_constructible<_Tp, const _Tp&>\n    : integral_constant<bool, is_scalar<_Tp>::value>\n{\n};\n\ntemplate <class _Tp>\nstruct _LIBCPP_TEMPLATE_VIS is_trivially_constructible<_Tp, _Tp&>\n    : integral_constant<bool, is_scalar<_Tp>::value>\n{\n};\n\n#endif  // !__has_feature(is_trivially_constructible)\n\n#else  // _LIBCPP_HAS_NO_VARIADICS\n\ntemplate <class _Tp, class _A0 = __is_construct::__nat,\n                     class _A1 = __is_construct::__nat>\nstruct _LIBCPP_TEMPLATE_VIS is_trivially_constructible\n    : false_type\n{\n};\n\n#if __has_feature(is_trivially_constructible) || _GNUC_VER >= 501\n\ntemplate <class _Tp>\nstruct _LIBCPP_TEMPLATE_VIS is_trivially_constructible<_Tp, __is_construct::__nat,\n                                                       __is_construct::__nat>\n    : integral_constant<bool, __is_trivially_constructible(_Tp)>\n{\n};\n\ntemplate <class _Tp>\nstruct _LIBCPP_TEMPLATE_VIS is_trivially_constructible<_Tp, _Tp,\n                                                       __is_construct::__nat>\n    : integral_constant<bool, __is_trivially_constructible(_Tp, _Tp)>\n{\n};\n\ntemplate <class _Tp>\nstruct _LIBCPP_TEMPLATE_VIS is_trivially_constructible<_Tp, const _Tp&,\n                                                       __is_construct::__nat>\n    : integral_constant<bool, __is_trivially_constructible(_Tp, const _Tp&)>\n{\n};\n\ntemplate <class _Tp>\nstruct _LIBCPP_TEMPLATE_VIS is_trivially_constructible<_Tp, _Tp&,\n                                                       __is_construct::__nat>\n    : integral_constant<bool, __is_trivially_constructible(_Tp, _Tp&)>\n{\n};\n\n#else  // !__has_feature(is_trivially_constructible)\n\ntemplate <class _Tp>\nstruct _LIBCPP_TEMPLATE_VIS is_trivially_constructible<_Tp, __is_construct::__nat,\n                                                       __is_construct::__nat>\n    : integral_constant<bool, is_scalar<_Tp>::value>\n{\n};\n\ntemplate <class _Tp>\nstruct _LIBCPP_TEMPLATE_VIS is_trivially_constructible<_Tp, _Tp,\n                                                       __is_construct::__nat>\n    : integral_constant<bool, is_scalar<_Tp>::value>\n{\n};\n\ntemplate <class _Tp>\nstruct _LIBCPP_TEMPLATE_VIS is_trivially_constructible<_Tp, const _Tp&,\n                                                       __is_construct::__nat>\n    : integral_constant<bool, is_scalar<_Tp>::value>\n{\n};\n\ntemplate <class _Tp>\nstruct _LIBCPP_TEMPLATE_VIS is_trivially_constructible<_Tp, _Tp&,\n                                                       __is_construct::__nat>\n    : integral_constant<bool, is_scalar<_Tp>::value>\n{\n};\n\n#endif  // !__has_feature(is_trivially_constructible)\n\n#endif  // _LIBCPP_HAS_NO_VARIADICS\n\n#if _LIBCPP_STD_VER > 14 && !defined(_LIBCPP_HAS_NO_VARIABLE_TEMPLATES) && !defined(_LIBCPP_HAS_NO_VARIADICS)\ntemplate <class _Tp, class... _Args> _LIBCPP_CONSTEXPR bool is_trivially_constructible_v\n    = is_trivially_constructible<_Tp, _Args...>::value;\n#endif\n\n// is_trivially_default_constructible\n\ntemplate <class _Tp> struct _LIBCPP_TEMPLATE_VIS is_trivially_default_constructible\n    : public is_trivially_constructible<_Tp>\n    {};\n\n#if _LIBCPP_STD_VER > 14 && !defined(_LIBCPP_HAS_NO_VARIABLE_TEMPLATES)\ntemplate <class _Tp> _LIBCPP_CONSTEXPR bool is_trivially_default_constructible_v\n    = is_trivially_default_constructible<_Tp>::value;\n#endif\n\n// is_trivially_copy_constructible\n\ntemplate <class _Tp> struct _LIBCPP_TEMPLATE_VIS is_trivially_copy_constructible\n    : public is_trivially_constructible<_Tp, typename add_lvalue_reference<const _Tp>::type>\n    {};\n\n#if _LIBCPP_STD_VER > 14 && !defined(_LIBCPP_HAS_NO_VARIABLE_TEMPLATES)\ntemplate <class _Tp> _LIBCPP_CONSTEXPR bool is_trivially_copy_constructible_v\n    = is_trivially_copy_constructible<_Tp>::value;\n#endif\n\n// is_trivially_move_constructible\n\ntemplate <class _Tp> struct _LIBCPP_TEMPLATE_VIS is_trivially_move_constructible\n#ifndef _LIBCPP_HAS_NO_RVALUE_REFERENCES\n    : public is_trivially_constructible<_Tp, typename add_rvalue_reference<_Tp>::type>\n#else\n    : public is_trivially_copy_constructible<_Tp>\n#endif\n    {};\n\n#if _LIBCPP_STD_VER > 14 && !defined(_LIBCPP_HAS_NO_VARIABLE_TEMPLATES)\ntemplate <class _Tp> _LIBCPP_CONSTEXPR bool is_trivially_move_constructible_v\n    = is_trivially_move_constructible<_Tp>::value;\n#endif\n\n// is_trivially_assignable\n\n#if __has_feature(is_trivially_assignable) || _GNUC_VER >= 501\n\ntemplate <class _Tp, class _Arg>\nstruct is_trivially_assignable\n    : integral_constant<bool, __is_trivially_assignable(_Tp, _Arg)>\n{\n};\n\n#else  // !__has_feature(is_trivially_assignable)\n\ntemplate <class _Tp, class _Arg>\nstruct is_trivially_assignable\n    : public false_type {};\n\ntemplate <class _Tp>\nstruct is_trivially_assignable<_Tp&, _Tp>\n    : integral_constant<bool, is_scalar<_Tp>::value> {};\n\ntemplate <class _Tp>\nstruct is_trivially_assignable<_Tp&, _Tp&>\n    : integral_constant<bool, is_scalar<_Tp>::value> {};\n\ntemplate <class _Tp>\nstruct is_trivially_assignable<_Tp&, const _Tp&>\n    : integral_constant<bool, is_scalar<_Tp>::value> {};\n\n#ifndef _LIBCPP_HAS_NO_RVALUE_REFERENCES\n\ntemplate <class _Tp>\nstruct is_trivially_assignable<_Tp&, _Tp&&>\n    : integral_constant<bool, is_scalar<_Tp>::value> {};\n\n#endif  // _LIBCPP_HAS_NO_RVALUE_REFERENCES\n\n#endif  // !__has_feature(is_trivially_assignable)\n\n#if _LIBCPP_STD_VER > 14 && !defined(_LIBCPP_HAS_NO_VARIABLE_TEMPLATES)\ntemplate <class _Tp, class _Arg> _LIBCPP_CONSTEXPR bool is_trivially_assignable_v\n    = is_trivially_assignable<_Tp, _Arg>::value;\n#endif\n\n// is_trivially_copy_assignable\n\ntemplate <class _Tp> struct _LIBCPP_TEMPLATE_VIS is_trivially_copy_assignable\n    : public is_trivially_assignable<typename add_lvalue_reference<_Tp>::type,\n                  typename add_lvalue_reference<typename add_const<_Tp>::type>::type> {};\n\n#if _LIBCPP_STD_VER > 14 && !defined(_LIBCPP_HAS_NO_VARIABLE_TEMPLATES)\ntemplate <class _Tp> _LIBCPP_CONSTEXPR bool is_trivially_copy_assignable_v\n    = is_trivially_copy_assignable<_Tp>::value;\n#endif\n\n// is_trivially_move_assignable\n\ntemplate <class _Tp> struct _LIBCPP_TEMPLATE_VIS is_trivially_move_assignable\n    : public is_trivially_assignable<typename add_lvalue_reference<_Tp>::type,\n#ifndef _LIBCPP_HAS_NO_RVALUE_REFERENCES\n                                     typename add_rvalue_reference<_Tp>::type>\n#else\n                                     typename add_lvalue_reference<_Tp>::type>\n#endif\n    {};\n\n#if _LIBCPP_STD_VER > 14 && !defined(_LIBCPP_HAS_NO_VARIABLE_TEMPLATES)\ntemplate <class _Tp> _LIBCPP_CONSTEXPR bool is_trivially_move_assignable_v\n    = is_trivially_move_assignable<_Tp>::value;\n#endif\n\n// is_trivially_destructible\n\n#if __has_feature(has_trivial_destructor) || (_GNUC_VER >= 403)\n\ntemplate <class _Tp> struct _LIBCPP_TEMPLATE_VIS is_trivially_destructible\n    : public integral_constant<bool, is_destructible<_Tp>::value && __has_trivial_destructor(_Tp)> {};\n\n#else\n\ntemplate <class _Tp> struct __libcpp_trivial_destructor\n    : public integral_constant<bool, is_scalar<_Tp>::value ||\n                                     is_reference<_Tp>::value> {};\n\ntemplate <class _Tp> struct _LIBCPP_TEMPLATE_VIS is_trivially_destructible\n    : public __libcpp_trivial_destructor<typename remove_all_extents<_Tp>::type> {};\n\ntemplate <class _Tp> struct _LIBCPP_TEMPLATE_VIS is_trivially_destructible<_Tp[]>\n    : public false_type {};\n\n#endif\n\n#if _LIBCPP_STD_VER > 14 && !defined(_LIBCPP_HAS_NO_VARIABLE_TEMPLATES)\ntemplate <class _Tp> _LIBCPP_CONSTEXPR bool is_trivially_destructible_v\n    = is_trivially_destructible<_Tp>::value;\n#endif\n\n// is_nothrow_constructible\n\n#if 0\ntemplate <class _Tp, class... _Args>\nstruct _LIBCPP_TEMPLATE_VIS is_nothrow_constructible\n    : public integral_constant<bool, __is_nothrow_constructible(_Tp(_Args...))>\n{\n};\n\n#else\n\n#ifndef _LIBCPP_HAS_NO_VARIADICS\n\n#if __has_feature(cxx_noexcept) || (_GNUC_VER >= 407 && __cplusplus >= 201103L)\n\ntemplate <bool, bool, class _Tp, class... _Args> struct __libcpp_is_nothrow_constructible;\n\ntemplate <class _Tp, class... _Args>\nstruct __libcpp_is_nothrow_constructible</*is constructible*/true, /*is reference*/false, _Tp, _Args...>\n    : public integral_constant<bool, noexcept(_Tp(declval<_Args>()...))>\n{\n};\n\ntemplate <class _Tp>\nvoid __implicit_conversion_to(_Tp) noexcept { }\n\ntemplate <class _Tp, class _Arg>\nstruct __libcpp_is_nothrow_constructible</*is constructible*/true, /*is reference*/true, _Tp, _Arg>\n    : public integral_constant<bool, noexcept(__implicit_conversion_to<_Tp>(declval<_Arg>()))>\n{\n};\n\ntemplate <class _Tp, bool _IsReference, class... _Args>\nstruct __libcpp_is_nothrow_constructible</*is constructible*/false, _IsReference, _Tp, _Args...>\n    : public false_type\n{\n};\n\ntemplate <class _Tp, class... _Args>\nstruct _LIBCPP_TEMPLATE_VIS is_nothrow_constructible\n    : __libcpp_is_nothrow_constructible<is_constructible<_Tp, _Args...>::value, is_reference<_Tp>::value, _Tp, _Args...>\n{\n};\n\ntemplate <class _Tp, size_t _Ns>\nstruct _LIBCPP_TEMPLATE_VIS is_nothrow_constructible<_Tp[_Ns]>\n    : __libcpp_is_nothrow_constructible<is_constructible<_Tp>::value, is_reference<_Tp>::value, _Tp>\n{\n};\n\n#else  // __has_feature(cxx_noexcept)\n\ntemplate <class _Tp, class... _Args>\nstruct _LIBCPP_TEMPLATE_VIS is_nothrow_constructible\n    : false_type\n{\n};\n\ntemplate <class _Tp>\nstruct _LIBCPP_TEMPLATE_VIS is_nothrow_constructible<_Tp>\n#if __has_feature(has_nothrow_constructor) || (_GNUC_VER >= 403)\n    : integral_constant<bool, __has_nothrow_constructor(_Tp)>\n#else\n    : integral_constant<bool, is_scalar<_Tp>::value>\n#endif\n{\n};\n\ntemplate <class _Tp>\n#ifndef _LIBCPP_HAS_NO_RVALUE_REFERENCES\nstruct _LIBCPP_TEMPLATE_VIS is_nothrow_constructible<_Tp, _Tp&&>\n#else\nstruct _LIBCPP_TEMPLATE_VIS is_nothrow_constructible<_Tp, _Tp>\n#endif\n#if __has_feature(has_nothrow_copy) || (_GNUC_VER >= 403)\n    : integral_constant<bool, __has_nothrow_copy(_Tp)>\n#else\n    : integral_constant<bool, is_scalar<_Tp>::value>\n#endif\n{\n};\n\ntemplate <class _Tp>\nstruct _LIBCPP_TEMPLATE_VIS is_nothrow_constructible<_Tp, const _Tp&>\n#if __has_feature(has_nothrow_copy) || (_GNUC_VER >= 403)\n    : integral_constant<bool, __has_nothrow_copy(_Tp)>\n#else\n    : integral_constant<bool, is_scalar<_Tp>::value>\n#endif\n{\n};\n\ntemplate <class _Tp>\nstruct _LIBCPP_TEMPLATE_VIS is_nothrow_constructible<_Tp, _Tp&>\n#if __has_feature(has_nothrow_copy) || (_GNUC_VER >= 403)\n    : integral_constant<bool, __has_nothrow_copy(_Tp)>\n#else\n    : integral_constant<bool, is_scalar<_Tp>::value>\n#endif\n{\n};\n\n#endif  // __has_feature(cxx_noexcept)\n\n#else  // _LIBCPP_HAS_NO_VARIADICS\n\ntemplate <class _Tp, class _A0 = __is_construct::__nat,\n                     class _A1 = __is_construct::__nat>\nstruct _LIBCPP_TEMPLATE_VIS is_nothrow_constructible\n    : false_type\n{\n};\n\ntemplate <class _Tp>\nstruct _LIBCPP_TEMPLATE_VIS is_nothrow_constructible<_Tp, __is_construct::__nat,\n                                                       __is_construct::__nat>\n#if __has_feature(has_nothrow_constructor) || (_GNUC_VER >= 403)\n    : integral_constant<bool, __has_nothrow_constructor(_Tp)>\n#else\n    : integral_constant<bool, is_scalar<_Tp>::value>\n#endif\n{\n};\n\ntemplate <class _Tp>\nstruct _LIBCPP_TEMPLATE_VIS is_nothrow_constructible<_Tp, _Tp,\n                                                       __is_construct::__nat>\n#if __has_feature(has_nothrow_copy) || (_GNUC_VER >= 403)\n    : integral_constant<bool, __has_nothrow_copy(_Tp)>\n#else\n    : integral_constant<bool, is_scalar<_Tp>::value>\n#endif\n{\n};\n\ntemplate <class _Tp>\nstruct _LIBCPP_TEMPLATE_VIS is_nothrow_constructible<_Tp, const _Tp&,\n                                                       __is_construct::__nat>\n#if __has_feature(has_nothrow_copy) || (_GNUC_VER >= 403)\n    : integral_constant<bool, __has_nothrow_copy(_Tp)>\n#else\n    : integral_constant<bool, is_scalar<_Tp>::value>\n#endif\n{\n};\n\ntemplate <class _Tp>\nstruct _LIBCPP_TEMPLATE_VIS is_nothrow_constructible<_Tp, _Tp&,\n                                                       __is_construct::__nat>\n#if __has_feature(has_nothrow_copy) || (_GNUC_VER >= 403)\n    : integral_constant<bool, __has_nothrow_copy(_Tp)>\n#else\n    : integral_constant<bool, is_scalar<_Tp>::value>\n#endif\n{\n};\n\n#endif  // _LIBCPP_HAS_NO_VARIADICS\n#endif  // __has_feature(is_nothrow_constructible)\n\n#if _LIBCPP_STD_VER > 14 && !defined(_LIBCPP_HAS_NO_VARIABLE_TEMPLATES) && !defined(_LIBCPP_HAS_NO_VARIADICS)\ntemplate <class _Tp, class ..._Args> _LIBCPP_CONSTEXPR bool is_nothrow_constructible_v\n    = is_nothrow_constructible<_Tp, _Args...>::value;\n#endif\n\n// is_nothrow_default_constructible\n\ntemplate <class _Tp> struct _LIBCPP_TEMPLATE_VIS is_nothrow_default_constructible\n    : public is_nothrow_constructible<_Tp>\n    {};\n\n#if _LIBCPP_STD_VER > 14 && !defined(_LIBCPP_HAS_NO_VARIABLE_TEMPLATES)\ntemplate <class _Tp> _LIBCPP_CONSTEXPR bool is_nothrow_default_constructible_v\n    = is_nothrow_default_constructible<_Tp>::value;\n#endif\n\n// is_nothrow_copy_constructible\n\ntemplate <class _Tp> struct _LIBCPP_TEMPLATE_VIS is_nothrow_copy_constructible\n    : public is_nothrow_constructible<_Tp,\n                  typename add_lvalue_reference<typename add_const<_Tp>::type>::type> {};\n\n#if _LIBCPP_STD_VER > 14 && !defined(_LIBCPP_HAS_NO_VARIABLE_TEMPLATES)\ntemplate <class _Tp> _LIBCPP_CONSTEXPR bool is_nothrow_copy_constructible_v\n    = is_nothrow_copy_constructible<_Tp>::value;\n#endif\n\n// is_nothrow_move_constructible\n\ntemplate <class _Tp> struct _LIBCPP_TEMPLATE_VIS is_nothrow_move_constructible\n#ifndef _LIBCPP_HAS_NO_RVALUE_REFERENCES\n    : public is_nothrow_constructible<_Tp, typename add_rvalue_reference<_Tp>::type>\n#else\n    : public is_nothrow_copy_constructible<_Tp>\n#endif\n    {};\n\n#if _LIBCPP_STD_VER > 14 && !defined(_LIBCPP_HAS_NO_VARIABLE_TEMPLATES)\ntemplate <class _Tp> _LIBCPP_CONSTEXPR bool is_nothrow_move_constructible_v\n    = is_nothrow_move_constructible<_Tp>::value;\n#endif\n\n// is_nothrow_assignable\n\n#if __has_feature(cxx_noexcept) || (_GNUC_VER >= 407 && __cplusplus >= 201103L)\n\ntemplate <bool, class _Tp, class _Arg> struct __libcpp_is_nothrow_assignable;\n\ntemplate <class _Tp, class _Arg>\nstruct __libcpp_is_nothrow_assignable<false, _Tp, _Arg>\n    : public false_type\n{\n};\n\ntemplate <class _Tp, class _Arg>\nstruct __libcpp_is_nothrow_assignable<true, _Tp, _Arg>\n    : public integral_constant<bool, noexcept(_VSTD::declval<_Tp>() = _VSTD::declval<_Arg>()) >\n{\n};\n\ntemplate <class _Tp, class _Arg>\nstruct _LIBCPP_TEMPLATE_VIS is_nothrow_assignable\n    : public __libcpp_is_nothrow_assignable<is_assignable<_Tp, _Arg>::value, _Tp, _Arg>\n{\n};\n\n#else  // __has_feature(cxx_noexcept)\n\ntemplate <class _Tp, class _Arg>\nstruct _LIBCPP_TEMPLATE_VIS is_nothrow_assignable\n    : public false_type {};\n\ntemplate <class _Tp>\nstruct _LIBCPP_TEMPLATE_VIS is_nothrow_assignable<_Tp&, _Tp>\n#if __has_feature(has_nothrow_assign) || (_GNUC_VER >= 403)\n    : integral_constant<bool, __has_nothrow_assign(_Tp)> {};\n#else\n    : integral_constant<bool, is_scalar<_Tp>::value> {};\n#endif\n\ntemplate <class _Tp>\nstruct _LIBCPP_TEMPLATE_VIS is_nothrow_assignable<_Tp&, _Tp&>\n#if __has_feature(has_nothrow_assign) || (_GNUC_VER >= 403)\n    : integral_constant<bool, __has_nothrow_assign(_Tp)> {};\n#else\n    : integral_constant<bool, is_scalar<_Tp>::value> {};\n#endif\n\ntemplate <class _Tp>\nstruct _LIBCPP_TEMPLATE_VIS is_nothrow_assignable<_Tp&, const _Tp&>\n#if __has_feature(has_nothrow_assign) || (_GNUC_VER >= 403)\n    : integral_constant<bool, __has_nothrow_assign(_Tp)> {};\n#else\n    : integral_constant<bool, is_scalar<_Tp>::value> {};\n#endif\n\n#ifndef _LIBCPP_HAS_NO_RVALUE_REFERENCES\n\ntemplate <class _Tp>\nstruct is_nothrow_assignable<_Tp&, _Tp&&>\n#if __has_feature(has_nothrow_assign) || (_GNUC_VER >= 403)\n    : integral_constant<bool, __has_nothrow_assign(_Tp)> {};\n#else\n    : integral_constant<bool, is_scalar<_Tp>::value> {};\n#endif\n\n#endif  // _LIBCPP_HAS_NO_RVALUE_REFERENCES\n\n#endif  // __has_feature(cxx_noexcept)\n\n#if _LIBCPP_STD_VER > 14 && !defined(_LIBCPP_HAS_NO_VARIABLE_TEMPLATES)\ntemplate <class _Tp, class _Arg> _LIBCPP_CONSTEXPR bool is_nothrow_assignable_v\n    = is_nothrow_assignable<_Tp, _Arg>::value;\n#endif\n\n// is_nothrow_copy_assignable\n\ntemplate <class _Tp> struct _LIBCPP_TEMPLATE_VIS is_nothrow_copy_assignable\n    : public is_nothrow_assignable<typename add_lvalue_reference<_Tp>::type,\n                  typename add_lvalue_reference<typename add_const<_Tp>::type>::type> {};\n\n#if _LIBCPP_STD_VER > 14 && !defined(_LIBCPP_HAS_NO_VARIABLE_TEMPLATES)\ntemplate <class _Tp> _LIBCPP_CONSTEXPR bool is_nothrow_copy_assignable_v\n    = is_nothrow_copy_assignable<_Tp>::value;\n#endif\n\n// is_nothrow_move_assignable\n\ntemplate <class _Tp> struct _LIBCPP_TEMPLATE_VIS is_nothrow_move_assignable\n    : public is_nothrow_assignable<typename add_lvalue_reference<_Tp>::type,\n#ifndef _LIBCPP_HAS_NO_RVALUE_REFERENCES\n                                     typename add_rvalue_reference<_Tp>::type>\n#else\n                                     typename add_lvalue_reference<_Tp>::type>\n#endif\n    {};\n\n#if _LIBCPP_STD_VER > 14 && !defined(_LIBCPP_HAS_NO_VARIABLE_TEMPLATES)\ntemplate <class _Tp> _LIBCPP_CONSTEXPR bool is_nothrow_move_assignable_v\n    = is_nothrow_move_assignable<_Tp>::value;\n#endif\n\n// is_nothrow_destructible\n\n#if __has_feature(cxx_noexcept) || (_GNUC_VER >= 407 && __cplusplus >= 201103L)\n\ntemplate <bool, class _Tp> struct __libcpp_is_nothrow_destructible;\n\ntemplate <class _Tp>\nstruct __libcpp_is_nothrow_destructible<false, _Tp>\n    : public false_type\n{\n};\n\ntemplate <class _Tp>\nstruct __libcpp_is_nothrow_destructible<true, _Tp>\n    : public integral_constant<bool, noexcept(_VSTD::declval<_Tp>().~_Tp()) >\n{\n};\n\ntemplate <class _Tp>\nstruct _LIBCPP_TEMPLATE_VIS is_nothrow_destructible\n    : public __libcpp_is_nothrow_destructible<is_destructible<_Tp>::value, _Tp>\n{\n};\n\ntemplate <class _Tp, size_t _Ns>\nstruct _LIBCPP_TEMPLATE_VIS is_nothrow_destructible<_Tp[_Ns]>\n    : public is_nothrow_destructible<_Tp>\n{\n};\n\ntemplate <class _Tp>\nstruct _LIBCPP_TEMPLATE_VIS is_nothrow_destructible<_Tp&>\n    : public true_type\n{\n};\n\n#ifndef _LIBCPP_HAS_NO_RVALUE_REFERENCES\n\ntemplate <class _Tp>\nstruct _LIBCPP_TEMPLATE_VIS is_nothrow_destructible<_Tp&&>\n    : public true_type\n{\n};\n\n#endif\n\n#else\n\ntemplate <class _Tp> struct __libcpp_nothrow_destructor\n    : public integral_constant<bool, is_scalar<_Tp>::value ||\n                                     is_reference<_Tp>::value> {};\n\ntemplate <class _Tp> struct _LIBCPP_TEMPLATE_VIS is_nothrow_destructible\n    : public __libcpp_nothrow_destructor<typename remove_all_extents<_Tp>::type> {};\n\ntemplate <class _Tp>\nstruct _LIBCPP_TEMPLATE_VIS is_nothrow_destructible<_Tp[]>\n    : public false_type {};\n\n#endif\n\n#if _LIBCPP_STD_VER > 14 && !defined(_LIBCPP_HAS_NO_VARIABLE_TEMPLATES)\ntemplate <class _Tp> _LIBCPP_CONSTEXPR bool is_nothrow_destructible_v\n    = is_nothrow_destructible<_Tp>::value;\n#endif\n\n// is_pod\n\n#if __has_feature(is_pod) || (_GNUC_VER >= 403)\n\ntemplate <class _Tp> struct _LIBCPP_TEMPLATE_VIS is_pod\n    : public integral_constant<bool, __is_pod(_Tp)> {};\n\n#else\n\ntemplate <class _Tp> struct _LIBCPP_TEMPLATE_VIS is_pod\n    : public integral_constant<bool, is_trivially_default_constructible<_Tp>::value   &&\n                                     is_trivially_copy_constructible<_Tp>::value      &&\n                                     is_trivially_copy_assignable<_Tp>::value    &&\n                                     is_trivially_destructible<_Tp>::value> {};\n\n#endif\n\n#if _LIBCPP_STD_VER > 14 && !defined(_LIBCPP_HAS_NO_VARIABLE_TEMPLATES)\ntemplate <class _Tp> _LIBCPP_CONSTEXPR bool is_pod_v\n    = is_pod<_Tp>::value;\n#endif\n\n// is_literal_type;\n\ntemplate <class _Tp> struct _LIBCPP_TEMPLATE_VIS is_literal_type\n#ifdef _LIBCPP_IS_LITERAL\n    : public integral_constant<bool, _LIBCPP_IS_LITERAL(_Tp)>\n#else\n    : integral_constant<bool, is_scalar<typename remove_all_extents<_Tp>::type>::value ||\n                              is_reference<typename remove_all_extents<_Tp>::type>::value>\n#endif\n    {};\n    \n#if _LIBCPP_STD_VER > 14 && !defined(_LIBCPP_HAS_NO_VARIABLE_TEMPLATES)\ntemplate <class _Tp> _LIBCPP_CONSTEXPR bool is_literal_type_v\n    = is_literal_type<_Tp>::value;\n#endif\n\n// is_standard_layout;\n\ntemplate <class _Tp> struct _LIBCPP_TEMPLATE_VIS is_standard_layout\n#if __has_feature(is_standard_layout) || (_GNUC_VER >= 407)\n    : public integral_constant<bool, __is_standard_layout(_Tp)>\n#else\n    : integral_constant<bool, is_scalar<typename remove_all_extents<_Tp>::type>::value>\n#endif\n    {};\n    \n#if _LIBCPP_STD_VER > 14 && !defined(_LIBCPP_HAS_NO_VARIABLE_TEMPLATES)\ntemplate <class _Tp> _LIBCPP_CONSTEXPR bool is_standard_layout_v\n    = is_standard_layout<_Tp>::value;\n#endif\n\n// is_trivially_copyable;\n\ntemplate <class _Tp> struct _LIBCPP_TEMPLATE_VIS is_trivially_copyable\n#if __has_feature(is_trivially_copyable)\n    : public integral_constant<bool, __is_trivially_copyable(_Tp)>\n#elif _GNUC_VER >= 501\n    : public integral_constant<bool, !is_volatile<_Tp>::value && __is_trivially_copyable(_Tp)>\n#else\n    : integral_constant<bool, is_scalar<typename remove_all_extents<_Tp>::type>::value>\n#endif\n    {};\n    \n#if _LIBCPP_STD_VER > 14 && !defined(_LIBCPP_HAS_NO_VARIABLE_TEMPLATES)\ntemplate <class _Tp> _LIBCPP_CONSTEXPR bool is_trivially_copyable_v\n    = is_trivially_copyable<_Tp>::value;\n#endif\n\n// is_trivial;\n\ntemplate <class _Tp> struct _LIBCPP_TEMPLATE_VIS is_trivial\n#if __has_feature(is_trivial) || _GNUC_VER >= 407\n    : public integral_constant<bool, __is_trivial(_Tp)>\n#else\n    : integral_constant<bool, is_trivially_copyable<_Tp>::value &&\n                                 is_trivially_default_constructible<_Tp>::value>\n#endif\n    {};\n\n#if _LIBCPP_STD_VER > 14 && !defined(_LIBCPP_HAS_NO_VARIABLE_TEMPLATES)\ntemplate <class _Tp> _LIBCPP_CONSTEXPR bool is_trivial_v\n    = is_trivial<_Tp>::value;\n#endif\n\ntemplate <class _Tp> struct __is_reference_wrapper_impl : public false_type {};\ntemplate <class _Tp> struct __is_reference_wrapper_impl<reference_wrapper<_Tp> > : public true_type {};\ntemplate <class _Tp> struct __is_reference_wrapper\n    : public __is_reference_wrapper_impl<typename remove_cv<_Tp>::type> {};\n\n#ifndef _LIBCPP_CXX03_LANG\n\n// Check for complete types\n\ntemplate <class ..._Tp> struct __check_complete;\n\ntemplate <>\nstruct __check_complete<>\n{\n};\n\ntemplate <class _Hp, class _T0, class ..._Tp>\nstruct __check_complete<_Hp, _T0, _Tp...>\n    : private __check_complete<_Hp>,\n      private __check_complete<_T0, _Tp...>\n{\n};\n\ntemplate <class _Hp>\nstruct __check_complete<_Hp, _Hp>\n    : private __check_complete<_Hp>\n{\n};\n\ntemplate <class _Tp>\nstruct __check_complete<_Tp>\n{\n    static_assert(sizeof(_Tp) > 0, \"Type must be complete.\");\n};\n\ntemplate <class _Tp>\nstruct __check_complete<_Tp&>\n    : private __check_complete<_Tp>\n{\n};\n\ntemplate <class _Tp>\nstruct __check_complete<_Tp&&>\n    : private __check_complete<_Tp>\n{\n};\n\ntemplate <class _Rp, class ..._Param>\nstruct __check_complete<_Rp (*)(_Param...)>\n    : private __check_complete<_Rp>\n{\n};\n\ntemplate <class ..._Param>\nstruct __check_complete<void (*)(_Param...)>\n{\n};\n\ntemplate <class _Rp, class ..._Param>\nstruct __check_complete<_Rp (_Param...)>\n    : private __check_complete<_Rp>\n{\n};\n\ntemplate <class ..._Param>\nstruct __check_complete<void (_Param...)>\n{\n};\n\ntemplate <class _Rp, class _Class, class ..._Param>\nstruct __check_complete<_Rp (_Class::*)(_Param...)>\n    : private __check_complete<_Class>\n{\n};\n\ntemplate <class _Rp, class _Class, class ..._Param>\nstruct __check_complete<_Rp (_Class::*)(_Param...) const>\n    : private __check_complete<_Class>\n{\n};\n\ntemplate <class _Rp, class _Class, class ..._Param>\nstruct __check_complete<_Rp (_Class::*)(_Param...) volatile>\n    : private __check_complete<_Class>\n{\n};\n\ntemplate <class _Rp, class _Class, class ..._Param>\nstruct __check_complete<_Rp (_Class::*)(_Param...) const volatile>\n    : private __check_complete<_Class>\n{\n};\n\ntemplate <class _Rp, class _Class, class ..._Param>\nstruct __check_complete<_Rp (_Class::*)(_Param...) &>\n    : private __check_complete<_Class>\n{\n};\n\ntemplate <class _Rp, class _Class, class ..._Param>\nstruct __check_complete<_Rp (_Class::*)(_Param...) const&>\n    : private __check_complete<_Class>\n{\n};\n\ntemplate <class _Rp, class _Class, class ..._Param>\nstruct __check_complete<_Rp (_Class::*)(_Param...) volatile&>\n    : private __check_complete<_Class>\n{\n};\n\ntemplate <class _Rp, class _Class, class ..._Param>\nstruct __check_complete<_Rp (_Class::*)(_Param...) const volatile&>\n    : private __check_complete<_Class>\n{\n};\n\ntemplate <class _Rp, class _Class, class ..._Param>\nstruct __check_complete<_Rp (_Class::*)(_Param...) &&>\n    : private __check_complete<_Class>\n{\n};\n\ntemplate <class _Rp, class _Class, class ..._Param>\nstruct __check_complete<_Rp (_Class::*)(_Param...) const&&>\n    : private __check_complete<_Class>\n{\n};\n\ntemplate <class _Rp, class _Class, class ..._Param>\nstruct __check_complete<_Rp (_Class::*)(_Param...) volatile&&>\n    : private __check_complete<_Class>\n{\n};\n\ntemplate <class _Rp, class _Class, class ..._Param>\nstruct __check_complete<_Rp (_Class::*)(_Param...) const volatile&&>\n    : private __check_complete<_Class>\n{\n};\n\ntemplate <class _Rp, class _Class>\nstruct __check_complete<_Rp _Class::*>\n    : private __check_complete<_Class>\n{\n};\n\n\ntemplate <class _Fp, class _A0,\n         class _DecayFp = typename decay<_Fp>::type,\n         class _DecayA0 = typename decay<_A0>::type,\n         class _ClassT = typename __member_pointer_class_type<_DecayFp>::type>\nusing __enable_if_bullet1 = typename enable_if\n    <\n        is_member_function_pointer<_DecayFp>::value\n        && is_base_of<_ClassT, _DecayA0>::value\n    >::type;\n\ntemplate <class _Fp, class _A0,\n         class _DecayFp = typename decay<_Fp>::type,\n         class _DecayA0 = typename decay<_A0>::type>\nusing __enable_if_bullet2 = typename enable_if\n    <\n        is_member_function_pointer<_DecayFp>::value\n        && __is_reference_wrapper<_DecayA0>::value\n    >::type;\n\ntemplate <class _Fp, class _A0,\n         class _DecayFp = typename decay<_Fp>::type,\n         class _DecayA0 = typename decay<_A0>::type,\n         class _ClassT = typename __member_pointer_class_type<_DecayFp>::type>\nusing __enable_if_bullet3 = typename enable_if\n    <\n        is_member_function_pointer<_DecayFp>::value\n        && !is_base_of<_ClassT, _DecayA0>::value\n        && !__is_reference_wrapper<_DecayA0>::value\n    >::type;\n\ntemplate <class _Fp, class _A0,\n         class _DecayFp = typename decay<_Fp>::type,\n         class _DecayA0 = typename decay<_A0>::type,\n         class _ClassT = typename __member_pointer_class_type<_DecayFp>::type>\nusing __enable_if_bullet4 = typename enable_if\n    <\n        is_member_object_pointer<_DecayFp>::value\n        && is_base_of<_ClassT, _DecayA0>::value\n    >::type;\n\ntemplate <class _Fp, class _A0,\n         class _DecayFp = typename decay<_Fp>::type,\n         class _DecayA0 = typename decay<_A0>::type>\nusing __enable_if_bullet5 = typename enable_if\n    <\n        is_member_object_pointer<_DecayFp>::value\n        && __is_reference_wrapper<_DecayA0>::value\n    >::type;\n\ntemplate <class _Fp, class _A0,\n         class _DecayFp = typename decay<_Fp>::type,\n         class _DecayA0 = typename decay<_A0>::type,\n         class _ClassT = typename __member_pointer_class_type<_DecayFp>::type>\nusing __enable_if_bullet6 = typename enable_if\n    <\n        is_member_object_pointer<_DecayFp>::value\n        && !is_base_of<_ClassT, _DecayA0>::value\n        && !__is_reference_wrapper<_DecayA0>::value\n    >::type;\n\n// __invoke forward declarations\n\n// fall back - none of the bullets\n\n#define _LIBCPP_INVOKE_RETURN(...) \\\n    noexcept(noexcept(__VA_ARGS__)) -> decltype(__VA_ARGS__) \\\n    { return __VA_ARGS__; }\n\ntemplate <class ..._Args>\nauto __invoke(__any, _Args&& ...__args) -> __nat;\n\ntemplate <class ..._Args>\nauto __invoke_constexpr(__any, _Args&& ...__args) -> __nat;\n\n// bullets 1, 2 and 3\n\ntemplate <class _Fp, class _A0, class ..._Args,\n          class = __enable_if_bullet1<_Fp, _A0>>\ninline _LIBCPP_INLINE_VISIBILITY\nauto\n__invoke(_Fp&& __f, _A0&& __a0, _Args&& ...__args)\n_LIBCPP_INVOKE_RETURN((_VSTD::forward<_A0>(__a0).*__f)(_VSTD::forward<_Args>(__args)...))\n\ntemplate <class _Fp, class _A0, class ..._Args,\n          class = __enable_if_bullet1<_Fp, _A0>>\ninline _LIBCPP_INLINE_VISIBILITY\n_LIBCPP_CONSTEXPR auto\n__invoke_constexpr(_Fp&& __f, _A0&& __a0, _Args&& ...__args)\n_LIBCPP_INVOKE_RETURN((_VSTD::forward<_A0>(__a0).*__f)(_VSTD::forward<_Args>(__args)...))\n\ntemplate <class _Fp, class _A0, class ..._Args,\n          class = __enable_if_bullet2<_Fp, _A0>>\ninline _LIBCPP_INLINE_VISIBILITY\nauto\n__invoke(_Fp&& __f, _A0&& __a0, _Args&& ...__args)\n_LIBCPP_INVOKE_RETURN((__a0.get().*__f)(_VSTD::forward<_Args>(__args)...))\n\ntemplate <class _Fp, class _A0, class ..._Args,\n          class = __enable_if_bullet2<_Fp, _A0>>\ninline _LIBCPP_INLINE_VISIBILITY\n_LIBCPP_CONSTEXPR auto\n__invoke_constexpr(_Fp&& __f, _A0&& __a0, _Args&& ...__args)\n_LIBCPP_INVOKE_RETURN((__a0.get().*__f)(_VSTD::forward<_Args>(__args)...))\n\ntemplate <class _Fp, class _A0, class ..._Args,\n          class = __enable_if_bullet3<_Fp, _A0>>\ninline _LIBCPP_INLINE_VISIBILITY\nauto\n__invoke(_Fp&& __f, _A0&& __a0, _Args&& ...__args)\n_LIBCPP_INVOKE_RETURN(((*_VSTD::forward<_A0>(__a0)).*__f)(_VSTD::forward<_Args>(__args)...))\n\ntemplate <class _Fp, class _A0, class ..._Args,\n          class = __enable_if_bullet3<_Fp, _A0>>\ninline _LIBCPP_INLINE_VISIBILITY\n_LIBCPP_CONSTEXPR auto\n__invoke_constexpr(_Fp&& __f, _A0&& __a0, _Args&& ...__args)\n_LIBCPP_INVOKE_RETURN(((*_VSTD::forward<_A0>(__a0)).*__f)(_VSTD::forward<_Args>(__args)...))\n\n// bullets 4, 5 and 6\n\ntemplate <class _Fp, class _A0,\n          class = __enable_if_bullet4<_Fp, _A0>>\ninline _LIBCPP_INLINE_VISIBILITY\nauto\n__invoke(_Fp&& __f, _A0&& __a0)\n_LIBCPP_INVOKE_RETURN(_VSTD::forward<_A0>(__a0).*__f)\n\ntemplate <class _Fp, class _A0,\n          class = __enable_if_bullet4<_Fp, _A0>>\ninline _LIBCPP_INLINE_VISIBILITY\n_LIBCPP_CONSTEXPR auto\n__invoke_constexpr(_Fp&& __f, _A0&& __a0)\n_LIBCPP_INVOKE_RETURN(_VSTD::forward<_A0>(__a0).*__f)\n\ntemplate <class _Fp, class _A0,\n          class = __enable_if_bullet5<_Fp, _A0>>\ninline _LIBCPP_INLINE_VISIBILITY\nauto\n__invoke(_Fp&& __f, _A0&& __a0)\n_LIBCPP_INVOKE_RETURN(__a0.get().*__f)\n\ntemplate <class _Fp, class _A0,\n          class = __enable_if_bullet5<_Fp, _A0>>\ninline _LIBCPP_INLINE_VISIBILITY\n_LIBCPP_CONSTEXPR auto\n__invoke_constexpr(_Fp&& __f, _A0&& __a0)\n_LIBCPP_INVOKE_RETURN(__a0.get().*__f)\n\ntemplate <class _Fp, class _A0,\n          class = __enable_if_bullet6<_Fp, _A0>>\ninline _LIBCPP_INLINE_VISIBILITY\nauto\n__invoke(_Fp&& __f, _A0&& __a0)\n_LIBCPP_INVOKE_RETURN((*_VSTD::forward<_A0>(__a0)).*__f)\n\ntemplate <class _Fp, class _A0,\n          class = __enable_if_bullet6<_Fp, _A0>>\ninline _LIBCPP_INLINE_VISIBILITY\n_LIBCPP_CONSTEXPR auto\n__invoke_constexpr(_Fp&& __f, _A0&& __a0)\n_LIBCPP_INVOKE_RETURN((*_VSTD::forward<_A0>(__a0)).*__f)\n\n// bullet 7\n\ntemplate <class _Fp, class ..._Args>\ninline _LIBCPP_INLINE_VISIBILITY\nauto\n__invoke(_Fp&& __f, _Args&& ...__args)\n_LIBCPP_INVOKE_RETURN(_VSTD::forward<_Fp>(__f)(_VSTD::forward<_Args>(__args)...))\n\ntemplate <class _Fp, class ..._Args>\ninline _LIBCPP_INLINE_VISIBILITY\n_LIBCPP_CONSTEXPR auto\n__invoke_constexpr(_Fp&& __f, _Args&& ...__args)\n_LIBCPP_INVOKE_RETURN(_VSTD::forward<_Fp>(__f)(_VSTD::forward<_Args>(__args)...))\n\n#undef _LIBCPP_INVOKE_RETURN\n\n// __invokable\n\ntemplate <class _Ret, class _Fp, class ..._Args>\nstruct __invokable_r\n    : private __check_complete<_Fp>\n{\n    using _Result = decltype(\n        _VSTD::__invoke(_VSTD::declval<_Fp>(), _VSTD::declval<_Args>()...));\n\n    static const bool value =\n        conditional<\n            !is_same<_Result, __nat>::value,\n            typename conditional<\n                is_void<_Ret>::value,\n                true_type,\n                is_convertible<_Result, _Ret>\n            >::type,\n            false_type\n        >::type::value;\n};\n\ntemplate <class _Fp, class ..._Args>\nusing __invokable = __invokable_r<void, _Fp, _Args...>;\n\ntemplate <bool _IsInvokable, bool _IsCVVoid, class _Ret, class _Fp, class ..._Args>\nstruct __nothrow_invokable_r_imp {\n  static const bool value = false;\n};\n\ntemplate <class _Ret, class _Fp, class ..._Args>\nstruct __nothrow_invokable_r_imp<true, false, _Ret, _Fp, _Args...>\n{\n    typedef __nothrow_invokable_r_imp _ThisT;\n\n    template <class _Tp>\n    static void __test_noexcept(_Tp) noexcept;\n\n    static const bool value = noexcept(_ThisT::__test_noexcept<_Ret>(\n        _VSTD::__invoke(_VSTD::declval<_Fp>(), _VSTD::declval<_Args>()...)));\n};\n\ntemplate <class _Ret, class _Fp, class ..._Args>\nstruct __nothrow_invokable_r_imp<true, true, _Ret, _Fp, _Args...>\n{\n    static const bool value = noexcept(\n        _VSTD::__invoke(_VSTD::declval<_Fp>(), _VSTD::declval<_Args>()...));\n};\n\ntemplate <class _Ret, class _Fp, class ..._Args>\nusing __nothrow_invokable_r =\n    __nothrow_invokable_r_imp<\n            __invokable_r<_Ret, _Fp, _Args...>::value,\n            is_void<_Ret>::value,\n            _Ret, _Fp, _Args...\n    >;\n\ntemplate <class _Fp, class ..._Args>\nstruct __invoke_of\n    : public enable_if<\n        __invokable<_Fp, _Args...>::value,\n        typename __invokable_r<void, _Fp, _Args...>::_Result>\n{\n};\n\n// result_of\n\ntemplate <class _Fp, class ..._Args>\nclass _LIBCPP_TEMPLATE_VIS result_of<_Fp(_Args...)>\n    : public __invoke_of<_Fp, _Args...>\n{\n};\n\n#if _LIBCPP_STD_VER > 11\ntemplate <class _Tp> using result_of_t = typename result_of<_Tp>::type;\n#endif\n\n#if _LIBCPP_STD_VER > 14\n\n// is_callable\n\ntemplate <class _Fn, class _Ret = void>\nstruct _LIBCPP_TEMPLATE_VIS is_callable;\n\ntemplate <class _Fn, class ..._Args, class _Ret>\nstruct _LIBCPP_TEMPLATE_VIS is_callable<_Fn(_Args...), _Ret>\n    : integral_constant<bool, __invokable_r<_Ret, _Fn, _Args...>::value> {};\n\ntemplate <class _Fn, class _Ret = void>\nconstexpr bool is_callable_v = is_callable<_Fn, _Ret>::value;\n\n// is_nothrow_callable\n\ntemplate <class _Fn, class _Ret = void>\nstruct _LIBCPP_TEMPLATE_VIS is_nothrow_callable;\n\ntemplate <class _Fn, class ..._Args, class _Ret>\nstruct _LIBCPP_TEMPLATE_VIS is_nothrow_callable<_Fn(_Args...), _Ret>\n    : integral_constant<bool, __nothrow_invokable_r<_Ret, _Fn, _Args...>::value>\n{};\n\ntemplate <class _Fn, class _Ret = void>\nconstexpr bool is_nothrow_callable_v = is_nothrow_callable<_Fn, _Ret>::value;\n\n#endif // _LIBCPP_STD_VER > 14\n\n#endif  // !defined(_LIBCPP_CXX03_LANG)\n\ntemplate <class _Tp> struct __is_swappable;\ntemplate <class _Tp> struct __is_nothrow_swappable;\n\ntemplate <class _Tp>\ninline _LIBCPP_INLINE_VISIBILITY\n#ifndef _LIBCPP_CXX03_LANG\ntypename enable_if\n<\n    is_move_constructible<_Tp>::value &&\n    is_move_assignable<_Tp>::value\n>::type\n#else\nvoid\n#endif\nswap(_Tp& __x, _Tp& __y) _NOEXCEPT_(is_nothrow_move_constructible<_Tp>::value &&\n                                    is_nothrow_move_assignable<_Tp>::value)\n{\n    _Tp __t(_VSTD::move(__x));\n    __x = _VSTD::move(__y);\n    __y = _VSTD::move(__t);\n}\n\ntemplate<class _Tp, size_t _Np>\ninline _LIBCPP_INLINE_VISIBILITY\ntypename enable_if<\n    __is_swappable<_Tp>::value\n>::type\nswap(_Tp (&__a)[_Np], _Tp (&__b)[_Np]) _NOEXCEPT_(__is_nothrow_swappable<_Tp>::value);\n\ntemplate <class _ForwardIterator1, class _ForwardIterator2>\ninline _LIBCPP_INLINE_VISIBILITY\nvoid\niter_swap(_ForwardIterator1 __a, _ForwardIterator2 __b)\n    //                                  _NOEXCEPT_(_NOEXCEPT_(swap(*__a, *__b)))\n               _NOEXCEPT_(_NOEXCEPT_(swap(*_VSTD::declval<_ForwardIterator1>(),\n                                          *_VSTD::declval<_ForwardIterator2>())))\n{\n    swap(*__a, *__b);\n}\n\n// __swappable\n\nnamespace __detail\n{\n// ALL generic swap overloads MUST already have a declaration available at this point.\n\ntemplate <class _Tp, class _Up = _Tp,\n          bool _NotVoid = !is_void<_Tp>::value && !is_void<_Up>::value>\nstruct __swappable_with\n{\n    template <class _LHS, class _RHS>\n    static decltype(swap(_VSTD::declval<_LHS>(), _VSTD::declval<_RHS>()))\n    __test_swap(int);\n    template <class, class>\n    static __nat __test_swap(long);\n\n    // Extra parens are needed for the C++03 definition of decltype.\n    typedef decltype((__test_swap<_Tp, _Up>(0))) __swap1;\n    typedef decltype((__test_swap<_Up, _Tp>(0))) __swap2;\n\n    static const bool value = !is_same<__swap1, __nat>::value\n                           && !is_same<__swap2, __nat>::value;\n};\n\ntemplate <class _Tp, class _Up>\nstruct __swappable_with<_Tp, _Up,  false> : false_type {};\n\ntemplate <class _Tp, class _Up = _Tp, bool _Swappable = __swappable_with<_Tp, _Up>::value>\nstruct __nothrow_swappable_with {\n  static const bool value =\n#ifndef _LIBCPP_HAS_NO_NOEXCEPT\n      noexcept(swap(_VSTD::declval<_Tp>(), _VSTD::declval<_Up>()))\n  &&  noexcept(swap(_VSTD::declval<_Up>(), _VSTD::declval<_Tp>()));\n#else\n      false;\n#endif\n};\n\ntemplate <class _Tp, class _Up>\nstruct __nothrow_swappable_with<_Tp, _Up, false> : false_type {};\n\n}  // __detail\n\ntemplate <class _Tp>\nstruct __is_swappable\n    : public integral_constant<bool, __detail::__swappable_with<_Tp&>::value>\n{\n};\n\ntemplate <class _Tp>\nstruct __is_nothrow_swappable\n    : public integral_constant<bool, __detail::__nothrow_swappable_with<_Tp&>::value>\n{\n};\n\n#if _LIBCPP_STD_VER > 14\n\ntemplate <class _Tp, class _Up>\nstruct _LIBCPP_TEMPLATE_VIS is_swappable_with\n    : public integral_constant<bool, __detail::__swappable_with<_Tp, _Up>::value>\n{\n};\n\ntemplate <class _Tp>\nstruct _LIBCPP_TEMPLATE_VIS is_swappable\n    : public conditional<\n        __is_referenceable<_Tp>::value,\n        is_swappable_with<\n            typename add_lvalue_reference<_Tp>::type,\n            typename add_lvalue_reference<_Tp>::type>,\n        false_type\n    >::type\n{\n};\n\ntemplate <class _Tp, class _Up>\nstruct _LIBCPP_TEMPLATE_VIS is_nothrow_swappable_with\n    : public integral_constant<bool, __detail::__nothrow_swappable_with<_Tp, _Up>::value>\n{\n};\n\ntemplate <class _Tp>\nstruct _LIBCPP_TEMPLATE_VIS is_nothrow_swappable\n    : public conditional<\n        __is_referenceable<_Tp>::value,\n        is_nothrow_swappable_with<\n            typename add_lvalue_reference<_Tp>::type,\n            typename add_lvalue_reference<_Tp>::type>,\n        false_type\n    >::type\n{\n};\n\ntemplate <class _Tp, class _Up>\nconstexpr bool is_swappable_with_v = is_swappable_with<_Tp, _Up>::value;\n\ntemplate <class _Tp>\nconstexpr bool is_swappable_v = is_swappable<_Tp>::value;\n\ntemplate <class _Tp, class _Up>\nconstexpr bool is_nothrow_swappable_with_v = is_nothrow_swappable_with<_Tp, _Up>::value;\n\ntemplate <class _Tp>\nconstexpr bool is_nothrow_swappable_v = is_nothrow_swappable<_Tp>::value;\n\n#endif // _LIBCPP_STD_VER > 14\n\n#ifdef _LIBCPP_UNDERLYING_TYPE\n\ntemplate <class _Tp>\nstruct underlying_type\n{\n    typedef _LIBCPP_UNDERLYING_TYPE(_Tp) type;\n};\n\n#if _LIBCPP_STD_VER > 11\ntemplate <class _Tp> using underlying_type_t = typename underlying_type<_Tp>::type;\n#endif\n\n#else  // _LIBCPP_UNDERLYING_TYPE\n\ntemplate <class _Tp, bool _Support = false>\nstruct underlying_type\n{\n    static_assert(_Support, \"The underyling_type trait requires compiler \"\n                            \"support. Either no such support exists or \"\n                            \"libc++ does not know how to use it.\");\n};\n\n#endif // _LIBCPP_UNDERLYING_TYPE\n\n\ntemplate <class _Tp, bool = is_enum<_Tp>::value>\nstruct __sfinae_underlying_type\n{\n    typedef typename underlying_type<_Tp>::type type;\n    typedef decltype(((type)1) + 0) __promoted_type;\n};\n\ntemplate <class _Tp>\nstruct __sfinae_underlying_type<_Tp, false> {};\n\ninline _LIBCPP_INLINE_VISIBILITY\nint __convert_to_integral(int __val) { return __val; }\n\ninline _LIBCPP_INLINE_VISIBILITY\nunsigned __convert_to_integral(unsigned __val) { return __val; }\n\ninline _LIBCPP_INLINE_VISIBILITY\nlong __convert_to_integral(long __val) { return __val; }\n\ninline _LIBCPP_INLINE_VISIBILITY\nunsigned long __convert_to_integral(unsigned long __val) { return __val; }\n\ninline _LIBCPP_INLINE_VISIBILITY\nlong long __convert_to_integral(long long __val) { return __val; }\n\ninline _LIBCPP_INLINE_VISIBILITY\nunsigned long long __convert_to_integral(unsigned long long __val) {return __val; }\n\n#ifndef _LIBCPP_HAS_NO_INT128\ninline _LIBCPP_INLINE_VISIBILITY\n__int128_t __convert_to_integral(__int128_t __val) { return __val; }\n\ninline _LIBCPP_INLINE_VISIBILITY\n__uint128_t __convert_to_integral(__uint128_t __val) { return __val; }\n#endif\n\ntemplate <class _Tp>\ninline _LIBCPP_INLINE_VISIBILITY\ntypename __sfinae_underlying_type<_Tp>::__promoted_type\n__convert_to_integral(_Tp __val) { return __val; }\n\n#ifndef _LIBCPP_CXX03_LANG\n\ntemplate <class _Tp>\nstruct __has_operator_addressof_member_imp\n{\n    template <class _Up>\n        static auto __test(int)\n            -> typename __select_2nd<decltype(_VSTD::declval<_Up>().operator&()), true_type>::type;\n    template <class>\n        static auto __test(long) -> false_type;\n\n    static const bool value = decltype(__test<_Tp>(0))::value;\n};\n\ntemplate <class _Tp>\nstruct __has_operator_addressof_free_imp\n{\n    template <class _Up>\n        static auto __test(int)\n            -> typename __select_2nd<decltype(operator&(_VSTD::declval<_Up>())), true_type>::type;\n    template <class>\n        static auto __test(long) -> false_type;\n\n    static const bool value = decltype(__test<_Tp>(0))::value;\n};\n\ntemplate <class _Tp>\nstruct __has_operator_addressof\n    : public integral_constant<bool, __has_operator_addressof_member_imp<_Tp>::value\n                                  || __has_operator_addressof_free_imp<_Tp>::value>\n{};\n\n#endif  // _LIBCPP_CXX03_LANG\n\n#if _LIBCPP_STD_VER > 14\n\n#define __cpp_lib_void_t 201411\ntemplate <class...> using void_t = void;\n\n# ifndef _LIBCPP_HAS_NO_VARIADICS\ntemplate <class... _Args>\nstruct conjunction : __and_<_Args...> {};\ntemplate<class... _Args> constexpr bool conjunction_v = conjunction<_Args...>::value;\n\ntemplate <class... _Args>\nstruct disjunction : __or_<_Args...> {};\ntemplate<class... _Args> constexpr bool disjunction_v = disjunction<_Args...>::value;\n\ntemplate <class _Tp>\nstruct negation : __not_<_Tp> {};\ntemplate<class _Tp> constexpr bool negation_v = negation<_Tp>::value;\n# endif // _LIBCPP_HAS_NO_VARIADICS\n#endif  // _LIBCPP_STD_VER > 14\n\n// These traits are used in __tree and __hash_table\n#ifndef _LIBCPP_CXX03_LANG\nstruct __extract_key_fail_tag {};\nstruct __extract_key_self_tag {};\nstruct __extract_key_first_tag {};\n\ntemplate <class _ValTy, class _Key,\n          class _RawValTy = typename __unconstref<_ValTy>::type>\nstruct __can_extract_key\n    : conditional<is_same<_RawValTy, _Key>::value, __extract_key_self_tag,\n                  __extract_key_fail_tag>::type {};\n\ntemplate <class _Pair, class _Key, class _First, class _Second>\nstruct __can_extract_key<_Pair, _Key, pair<_First, _Second>>\n    : conditional<is_same<typename remove_const<_First>::type, _Key>::value,\n                  __extract_key_first_tag, __extract_key_fail_tag>::type {};\n\n// __can_extract_map_key uses true_type/false_type instead of the tags.\n// It returns true if _Key != _ContainerValueTy (the container is a map not a set)\n// and _ValTy == _Key.\ntemplate <class _ValTy, class _Key, class _ContainerValueTy,\n          class _RawValTy = typename __unconstref<_ValTy>::type>\nstruct __can_extract_map_key\n    : integral_constant<bool, is_same<_RawValTy, _Key>::value> {};\n\n// This specialization returns __extract_key_fail_tag for non-map containers\n// because _Key == _ContainerValueTy\ntemplate <class _ValTy, class _Key, class _RawValTy>\nstruct __can_extract_map_key<_ValTy, _Key, _Key, _RawValTy>\n    : false_type {};\n\n#endif\n\n_LIBCPP_END_NAMESPACE_STD\n\n#endif  // _LIBCPP_TYPE_TRAITS\n","#pragma once\n#include <vector>\n#include <string>\n#include <any>\n#include <unordered_map>\n#include <functional>\n\n#include \"ParserTypes.h\"\n\n\n//In Runner.h\nclass Runner;\nclass FunctionDefinition;\n\nstruct BuiltinFunction {\n\tstd::variant<std::function<void(Runner*)>, std::function<void(Runner*, RunnerContext*)>> f;\n\tbool takesContext;\n};\n\nclass PredefinedFunctions {\nprivate:\n\t//helper function to ensure the function is 2 things:\n\t//a) a number\n\t//b) an int\n\tstatic bool isInt(CharmFunction f);\npublic:\n\tstd::unordered_map<std::string, BuiltinFunction> cppFunctionNames;\n\tPredefinedFunctions();\n\tvoid functionLookup(std::string functionName, Runner* r, RunnerContext* context);\n\tvoid addBuiltinFunction(std::string n, std::function<void(Runner*, RunnerContext*)> f);\n\tvoid addBuiltinFunction(std::string n, std::function<void(Runner*)> f);\n};\n","// -*- C++ -*-\n//===---------------------------- array -----------------------------------===//\n//\n//                     The LLVM Compiler Infrastructure\n//\n// This file is dual licensed under the MIT and the University of Illinois Open\n// Source Licenses. See LICENSE.TXT for details.\n//\n//===----------------------------------------------------------------------===//\n\n#ifndef _LIBCPP_ARRAY\n#define _LIBCPP_ARRAY\n\n/*\n    array synopsis\n\nnamespace std\n{\ntemplate <class T, size_t N >\nstruct array\n{\n    // types:\n    typedef T & reference;\n    typedef const T & const_reference;\n    typedef implementation defined iterator;\n    typedef implementation defined const_iterator;\n    typedef size_t size_type;\n    typedef ptrdiff_t difference_type;\n    typedef T value_type;\n    typedef T* pointer;\n    typedef const T* const_pointer;\n    typedef std::reverse_iterator<iterator> reverse_iterator;\n    typedef std::reverse_iterator<const_iterator> const_reverse_iterator;\n\n    // No explicit construct/copy/destroy for aggregate type\n    void fill(const T& u);\n    void swap(array& a) noexcept(is_nothrow_swappable_v<T>);\n\n    // iterators:\n    iterator begin() noexcept;\n    const_iterator begin() const noexcept;\n    iterator end() noexcept;\n    const_iterator end() const noexcept;\n\n    reverse_iterator rbegin() noexcept;\n    const_reverse_iterator rbegin() const noexcept;\n    reverse_iterator rend() noexcept;\n    const_reverse_iterator rend() const noexcept;\n\n    const_iterator cbegin() const noexcept;\n    const_iterator cend() const noexcept;\n    const_reverse_iterator crbegin() const noexcept;\n    const_reverse_iterator crend() const noexcept;\n\n    // capacity:\n    constexpr size_type size() const noexcept;\n    constexpr size_type max_size() const noexcept;\n    constexpr bool empty() const noexcept;\n\n    // element access:\n    reference operator[](size_type n);\n    const_reference operator[](size_type n) const; // constexpr in C++14\n    const_reference at(size_type n) const; // constexpr in C++14\n    reference at(size_type n);\n\n    reference front();\n    const_reference front() const; // constexpr in C++14\n    reference back();\n    const_reference back() const; // constexpr in C++14\n\n    T* data() noexcept;\n    const T* data() const noexcept;\n};\n\ntemplate <class T, size_t N>\n  bool operator==(const array<T,N>& x, const array<T,N>& y);\ntemplate <class T, size_t N>\n  bool operator!=(const array<T,N>& x, const array<T,N>& y);\ntemplate <class T, size_t N>\n  bool operator<(const array<T,N>& x, const array<T,N>& y);\ntemplate <class T, size_t N>\n  bool operator>(const array<T,N>& x, const array<T,N>& y);\ntemplate <class T, size_t N>\n  bool operator<=(const array<T,N>& x, const array<T,N>& y);\ntemplate <class T, size_t N>\n  bool operator>=(const array<T,N>& x, const array<T,N>& y);\n\ntemplate <class T, size_t N >\n  void swap(array<T,N>& x, array<T,N>& y) noexcept(noexcept(x.swap(y)));\n\ntemplate <class T> class tuple_size;\ntemplate <size_t I, class T> class tuple_element;\ntemplate <class T, size_t N> struct tuple_size<array<T, N>>;\ntemplate <size_t I, class T, size_t N> struct tuple_element<I, array<T, N>>;\ntemplate <size_t I, class T, size_t N> T& get(array<T, N>&) noexcept; // constexpr in C++14\ntemplate <size_t I, class T, size_t N> const T& get(const array<T, N>&) noexcept; // constexpr in C++14\ntemplate <size_t I, class T, size_t N> T&& get(array<T, N>&&) noexcept; // constexpr in C++14\ntemplate <size_t I, class T, size_t N> const T&& get(const array<T, N>&&) noexcept; // constexpr in C++14\n\n}  // std\n\n*/\n\n#include <__config>\n#include <__tuple>\n#include <type_traits>\n#include <utility>\n#include <iterator>\n#include <algorithm>\n#include <stdexcept>\n\n#if !defined(_LIBCPP_HAS_NO_PRAGMA_SYSTEM_HEADER)\n#pragma GCC system_header\n#endif\n\n_LIBCPP_BEGIN_NAMESPACE_STD\n\ntemplate <class _Tp, size_t _Size>\nstruct _LIBCPP_TEMPLATE_VIS array\n{\n    // types:\n    typedef array __self;\n    typedef _Tp                                   value_type;\n    typedef value_type&                           reference;\n    typedef const value_type&                     const_reference;\n    typedef value_type*                           iterator;\n    typedef const value_type*                     const_iterator;\n    typedef value_type*                           pointer;\n    typedef const value_type*                     const_pointer;\n    typedef size_t                                size_type;\n    typedef ptrdiff_t                             difference_type;\n    typedef std::reverse_iterator<iterator>       reverse_iterator;\n    typedef std::reverse_iterator<const_iterator> const_reverse_iterator;\n\n    value_type __elems_[_Size > 0 ? _Size : 1];\n\n    // No explicit construct/copy/destroy for aggregate type\n    _LIBCPP_INLINE_VISIBILITY void fill(const value_type& __u)\n        {_VSTD::fill_n(__elems_, _Size, __u);}\n    _LIBCPP_INLINE_VISIBILITY\n    void swap(array& __a) _NOEXCEPT_(_Size == 0 || __is_nothrow_swappable<_Tp>::value)\n        { __swap_dispatch((std::integral_constant<bool, _Size == 0>()), __a); }\n\n    _LIBCPP_INLINE_VISIBILITY\n    void __swap_dispatch(std::true_type, array&) {}\n\n    _LIBCPP_INLINE_VISIBILITY\n    void __swap_dispatch(std::false_type, array& __a)\n        { _VSTD::swap_ranges(__elems_, __elems_ + _Size, __a.__elems_);}\n\n    // iterators:\n    _LIBCPP_INLINE_VISIBILITY _LIBCPP_CONSTEXPR_AFTER_CXX14\n    iterator begin() _NOEXCEPT {return iterator(__elems_);}\n    _LIBCPP_INLINE_VISIBILITY _LIBCPP_CONSTEXPR_AFTER_CXX14\n    const_iterator begin() const _NOEXCEPT {return const_iterator(__elems_);}\n    _LIBCPP_INLINE_VISIBILITY _LIBCPP_CONSTEXPR_AFTER_CXX14\n    iterator end() _NOEXCEPT {return iterator(__elems_ + _Size);}\n    _LIBCPP_INLINE_VISIBILITY _LIBCPP_CONSTEXPR_AFTER_CXX14\n    const_iterator end() const _NOEXCEPT {return const_iterator(__elems_ + _Size);}\n\n    _LIBCPP_INLINE_VISIBILITY _LIBCPP_CONSTEXPR_AFTER_CXX14\n    reverse_iterator rbegin() _NOEXCEPT {return reverse_iterator(end());}\n    _LIBCPP_INLINE_VISIBILITY _LIBCPP_CONSTEXPR_AFTER_CXX14\n    const_reverse_iterator rbegin() const _NOEXCEPT {return const_reverse_iterator(end());}\n    _LIBCPP_INLINE_VISIBILITY _LIBCPP_CONSTEXPR_AFTER_CXX14\n    reverse_iterator rend() _NOEXCEPT {return reverse_iterator(begin());}\n    _LIBCPP_INLINE_VISIBILITY _LIBCPP_CONSTEXPR_AFTER_CXX14\n    const_reverse_iterator rend() const _NOEXCEPT {return const_reverse_iterator(begin());}\n\n    _LIBCPP_INLINE_VISIBILITY _LIBCPP_CONSTEXPR_AFTER_CXX14\n    const_iterator cbegin() const _NOEXCEPT {return begin();}\n    _LIBCPP_INLINE_VISIBILITY _LIBCPP_CONSTEXPR_AFTER_CXX14\n    const_iterator cend() const _NOEXCEPT {return end();}\n    _LIBCPP_INLINE_VISIBILITY _LIBCPP_CONSTEXPR_AFTER_CXX14\n    const_reverse_iterator crbegin() const _NOEXCEPT {return rbegin();}\n    _LIBCPP_INLINE_VISIBILITY _LIBCPP_CONSTEXPR_AFTER_CXX14\n    const_reverse_iterator crend() const _NOEXCEPT {return rend();}\n\n    // capacity:\n    _LIBCPP_INLINE_VISIBILITY\n    _LIBCPP_CONSTEXPR size_type size() const _NOEXCEPT {return _Size;}\n    _LIBCPP_INLINE_VISIBILITY\n    _LIBCPP_CONSTEXPR size_type max_size() const _NOEXCEPT {return _Size;}\n    _LIBCPP_INLINE_VISIBILITY\n    _LIBCPP_CONSTEXPR bool empty() const _NOEXCEPT {return _Size == 0;}\n\n    // element access:\n    _LIBCPP_INLINE_VISIBILITY _LIBCPP_CONSTEXPR_AFTER_CXX14\n    reference operator[](size_type __n)             {return __elems_[__n];}\n    _LIBCPP_INLINE_VISIBILITY _LIBCPP_CONSTEXPR_AFTER_CXX11\n    const_reference operator[](size_type __n) const {return __elems_[__n];}\n\n    _LIBCPP_CONSTEXPR_AFTER_CXX14       reference at(size_type __n);\n    _LIBCPP_CONSTEXPR_AFTER_CXX11 const_reference at(size_type __n) const;\n\n    _LIBCPP_INLINE_VISIBILITY _LIBCPP_CONSTEXPR_AFTER_CXX14 reference front()             {return __elems_[0];}\n    _LIBCPP_INLINE_VISIBILITY _LIBCPP_CONSTEXPR_AFTER_CXX11 const_reference front() const {return __elems_[0];}\n    _LIBCPP_INLINE_VISIBILITY _LIBCPP_CONSTEXPR_AFTER_CXX14 reference back()              {return __elems_[_Size > 0 ? _Size-1 : 0];}\n    _LIBCPP_INLINE_VISIBILITY _LIBCPP_CONSTEXPR_AFTER_CXX11 const_reference back() const  {return __elems_[_Size > 0 ? _Size-1 : 0];}\n\n    _LIBCPP_INLINE_VISIBILITY _LIBCPP_CONSTEXPR_AFTER_CXX14\n    value_type* data() _NOEXCEPT {return __elems_;}\n    _LIBCPP_INLINE_VISIBILITY _LIBCPP_CONSTEXPR_AFTER_CXX14\n    const value_type* data() const _NOEXCEPT {return __elems_;}\n};\n\ntemplate <class _Tp, size_t _Size>\n_LIBCPP_CONSTEXPR_AFTER_CXX14\ntypename array<_Tp, _Size>::reference\narray<_Tp, _Size>::at(size_type __n)\n{\n    if (__n >= _Size)\n        __throw_out_of_range(\"array::at\");\n\n    return __elems_[__n];\n}\n\ntemplate <class _Tp, size_t _Size>\n_LIBCPP_CONSTEXPR_AFTER_CXX11\ntypename array<_Tp, _Size>::const_reference\narray<_Tp, _Size>::at(size_type __n) const\n{\n    if (__n >= _Size)\n        __throw_out_of_range(\"array::at\");\n    return __elems_[__n];\n}\n\ntemplate <class _Tp, size_t _Size>\ninline _LIBCPP_INLINE_VISIBILITY\nbool\noperator==(const array<_Tp, _Size>& __x, const array<_Tp, _Size>& __y)\n{\n    return _VSTD::equal(__x.__elems_, __x.__elems_ + _Size, __y.__elems_);\n}\n\ntemplate <class _Tp, size_t _Size>\ninline _LIBCPP_INLINE_VISIBILITY\nbool\noperator!=(const array<_Tp, _Size>& __x, const array<_Tp, _Size>& __y)\n{\n    return !(__x == __y);\n}\n\ntemplate <class _Tp, size_t _Size>\ninline _LIBCPP_INLINE_VISIBILITY\nbool\noperator<(const array<_Tp, _Size>& __x, const array<_Tp, _Size>& __y)\n{\n    return _VSTD::lexicographical_compare(__x.__elems_, __x.__elems_ + _Size, __y.__elems_, __y.__elems_ + _Size);\n}\n\ntemplate <class _Tp, size_t _Size>\ninline _LIBCPP_INLINE_VISIBILITY\nbool\noperator>(const array<_Tp, _Size>& __x, const array<_Tp, _Size>& __y)\n{\n    return __y < __x;\n}\n\ntemplate <class _Tp, size_t _Size>\ninline _LIBCPP_INLINE_VISIBILITY\nbool\noperator<=(const array<_Tp, _Size>& __x, const array<_Tp, _Size>& __y)\n{\n    return !(__y < __x);\n}\n\ntemplate <class _Tp, size_t _Size>\ninline _LIBCPP_INLINE_VISIBILITY\nbool\noperator>=(const array<_Tp, _Size>& __x, const array<_Tp, _Size>& __y)\n{\n    return !(__x < __y);\n}\n\ntemplate <class _Tp, size_t _Size>\ninline _LIBCPP_INLINE_VISIBILITY\ntypename enable_if\n<\n    _Size == 0 ||\n    __is_swappable<_Tp>::value,\n    void\n>::type\nswap(array<_Tp, _Size>& __x, array<_Tp, _Size>& __y)\n                                  _NOEXCEPT_(noexcept(__x.swap(__y)))\n{\n    __x.swap(__y);\n}\n\ntemplate <class _Tp, size_t _Size>\nclass _LIBCPP_TEMPLATE_VIS tuple_size<array<_Tp, _Size> >\n    : public integral_constant<size_t, _Size> {};\n\ntemplate <size_t _Ip, class _Tp, size_t _Size>\nclass _LIBCPP_TEMPLATE_VIS tuple_element<_Ip, array<_Tp, _Size> >\n{\npublic:\n    typedef _Tp type;\n};\n\ntemplate <size_t _Ip, class _Tp, size_t _Size>\ninline _LIBCPP_INLINE_VISIBILITY _LIBCPP_CONSTEXPR_AFTER_CXX11\n_Tp&\nget(array<_Tp, _Size>& __a) _NOEXCEPT\n{\n    static_assert(_Ip < _Size, \"Index out of bounds in std::get<> (std::array)\");\n    return __a.__elems_[_Ip];\n}\n\ntemplate <size_t _Ip, class _Tp, size_t _Size>\ninline _LIBCPP_INLINE_VISIBILITY _LIBCPP_CONSTEXPR_AFTER_CXX11\nconst _Tp&\nget(const array<_Tp, _Size>& __a) _NOEXCEPT\n{\n    static_assert(_Ip < _Size, \"Index out of bounds in std::get<> (const std::array)\");\n    return __a.__elems_[_Ip];\n}\n\n#ifndef _LIBCPP_HAS_NO_RVALUE_REFERENCES\n\ntemplate <size_t _Ip, class _Tp, size_t _Size>\ninline _LIBCPP_INLINE_VISIBILITY _LIBCPP_CONSTEXPR_AFTER_CXX11\n_Tp&&\nget(array<_Tp, _Size>&& __a) _NOEXCEPT\n{\n    static_assert(_Ip < _Size, \"Index out of bounds in std::get<> (std::array &&)\");\n    return _VSTD::move(__a.__elems_[_Ip]);\n}\n\ntemplate <size_t _Ip, class _Tp, size_t _Size>\ninline _LIBCPP_INLINE_VISIBILITY _LIBCPP_CONSTEXPR_AFTER_CXX11\nconst _Tp&&\nget(const array<_Tp, _Size>&& __a) _NOEXCEPT\n{\n    static_assert(_Ip < _Size, \"Index out of bounds in std::get<> (const std::array &&)\");\n    return _VSTD::move(__a.__elems_[_Ip]);\n}\n\n#endif  // _LIBCPP_HAS_NO_RVALUE_REFERENCES\n\n_LIBCPP_END_NAMESPACE_STD\n\n#endif  // _LIBCPP_ARRAY\n","#include <vector>\n#include <sstream>\n#include <utility>\n\n#include \"Parser.h\"\n#include \"ParserTypes.h\"\n#include \"Debug.h\"\n#include \"FunctionAnalyzer.h\"\n#include \"Error.h\"\n\n\n//thank u https://stackoverflow.com/questions/216823/whats-the-best-way-to-trim-stdstring?utm_medium=organic&utm_source=google_rich_qa&utm_campaign=google_rich_qa\n#include <algorithm>\n#include <cctype>\n#include <locale>\n\n// trim from start (in place)\ninline void Parser::ltrim(std::string &s) {\n    s.erase(s.begin(), std::find_if(s.begin(), s.end(), [](int ch) {\n        return !std::isspace(ch);\n    }));\n}\n\n// trim from end (in place)\ninline void Parser::rtrim(std::string &s) {\n    s.erase(std::find_if(s.rbegin(), s.rend(), [](int ch) {\n        return !std::isspace(ch);\n    }).base(), s.end());\n}\n\nParser::Parser() {\n}\n\nbool Parser::isCharDigit(char c) {\n\tstd::string acceptableNumberChars = \"-.0123456789\";\n\tfor (auto checkNum : acceptableNumberChars) {\n\t\tif (c == checkNum) return true;\n\t}\n\treturn false;\n}\n\nbool Parser::isStringNumber(std::string str) {\n\tbool hasDigit = false;\n\tbool hasPunctuation = false;\n\tfor (auto c : str) {\n\t\tif (!Parser::isCharDigit(c)) {\n\t\t\treturn false;\n\t\t}\n\t\tif (c == '.' || c == '-') {\n\t\t\thasPunctuation = true;\n\t\t} else {\n\t\t\thasDigit = true;\n\t\t}\n\t}\n\treturn (hasDigit && hasPunctuation) || hasDigit;\n}\n\nbool Parser::isLineFunctionDefinition(std::string line) {\n\tstd::stringstream lineS(line);\n\tstd::string f;\n    bool stringDepth = false;\n    int listDepth = 0;\n\twhile (std::getline(lineS, f, ' ')) {\n        if (Parser::recognizeFunction(f) == LIST_FUNCTION) {\n            listDepth++;\n        } else if (f == \"]\") {\n            listDepth--;\n        } else if (Parser::recognizeFunction(f) == STRING_FUNCTION) {\n            stringDepth = !stringDepth;\n        }\n        if (listDepth == 0 && !stringDepth) {\n            if (Parser::recognizeFunction(f) == FUNCTION_DEFINITION) {\n                return true;\n            }\n        }\n\t}\n\treturn false;\n}\n\nbool Parser::isLineTypeSignature(std::string line) {\n\tstd::stringstream lineS(line);\n\tstd::string f;\n    bool stringDepth = false;\n    int listDepth = 0;\n\twhile (std::getline(lineS, f, ' ')) {\n        if (Parser::recognizeFunction(f) == LIST_FUNCTION) {\n            listDepth++;\n        } else if (f == \"]\") {\n            listDepth--;\n        } else if (Parser::recognizeFunction(f) == STRING_FUNCTION) {\n            stringDepth = !stringDepth;\n        }\n        if (listDepth == 0 && !stringDepth) {\n            if (f == \"::\") {\n                return true;\n            }\n        }\n\t}\n\treturn false;\n}\n\nCharmTypes Parser::tokenToType(std::string token) {\n    if (token == \"any\") {\n        return TYPESIG_ANY;\n    } else if (token == \"list\") {\n        return TYPESIG_LIST;\n    } else if (token == \"list/string\") {\n        return TYPESIG_LISTSTRING;\n    } else if (token == \"string\") {\n        return TYPESIG_STRING;\n    } else if (token == \"int\") {\n        return TYPESIG_INT;\n    } else if (token == \"float\") {\n        return TYPESIG_FLOAT;\n    } else {\n        std::stringstream errorOut;\n        errorOut << \"Unrecognized type: \" << token << std::endl;\n        runtime_die(errorOut.str());\n    }\n}\nCharmTypeSignature Parser::parseTypeSignature(std::string line) {\n\tCharmTypeSignature typeSignature;\n\t//this is called only if Parser::isLineFunctionDefinition was true, so that guarentees that\n\t//the string \" := \" is somewhere in this string\n\tauto colonIndex = line.find(\"::\");\n\ttypeSignature.functionName = line.substr(0, colonIndex);\n\tParser::rtrim(typeSignature.functionName);\n\tParser::ltrim(typeSignature.functionName);\n\n    ParseUnit:\n    CharmTypeSignatureUnit unit;\n\tstd::string typeStringRest = line.substr(colonIndex + 2);\n    std::string typeStringToken;\n\n    //first, parse the popped types\n    while (Parser::advanceParse(typeStringToken, typeStringRest)) {\n        if (typeStringToken == \"\") {\n            continue;\n        }\n        if (typeStringToken == \"->\") {\n            break;\n        }\n        if (typeStringToken == \"|\") {\n            //this is only valid after an entire type signature has been specified.\n            //thus, using it before a -> is invalid\n            runtime_die(\"Type alternative specified before completion of type\");\n        }\n        unit.pops.push_back(Parser::tokenToType(typeStringToken));\n    }\n\n    //then, parse the pushed types\n    while (Parser::advanceParse(typeStringToken, typeStringRest)) {\n        if (typeStringToken == \"\") {\n            continue;\n        }\n        if (typeStringToken == \"|\") {\n            Parser::advanceParse(typeStringToken, typeStringRest);\n            typeSignature.units.push_back(unit);\n            goto ParseUnit;\n        }\n        unit.pushes.push_back(Parser::tokenToType(typeStringToken));\n    }\n    typeSignature.units.push_back(unit);\n\treturn typeSignature;\n}\n\n\nCharmFunctionType Parser::recognizeFunction(std::string s) {\n\tif (s == \"[\") return LIST_FUNCTION;\n\tif (s == \"\\\"\") return STRING_FUNCTION;\n\tif (s == \":=\") return FUNCTION_DEFINITION;\n\t//if it's not any of those two\n\tif (Parser::isStringNumber(s)) return NUMBER_FUNCTION;\n\t//if it's just a string, it's just a function\n\treturn DEFINED_FUNCTION;\n}\n\nCharmFunctionDefinitionInfo Parser::analyzeDefinition(CharmFunction f) {\n\tCharmFunctionDefinitionInfo out;\n\t//first, we fill in the info and see if the function is not recursive/inlineable\n\tout.inlineable = fA.isInlinable(f);\n\t//then we fill in the inlineDefinitions deque, for parsing future DEFINED_FUNCTIONs\n\tif (out.inlineable) {\n\t\tfA.addToInlineDefinitions(f);\n\t}\n\tout.tailCallRecursive = fA.isTailCallRecursive(f);\n\treturn out;\n}\n\nCharmFunction Parser::parseDefinition(std::string line) {\n\t//if there was a function definition, do some weird stuff\n\t//set functionType to FUNCTION_DEFINITION (duh)\n\t//take the first token before the := and set it to the functionName\n\t//take all the tokens after the :=, parse them, and make them the literalFunctions\n\tCharmFunction currentFunction;\n\tcurrentFunction.functionType = FUNCTION_DEFINITION;\n\tstd::pair<std::string, std::string> nameAndDef;\n\n\t//this is called only if Parser::isLineFunctionDefinition was true, so that guarentees that\n\t//the string \" := \" is somewhere in this string\n\tauto equalsIndex = line.find(\":=\");\n\tnameAndDef.first = line.substr(0, equalsIndex);\n\tParser::rtrim(nameAndDef.first);\n\tParser::ltrim(nameAndDef.first);\n\tnameAndDef.second = line.substr(equalsIndex + 2);\n\t//now we set the stuff!\n\tcurrentFunction.functionName = nameAndDef.first;\n\tONLYDEBUG printf(\"FUNCTION IS NAMED %s\\n\", currentFunction.functionName.c_str());\n\tONLYDEBUG printf(\"FUNCTION BODY IS %s\\n\", nameAndDef.second.c_str());\n\tcurrentFunction.literalFunctions = Parser::lex(nameAndDef.second).first;\n\t//we outta here!\n\n\t//then, we analyze the function before returning it\n\tCharmFunctionDefinitionInfo functionInfo = Parser::analyzeDefinition(currentFunction);\n\tcurrentFunction.definitionInfo = functionInfo;\n\tONLYDEBUG printf(\"IS %s INLINEABLE? %s\\n\", currentFunction.functionName.c_str(), currentFunction.definitionInfo.inlineable ? \"Yes\" : \"No\");\n\tONLYDEBUG printf(\"IS %s TAIL CALL RECURSIVE? %s\\n\", currentFunction.functionName.c_str(), currentFunction.definitionInfo.tailCallRecursive ? \"Yes\" : \"No\");\n\treturn currentFunction;\n}\n\nCharmFunction Parser::parseDefinedFunction(std::string tok) {\n\tCharmFunction out;\n\tout.functionType = DEFINED_FUNCTION;\n\tout.functionName = tok;\n\treturn out;\n}\n\nCharmFunction Parser::parseNumberFunction(std::string tok) {\n\tCharmFunction out;\n\tout.functionType = NUMBER_FUNCTION;\n\tCharmNumber numberValue;\n\t//if it contains a '.' it's a long double\n\t//if not it's a long long\n\tif (tok.find('.') != std::string::npos) {\n\t\tnumberValue.whichType = FLOAT_VALUE;\n\t\tnumberValue.floatValue = std::stold(tok);\n\t} else {\n\t\tnumberValue.whichType = INTEGER_VALUE;\n\t\tnumberValue.integerValue = std::stoll(tok);\n\t}\n\tout.numberValue = numberValue;\n\treturn out;\n}\n\nstd::string Parser::escapeString(std::string tok) {\n    for (auto c = tok.begin(); c != tok.end(); c++) {\n        //this will return \"\\ \" unmodified\n        if (c == std::prev(tok.end())) {\n            break;\n        }\n        if (*c == '\\\\') {\n            auto i = c - tok.begin();\n            if (*std::next(c) == 'n') {\n                tok.replace(i, 2, \"\\n\");\n            } else if (*std::next(c) == '\\\"') {\n                tok.replace(i, 2, \"\\\"\");\n            } else if (*std::next(c) == 't') {\n                tok.replace(i, 2, \"\\t\");\n            } else if (*std::next(c) == '0') {\n                tok.replace(i, 2, \"\\0\");\n            } else if (*std::next(c) == '\\\\') {\n                tok.replace(i, 2, \"\\\\\");\n            }\n        }\n    }\n    return tok;\n}\nCharmFunction Parser::parseStringFunction(std::string& token, std::string& rest) {\n\tCharmFunction out;\n\tout.functionType = STRING_FUNCTION;\n    //a string continues until it hits a \" \\\" \" token\n    std::stringstream outS;\n    while (Parser::advanceParse(token, rest)) {\n        if (token == \"\\\"\") {\n            break;\n        }\n        outS << Parser::escapeString(token) << \" \";\n    }\n    out.stringValue = outS.str();\n    //if our string is non-empty, there will be a final space pushed to it that\n    //we don't want. delete it here.\n    if (out.stringValue.size() > 0) {\n        out.stringValue.erase(std::prev(out.stringValue.end()));\n    }\n\t//make sure that the final quote was removed if it exists\n\t//(AKA we're not at the end of the line)\n\t//FINALLY we can fill in out\n\treturn out;\n}\n\nCharmFunction Parser::parseListFunction(std::string& token, std::string& rest) {\n\tCharmFunction out;\n\tout.functionType = LIST_FUNCTION;\n\t//and not a string. this time, we look for a \"]\"\n\t//to end the list (or a new line. that works too)\n\t//first, we have to make another string with the contents\n\t//this is just like the string\n\tstd::stringstream outS;\n\tstd::stringstream listS(rest);\n\tint listDepth = 1;\n\tstd::string f;\n\twhile (std::getline(listS, f, ' ')) {\n\t\tParser::advanceParse(token, rest);\n\t\tONLYDEBUG printf(\"LIST DEPTH %i\\n\", listDepth);\n\t\tif (Parser::recognizeFunction(token) == LIST_FUNCTION) {\n\t\t   //if we see another \"[\" inside of here, we increase listDepth in order to not break on the first ]\n\t\t   listDepth++;\n\t\t} else if (token == \"]\") {\n\t\t   //else, we decrease listDepth\n\t\t   //remember, the loop ends when listDepth is zero, and it starts at one.\n\t\t   //additionally: ] is NOT a function and is not parsed as one, and weirdness ensues if it is\n\t\t   listDepth--;\n\t\t   if (listDepth <= 0) {\n\t\t\t   break;\n\t\t   }\n\t\t}\n\t\toutS << token << \" \";\n\t}\n\t//finally, we can put the inside of the [ ] into the out\n\tout.literalFunctions = Parser::lexAskToInline(outS.str(), false).first;\n\treturn out;\n}\n\nvoid Parser::delegateParsing(CHARM_LIST_TYPE& out, std::string& token, std::string& rest, bool willInline) {\n\tONLYDEBUG printf(\"DELEGATE PARSING %s\\n\", token.c_str());\n\tCharmFunction currentFunction;\n\tCharmFunctionType type = Parser::recognizeFunction(token);\n\tif (type == DEFINED_FUNCTION) {\n\t\t//deal with DEFINED_FUNCTION first, easiest to deal with\n\t\tcurrentFunction = Parser::parseDefinedFunction(token);\n\t\t//if we're doing inline optimizations, do them here:\n\t\tif (OPTIMIZE_INLINE && willInline) {\n\t\t\tONLYDEBUG puts(\"WE ARE DOING INLINE DEFINITIONS\");\n\t\t\tif (fA.doInline(out, currentFunction)) {\n\t\t\t\t//if the function was able to be inline optimized, skip the final push_back\n\t\t\t\t//this means that we don't push a duplicate currentFunction\n\t\t\t\treturn;\n\t\t\t}\n\t\t}\n\t} else if (type == NUMBER_FUNCTION) {\n\t\t//next deal with NUMBER_FUNCTION\n\t\tcurrentFunction = Parser::parseNumberFunction(token);\n\t} else if (type == STRING_FUNCTION) {\n\t\t//next deal with STRING_FUNCTION\n\t\tcurrentFunction = Parser::parseStringFunction(token, rest);\n\t} else if (type == LIST_FUNCTION) {\n\t\t//same thing as before, except it's a list\n\t\tcurrentFunction = Parser::parseListFunction(token, rest);\n\t}\n\tout.push_back(currentFunction);\n\tif (DEBUGMODE) {\n\t\tprintf(\"AFTER 1 TOKEN, OUT NOW LOOKS LIKE THIS:\\n     \");\n\t\tfor (CharmFunction f : out) {\n\t\t\tprintf(\"%s \", charmFunctionToString(f).c_str());\n\t\t}\n\t\tprintf(\"\\n\");\n\t}\n}\n\nbool Parser::advanceParse(std::string& token, std::string& rest) {\n    if (rest == \"\") {\n        return false;\n    }\n\tauto nextSpace = rest.find_first_of(' ');\n\tif (nextSpace == std::string::npos) {\n\t\ttoken = rest;\n\t\trest = \"\";\n\t} else {\n\t\ttoken = rest.substr(0, nextSpace);\n\t\trest = rest.substr(nextSpace + 1);\n\t}\n    return true;\n}\n\nstd::pair<CHARM_LIST_TYPE, FunctionAnalyzer*> Parser::lexAskToInline(const std::string charmInput, bool willInline) {\n\tONLYDEBUG printf(\"WILL PARSE %s\\n\", charmInput.c_str());\n\tCHARM_LIST_TYPE out;\n\n\tstd::stringstream charmInputS(charmInput);\n\tstd::string line;\n\twhile (std::getline(charmInputS, line, '\\n')) {\n\t\t//first, check and make sure that this line doesn't\n\t\t//contain a function definition before parsing it\n\t\tif (isLineFunctionDefinition(line)) {\n\t\t\t//deal with FUNCTION_DEFINITION\n\t\t\tout.push_back(Parser::parseDefinition(line));\n\t\t} else if (isLineTypeSignature(line)) {\n            fA.addTypeSignature(Parser::parseTypeSignature(line));\n        } else {\n\t\t\tstd::string rest = line;\n\t\t\tstd::string token;\n\t\t\twhile (Parser::advanceParse(token, rest)) {\n\t\t\t\tif (token == \"\") {\n\t\t\t\t\t//if the token is empty bc multiple spaces\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t\tdelegateParsing(out, token, rest, willInline);\n\t\t\t}\n\t\t}\n\t}\n\t//wow, we're finally done with this abomination of a function\n\tstd::pair<CHARM_LIST_TYPE, FunctionAnalyzer*> outPair(out, &fA);\n\treturn outPair;\n}\nstd::pair<CHARM_LIST_TYPE, FunctionAnalyzer*> Parser::lex(const std::string charmInput) {\n\treturn Parser::lexAskToInline(charmInput, true);\n}\n","// -*- C++ -*-\n//===--------------------------- istream ----------------------------------===//\n//\n//                     The LLVM Compiler Infrastructure\n//\n// This file is dual licensed under the MIT and the University of Illinois Open\n// Source Licenses. See LICENSE.TXT for details.\n//\n//===----------------------------------------------------------------------===//\n\n#ifndef _LIBCPP_ISTREAM\n#define _LIBCPP_ISTREAM\n\n/*\n    istream synopsis\n\ntemplate <class charT, class traits = char_traits<charT> >\nclass basic_istream\n    : virtual public basic_ios<charT,traits>\n{\npublic:\n    // types (inherited from basic_ios (27.5.4)):\n    typedef charT                          char_type;\n    typedef traits                         traits_type;\n    typedef typename traits_type::int_type int_type;\n    typedef typename traits_type::pos_type pos_type;\n    typedef typename traits_type::off_type off_type;\n\n    // 27.7.1.1.1 Constructor/destructor:\n    explicit basic_istream(basic_streambuf<char_type, traits_type>* sb);\n    basic_istream(basic_istream&& rhs);\n    virtual ~basic_istream();\n\n    // 27.7.1.1.2 Assign/swap:\n    basic_istream& operator=(basic_istream&& rhs);\n    void swap(basic_istream& rhs);\n\n    // 27.7.1.1.3 Prefix/suffix:\n    class sentry;\n\n    // 27.7.1.2 Formatted input:\n    basic_istream& operator>>(basic_istream& (*pf)(basic_istream&));\n    basic_istream& operator>>(basic_ios<char_type, traits_type>&\n                              (*pf)(basic_ios<char_type, traits_type>&));\n    basic_istream& operator>>(ios_base& (*pf)(ios_base&));\n    basic_istream& operator>>(basic_streambuf<char_type, traits_type>* sb);\n    basic_istream& operator>>(bool& n);\n    basic_istream& operator>>(short& n);\n    basic_istream& operator>>(unsigned short& n);\n    basic_istream& operator>>(int& n);\n    basic_istream& operator>>(unsigned int& n);\n    basic_istream& operator>>(long& n);\n    basic_istream& operator>>(unsigned long& n);\n    basic_istream& operator>>(long long& n);\n    basic_istream& operator>>(unsigned long long& n);\n    basic_istream& operator>>(float& f);\n    basic_istream& operator>>(double& f);\n    basic_istream& operator>>(long double& f);\n    basic_istream& operator>>(void*& p);\n\n    // 27.7.1.3 Unformatted input:\n    streamsize gcount() const;\n    int_type get();\n    basic_istream& get(char_type& c);\n    basic_istream& get(char_type* s, streamsize n);\n    basic_istream& get(char_type* s, streamsize n, char_type delim);\n    basic_istream& get(basic_streambuf<char_type,traits_type>& sb);\n    basic_istream& get(basic_streambuf<char_type,traits_type>& sb, char_type delim);\n\n    basic_istream& getline(char_type* s, streamsize n);\n    basic_istream& getline(char_type* s, streamsize n, char_type delim);\n\n    basic_istream& ignore(streamsize n = 1, int_type delim = traits_type::eof());\n    int_type peek();\n    basic_istream& read (char_type* s, streamsize n);\n    streamsize readsome(char_type* s, streamsize n);\n\n    basic_istream& putback(char_type c);\n    basic_istream& unget();\n    int sync();\n\n    pos_type tellg();\n    basic_istream& seekg(pos_type);\n    basic_istream& seekg(off_type, ios_base::seekdir);\nprotected:\n    basic_istream(const basic_istream& rhs) = delete;\n    basic_istream(basic_istream&& rhs);\n    // 27.7.2.1.2 Assign/swap:\n    basic_istream& operator=(const basic_istream& rhs) = delete;\n    basic_istream& operator=(basic_istream&& rhs);\n    void swap(basic_istream& rhs);\n};\n\n// 27.7.1.2.3 character extraction templates:\ntemplate<class charT, class traits>\n  basic_istream<charT,traits>& operator>>(basic_istream<charT,traits>&, charT&);\n\ntemplate<class traits>\n  basic_istream<char,traits>& operator>>(basic_istream<char,traits>&, unsigned char&);\n\ntemplate<class traits>\n  basic_istream<char,traits>& operator>>(basic_istream<char,traits>&, signed char&);\n\ntemplate<class charT, class traits>\n  basic_istream<charT,traits>& operator>>(basic_istream<charT,traits>&, charT*);\n\ntemplate<class traits>\n  basic_istream<char,traits>& operator>>(basic_istream<char,traits>&, unsigned char*);\n\ntemplate<class traits>\n  basic_istream<char,traits>& operator>>(basic_istream<char,traits>&, signed char*);\n\ntemplate <class charT, class traits>\n  void\n  swap(basic_istream<charT, traits>& x, basic_istream<charT, traits>& y);\n\ntypedef basic_istream<char> istream;\ntypedef basic_istream<wchar_t> wistream;\n\ntemplate <class charT, class traits = char_traits<charT> >\nclass basic_iostream :\n    public basic_istream<charT,traits>,\n    public basic_ostream<charT,traits>\n{\npublic:\n    // types:\n    typedef charT                          char_type;\n    typedef traits                         traits_type;\n    typedef typename traits_type::int_type int_type;\n    typedef typename traits_type::pos_type pos_type;\n    typedef typename traits_type::off_type off_type;\n\n    // constructor/destructor\n    explicit basic_iostream(basic_streambuf<char_type, traits_type>* sb);\n    basic_iostream(basic_iostream&& rhs);\n    virtual ~basic_iostream();\n\n    // assign/swap\n    basic_iostream& operator=(basic_iostream&& rhs);\n    void swap(basic_iostream& rhs);\n};\n\ntemplate <class charT, class traits>\n  void\n  swap(basic_iostream<charT, traits>& x, basic_iostream<charT, traits>& y);\n\ntypedef basic_iostream<char> iostream;\ntypedef basic_iostream<wchar_t> wiostream;\n\ntemplate <class charT, class traits>\n  basic_istream<charT,traits>&\n  ws(basic_istream<charT,traits>& is);\n\ntemplate <class charT, class traits, class T>\n  basic_istream<charT, traits>&\n  operator>>(basic_istream<charT, traits>&& is, T& x);\n\n}  // std\n\n*/\n\n#include <__config>\n#include <ostream>\n\n#include <__undef_min_max>\n\n#if !defined(_LIBCPP_HAS_NO_PRAGMA_SYSTEM_HEADER)\n#pragma GCC system_header\n#endif\n\n_LIBCPP_BEGIN_NAMESPACE_STD\n\ntemplate <class _CharT, class _Traits>\nclass _LIBCPP_TEMPLATE_VIS basic_istream\n    : virtual public basic_ios<_CharT, _Traits>\n{\n    streamsize __gc_;\npublic:\n    // types (inherited from basic_ios (27.5.4)):\n    typedef _CharT                         char_type;\n    typedef _Traits                        traits_type;\n    typedef typename traits_type::int_type int_type;\n    typedef typename traits_type::pos_type pos_type;\n    typedef typename traits_type::off_type off_type;\n\n    // 27.7.1.1.1 Constructor/destructor:\n    inline _LIBCPP_EXTERN_TEMPLATE_INLINE_VISIBILITY\n    explicit basic_istream(basic_streambuf<char_type, traits_type>* __sb) : __gc_(0)\n    { this->init(__sb); }\n    virtual ~basic_istream();\nprotected:\n#ifndef _LIBCPP_HAS_NO_RVALUE_REFERENCES\n    inline _LIBCPP_INLINE_VISIBILITY\n    basic_istream(basic_istream&& __rhs);\n#endif\n    // 27.7.1.1.2 Assign/swap:\n#ifndef _LIBCPP_HAS_NO_RVALUE_REFERENCES\n    inline _LIBCPP_INLINE_VISIBILITY\n    basic_istream& operator=(basic_istream&& __rhs);\n#endif\n\n    inline _LIBCPP_EXTERN_TEMPLATE_INLINE_VISIBILITY\n    void swap(basic_istream& __rhs) {\n      _VSTD::swap(__gc_, __rhs.__gc_);\n      basic_ios<char_type, traits_type>::swap(__rhs);\n    }\n\n#ifndef _LIBCPP_CXX03_LANG\n    basic_istream           (const basic_istream& __rhs) = delete;\n    basic_istream& operator=(const basic_istream& __rhs) = delete;\n#endif\npublic:\n\n    // 27.7.1.1.3 Prefix/suffix:\n    class _LIBCPP_TEMPLATE_VIS sentry;\n\n    // 27.7.1.2 Formatted input:\n    inline _LIBCPP_EXTERN_TEMPLATE_INLINE_VISIBILITY\n    basic_istream& operator>>(basic_istream& (*__pf)(basic_istream&))\n    { return __pf(*this); }\n\n    inline _LIBCPP_EXTERN_TEMPLATE_INLINE_VISIBILITY\n    basic_istream& operator>>(basic_ios<char_type, traits_type>&\n                              (*__pf)(basic_ios<char_type, traits_type>&))\n    { __pf(*this); return *this; }\n\n    inline _LIBCPP_EXTERN_TEMPLATE_INLINE_VISIBILITY\n    basic_istream& operator>>(ios_base& (*__pf)(ios_base&))\n    { __pf(*this); return *this; }\n\n    basic_istream& operator>>(basic_streambuf<char_type, traits_type>* __sb);\n    basic_istream& operator>>(bool& __n);\n    basic_istream& operator>>(short& __n);\n    basic_istream& operator>>(unsigned short& __n);\n    basic_istream& operator>>(int& __n);\n    basic_istream& operator>>(unsigned int& __n);\n    basic_istream& operator>>(long& __n);\n    basic_istream& operator>>(unsigned long& __n);\n    basic_istream& operator>>(long long& __n);\n    basic_istream& operator>>(unsigned long long& __n);\n    basic_istream& operator>>(float& __f);\n    basic_istream& operator>>(double& __f);\n    basic_istream& operator>>(long double& __f);\n    basic_istream& operator>>(void*& __p);\n\n    // 27.7.1.3 Unformatted input:\n    _LIBCPP_INLINE_VISIBILITY\n    streamsize gcount() const {return __gc_;}\n    int_type get();\n\n    inline _LIBCPP_EXTERN_TEMPLATE_INLINE_VISIBILITY\n    basic_istream& get(char_type& __c) {\n      int_type __ch = get();\n      if (__ch != traits_type::eof())\n        __c = traits_type::to_char_type(__ch);\n      return *this;\n    }\n\n    inline _LIBCPP_EXTERN_TEMPLATE_INLINE_VISIBILITY\n    basic_istream& get(char_type* __s, streamsize __n)\n    { return get(__s, __n, this->widen('\\n')); }\n\n    basic_istream& get(char_type* __s, streamsize __n, char_type __dlm);\n\n    inline _LIBCPP_EXTERN_TEMPLATE_INLINE_VISIBILITY\n    basic_istream& get(basic_streambuf<char_type, traits_type>& __sb)\n    { return get(__sb, this->widen('\\n')); }\n\n    basic_istream& get(basic_streambuf<char_type, traits_type>& __sb, char_type __dlm);\n\n    inline _LIBCPP_EXTERN_TEMPLATE_INLINE_VISIBILITY\n    basic_istream& getline(char_type* __s, streamsize __n)\n    { return getline(__s, __n, this->widen('\\n')); }\n\n    basic_istream& getline(char_type* __s, streamsize __n, char_type __dlm);\n\n    basic_istream& ignore(streamsize __n = 1, int_type __dlm = traits_type::eof());\n    int_type peek();\n    basic_istream& read (char_type* __s, streamsize __n);\n    streamsize readsome(char_type* __s, streamsize __n);\n\n    basic_istream& putback(char_type __c);\n    basic_istream& unget();\n    int sync();\n\n    pos_type tellg();\n    basic_istream& seekg(pos_type __pos);\n    basic_istream& seekg(off_type __off, ios_base::seekdir __dir);\n};\n\ntemplate <class _CharT, class _Traits>\nclass _LIBCPP_TEMPLATE_VIS basic_istream<_CharT, _Traits>::sentry\n{\n    bool __ok_;\n\n    sentry(const sentry&); // = delete;\n    sentry& operator=(const sentry&); // = delete;\n\npublic:\n    explicit sentry(basic_istream<_CharT, _Traits>& __is, bool __noskipws = false);\n//    ~sentry() = default;\n\n    _LIBCPP_INLINE_VISIBILITY\n        _LIBCPP_EXPLICIT\n        operator bool() const {return __ok_;}\n};\n\ntemplate <class _CharT, class _Traits>\nbasic_istream<_CharT, _Traits>::sentry::sentry(basic_istream<_CharT, _Traits>& __is,\n                                               bool __noskipws)\n    : __ok_(false)\n{\n    if (__is.good())\n    {\n        if (__is.tie())\n            __is.tie()->flush();\n        if (!__noskipws && (__is.flags() & ios_base::skipws))\n        {\n            typedef istreambuf_iterator<_CharT, _Traits> _Ip;\n            const ctype<_CharT>& __ct = use_facet<ctype<_CharT> >(__is.getloc());\n            _Ip __i(__is);\n            _Ip __eof;\n            for (; __i != __eof; ++__i)\n                if (!__ct.is(__ct.space, *__i))\n                    break;\n            if (__i == __eof)\n                __is.setstate(ios_base::failbit | ios_base::eofbit);\n        }\n        __ok_ = __is.good();\n    }\n    else\n        __is.setstate(ios_base::failbit);\n}\n\n#ifndef _LIBCPP_HAS_NO_RVALUE_REFERENCES\n\ntemplate <class _CharT, class _Traits>\nbasic_istream<_CharT, _Traits>::basic_istream(basic_istream&& __rhs)\n    : __gc_(__rhs.__gc_)\n{\n    __rhs.__gc_ = 0;\n    this->move(__rhs);\n}\n\ntemplate <class _CharT, class _Traits>\nbasic_istream<_CharT, _Traits>&\nbasic_istream<_CharT, _Traits>::operator=(basic_istream&& __rhs)\n{\n    swap(__rhs);\n    return *this;\n}\n\n#endif  // _LIBCPP_HAS_NO_RVALUE_REFERENCES\n\ntemplate <class _CharT, class _Traits>\nbasic_istream<_CharT, _Traits>::~basic_istream()\n{\n}\n\ntemplate <class _CharT, class _Traits>\nbasic_istream<_CharT, _Traits>&\nbasic_istream<_CharT, _Traits>::operator>>(unsigned short& __n)\n{\n#ifndef _LIBCPP_NO_EXCEPTIONS\n    try\n    {\n#endif  // _LIBCPP_NO_EXCEPTIONS\n        sentry __s(*this);\n        if (__s)\n        {\n            typedef istreambuf_iterator<char_type, traits_type> _Ip;\n            typedef num_get<char_type, _Ip> _Fp;\n            ios_base::iostate __err = ios_base::goodbit;\n            use_facet<_Fp>(this->getloc()).get(_Ip(*this), _Ip(), *this, __err, __n);\n            this->setstate(__err);\n        }\n#ifndef _LIBCPP_NO_EXCEPTIONS\n    }\n    catch (...)\n    {\n        this->__set_badbit_and_consider_rethrow();\n    }\n#endif  // _LIBCPP_NO_EXCEPTIONS\n    return *this;\n}\n\ntemplate <class _CharT, class _Traits>\nbasic_istream<_CharT, _Traits>&\nbasic_istream<_CharT, _Traits>::operator>>(unsigned int& __n)\n{\n#ifndef _LIBCPP_NO_EXCEPTIONS\n    try\n    {\n#endif  // _LIBCPP_NO_EXCEPTIONS\n        sentry __s(*this);\n        if (__s)\n        {\n            typedef istreambuf_iterator<char_type, traits_type> _Ip;\n            typedef num_get<char_type, _Ip> _Fp;\n            ios_base::iostate __err = ios_base::goodbit;\n            use_facet<_Fp>(this->getloc()).get(_Ip(*this), _Ip(), *this, __err, __n);\n            this->setstate(__err);\n        }\n#ifndef _LIBCPP_NO_EXCEPTIONS\n    }\n    catch (...)\n    {\n        this->__set_badbit_and_consider_rethrow();\n    }\n#endif  // _LIBCPP_NO_EXCEPTIONS\n    return *this;\n}\n\ntemplate <class _CharT, class _Traits>\nbasic_istream<_CharT, _Traits>&\nbasic_istream<_CharT, _Traits>::operator>>(long& __n)\n{\n#ifndef _LIBCPP_NO_EXCEPTIONS\n    try\n    {\n#endif  // _LIBCPP_NO_EXCEPTIONS\n        sentry __s(*this);\n        if (__s)\n        {\n            typedef istreambuf_iterator<char_type, traits_type> _Ip;\n            typedef num_get<char_type, _Ip> _Fp;\n            ios_base::iostate __err = ios_base::goodbit;\n            use_facet<_Fp>(this->getloc()).get(_Ip(*this), _Ip(), *this, __err, __n);\n            this->setstate(__err);\n        }\n#ifndef _LIBCPP_NO_EXCEPTIONS\n    }\n    catch (...)\n    {\n        this->__set_badbit_and_consider_rethrow();\n    }\n#endif  // _LIBCPP_NO_EXCEPTIONS\n    return *this;\n}\n\ntemplate <class _CharT, class _Traits>\nbasic_istream<_CharT, _Traits>&\nbasic_istream<_CharT, _Traits>::operator>>(unsigned long& __n)\n{\n#ifndef _LIBCPP_NO_EXCEPTIONS\n    try\n    {\n#endif  // _LIBCPP_NO_EXCEPTIONS\n        sentry __s(*this);\n        if (__s)\n        {\n            typedef istreambuf_iterator<char_type, traits_type> _Ip;\n            typedef num_get<char_type, _Ip> _Fp;\n            ios_base::iostate __err = ios_base::goodbit;\n            use_facet<_Fp>(this->getloc()).get(_Ip(*this), _Ip(), *this, __err, __n);\n            this->setstate(__err);\n        }\n#ifndef _LIBCPP_NO_EXCEPTIONS\n    }\n    catch (...)\n    {\n        this->__set_badbit_and_consider_rethrow();\n    }\n#endif  // _LIBCPP_NO_EXCEPTIONS\n    return *this;\n}\n\ntemplate <class _CharT, class _Traits>\nbasic_istream<_CharT, _Traits>&\nbasic_istream<_CharT, _Traits>::operator>>(long long& __n)\n{\n#ifndef _LIBCPP_NO_EXCEPTIONS\n    try\n    {\n#endif  // _LIBCPP_NO_EXCEPTIONS\n        sentry __s(*this);\n        if (__s)\n        {\n            typedef istreambuf_iterator<char_type, traits_type> _Ip;\n            typedef num_get<char_type, _Ip> _Fp;\n            ios_base::iostate __err = ios_base::goodbit;\n            use_facet<_Fp>(this->getloc()).get(_Ip(*this), _Ip(), *this, __err, __n);\n            this->setstate(__err);\n        }\n#ifndef _LIBCPP_NO_EXCEPTIONS\n    }\n    catch (...)\n    {\n        this->__set_badbit_and_consider_rethrow();\n    }\n#endif  // _LIBCPP_NO_EXCEPTIONS\n    return *this;\n}\n\ntemplate <class _CharT, class _Traits>\nbasic_istream<_CharT, _Traits>&\nbasic_istream<_CharT, _Traits>::operator>>(unsigned long long& __n)\n{\n#ifndef _LIBCPP_NO_EXCEPTIONS\n    try\n    {\n#endif  // _LIBCPP_NO_EXCEPTIONS\n        sentry __s(*this);\n        if (__s)\n        {\n            typedef istreambuf_iterator<char_type, traits_type> _Ip;\n            typedef num_get<char_type, _Ip> _Fp;\n            ios_base::iostate __err = ios_base::goodbit;\n            use_facet<_Fp>(this->getloc()).get(_Ip(*this), _Ip(), *this, __err, __n);\n            this->setstate(__err);\n        }\n#ifndef _LIBCPP_NO_EXCEPTIONS\n    }\n    catch (...)\n    {\n        this->__set_badbit_and_consider_rethrow();\n    }\n#endif  // _LIBCPP_NO_EXCEPTIONS\n    return *this;\n}\n\ntemplate <class _CharT, class _Traits>\nbasic_istream<_CharT, _Traits>&\nbasic_istream<_CharT, _Traits>::operator>>(float& __n)\n{\n#ifndef _LIBCPP_NO_EXCEPTIONS\n    try\n    {\n#endif  // _LIBCPP_NO_EXCEPTIONS\n        sentry __s(*this);\n        if (__s)\n        {\n            typedef istreambuf_iterator<char_type, traits_type> _Ip;\n            typedef num_get<char_type, _Ip> _Fp;\n            ios_base::iostate __err = ios_base::goodbit;\n            use_facet<_Fp>(this->getloc()).get(_Ip(*this), _Ip(), *this, __err, __n);\n            this->setstate(__err);\n        }\n#ifndef _LIBCPP_NO_EXCEPTIONS\n    }\n    catch (...)\n    {\n        this->__set_badbit_and_consider_rethrow();\n    }\n#endif  // _LIBCPP_NO_EXCEPTIONS\n    return *this;\n}\n\ntemplate <class _CharT, class _Traits>\nbasic_istream<_CharT, _Traits>&\nbasic_istream<_CharT, _Traits>::operator>>(double& __n)\n{\n#ifndef _LIBCPP_NO_EXCEPTIONS\n    try\n    {\n#endif  // _LIBCPP_NO_EXCEPTIONS\n        sentry __s(*this);\n        if (__s)\n        {\n            typedef istreambuf_iterator<char_type, traits_type> _Ip;\n            typedef num_get<char_type, _Ip> _Fp;\n            ios_base::iostate __err = ios_base::goodbit;\n            use_facet<_Fp>(this->getloc()).get(_Ip(*this), _Ip(), *this, __err, __n);\n            this->setstate(__err);\n        }\n#ifndef _LIBCPP_NO_EXCEPTIONS\n    }\n    catch (...)\n    {\n        this->__set_badbit_and_consider_rethrow();\n    }\n#endif  // _LIBCPP_NO_EXCEPTIONS\n    return *this;\n}\n\ntemplate <class _CharT, class _Traits>\nbasic_istream<_CharT, _Traits>&\nbasic_istream<_CharT, _Traits>::operator>>(long double& __n)\n{\n#ifndef _LIBCPP_NO_EXCEPTIONS\n    try\n    {\n#endif  // _LIBCPP_NO_EXCEPTIONS\n        sentry __s(*this);\n        if (__s)\n        {\n            typedef istreambuf_iterator<char_type, traits_type> _Ip;\n            typedef num_get<char_type, _Ip> _Fp;\n            ios_base::iostate __err = ios_base::goodbit;\n            use_facet<_Fp>(this->getloc()).get(_Ip(*this), _Ip(), *this, __err, __n);\n            this->setstate(__err);\n        }\n#ifndef _LIBCPP_NO_EXCEPTIONS\n    }\n    catch (...)\n    {\n        this->__set_badbit_and_consider_rethrow();\n    }\n#endif  // _LIBCPP_NO_EXCEPTIONS\n    return *this;\n}\n\ntemplate <class _CharT, class _Traits>\nbasic_istream<_CharT, _Traits>&\nbasic_istream<_CharT, _Traits>::operator>>(bool& __n)\n{\n#ifndef _LIBCPP_NO_EXCEPTIONS\n    try\n    {\n#endif  // _LIBCPP_NO_EXCEPTIONS\n        sentry __s(*this);\n        if (__s)\n        {\n            typedef istreambuf_iterator<char_type, traits_type> _Ip;\n            typedef num_get<char_type, _Ip> _Fp;\n            ios_base::iostate __err = ios_base::goodbit;\n            use_facet<_Fp>(this->getloc()).get(_Ip(*this), _Ip(), *this, __err, __n);\n            this->setstate(__err);\n        }\n#ifndef _LIBCPP_NO_EXCEPTIONS\n    }\n    catch (...)\n    {\n        this->__set_badbit_and_consider_rethrow();\n    }\n#endif  // _LIBCPP_NO_EXCEPTIONS\n    return *this;\n}\n\ntemplate <class _CharT, class _Traits>\nbasic_istream<_CharT, _Traits>&\nbasic_istream<_CharT, _Traits>::operator>>(void*& __n)\n{\n#ifndef _LIBCPP_NO_EXCEPTIONS\n    try\n    {\n#endif  // _LIBCPP_NO_EXCEPTIONS\n        sentry __s(*this);\n        if (__s)\n        {\n            typedef istreambuf_iterator<char_type, traits_type> _Ip;\n            typedef num_get<char_type, _Ip> _Fp;\n            ios_base::iostate __err = ios_base::goodbit;\n            use_facet<_Fp>(this->getloc()).get(_Ip(*this), _Ip(), *this, __err, __n);\n            this->setstate(__err);\n        }\n#ifndef _LIBCPP_NO_EXCEPTIONS\n    }\n    catch (...)\n    {\n        this->__set_badbit_and_consider_rethrow();\n    }\n#endif  // _LIBCPP_NO_EXCEPTIONS\n    return *this;\n}\n\ntemplate <class _CharT, class _Traits>\nbasic_istream<_CharT, _Traits>&\nbasic_istream<_CharT, _Traits>::operator>>(short& __n)\n{\n#ifndef _LIBCPP_NO_EXCEPTIONS\n    try\n    {\n#endif  // _LIBCPP_NO_EXCEPTIONS\n        sentry __s(*this);\n        if (__s)\n        {\n            typedef istreambuf_iterator<char_type, traits_type> _Ip;\n            typedef num_get<char_type, _Ip> _Fp;\n            ios_base::iostate __err = ios_base::goodbit;\n            long __temp;\n            use_facet<_Fp>(this->getloc()).get(_Ip(*this), _Ip(), *this, __err, __temp);\n            if (__temp < numeric_limits<short>::min())\n            {\n                __err |= ios_base::failbit;\n                __n = numeric_limits<short>::min();\n            }\n            else if (__temp > numeric_limits<short>::max())\n            {\n                __err |= ios_base::failbit;\n                __n = numeric_limits<short>::max();\n            }\n            else\n                __n = static_cast<short>(__temp);\n            this->setstate(__err);\n        }\n#ifndef _LIBCPP_NO_EXCEPTIONS\n    }\n    catch (...)\n    {\n        this->__set_badbit_and_consider_rethrow();\n    }\n#endif  // _LIBCPP_NO_EXCEPTIONS\n    return *this;\n}\n\ntemplate <class _CharT, class _Traits>\nbasic_istream<_CharT, _Traits>&\nbasic_istream<_CharT, _Traits>::operator>>(int& __n)\n{\n#ifndef _LIBCPP_NO_EXCEPTIONS\n    try\n    {\n#endif  // _LIBCPP_NO_EXCEPTIONS\n        sentry __s(*this);\n        if (__s)\n        {\n            typedef istreambuf_iterator<char_type, traits_type> _Ip;\n            typedef num_get<char_type, _Ip> _Fp;\n            ios_base::iostate __err = ios_base::goodbit;\n            long __temp;\n            use_facet<_Fp>(this->getloc()).get(_Ip(*this), _Ip(), *this, __err, __temp);\n            if (__temp < numeric_limits<int>::min())\n            {\n                __err |= ios_base::failbit;\n                __n = numeric_limits<int>::min();\n            }\n            else if (__temp > numeric_limits<int>::max())\n            {\n                __err |= ios_base::failbit;\n                __n = numeric_limits<int>::max();\n            }\n            else\n                __n = static_cast<int>(__temp);\n            this->setstate(__err);\n        }\n#ifndef _LIBCPP_NO_EXCEPTIONS\n    }\n    catch (...)\n    {\n        this->__set_badbit_and_consider_rethrow();\n    }\n#endif  // _LIBCPP_NO_EXCEPTIONS\n    return *this;\n}\n\ntemplate<class _CharT, class _Traits>\nbasic_istream<_CharT, _Traits>&\noperator>>(basic_istream<_CharT, _Traits>& __is, _CharT* __s)\n{\n#ifndef _LIBCPP_NO_EXCEPTIONS\n    try\n    {\n#endif  // _LIBCPP_NO_EXCEPTIONS\n        typename basic_istream<_CharT, _Traits>::sentry __sen(__is);\n        if (__sen)\n        {\n            streamsize __n = __is.width();\n            if (__n <= 0)\n                __n = numeric_limits<streamsize>::max() / sizeof(_CharT) - 1;\n            streamsize __c = 0;\n            const ctype<_CharT>& __ct = use_facet<ctype<_CharT> >(__is.getloc());\n            ios_base::iostate __err = ios_base::goodbit;\n            while (__c < __n-1)\n            {\n                typename _Traits::int_type __i = __is.rdbuf()->sgetc();\n                if (_Traits::eq_int_type(__i, _Traits::eof()))\n                {\n                   __err |= ios_base::eofbit;\n                   break;\n                }\n                _CharT __ch = _Traits::to_char_type(__i);\n                if (__ct.is(__ct.space, __ch))\n                    break;\n                *__s++ = __ch;\n                ++__c;\n                 __is.rdbuf()->sbumpc();\n            }\n            *__s = _CharT();\n            __is.width(0);\n            if (__c == 0)\n               __err |= ios_base::failbit;\n            __is.setstate(__err);\n        }\n#ifndef _LIBCPP_NO_EXCEPTIONS\n    }\n    catch (...)\n    {\n        __is.__set_badbit_and_consider_rethrow();\n    }\n#endif  // _LIBCPP_NO_EXCEPTIONS\n    return __is;\n}\n\ntemplate<class _Traits>\ninline _LIBCPP_INLINE_VISIBILITY\nbasic_istream<char, _Traits>&\noperator>>(basic_istream<char, _Traits>& __is, unsigned char* __s)\n{\n    return __is >> (char*)__s;\n}\n\ntemplate<class _Traits>\ninline _LIBCPP_INLINE_VISIBILITY\nbasic_istream<char, _Traits>&\noperator>>(basic_istream<char, _Traits>& __is, signed char* __s)\n{\n    return __is >> (char*)__s;\n}\n\ntemplate<class _CharT, class _Traits>\nbasic_istream<_CharT, _Traits>&\noperator>>(basic_istream<_CharT, _Traits>& __is, _CharT& __c)\n{\n#ifndef _LIBCPP_NO_EXCEPTIONS\n    try\n    {\n#endif  // _LIBCPP_NO_EXCEPTIONS\n        typename basic_istream<_CharT, _Traits>::sentry __sen(__is);\n        if (__sen)\n        {\n            typename _Traits::int_type __i = __is.rdbuf()->sbumpc();\n            if (_Traits::eq_int_type(__i, _Traits::eof()))\n                __is.setstate(ios_base::eofbit | ios_base::failbit);\n            else\n                __c = _Traits::to_char_type(__i);\n        }\n#ifndef _LIBCPP_NO_EXCEPTIONS\n    }\n    catch (...)\n    {\n        __is.__set_badbit_and_consider_rethrow();\n    }\n#endif  // _LIBCPP_NO_EXCEPTIONS\n    return __is;\n}\n\ntemplate<class _Traits>\ninline _LIBCPP_INLINE_VISIBILITY\nbasic_istream<char, _Traits>&\noperator>>(basic_istream<char, _Traits>& __is, unsigned char& __c)\n{\n    return __is >> (char&)__c;\n}\n\ntemplate<class _Traits>\ninline _LIBCPP_INLINE_VISIBILITY\nbasic_istream<char, _Traits>&\noperator>>(basic_istream<char, _Traits>& __is, signed char& __c)\n{\n    return __is >> (char&)__c;\n}\n\ntemplate<class _CharT, class _Traits>\nbasic_istream<_CharT, _Traits>&\nbasic_istream<_CharT, _Traits>::operator>>(basic_streambuf<char_type, traits_type>* __sb)\n{\n    __gc_ = 0;\n#ifndef _LIBCPP_NO_EXCEPTIONS\n    try\n    {\n#endif  // _LIBCPP_NO_EXCEPTIONS\n        sentry __s(*this, true);\n        if (__s)\n        {\n            if (__sb)\n            {\n#ifndef _LIBCPP_NO_EXCEPTIONS\n                try\n                {\n#endif  // _LIBCPP_NO_EXCEPTIONS\n                    ios_base::iostate __err = ios_base::goodbit;\n                    while (true)\n                    {\n                        typename traits_type::int_type __i = this->rdbuf()->sgetc();\n                        if (traits_type::eq_int_type(__i, _Traits::eof()))\n                        {\n                           __err |= ios_base::eofbit;\n                           break;\n                        }\n                        if (traits_type::eq_int_type(\n                                __sb->sputc(traits_type::to_char_type(__i)),\n                                traits_type::eof()))\n                            break;\n                        ++__gc_;\n                        this->rdbuf()->sbumpc();\n                    }\n                    if (__gc_ == 0)\n                       __err |= ios_base::failbit;\n                    this->setstate(__err);\n#ifndef _LIBCPP_NO_EXCEPTIONS\n                }\n                catch (...)\n                {\n                    if (__gc_ == 0)\n                        this->__set_failbit_and_consider_rethrow();\n                }\n#endif  // _LIBCPP_NO_EXCEPTIONS\n            }\n            else\n                this->setstate(ios_base::failbit);\n        }\n#ifndef _LIBCPP_NO_EXCEPTIONS\n    }\n    catch (...)\n    {\n        this->__set_badbit_and_consider_rethrow();\n    }\n#endif  // _LIBCPP_NO_EXCEPTIONS\n    return *this;\n}\n\ntemplate<class _CharT, class _Traits>\ntypename basic_istream<_CharT, _Traits>::int_type\nbasic_istream<_CharT, _Traits>::get()\n{\n    __gc_ = 0;\n    int_type __r = traits_type::eof();\n#ifndef _LIBCPP_NO_EXCEPTIONS\n    try\n    {\n#endif  // _LIBCPP_NO_EXCEPTIONS\n        sentry __s(*this, true);\n        if (__s)\n        {\n            __r = this->rdbuf()->sbumpc();\n            if (traits_type::eq_int_type(__r, traits_type::eof()))\n               this->setstate(ios_base::failbit | ios_base::eofbit);\n            else\n                __gc_ = 1;\n        }\n#ifndef _LIBCPP_NO_EXCEPTIONS\n    }\n    catch (...)\n    {\n        this->__set_badbit_and_consider_rethrow();\n    }\n#endif  // _LIBCPP_NO_EXCEPTIONS\n    return __r;\n}\n\ntemplate<class _CharT, class _Traits>\nbasic_istream<_CharT, _Traits>&\nbasic_istream<_CharT, _Traits>::get(char_type* __s, streamsize __n, char_type __dlm)\n{\n    __gc_ = 0;\n#ifndef _LIBCPP_NO_EXCEPTIONS\n    try\n    {\n#endif  // _LIBCPP_NO_EXCEPTIONS\n        sentry __sen(*this, true);\n        if (__sen)\n        {\n            if (__n > 0)\n            {\n                ios_base::iostate __err = ios_base::goodbit;\n                while (__gc_ < __n-1)\n                {\n                    int_type __i = this->rdbuf()->sgetc();\n                    if (traits_type::eq_int_type(__i, traits_type::eof()))\n                    {\n                       __err |= ios_base::eofbit;\n                       break;\n                    }\n                    char_type __ch = traits_type::to_char_type(__i);\n                    if (traits_type::eq(__ch, __dlm))\n                        break;\n                    *__s++ = __ch;\n                    ++__gc_;\n                     this->rdbuf()->sbumpc();\n                }\n                *__s = char_type();\n                if (__gc_ == 0)\n                   __err |= ios_base::failbit;\n                this->setstate(__err);\n            }\n            else\n                this->setstate(ios_base::failbit);\n        }\n#ifndef _LIBCPP_NO_EXCEPTIONS\n    }\n    catch (...)\n    {\n        this->__set_badbit_and_consider_rethrow();\n    }\n#endif  // _LIBCPP_NO_EXCEPTIONS\n    return *this;\n}\n\ntemplate<class _CharT, class _Traits>\nbasic_istream<_CharT, _Traits>&\nbasic_istream<_CharT, _Traits>::get(basic_streambuf<char_type, traits_type>& __sb,\n                                    char_type __dlm)\n{\n    __gc_ = 0;\n#ifndef _LIBCPP_NO_EXCEPTIONS\n    try\n    {\n#endif  // _LIBCPP_NO_EXCEPTIONS\n        sentry __sen(*this, true);\n        if (__sen)\n        {\n            ios_base::iostate __err = ios_base::goodbit;\n#ifndef _LIBCPP_NO_EXCEPTIONS\n            try\n            {\n#endif  // _LIBCPP_NO_EXCEPTIONS\n                while (true)\n                {\n                    typename traits_type::int_type __i = this->rdbuf()->sgetc();\n                    if (traits_type::eq_int_type(__i, traits_type::eof()))\n                    {\n                       __err |= ios_base::eofbit;\n                       break;\n                    }\n                    char_type __ch = traits_type::to_char_type(__i);\n                    if (traits_type::eq(__ch, __dlm))\n                        break;\n                    if (traits_type::eq_int_type(__sb.sputc(__ch), traits_type::eof()))\n                        break;\n                    ++__gc_;\n                    this->rdbuf()->sbumpc();\n                }\n#ifndef _LIBCPP_NO_EXCEPTIONS\n            }\n            catch (...)\n            {\n            }\n#endif  // _LIBCPP_NO_EXCEPTIONS\n            if (__gc_ == 0)\n               __err |= ios_base::failbit;\n            this->setstate(__err);\n        }\n#ifndef _LIBCPP_NO_EXCEPTIONS\n    }\n    catch (...)\n    {\n        this->__set_badbit_and_consider_rethrow();\n    }\n#endif  // _LIBCPP_NO_EXCEPTIONS\n    return *this;\n}\n\ntemplate<class _CharT, class _Traits>\nbasic_istream<_CharT, _Traits>&\nbasic_istream<_CharT, _Traits>::getline(char_type* __s, streamsize __n, char_type __dlm)\n{\n    __gc_ = 0;\n#ifndef _LIBCPP_NO_EXCEPTIONS\n    try\n    {\n#endif  // _LIBCPP_NO_EXCEPTIONS\n        sentry __sen(*this, true);\n        if (__sen)\n        {\n            ios_base::iostate __err = ios_base::goodbit;\n            while (true)\n            {\n                typename traits_type::int_type __i = this->rdbuf()->sgetc();\n                if (traits_type::eq_int_type(__i, traits_type::eof()))\n                {\n                   __err |= ios_base::eofbit;\n                   break;\n                }\n                char_type __ch = traits_type::to_char_type(__i);\n                if (traits_type::eq(__ch, __dlm))\n                {\n                    this->rdbuf()->sbumpc();\n                    ++__gc_;\n                    break;\n                }\n                if (__gc_ >= __n-1)\n                {\n                    __err |= ios_base::failbit;\n                    break;\n                }\n                *__s++ = __ch;\n                this->rdbuf()->sbumpc();\n                ++__gc_;\n            }\n            if (__n > 0)\n                *__s = char_type();\n            if (__gc_ == 0)\n               __err |= ios_base::failbit;\n            this->setstate(__err);\n        }\n#ifndef _LIBCPP_NO_EXCEPTIONS\n    }\n    catch (...)\n    {\n        this->__set_badbit_and_consider_rethrow();\n    }\n#endif  // _LIBCPP_NO_EXCEPTIONS\n    return *this;\n}\n\ntemplate<class _CharT, class _Traits>\nbasic_istream<_CharT, _Traits>&\nbasic_istream<_CharT, _Traits>::ignore(streamsize __n, int_type __dlm)\n{\n    __gc_ = 0;\n#ifndef _LIBCPP_NO_EXCEPTIONS\n    try\n    {\n#endif  // _LIBCPP_NO_EXCEPTIONS\n        sentry __sen(*this, true);\n        if (__sen)\n        {\n            ios_base::iostate __err = ios_base::goodbit;\n            if (__n == numeric_limits<streamsize>::max())\n            {\n                while (true)\n                {\n                    typename traits_type::int_type __i = this->rdbuf()->sbumpc();\n                    if (traits_type::eq_int_type(__i, traits_type::eof()))\n                    {\n                       __err |= ios_base::eofbit;\n                       break;\n                    }\n                    ++__gc_;\n                    if (traits_type::eq_int_type(__i, __dlm))\n                        break;\n                }\n            }\n            else\n            {\n                while (__gc_ < __n)\n                {\n                    typename traits_type::int_type __i = this->rdbuf()->sbumpc();\n                    if (traits_type::eq_int_type(__i, traits_type::eof()))\n                    {\n                       __err |= ios_base::eofbit;\n                       break;\n                    }\n                    ++__gc_;\n                    if (traits_type::eq_int_type(__i, __dlm))\n                        break;\n                }\n            }\n            this->setstate(__err);\n        }\n#ifndef _LIBCPP_NO_EXCEPTIONS\n    }\n    catch (...)\n    {\n        this->__set_badbit_and_consider_rethrow();\n    }\n#endif  // _LIBCPP_NO_EXCEPTIONS\n    return *this;\n}\n\ntemplate<class _CharT, class _Traits>\ntypename basic_istream<_CharT, _Traits>::int_type\nbasic_istream<_CharT, _Traits>::peek()\n{\n    __gc_ = 0;\n    int_type __r = traits_type::eof();\n#ifndef _LIBCPP_NO_EXCEPTIONS\n    try\n    {\n#endif  // _LIBCPP_NO_EXCEPTIONS\n        sentry __sen(*this, true);\n        if (__sen)\n        {\n            __r = this->rdbuf()->sgetc();\n            if (traits_type::eq_int_type(__r, traits_type::eof()))\n                this->setstate(ios_base::eofbit);\n        }\n#ifndef _LIBCPP_NO_EXCEPTIONS\n    }\n    catch (...)\n    {\n        this->__set_badbit_and_consider_rethrow();\n    }\n#endif  // _LIBCPP_NO_EXCEPTIONS\n    return __r;\n}\n\ntemplate<class _CharT, class _Traits>\nbasic_istream<_CharT, _Traits>&\nbasic_istream<_CharT, _Traits>::read(char_type* __s, streamsize __n)\n{\n    __gc_ = 0;\n#ifndef _LIBCPP_NO_EXCEPTIONS\n    try\n    {\n#endif  // _LIBCPP_NO_EXCEPTIONS\n        sentry __sen(*this, true);\n        if (__sen)\n        {\n            __gc_ = this->rdbuf()->sgetn(__s, __n);\n            if (__gc_ != __n)\n                this->setstate(ios_base::failbit | ios_base::eofbit);\n        }\n        else\n            this->setstate(ios_base::failbit);\n#ifndef _LIBCPP_NO_EXCEPTIONS\n    }\n    catch (...)\n    {\n        this->__set_badbit_and_consider_rethrow();\n    }\n#endif  // _LIBCPP_NO_EXCEPTIONS\n    return *this;\n}\n\ntemplate<class _CharT, class _Traits>\nstreamsize\nbasic_istream<_CharT, _Traits>::readsome(char_type* __s, streamsize __n)\n{\n    __gc_ = 0;\n#ifndef _LIBCPP_NO_EXCEPTIONS\n    try\n    {\n#endif  // _LIBCPP_NO_EXCEPTIONS\n        sentry __sen(*this, true);\n        if (__sen)\n        {\n            streamsize __c = this->rdbuf()->in_avail();\n            switch (__c)\n            {\n            case -1:\n                this->setstate(ios_base::eofbit);\n                break;\n            case 0:\n                break;\n            default:\n                read(__s, _VSTD::min(__c, __n));\n                break;\n            }\n        }\n        else\n            this->setstate(ios_base::failbit);\n#ifndef _LIBCPP_NO_EXCEPTIONS\n    }\n    catch (...)\n    {\n        this->__set_badbit_and_consider_rethrow();\n    }\n#endif  // _LIBCPP_NO_EXCEPTIONS\n    return __gc_;\n}\n\ntemplate<class _CharT, class _Traits>\nbasic_istream<_CharT, _Traits>&\nbasic_istream<_CharT, _Traits>::putback(char_type __c)\n{\n    __gc_ = 0;\n#ifndef _LIBCPP_NO_EXCEPTIONS\n    try\n    {\n#endif  // _LIBCPP_NO_EXCEPTIONS\n        this->clear(this->rdstate() & ~ios_base::eofbit);\n        sentry __sen(*this, true);\n        if (__sen)\n        {\n            if (this->rdbuf() == 0 || this->rdbuf()->sputbackc(__c) == traits_type::eof())\n                this->setstate(ios_base::badbit);\n        }\n        else\n            this->setstate(ios_base::failbit);\n#ifndef _LIBCPP_NO_EXCEPTIONS\n    }\n    catch (...)\n    {\n        this->__set_badbit_and_consider_rethrow();\n    }\n#endif  // _LIBCPP_NO_EXCEPTIONS\n    return *this;\n}\n\ntemplate<class _CharT, class _Traits>\nbasic_istream<_CharT, _Traits>&\nbasic_istream<_CharT, _Traits>::unget()\n{\n    __gc_ = 0;\n#ifndef _LIBCPP_NO_EXCEPTIONS\n    try\n    {\n#endif  // _LIBCPP_NO_EXCEPTIONS\n        this->clear(this->rdstate() & ~ios_base::eofbit);\n        sentry __sen(*this, true);\n        if (__sen)\n        {\n            if (this->rdbuf() == 0 || this->rdbuf()->sungetc() == traits_type::eof())\n                this->setstate(ios_base::badbit);\n        }\n        else\n            this->setstate(ios_base::failbit);\n#ifndef _LIBCPP_NO_EXCEPTIONS\n    }\n    catch (...)\n    {\n        this->__set_badbit_and_consider_rethrow();\n    }\n#endif  // _LIBCPP_NO_EXCEPTIONS\n    return *this;\n}\n\ntemplate<class _CharT, class _Traits>\nint\nbasic_istream<_CharT, _Traits>::sync()\n{\n    int __r = 0;\n#ifndef _LIBCPP_NO_EXCEPTIONS\n    try\n    {\n#endif  // _LIBCPP_NO_EXCEPTIONS\n        sentry __sen(*this, true);\n        if (__sen)\n        {\n            if (this->rdbuf() == 0)\n                return -1;\n            if (this->rdbuf()->pubsync() == -1)\n            {\n                this->setstate(ios_base::badbit);\n                return -1;\n            }\n        }\n#ifndef _LIBCPP_NO_EXCEPTIONS\n    }\n    catch (...)\n    {\n        this->__set_badbit_and_consider_rethrow();\n    }\n#endif  // _LIBCPP_NO_EXCEPTIONS\n    return __r;\n}\n\ntemplate<class _CharT, class _Traits>\ntypename basic_istream<_CharT, _Traits>::pos_type\nbasic_istream<_CharT, _Traits>::tellg()\n{\n    pos_type __r(-1);\n#ifndef _LIBCPP_NO_EXCEPTIONS\n    try\n    {\n#endif  // _LIBCPP_NO_EXCEPTIONS\n        sentry __sen(*this, true);\n        if (__sen)\n            __r = this->rdbuf()->pubseekoff(0, ios_base::cur, ios_base::in);\n#ifndef _LIBCPP_NO_EXCEPTIONS\n    }\n    catch (...)\n    {\n        this->__set_badbit_and_consider_rethrow();\n    }\n#endif  // _LIBCPP_NO_EXCEPTIONS\n    return __r;\n}\n\ntemplate<class _CharT, class _Traits>\nbasic_istream<_CharT, _Traits>&\nbasic_istream<_CharT, _Traits>::seekg(pos_type __pos)\n{\n#ifndef _LIBCPP_NO_EXCEPTIONS\n    try\n    {\n#endif  // _LIBCPP_NO_EXCEPTIONS\n        this->clear(this->rdstate() & ~ios_base::eofbit);\n        sentry __sen(*this, true);\n        if (__sen)\n        {\n            if (this->rdbuf()->pubseekpos(__pos, ios_base::in) == pos_type(-1))\n                this->setstate(ios_base::failbit);\n        }\n#ifndef _LIBCPP_NO_EXCEPTIONS\n    }\n    catch (...)\n    {\n        this->__set_badbit_and_consider_rethrow();\n    }\n#endif  // _LIBCPP_NO_EXCEPTIONS\n    return *this;\n}\n\ntemplate<class _CharT, class _Traits>\nbasic_istream<_CharT, _Traits>&\nbasic_istream<_CharT, _Traits>::seekg(off_type __off, ios_base::seekdir __dir)\n{\n#ifndef _LIBCPP_NO_EXCEPTIONS\n    try\n    {\n#endif  // _LIBCPP_NO_EXCEPTIONS\n        this->clear(this->rdstate() & ~ios_base::eofbit);\n        sentry __sen(*this, true);\n        if (__sen)\n        {\n            if (this->rdbuf()->pubseekoff(__off, __dir, ios_base::in) == pos_type(-1))\n                this->setstate(ios_base::failbit);\n        }\n#ifndef _LIBCPP_NO_EXCEPTIONS\n    }\n    catch (...)\n    {\n        this->__set_badbit_and_consider_rethrow();\n    }\n#endif  // _LIBCPP_NO_EXCEPTIONS\n    return *this;\n}\n\ntemplate <class _CharT, class _Traits>\nbasic_istream<_CharT, _Traits>&\nws(basic_istream<_CharT, _Traits>& __is)\n{\n#ifndef _LIBCPP_NO_EXCEPTIONS\n    try\n    {\n#endif  // _LIBCPP_NO_EXCEPTIONS\n        typename basic_istream<_CharT, _Traits>::sentry __sen(__is, true);\n        if (__sen)\n        {\n            const ctype<_CharT>& __ct = use_facet<ctype<_CharT> >(__is.getloc());\n            while (true)\n            {\n                typename _Traits::int_type __i = __is.rdbuf()->sgetc();\n                if (_Traits::eq_int_type(__i, _Traits::eof()))\n                {\n                   __is.setstate(ios_base::eofbit);\n                   break;\n                }\n                if (!__ct.is(__ct.space, _Traits::to_char_type(__i)))\n                    break;\n                __is.rdbuf()->sbumpc();\n            }\n        }\n#ifndef _LIBCPP_NO_EXCEPTIONS\n    }\n    catch (...)\n    {\n        __is.__set_badbit_and_consider_rethrow();\n    }\n#endif  // _LIBCPP_NO_EXCEPTIONS\n    return __is;\n}\n\n#ifndef _LIBCPP_HAS_NO_RVALUE_REFERENCES\n\ntemplate <class _CharT, class _Traits, class _Tp>\ninline _LIBCPP_INLINE_VISIBILITY\nbasic_istream<_CharT, _Traits>&\noperator>>(basic_istream<_CharT, _Traits>&& __is, _Tp&& __x)\n{\n    __is >> _VSTD::forward<_Tp>(__x);\n    return __is;\n}\n\n#endif  // _LIBCPP_HAS_NO_RVALUE_REFERENCES\n\ntemplate <class _CharT, class _Traits>\nclass _LIBCPP_TEMPLATE_VIS basic_iostream\n    : public basic_istream<_CharT, _Traits>,\n      public basic_ostream<_CharT, _Traits>\n{\npublic:\n    // types:\n    typedef _CharT                         char_type;\n    typedef _Traits                        traits_type;\n    typedef typename traits_type::int_type int_type;\n    typedef typename traits_type::pos_type pos_type;\n    typedef typename traits_type::off_type off_type;\n\n    // constructor/destructor\n    inline _LIBCPP_EXTERN_TEMPLATE_INLINE_VISIBILITY\n    explicit basic_iostream(basic_streambuf<char_type, traits_type>* __sb)\n      : basic_istream<_CharT, _Traits>(__sb)\n    {}\n\n    virtual ~basic_iostream();\nprotected:\n#ifndef _LIBCPP_HAS_NO_RVALUE_REFERENCES\n    inline _LIBCPP_INLINE_VISIBILITY\n    basic_iostream(basic_iostream&& __rhs);\n#endif\n\n    // assign/swap\n#ifndef _LIBCPP_HAS_NO_RVALUE_REFERENCES\n    inline _LIBCPP_INLINE_VISIBILITY\n    basic_iostream& operator=(basic_iostream&& __rhs);\n#endif\n    inline _LIBCPP_EXTERN_TEMPLATE_INLINE_VISIBILITY\n    void swap(basic_iostream& __rhs)\n    { basic_istream<char_type, traits_type>::swap(__rhs); }\npublic:\n};\n\n#ifndef _LIBCPP_HAS_NO_RVALUE_REFERENCES\n\ntemplate <class _CharT, class _Traits>\nbasic_iostream<_CharT, _Traits>::basic_iostream(basic_iostream&& __rhs)\n    : basic_istream<_CharT, _Traits>(_VSTD::move(__rhs))\n{\n}\n\ntemplate <class _CharT, class _Traits>\nbasic_iostream<_CharT, _Traits>&\nbasic_iostream<_CharT, _Traits>::operator=(basic_iostream&& __rhs)\n{\n    swap(__rhs);\n    return *this;\n}\n\n#endif  // _LIBCPP_HAS_NO_RVALUE_REFERENCES\n\ntemplate <class _CharT, class _Traits>\nbasic_iostream<_CharT, _Traits>::~basic_iostream()\n{\n}\n\ntemplate<class _CharT, class _Traits, class _Allocator>\nbasic_istream<_CharT, _Traits>&\noperator>>(basic_istream<_CharT, _Traits>& __is,\n           basic_string<_CharT, _Traits, _Allocator>& __str)\n{\n#ifndef _LIBCPP_NO_EXCEPTIONS\n    try\n    {\n#endif  // _LIBCPP_NO_EXCEPTIONS\n        typename basic_istream<_CharT, _Traits>::sentry __sen(__is);\n        if (__sen)\n        {\n            __str.clear();\n            streamsize __n = __is.width();\n            if (__n <= 0)\n                __n = __str.max_size();\n            if (__n <= 0)\n                __n = numeric_limits<streamsize>::max();\n            streamsize __c = 0;\n            const ctype<_CharT>& __ct = use_facet<ctype<_CharT> >(__is.getloc());\n            ios_base::iostate __err = ios_base::goodbit;\n            while (__c < __n)\n            {\n                typename _Traits::int_type __i = __is.rdbuf()->sgetc();\n                if (_Traits::eq_int_type(__i, _Traits::eof()))\n                {\n                   __err |= ios_base::eofbit;\n                   break;\n                }\n                _CharT __ch = _Traits::to_char_type(__i);\n                if (__ct.is(__ct.space, __ch))\n                    break;\n                __str.push_back(__ch);\n                ++__c;\n                 __is.rdbuf()->sbumpc();\n            }\n            __is.width(0);\n            if (__c == 0)\n               __err |= ios_base::failbit;\n            __is.setstate(__err);\n        }\n        else\n            __is.setstate(ios_base::failbit);\n#ifndef _LIBCPP_NO_EXCEPTIONS\n    }\n    catch (...)\n    {\n        __is.__set_badbit_and_consider_rethrow();\n    }\n#endif  // _LIBCPP_NO_EXCEPTIONS\n    return __is;\n}\n\ntemplate<class _CharT, class _Traits, class _Allocator>\nbasic_istream<_CharT, _Traits>&\ngetline(basic_istream<_CharT, _Traits>& __is,\n        basic_string<_CharT, _Traits, _Allocator>& __str, _CharT __dlm)\n{\n#ifndef _LIBCPP_NO_EXCEPTIONS\n    try\n    {\n#endif  // _LIBCPP_NO_EXCEPTIONS\n        typename basic_istream<_CharT, _Traits>::sentry __sen(__is, true);\n        if (__sen)\n        {\n            __str.clear();\n            ios_base::iostate __err = ios_base::goodbit;\n            streamsize __extr = 0;\n            while (true)\n            {\n                typename _Traits::int_type __i = __is.rdbuf()->sbumpc();\n                if (_Traits::eq_int_type(__i, _Traits::eof()))\n                {\n                   __err |= ios_base::eofbit;\n                   break;\n                }\n                ++__extr;\n                _CharT __ch = _Traits::to_char_type(__i);\n                if (_Traits::eq(__ch, __dlm))\n                    break;\n                __str.push_back(__ch);\n                if (__str.size() == __str.max_size())\n                {\n                    __err |= ios_base::failbit;\n                    break;\n                }\n            }\n            if (__extr == 0)\n               __err |= ios_base::failbit;\n            __is.setstate(__err);\n        }\n#ifndef _LIBCPP_NO_EXCEPTIONS\n    }\n    catch (...)\n    {\n        __is.__set_badbit_and_consider_rethrow();\n    }\n#endif  // _LIBCPP_NO_EXCEPTIONS\n    return __is;\n}\n\ntemplate<class _CharT, class _Traits, class _Allocator>\ninline _LIBCPP_INLINE_VISIBILITY\nbasic_istream<_CharT, _Traits>&\ngetline(basic_istream<_CharT, _Traits>& __is,\n        basic_string<_CharT, _Traits, _Allocator>& __str)\n{\n    return getline(__is, __str, __is.widen('\\n'));\n}\n\n#ifndef _LIBCPP_HAS_NO_RVALUE_REFERENCES\n\ntemplate<class _CharT, class _Traits, class _Allocator>\ninline _LIBCPP_INLINE_VISIBILITY\nbasic_istream<_CharT, _Traits>&\ngetline(basic_istream<_CharT, _Traits>&& __is,\n        basic_string<_CharT, _Traits, _Allocator>& __str, _CharT __dlm)\n{\n    return getline(__is, __str, __dlm);\n}\n\ntemplate<class _CharT, class _Traits, class _Allocator>\ninline _LIBCPP_INLINE_VISIBILITY\nbasic_istream<_CharT, _Traits>&\ngetline(basic_istream<_CharT, _Traits>&& __is,\n        basic_string<_CharT, _Traits, _Allocator>& __str)\n{\n    return getline(__is, __str, __is.widen('\\n'));\n}\n\n#endif  // _LIBCPP_HAS_NO_RVALUE_REFERENCES\n\ntemplate <class _CharT, class _Traits, size_t _Size>\nbasic_istream<_CharT, _Traits>&\noperator>>(basic_istream<_CharT, _Traits>& __is, bitset<_Size>& __x)\n{\n#ifndef _LIBCPP_NO_EXCEPTIONS\n    try\n    {\n#endif  // _LIBCPP_NO_EXCEPTIONS\n        typename basic_istream<_CharT, _Traits>::sentry __sen(__is);\n        if (__sen)\n        {\n            basic_string<_CharT, _Traits> __str;\n            const ctype<_CharT>& __ct = use_facet<ctype<_CharT> >(__is.getloc());\n            size_t __c = 0;\n            ios_base::iostate __err = ios_base::goodbit;\n            _CharT __zero = __ct.widen('0');\n            _CharT __one = __ct.widen('1');\n            while (__c < _Size)\n            {\n                typename _Traits::int_type __i = __is.rdbuf()->sgetc();\n                if (_Traits::eq_int_type(__i, _Traits::eof()))\n                {\n                   __err |= ios_base::eofbit;\n                   break;\n                }\n                _CharT __ch = _Traits::to_char_type(__i);\n                if (!_Traits::eq(__ch, __zero) && !_Traits::eq(__ch, __one))\n                    break;\n                __str.push_back(__ch);\n                ++__c;\n                 __is.rdbuf()->sbumpc();\n            }\n            __x = bitset<_Size>(__str);\n            if (__c == 0)\n               __err |= ios_base::failbit;\n            __is.setstate(__err);\n        }\n        else\n            __is.setstate(ios_base::failbit);\n#ifndef _LIBCPP_NO_EXCEPTIONS\n    }\n    catch (...)\n    {\n        __is.__set_badbit_and_consider_rethrow();\n    }\n#endif  // _LIBCPP_NO_EXCEPTIONS\n    return __is;\n}\n\n_LIBCPP_EXTERN_TEMPLATE(class _LIBCPP_EXTERN_TEMPLATE_TYPE_VIS basic_istream<char>)\n_LIBCPP_EXTERN_TEMPLATE(class _LIBCPP_EXTERN_TEMPLATE_TYPE_VIS basic_istream<wchar_t>)\n_LIBCPP_EXTERN_TEMPLATE(class _LIBCPP_EXTERN_TEMPLATE_TYPE_VIS basic_iostream<char>)\n\n_LIBCPP_END_NAMESPACE_STD\n\n#endif  // _LIBCPP_ISTREAM\n","// -*- C++ -*-\n//===---------------------------- ios -------------------------------------===//\n//\n//                     The LLVM Compiler Infrastructure\n//\n// This file is dual licensed under the MIT and the University of Illinois Open\n// Source Licenses. See LICENSE.TXT for details.\n//\n//===----------------------------------------------------------------------===//\n\n#ifndef _LIBCPP_IOS\n#define _LIBCPP_IOS\n\n/*\n    ios synopsis\n\n#include <iosfwd>\n\nnamespace std\n{\n\ntypedef OFF_T streamoff;\ntypedef SZ_T streamsize;\ntemplate <class stateT> class fpos;\n\nclass ios_base\n{\npublic:\n    class failure;\n\n    typedef T1 fmtflags;\n    static constexpr fmtflags boolalpha;\n    static constexpr fmtflags dec;\n    static constexpr fmtflags fixed;\n    static constexpr fmtflags hex;\n    static constexpr fmtflags internal;\n    static constexpr fmtflags left;\n    static constexpr fmtflags oct;\n    static constexpr fmtflags right;\n    static constexpr fmtflags scientific;\n    static constexpr fmtflags showbase;\n    static constexpr fmtflags showpoint;\n    static constexpr fmtflags showpos;\n    static constexpr fmtflags skipws;\n    static constexpr fmtflags unitbuf;\n    static constexpr fmtflags uppercase;\n    static constexpr fmtflags adjustfield;\n    static constexpr fmtflags basefield;\n    static constexpr fmtflags floatfield;\n\n    typedef T2 iostate;\n    static constexpr iostate badbit;\n    static constexpr iostate eofbit;\n    static constexpr iostate failbit;\n    static constexpr iostate goodbit;\n\n    typedef T3 openmode;\n    static constexpr openmode app;\n    static constexpr openmode ate;\n    static constexpr openmode binary;\n    static constexpr openmode in;\n    static constexpr openmode out;\n    static constexpr openmode trunc;\n\n    typedef T4 seekdir;\n    static constexpr seekdir beg;\n    static constexpr seekdir cur;\n    static constexpr seekdir end;\n\n    class Init;\n\n    // 27.5.2.2 fmtflags state:\n    fmtflags flags() const;\n    fmtflags flags(fmtflags fmtfl);\n    fmtflags setf(fmtflags fmtfl);\n    fmtflags setf(fmtflags fmtfl, fmtflags mask);\n    void unsetf(fmtflags mask);\n\n    streamsize precision() const;\n    streamsize precision(streamsize prec);\n    streamsize width() const;\n    streamsize width(streamsize wide);\n\n    // 27.5.2.3 locales:\n    locale imbue(const locale& loc);\n    locale getloc() const;\n\n    // 27.5.2.5 storage:\n    static int xalloc();\n    long& iword(int index);\n    void*& pword(int index);\n\n    // destructor\n    virtual ~ios_base();\n\n    // 27.5.2.6 callbacks;\n    enum event { erase_event, imbue_event, copyfmt_event };\n    typedef void (*event_callback)(event, ios_base&, int index);\n    void register_callback(event_callback fn, int index);\n\n    ios_base(const ios_base&) = delete;\n    ios_base& operator=(const ios_base&) = delete;\n\n    static bool sync_with_stdio(bool sync = true);\n\nprotected:\n    ios_base();\n};\n\ntemplate <class charT, class traits = char_traits<charT> >\nclass basic_ios\n    : public ios_base\n{\npublic:\n    // types:\n    typedef charT char_type;\n    typedef typename traits::int_type int_type;  // removed in C++17\n    typedef typename traits::pos_type pos_type;  // removed in C++17\n    typedef typename traits::off_type off_type;  // removed in C++17\n    typedef traits traits_type;\n\n    operator unspecified-bool-type() const;\n    bool operator!() const;\n    iostate rdstate() const;\n    void clear(iostate state = goodbit);\n    void setstate(iostate state);\n    bool good() const;\n    bool eof() const;\n    bool fail() const;\n    bool bad() const;\n\n    iostate exceptions() const;\n    void exceptions(iostate except);\n\n    // 27.5.4.1 Constructor/destructor:\n    explicit basic_ios(basic_streambuf<charT,traits>* sb);\n    virtual ~basic_ios();\n\n    // 27.5.4.2 Members:\n    basic_ostream<charT,traits>* tie() const;\n    basic_ostream<charT,traits>* tie(basic_ostream<charT,traits>* tiestr);\n\n    basic_streambuf<charT,traits>* rdbuf() const;\n    basic_streambuf<charT,traits>* rdbuf(basic_streambuf<charT,traits>* sb);\n\n    basic_ios& copyfmt(const basic_ios& rhs);\n\n    char_type fill() const;\n    char_type fill(char_type ch);\n\n    locale imbue(const locale& loc);\n\n    char narrow(char_type c, char dfault) const;\n    char_type widen(char c) const;\n\n    basic_ios(const basic_ios& ) = delete;\n    basic_ios& operator=(const basic_ios&) = delete;\n\nprotected:\n    basic_ios();\n    void init(basic_streambuf<charT,traits>* sb);\n    void move(basic_ios& rhs);\n    void swap(basic_ios& rhs) noexcept;\n    void set_rdbuf(basic_streambuf<charT, traits>* sb);\n};\n\n// 27.5.5, manipulators:\nios_base& boolalpha (ios_base& str);\nios_base& noboolalpha(ios_base& str);\nios_base& showbase (ios_base& str);\nios_base& noshowbase (ios_base& str);\nios_base& showpoint (ios_base& str);\nios_base& noshowpoint(ios_base& str);\nios_base& showpos (ios_base& str);\nios_base& noshowpos (ios_base& str);\nios_base& skipws (ios_base& str);\nios_base& noskipws (ios_base& str);\nios_base& uppercase (ios_base& str);\nios_base& nouppercase(ios_base& str);\nios_base& unitbuf (ios_base& str);\nios_base& nounitbuf (ios_base& str);\n\n// 27.5.5.2 adjustfield:\nios_base& internal (ios_base& str);\nios_base& left (ios_base& str);\nios_base& right (ios_base& str);\n\n// 27.5.5.3 basefield:\nios_base& dec (ios_base& str);\nios_base& hex (ios_base& str);\nios_base& oct (ios_base& str);\n\n// 27.5.5.4 floatfield:\nios_base& fixed (ios_base& str);\nios_base& scientific (ios_base& str);\nios_base& hexfloat (ios_base& str);\nios_base& defaultfloat(ios_base& str);\n\n// 27.5.5.5 error reporting:\nenum class io_errc\n{\n    stream = 1\n};\n\nconcept_map ErrorCodeEnum<io_errc> { };\nerror_code make_error_code(io_errc e) noexcept; \nerror_condition make_error_condition(io_errc e) noexcept; \nstorage-class-specifier const error_category& iostream_category() noexcept;\n\n}  // std\n\n*/\n\n#include <__config>\n#include <iosfwd>\n#include <__locale>\n#include <system_error>\n\n#if !defined(_LIBCPP_HAS_NO_ATOMIC_HEADER)\n#include <atomic>     // for __xindex_\n#endif\n\n#if !defined(_LIBCPP_HAS_NO_PRAGMA_SYSTEM_HEADER)\n#pragma GCC system_header\n#endif\n\n_LIBCPP_BEGIN_NAMESPACE_STD\n\ntypedef ptrdiff_t streamsize;\n\nclass _LIBCPP_TYPE_VIS ios_base\n{\npublic:\n    class _LIBCPP_EXCEPTION_ABI failure;\n\n    typedef unsigned int fmtflags;\n    static const fmtflags boolalpha   = 0x0001;\n    static const fmtflags dec         = 0x0002;\n    static const fmtflags fixed       = 0x0004;\n    static const fmtflags hex         = 0x0008;\n    static const fmtflags internal    = 0x0010;\n    static const fmtflags left        = 0x0020;\n    static const fmtflags oct         = 0x0040;\n    static const fmtflags right       = 0x0080;\n    static const fmtflags scientific  = 0x0100;\n    static const fmtflags showbase    = 0x0200;\n    static const fmtflags showpoint   = 0x0400;\n    static const fmtflags showpos     = 0x0800;\n    static const fmtflags skipws      = 0x1000;\n    static const fmtflags unitbuf     = 0x2000;\n    static const fmtflags uppercase   = 0x4000;\n    static const fmtflags adjustfield = left | right | internal;\n    static const fmtflags basefield   = dec | oct | hex;\n    static const fmtflags floatfield  = scientific | fixed;\n\n    typedef unsigned int iostate;\n    static const iostate badbit  = 0x1;\n    static const iostate eofbit  = 0x2;\n    static const iostate failbit = 0x4;\n    static const iostate goodbit = 0x0;\n\n    typedef unsigned int openmode;\n    static const openmode app    = 0x01;\n    static const openmode ate    = 0x02;\n    static const openmode binary = 0x04;\n    static const openmode in     = 0x08;\n    static const openmode out    = 0x10;\n    static const openmode trunc  = 0x20;\n\n    enum seekdir {beg, cur, end};\n\n#if _LIBCPP_STD_VER <= 14\n    typedef iostate      io_state;\n    typedef openmode     open_mode;\n    typedef seekdir      seek_dir;\n\n    typedef _VSTD::streamoff streamoff;\n    typedef _VSTD::streampos streampos;\n#endif\n\n    class _LIBCPP_TYPE_VIS Init;\n\n    // 27.5.2.2 fmtflags state:\n    _LIBCPP_INLINE_VISIBILITY fmtflags flags() const;\n    _LIBCPP_INLINE_VISIBILITY fmtflags flags(fmtflags __fmtfl);\n    _LIBCPP_INLINE_VISIBILITY fmtflags setf(fmtflags __fmtfl);\n    _LIBCPP_INLINE_VISIBILITY fmtflags setf(fmtflags __fmtfl, fmtflags __mask);\n    _LIBCPP_INLINE_VISIBILITY void unsetf(fmtflags __mask);\n\n    _LIBCPP_INLINE_VISIBILITY streamsize precision() const;\n    _LIBCPP_INLINE_VISIBILITY streamsize precision(streamsize __prec);\n    _LIBCPP_INLINE_VISIBILITY streamsize width() const;\n    _LIBCPP_INLINE_VISIBILITY streamsize width(streamsize __wide);\n\n    // 27.5.2.3 locales:\n    locale imbue(const locale& __loc);\n    locale getloc() const;\n\n    // 27.5.2.5 storage:\n    static int xalloc();\n    long& iword(int __index);\n    void*& pword(int __index);\n\n    // destructor\n    virtual ~ios_base();\n\n    // 27.5.2.6 callbacks;\n    enum event { erase_event, imbue_event, copyfmt_event };\n    typedef void (*event_callback)(event, ios_base&, int __index);\n    void register_callback(event_callback __fn, int __index);\n\nprivate:\n    ios_base(const ios_base&); // = delete;\n    ios_base& operator=(const ios_base&); // = delete;\n\npublic:\n    static bool sync_with_stdio(bool __sync = true);\n\n    _LIBCPP_INLINE_VISIBILITY iostate rdstate() const;\n    void clear(iostate __state = goodbit);\n    _LIBCPP_INLINE_VISIBILITY void setstate(iostate __state);\n\n    _LIBCPP_INLINE_VISIBILITY bool good() const;\n    _LIBCPP_INLINE_VISIBILITY bool eof() const;\n    _LIBCPP_INLINE_VISIBILITY bool fail() const;\n    _LIBCPP_INLINE_VISIBILITY bool bad() const;\n\n    _LIBCPP_INLINE_VISIBILITY iostate exceptions() const;\n    _LIBCPP_INLINE_VISIBILITY void exceptions(iostate __iostate);\n\n    void __set_badbit_and_consider_rethrow();\n    void __set_failbit_and_consider_rethrow();\n\nprotected:\n    _LIBCPP_INLINE_VISIBILITY\n    ios_base() {// purposefully does no initialization\n               }\n\n    void init(void* __sb);\n    _LIBCPP_ALWAYS_INLINE void* rdbuf() const {return __rdbuf_;}\n\n    _LIBCPP_ALWAYS_INLINE\n    void rdbuf(void* __sb)\n    {\n        __rdbuf_ = __sb;\n        clear();\n    }\n\n    void __call_callbacks(event);\n    void copyfmt(const ios_base&);\n    void move(ios_base&);\n    void swap(ios_base&) _NOEXCEPT;\n\n    _LIBCPP_ALWAYS_INLINE\n    void set_rdbuf(void* __sb)\n    {\n        __rdbuf_ = __sb;\n    }\n\nprivate:\n    // All data members must be scalars\n    fmtflags        __fmtflags_;\n    streamsize      __precision_;\n    streamsize      __width_;\n    iostate         __rdstate_;\n    iostate         __exceptions_;\n    void*           __rdbuf_;\n    void*           __loc_;\n    event_callback* __fn_;\n    int*            __index_;\n    size_t          __event_size_;\n    size_t          __event_cap_;\n// TODO(EricWF): Enable this for both Clang and GCC. Currently it is only\n// enabled with clang.\n#if defined(_LIBCPP_HAS_C_ATOMIC_IMP) && !defined(_LIBCPP_HAS_NO_THREADS)\n    static atomic<int> __xindex_;\n#else\n    static int      __xindex_;\n#endif\n    long*           __iarray_;\n    size_t          __iarray_size_;\n    size_t          __iarray_cap_;\n    void**          __parray_;\n    size_t          __parray_size_;\n    size_t          __parray_cap_;\n};\n\n//enum class io_errc\n_LIBCPP_DECLARE_STRONG_ENUM(io_errc)\n{\n    stream = 1\n};\n_LIBCPP_DECLARE_STRONG_ENUM_EPILOG(io_errc)\n\ntemplate <>\nstruct _LIBCPP_TEMPLATE_VIS is_error_code_enum<io_errc> : public true_type { };\n\n#ifdef _LIBCPP_HAS_NO_STRONG_ENUMS\ntemplate <>\nstruct _LIBCPP_TEMPLATE_VIS is_error_code_enum<io_errc::__lx> : public true_type { };\n#endif\n\n_LIBCPP_FUNC_VIS\nconst error_category& iostream_category() _NOEXCEPT;\n\ninline _LIBCPP_INLINE_VISIBILITY\nerror_code\nmake_error_code(io_errc __e) _NOEXCEPT\n{\n    return error_code(static_cast<int>(__e), iostream_category());\n}\n\ninline _LIBCPP_INLINE_VISIBILITY\nerror_condition\nmake_error_condition(io_errc __e) _NOEXCEPT\n{\n    return error_condition(static_cast<int>(__e), iostream_category());\n}\n\nclass _LIBCPP_EXCEPTION_ABI ios_base::failure\n    : public system_error\n{\npublic:\n    explicit failure(const string& __msg, const error_code& __ec = io_errc::stream);\n    explicit failure(const char* __msg, const error_code& __ec = io_errc::stream);\n    virtual ~failure() throw();\n};\n\nclass _LIBCPP_TYPE_VIS ios_base::Init\n{\npublic:\n    Init();\n    ~Init();\n};\n\n// fmtflags\n\ninline _LIBCPP_INLINE_VISIBILITY\nios_base::fmtflags\nios_base::flags() const\n{\n    return __fmtflags_;\n}\n\ninline _LIBCPP_INLINE_VISIBILITY\nios_base::fmtflags\nios_base::flags(fmtflags __fmtfl)\n{\n    fmtflags __r = __fmtflags_;\n    __fmtflags_ = __fmtfl;\n    return __r;\n}\n\ninline _LIBCPP_INLINE_VISIBILITY\nios_base::fmtflags\nios_base::setf(fmtflags __fmtfl)\n{\n    fmtflags __r = __fmtflags_;\n    __fmtflags_ |= __fmtfl;\n    return __r;\n}\n\ninline _LIBCPP_INLINE_VISIBILITY\nvoid\nios_base::unsetf(fmtflags __mask)\n{\n    __fmtflags_ &= ~__mask;\n}\n\ninline _LIBCPP_INLINE_VISIBILITY\nios_base::fmtflags\nios_base::setf(fmtflags __fmtfl, fmtflags __mask)\n{\n    fmtflags __r = __fmtflags_;\n    unsetf(__mask);\n    __fmtflags_ |= __fmtfl & __mask;\n    return __r;\n}\n\n// precision\n\ninline _LIBCPP_INLINE_VISIBILITY\nstreamsize\nios_base::precision() const\n{\n    return __precision_;\n}\n\ninline _LIBCPP_INLINE_VISIBILITY\nstreamsize\nios_base::precision(streamsize __prec)\n{\n    streamsize __r = __precision_;\n    __precision_ = __prec;\n    return __r;\n}\n\n// width\n\ninline _LIBCPP_INLINE_VISIBILITY\nstreamsize\nios_base::width() const\n{\n    return __width_;\n}\n\ninline _LIBCPP_INLINE_VISIBILITY\nstreamsize\nios_base::width(streamsize __wide)\n{\n    streamsize __r = __width_;\n    __width_ = __wide;\n    return __r;\n}\n\n// iostate\n\ninline _LIBCPP_INLINE_VISIBILITY\nios_base::iostate\nios_base::rdstate() const\n{\n    return __rdstate_;\n}\n\ninline _LIBCPP_INLINE_VISIBILITY\nvoid\nios_base::setstate(iostate __state)\n{\n    clear(__rdstate_ | __state);\n}\n\ninline _LIBCPP_INLINE_VISIBILITY\nbool\nios_base::good() const\n{\n    return __rdstate_ == 0;\n}\n\ninline _LIBCPP_INLINE_VISIBILITY\nbool\nios_base::eof() const\n{\n    return (__rdstate_ & eofbit) != 0;\n}\n\ninline _LIBCPP_INLINE_VISIBILITY\nbool\nios_base::fail() const\n{\n    return (__rdstate_ & (failbit | badbit)) != 0;\n}\n\ninline _LIBCPP_INLINE_VISIBILITY\nbool\nios_base::bad() const\n{\n    return (__rdstate_ & badbit) != 0;\n}\n\ninline _LIBCPP_INLINE_VISIBILITY\nios_base::iostate\nios_base::exceptions() const\n{\n    return __exceptions_;\n}\n\ninline _LIBCPP_INLINE_VISIBILITY\nvoid\nios_base::exceptions(iostate __iostate)\n{\n    __exceptions_ = __iostate;\n    clear(__rdstate_);\n}\n\n#if defined(_LIBCPP_CXX03_LANG)\nstruct _LIBCPP_TYPE_VIS __cxx03_bool {\n  typedef void (__cxx03_bool::*__bool_type)();\n  void __true_value() {}\n};\n#endif\n\ntemplate <class _CharT, class _Traits>\nclass _LIBCPP_TEMPLATE_VIS basic_ios\n    : public ios_base\n{\npublic:\n    // types:\n    typedef _CharT char_type;\n    typedef _Traits traits_type;\n\n    typedef typename traits_type::int_type int_type;\n    typedef typename traits_type::pos_type pos_type;\n    typedef typename traits_type::off_type off_type;\n\n#if defined(_LIBCPP_CXX03_LANG)\n    _LIBCPP_ALWAYS_INLINE\n    operator __cxx03_bool::__bool_type() const {\n        return !fail() ? &__cxx03_bool::__true_value : nullptr;\n    }\n#else\n    _LIBCPP_ALWAYS_INLINE\n    _LIBCPP_EXPLICIT operator bool() const {return !fail();}\n#endif\n\n    _LIBCPP_ALWAYS_INLINE bool operator!() const    {return  fail();}\n    _LIBCPP_ALWAYS_INLINE iostate rdstate() const   {return ios_base::rdstate();}\n    _LIBCPP_ALWAYS_INLINE void clear(iostate __state = goodbit) {ios_base::clear(__state);}\n    _LIBCPP_ALWAYS_INLINE void setstate(iostate __state) {ios_base::setstate(__state);}\n    _LIBCPP_ALWAYS_INLINE bool good() const {return ios_base::good();}\n    _LIBCPP_ALWAYS_INLINE bool eof() const  {return ios_base::eof();}\n    _LIBCPP_ALWAYS_INLINE bool fail() const {return ios_base::fail();}\n    _LIBCPP_ALWAYS_INLINE bool bad() const  {return ios_base::bad();}\n\n    _LIBCPP_ALWAYS_INLINE iostate exceptions() const {return ios_base::exceptions();}\n    _LIBCPP_ALWAYS_INLINE void exceptions(iostate __iostate) {ios_base::exceptions(__iostate);}\n\n    // 27.5.4.1 Constructor/destructor:\n    _LIBCPP_INLINE_VISIBILITY\n    explicit basic_ios(basic_streambuf<char_type,traits_type>* __sb);\n    virtual ~basic_ios();\n\n    // 27.5.4.2 Members:\n    _LIBCPP_INLINE_VISIBILITY \n    basic_ostream<char_type, traits_type>* tie() const;\n    _LIBCPP_INLINE_VISIBILITY \n    basic_ostream<char_type, traits_type>* tie(basic_ostream<char_type, traits_type>* __tiestr);\n\n    _LIBCPP_INLINE_VISIBILITY \n    basic_streambuf<char_type, traits_type>* rdbuf() const;\n    _LIBCPP_INLINE_VISIBILITY \n    basic_streambuf<char_type, traits_type>* rdbuf(basic_streambuf<char_type, traits_type>* __sb);\n\n    basic_ios& copyfmt(const basic_ios& __rhs);\n\n    _LIBCPP_INLINE_VISIBILITY \n    char_type fill() const;\n    _LIBCPP_INLINE_VISIBILITY \n    char_type fill(char_type __ch);\n\n    _LIBCPP_INLINE_VISIBILITY \n    locale imbue(const locale& __loc);\n\n    _LIBCPP_INLINE_VISIBILITY \n    char narrow(char_type __c, char __dfault) const;\n    _LIBCPP_INLINE_VISIBILITY \n    char_type widen(char __c) const;\n\nprotected:\n    _LIBCPP_ALWAYS_INLINE\n    basic_ios() {// purposefully does no initialization\n                }\n    _LIBCPP_INLINE_VISIBILITY \n    void init(basic_streambuf<char_type, traits_type>* __sb);\n\n    _LIBCPP_INLINE_VISIBILITY \n    void move(basic_ios& __rhs);\n#ifndef _LIBCPP_HAS_NO_RVALUE_REFERENCES\n    _LIBCPP_ALWAYS_INLINE\n    void move(basic_ios&& __rhs) {move(__rhs);}\n#endif\n    _LIBCPP_INLINE_VISIBILITY \n    void swap(basic_ios& __rhs) _NOEXCEPT;\n    _LIBCPP_INLINE_VISIBILITY \n    void set_rdbuf(basic_streambuf<char_type, traits_type>* __sb);\nprivate:\n    basic_ostream<char_type, traits_type>* __tie_;\n     mutable int_type __fill_;\n};\n\ntemplate <class _CharT, class _Traits>\ninline _LIBCPP_INLINE_VISIBILITY\nbasic_ios<_CharT, _Traits>::basic_ios(basic_streambuf<char_type,traits_type>* __sb)\n{\n    init(__sb);\n}\n\ntemplate <class _CharT, class _Traits>\nbasic_ios<_CharT, _Traits>::~basic_ios()\n{\n}\n\ntemplate <class _CharT, class _Traits>\ninline _LIBCPP_INLINE_VISIBILITY\nvoid\nbasic_ios<_CharT, _Traits>::init(basic_streambuf<char_type, traits_type>* __sb)\n{\n    ios_base::init(__sb);\n    __tie_ = 0;\n    __fill_ = traits_type::eof();\n}\n\ntemplate <class _CharT, class _Traits>\ninline _LIBCPP_INLINE_VISIBILITY\nbasic_ostream<_CharT, _Traits>*\nbasic_ios<_CharT, _Traits>::tie() const\n{\n    return __tie_;\n}\n\ntemplate <class _CharT, class _Traits>\ninline _LIBCPP_INLINE_VISIBILITY\nbasic_ostream<_CharT, _Traits>*\nbasic_ios<_CharT, _Traits>::tie(basic_ostream<char_type, traits_type>* __tiestr)\n{\n    basic_ostream<char_type, traits_type>* __r = __tie_;\n    __tie_ = __tiestr;\n    return __r;\n}\n\ntemplate <class _CharT, class _Traits>\ninline _LIBCPP_INLINE_VISIBILITY\nbasic_streambuf<_CharT, _Traits>*\nbasic_ios<_CharT, _Traits>::rdbuf() const\n{\n    return static_cast<basic_streambuf<char_type, traits_type>*>(ios_base::rdbuf());\n}\n\ntemplate <class _CharT, class _Traits>\ninline _LIBCPP_INLINE_VISIBILITY\nbasic_streambuf<_CharT, _Traits>*\nbasic_ios<_CharT, _Traits>::rdbuf(basic_streambuf<char_type, traits_type>* __sb)\n{\n    basic_streambuf<char_type, traits_type>* __r = rdbuf();\n    ios_base::rdbuf(__sb);\n    return __r;\n}\n\ntemplate <class _CharT, class _Traits>\ninline _LIBCPP_INLINE_VISIBILITY\nlocale\nbasic_ios<_CharT, _Traits>::imbue(const locale& __loc)\n{\n    locale __r = getloc();\n    ios_base::imbue(__loc);\n    if (rdbuf())\n        rdbuf()->pubimbue(__loc);\n    return __r;\n}\n\ntemplate <class _CharT, class _Traits>\ninline _LIBCPP_INLINE_VISIBILITY\nchar\nbasic_ios<_CharT, _Traits>::narrow(char_type __c, char __dfault) const\n{\n    return use_facet<ctype<char_type> >(getloc()).narrow(__c, __dfault);\n}\n\ntemplate <class _CharT, class _Traits>\ninline _LIBCPP_INLINE_VISIBILITY\n_CharT\nbasic_ios<_CharT, _Traits>::widen(char __c) const\n{\n    return use_facet<ctype<char_type> >(getloc()).widen(__c);\n}\n\ntemplate <class _CharT, class _Traits>\ninline _LIBCPP_INLINE_VISIBILITY\n_CharT\nbasic_ios<_CharT, _Traits>::fill() const\n{\n    if (traits_type::eq_int_type(traits_type::eof(), __fill_))\n        __fill_ = widen(' ');\n    return __fill_;\n}\n\ntemplate <class _CharT, class _Traits>\ninline _LIBCPP_INLINE_VISIBILITY\n_CharT\nbasic_ios<_CharT, _Traits>::fill(char_type __ch)\n{\n    char_type __r = __fill_;\n    __fill_ = __ch;\n    return __r;\n}\n\ntemplate <class _CharT, class _Traits>\nbasic_ios<_CharT, _Traits>&\nbasic_ios<_CharT, _Traits>::copyfmt(const basic_ios& __rhs)\n{\n    if (this != &__rhs)\n    {\n        __call_callbacks(erase_event);\n        ios_base::copyfmt(__rhs);\n        __tie_ = __rhs.__tie_;\n        __fill_ = __rhs.__fill_;\n        __call_callbacks(copyfmt_event);\n        exceptions(__rhs.exceptions());\n    }\n    return *this;\n}\n\ntemplate <class _CharT, class _Traits>\ninline _LIBCPP_INLINE_VISIBILITY\nvoid\nbasic_ios<_CharT, _Traits>::move(basic_ios& __rhs)\n{\n    ios_base::move(__rhs);\n    __tie_ = __rhs.__tie_;\n    __rhs.__tie_ = 0;\n    __fill_ = __rhs.__fill_;\n}\n\ntemplate <class _CharT, class _Traits>\ninline _LIBCPP_INLINE_VISIBILITY\nvoid\nbasic_ios<_CharT, _Traits>::swap(basic_ios& __rhs) _NOEXCEPT\n{\n    ios_base::swap(__rhs);\n    _VSTD::swap(__tie_, __rhs.__tie_);\n    _VSTD::swap(__fill_, __rhs.__fill_);\n}\n\ntemplate <class _CharT, class _Traits>\ninline _LIBCPP_INLINE_VISIBILITY\nvoid\nbasic_ios<_CharT, _Traits>::set_rdbuf(basic_streambuf<char_type, traits_type>* __sb)\n{\n    ios_base::set_rdbuf(__sb);\n}\n\ninline _LIBCPP_INLINE_VISIBILITY\nios_base&\nboolalpha(ios_base& __str)\n{\n    __str.setf(ios_base::boolalpha);\n    return __str;\n}\n\ninline _LIBCPP_INLINE_VISIBILITY\nios_base&\nnoboolalpha(ios_base& __str)\n{\n    __str.unsetf(ios_base::boolalpha);\n    return __str;\n}\n\ninline _LIBCPP_INLINE_VISIBILITY\nios_base&\nshowbase(ios_base& __str)\n{\n    __str.setf(ios_base::showbase);\n    return __str;\n}\n\ninline _LIBCPP_INLINE_VISIBILITY\nios_base&\nnoshowbase(ios_base& __str)\n{\n    __str.unsetf(ios_base::showbase);\n    return __str;\n}\n\ninline _LIBCPP_INLINE_VISIBILITY\nios_base&\nshowpoint(ios_base& __str)\n{\n    __str.setf(ios_base::showpoint);\n    return __str;\n}\n\ninline _LIBCPP_INLINE_VISIBILITY\nios_base&\nnoshowpoint(ios_base& __str)\n{\n    __str.unsetf(ios_base::showpoint);\n    return __str;\n}\n\ninline _LIBCPP_INLINE_VISIBILITY\nios_base&\nshowpos(ios_base& __str)\n{\n    __str.setf(ios_base::showpos);\n    return __str;\n}\n\ninline _LIBCPP_INLINE_VISIBILITY\nios_base&\nnoshowpos(ios_base& __str)\n{\n    __str.unsetf(ios_base::showpos);\n    return __str;\n}\n\ninline _LIBCPP_INLINE_VISIBILITY\nios_base&\nskipws(ios_base& __str)\n{\n    __str.setf(ios_base::skipws);\n    return __str;\n}\n\ninline _LIBCPP_INLINE_VISIBILITY\nios_base&\nnoskipws(ios_base& __str)\n{\n    __str.unsetf(ios_base::skipws);\n    return __str;\n}\n\ninline _LIBCPP_INLINE_VISIBILITY\nios_base&\nuppercase(ios_base& __str)\n{\n    __str.setf(ios_base::uppercase);\n    return __str;\n}\n\ninline _LIBCPP_INLINE_VISIBILITY\nios_base&\nnouppercase(ios_base& __str)\n{\n    __str.unsetf(ios_base::uppercase);\n    return __str;\n}\n\ninline _LIBCPP_INLINE_VISIBILITY\nios_base&\nunitbuf(ios_base& __str)\n{\n    __str.setf(ios_base::unitbuf);\n    return __str;\n}\n\ninline _LIBCPP_INLINE_VISIBILITY\nios_base&\nnounitbuf(ios_base& __str)\n{\n    __str.unsetf(ios_base::unitbuf);\n    return __str;\n}\n\ninline _LIBCPP_INLINE_VISIBILITY\nios_base&\ninternal(ios_base& __str)\n{\n    __str.setf(ios_base::internal, ios_base::adjustfield);\n    return __str;\n}\n\ninline _LIBCPP_INLINE_VISIBILITY\nios_base&\nleft(ios_base& __str)\n{\n    __str.setf(ios_base::left, ios_base::adjustfield);\n    return __str;\n}\n\ninline _LIBCPP_INLINE_VISIBILITY\nios_base&\nright(ios_base& __str)\n{\n    __str.setf(ios_base::right, ios_base::adjustfield);\n    return __str;\n}\n\ninline _LIBCPP_INLINE_VISIBILITY\nios_base&\ndec(ios_base& __str)\n{\n    __str.setf(ios_base::dec, ios_base::basefield);\n    return __str;\n}\n\ninline _LIBCPP_INLINE_VISIBILITY\nios_base&\nhex(ios_base& __str)\n{\n    __str.setf(ios_base::hex, ios_base::basefield);\n    return __str;\n}\n\ninline _LIBCPP_INLINE_VISIBILITY\nios_base&\noct(ios_base& __str)\n{\n    __str.setf(ios_base::oct, ios_base::basefield);\n    return __str;\n}\n\ninline _LIBCPP_INLINE_VISIBILITY\nios_base&\nfixed(ios_base& __str)\n{\n    __str.setf(ios_base::fixed, ios_base::floatfield);\n    return __str;\n}\n\ninline _LIBCPP_INLINE_VISIBILITY\nios_base&\nscientific(ios_base& __str)\n{\n    __str.setf(ios_base::scientific, ios_base::floatfield);\n    return __str;\n}\n\ninline _LIBCPP_INLINE_VISIBILITY\nios_base&\nhexfloat(ios_base& __str)\n{\n    __str.setf(ios_base::fixed | ios_base::scientific, ios_base::floatfield);\n    return __str;\n}\n\ninline _LIBCPP_INLINE_VISIBILITY\nios_base&\ndefaultfloat(ios_base& __str)\n{\n    __str.unsetf(ios_base::floatfield);\n    return __str;\n}\n\ntemplate <class _CharT, class _Traits>\nclass __save_flags\n{\n    typedef basic_ios<_CharT, _Traits> __stream_type;\n    typedef typename __stream_type::fmtflags fmtflags;\n\n    __stream_type& __stream_;\n    fmtflags       __fmtflags_;\n    _CharT         __fill_;\n\n    __save_flags(const __save_flags&);\n    __save_flags& operator=(const __save_flags&);\npublic:\n    _LIBCPP_INLINE_VISIBILITY\n    explicit __save_flags(__stream_type& __stream)\n        : __stream_(__stream),\n          __fmtflags_(__stream.flags()),\n          __fill_(__stream.fill())\n        {}\n    _LIBCPP_INLINE_VISIBILITY\n    ~__save_flags()\n    {\n        __stream_.flags(__fmtflags_);\n        __stream_.fill(__fill_);\n    }\n};\n\n_LIBCPP_END_NAMESPACE_STD\n\n#endif  // _LIBCPP_IOS\n","// -*- C++ -*-\n//===--------------------------- sstream ----------------------------------===//\n//\n//                     The LLVM Compiler Infrastructure\n//\n// This file is dual licensed under the MIT and the University of Illinois Open\n// Source Licenses. See LICENSE.TXT for details.\n//\n//===----------------------------------------------------------------------===//\n\n#ifndef _LIBCPP_SSTREAM\n#define _LIBCPP_SSTREAM\n\n/*\n    sstream synopsis\n\ntemplate <class charT, class traits = char_traits<charT>, class Allocator = allocator<charT> >\nclass basic_stringbuf\n    : public basic_streambuf<charT, traits>\n{\npublic:\n    typedef charT                          char_type;\n    typedef traits                         traits_type;\n    typedef typename traits_type::int_type int_type;\n    typedef typename traits_type::pos_type pos_type;\n    typedef typename traits_type::off_type off_type;\n    typedef Allocator                      allocator_type;\n\n    // 27.8.1.1 Constructors:\n    explicit basic_stringbuf(ios_base::openmode which = ios_base::in | ios_base::out);\n    explicit basic_stringbuf(const basic_string<char_type, traits_type, allocator_type>& str,\n                             ios_base::openmode which = ios_base::in | ios_base::out);\n    basic_stringbuf(basic_stringbuf&& rhs);\n\n    // 27.8.1.2 Assign and swap:\n    basic_stringbuf& operator=(basic_stringbuf&& rhs);\n    void swap(basic_stringbuf& rhs);\n\n    // 27.8.1.3 Get and set:\n    basic_string<char_type, traits_type, allocator_type> str() const;\n    void str(const basic_string<char_type, traits_type, allocator_type>& s);\n\nprotected:\n    // 27.8.1.4 Overridden virtual functions:\n    virtual int_type underflow();\n    virtual int_type pbackfail(int_type c = traits_type::eof());\n    virtual int_type overflow (int_type c = traits_type::eof());\n    virtual basic_streambuf<char_type, traits_type>* setbuf(char_type*, streamsize);\n    virtual pos_type seekoff(off_type off, ios_base::seekdir way,\n                             ios_base::openmode which = ios_base::in | ios_base::out);\n    virtual pos_type seekpos(pos_type sp,\n                             ios_base::openmode which = ios_base::in | ios_base::out);\n};\n\ntemplate <class charT, class traits, class Allocator>\n  void swap(basic_stringbuf<charT, traits, Allocator>& x,\n            basic_stringbuf<charT, traits, Allocator>& y);\n\ntypedef basic_stringbuf<char>    stringbuf;\ntypedef basic_stringbuf<wchar_t> wstringbuf;\n\ntemplate <class charT, class traits = char_traits<charT>, class Allocator = allocator<charT> >\nclass basic_istringstream\n    : public basic_istream<charT, traits>\n{\npublic:\n    typedef charT                          char_type;\n    typedef traits                         traits_type;\n    typedef typename traits_type::int_type int_type;\n    typedef typename traits_type::pos_type pos_type;\n    typedef typename traits_type::off_type off_type;\n    typedef Allocator                      allocator_type;\n\n    // 27.8.2.1 Constructors:\n    explicit basic_istringstream(ios_base::openmode which = ios_base::in);\n    explicit basic_istringstream(const basic_string<char_type, traits_type,allocator_type>& str,\n                                 ios_base::openmode which = ios_base::in);\n    basic_istringstream(basic_istringstream&& rhs);\n\n    // 27.8.2.2 Assign and swap:\n    basic_istringstream& operator=(basic_istringstream&& rhs);\n    void swap(basic_istringstream& rhs);\n\n    // 27.8.2.3 Members:\n    basic_stringbuf<char_type, traits_type, allocator_type>* rdbuf() const;\n    basic_string<char_type, traits_type, allocator_type> str() const;\n    void str(const basic_string<char_type, traits_type, allocator_type>& s);\n};\n\ntemplate <class charT, class traits, class Allocator>\n  void swap(basic_istringstream<charT, traits, Allocator>& x,\n            basic_istringstream<charT, traits, Allocator>& y);\n\ntypedef basic_istringstream<char>    istringstream;\ntypedef basic_istringstream<wchar_t> wistringstream;\n\ntemplate <class charT, class traits = char_traits<charT>, class Allocator = allocator<charT> >\nclass basic_ostringstream\n    : public basic_ostream<charT, traits>\n{\npublic:\n    // types:\n    typedef charT                          char_type;\n    typedef traits                         traits_type;\n    typedef typename traits_type::int_type int_type;\n    typedef typename traits_type::pos_type pos_type;\n    typedef typename traits_type::off_type off_type;\n    typedef Allocator                      allocator_type;\n\n    // 27.8.3.1 Constructors/destructor:\n    explicit basic_ostringstream(ios_base::openmode which = ios_base::out);\n    explicit basic_ostringstream(const basic_string<char_type, traits_type, allocator_type>& str,\n                                 ios_base::openmode which = ios_base::out);\n    basic_ostringstream(basic_ostringstream&& rhs);\n\n    // 27.8.3.2 Assign/swap:\n    basic_ostringstream& operator=(basic_ostringstream&& rhs);\n    void swap(basic_ostringstream& rhs);\n\n    // 27.8.3.3 Members:\n    basic_stringbuf<char_type, traits_type, allocator_type>* rdbuf() const;\n    basic_string<char_type, traits_type, allocator_type> str() const;\n    void str(const basic_string<char_type, traits_type, allocator_type>& s);\n};\n\ntemplate <class charT, class traits, class Allocator>\n  void swap(basic_ostringstream<charT, traits, Allocator>& x,\n            basic_ostringstream<charT, traits, Allocator>& y);\n\ntypedef basic_ostringstream<char>    ostringstream;\ntypedef basic_ostringstream<wchar_t> wostringstream;\n\ntemplate <class charT, class traits = char_traits<charT>, class Allocator = allocator<charT> >\nclass basic_stringstream\n    : public basic_iostream<charT, traits>\n{\npublic:\n    // types:\n    typedef charT                          char_type;\n    typedef traits                         traits_type;\n    typedef typename traits_type::int_type int_type;\n    typedef typename traits_type::pos_type pos_type;\n    typedef typename traits_type::off_type off_type;\n    typedef Allocator                      allocator_type;\n\n    // constructors/destructor\n    explicit basic_stringstream(ios_base::openmode which = ios_base::out|ios_base::in);\n    explicit basic_stringstream(const basic_string<char_type, traits_type, allocator_type>& str,\n                                ios_base::openmode which = ios_base::out|ios_base::in);\n    basic_stringstream(basic_stringstream&& rhs);\n\n    // 27.8.5.1 Assign/swap:\n    basic_stringstream& operator=(basic_stringstream&& rhs);\n    void swap(basic_stringstream& rhs);\n\n    // Members:\n    basic_stringbuf<char_type, traits_type, allocator_type>* rdbuf() const;\n    basic_string<char_type, traits_type, allocator_type> str() const;\n    void str(const basic_string<char_type, traits_type, allocator_type>& str);\n};\n\ntemplate <class charT, class traits, class Allocator>\n  void swap(basic_stringstream<charT, traits, Allocator>& x,\n            basic_stringstream<charT, traits, Allocator>& y);\n\ntypedef basic_stringstream<char>    stringstream;\ntypedef basic_stringstream<wchar_t> wstringstream;\n\n}  // std\n\n*/\n\n#include <__config>\n#include <ostream>\n#include <istream>\n#include <string>\n\n#include <__undef_min_max>\n\n#if !defined(_LIBCPP_HAS_NO_PRAGMA_SYSTEM_HEADER)\n#pragma GCC system_header\n#endif\n\n_LIBCPP_BEGIN_NAMESPACE_STD\n\n// basic_stringbuf\n\ntemplate <class _CharT, class _Traits, class _Allocator>\nclass _LIBCPP_TEMPLATE_VIS basic_stringbuf\n    : public basic_streambuf<_CharT, _Traits>\n{\npublic:\n    typedef _CharT                         char_type;\n    typedef _Traits                        traits_type;\n    typedef typename traits_type::int_type int_type;\n    typedef typename traits_type::pos_type pos_type;\n    typedef typename traits_type::off_type off_type;\n    typedef _Allocator                     allocator_type;\n\n    typedef basic_string<char_type, traits_type, allocator_type> string_type;\n\nprivate:\n\n    string_type __str_;\n    mutable char_type* __hm_;\n    ios_base::openmode __mode_;\n\npublic:\n    // 27.8.1.1 Constructors:\n    inline _LIBCPP_INLINE_VISIBILITY\n    explicit basic_stringbuf(ios_base::openmode __wch = ios_base::in | ios_base::out);\n    inline _LIBCPP_INLINE_VISIBILITY\n    explicit basic_stringbuf(const string_type& __s,\n                             ios_base::openmode __wch = ios_base::in | ios_base::out);\n#ifndef _LIBCPP_HAS_NO_RVALUE_REFERENCES\n    basic_stringbuf(basic_stringbuf&& __rhs);\n#endif\n\n    // 27.8.1.2 Assign and swap:\n#ifndef _LIBCPP_HAS_NO_RVALUE_REFERENCES\n    basic_stringbuf& operator=(basic_stringbuf&& __rhs);\n#endif\n    void swap(basic_stringbuf& __rhs);\n\n    // 27.8.1.3 Get and set:\n    string_type str() const;\n    void str(const string_type& __s);\n\nprotected:\n    // 27.8.1.4 Overridden virtual functions:\n    virtual int_type underflow();\n    virtual int_type pbackfail(int_type __c = traits_type::eof());\n    virtual int_type overflow (int_type __c = traits_type::eof());\n    virtual pos_type seekoff(off_type __off, ios_base::seekdir __way,\n                             ios_base::openmode __wch = ios_base::in | ios_base::out);\n    inline _LIBCPP_INLINE_VISIBILITY\n    virtual pos_type seekpos(pos_type __sp,\n                             ios_base::openmode __wch = ios_base::in | ios_base::out);\n};\n\ntemplate <class _CharT, class _Traits, class _Allocator>\nbasic_stringbuf<_CharT, _Traits, _Allocator>::basic_stringbuf(ios_base::openmode __wch)\n    : __hm_(0),\n      __mode_(__wch)\n{\n    str(string_type());\n}\n\ntemplate <class _CharT, class _Traits, class _Allocator>\nbasic_stringbuf<_CharT, _Traits, _Allocator>::basic_stringbuf(const string_type& __s,\n                             ios_base::openmode __wch)\n    : __hm_(0),\n      __mode_(__wch)\n{\n    str(__s);\n}\n\n#ifndef _LIBCPP_HAS_NO_RVALUE_REFERENCES\n\ntemplate <class _CharT, class _Traits, class _Allocator>\nbasic_stringbuf<_CharT, _Traits, _Allocator>::basic_stringbuf(basic_stringbuf&& __rhs)\n    : __mode_(__rhs.__mode_)\n{\n    char_type* __p = const_cast<char_type*>(__rhs.__str_.data());\n    ptrdiff_t __binp = -1;\n    ptrdiff_t __ninp = -1;\n    ptrdiff_t __einp = -1;\n    if (__rhs.eback() != nullptr)\n    {\n        __binp = __rhs.eback() - __p;\n        __ninp = __rhs.gptr() - __p;\n        __einp = __rhs.egptr() - __p;\n    }\n    ptrdiff_t __bout = -1;\n    ptrdiff_t __nout = -1;\n    ptrdiff_t __eout = -1;\n    if (__rhs.pbase() != nullptr)\n    {\n        __bout = __rhs.pbase() - __p;\n        __nout = __rhs.pptr() - __p;\n        __eout = __rhs.epptr() - __p;\n    }\n    ptrdiff_t __hm = __rhs.__hm_ == nullptr ? -1 : __rhs.__hm_ - __p;\n    __str_ = _VSTD::move(__rhs.__str_);\n    __p = const_cast<char_type*>(__str_.data());\n    if (__binp != -1)\n        this->setg(__p + __binp, __p + __ninp, __p + __einp);\n    if (__bout != -1)\n    {\n        this->setp(__p + __bout, __p + __eout);\n        this->pbump(__nout);\n    }\n    __hm_ = __hm == -1 ? nullptr : __p + __hm;\n    __p = const_cast<char_type*>(__rhs.__str_.data());\n    __rhs.setg(__p, __p, __p);\n    __rhs.setp(__p, __p);\n    __rhs.__hm_ = __p;\n    this->pubimbue(__rhs.getloc());\n}\n\ntemplate <class _CharT, class _Traits, class _Allocator>\nbasic_stringbuf<_CharT, _Traits, _Allocator>&\nbasic_stringbuf<_CharT, _Traits, _Allocator>::operator=(basic_stringbuf&& __rhs)\n{\n    char_type* __p = const_cast<char_type*>(__rhs.__str_.data());\n    ptrdiff_t __binp = -1;\n    ptrdiff_t __ninp = -1;\n    ptrdiff_t __einp = -1;\n    if (__rhs.eback() != nullptr)\n    {\n        __binp = __rhs.eback() - __p;\n        __ninp = __rhs.gptr() - __p;\n        __einp = __rhs.egptr() - __p;\n    }\n    ptrdiff_t __bout = -1;\n    ptrdiff_t __nout = -1;\n    ptrdiff_t __eout = -1;\n    if (__rhs.pbase() != nullptr)\n    {\n        __bout = __rhs.pbase() - __p;\n        __nout = __rhs.pptr() - __p;\n        __eout = __rhs.epptr() - __p;\n    }\n    ptrdiff_t __hm = __rhs.__hm_ == nullptr ? -1 : __rhs.__hm_ - __p;\n    __str_ = _VSTD::move(__rhs.__str_);\n    __p = const_cast<char_type*>(__str_.data());\n    if (__binp != -1)\n        this->setg(__p + __binp, __p + __ninp, __p + __einp);\n    else\n        this->setg(nullptr, nullptr, nullptr);\n    if (__bout != -1)\n    {\n        this->setp(__p + __bout, __p + __eout);\n        this->pbump(__nout);\n    }\n    else\n        this->setp(nullptr, nullptr);\n\n    __hm_ = __hm == -1 ? nullptr : __p + __hm;\n    __mode_ = __rhs.__mode_;\n    __p = const_cast<char_type*>(__rhs.__str_.data());\n    __rhs.setg(__p, __p, __p);\n    __rhs.setp(__p, __p);\n    __rhs.__hm_ = __p;\n    this->pubimbue(__rhs.getloc());\n    return *this;\n}\n\n#endif  // _LIBCPP_HAS_NO_RVALUE_REFERENCES\n\ntemplate <class _CharT, class _Traits, class _Allocator>\nvoid\nbasic_stringbuf<_CharT, _Traits, _Allocator>::swap(basic_stringbuf& __rhs)\n{\n    char_type* __p = const_cast<char_type*>(__rhs.__str_.data());\n    ptrdiff_t __rbinp = -1;\n    ptrdiff_t __rninp = -1;\n    ptrdiff_t __reinp = -1;\n    if (__rhs.eback() != nullptr)\n    {\n        __rbinp = __rhs.eback() - __p;\n        __rninp = __rhs.gptr() - __p;\n        __reinp = __rhs.egptr() - __p;\n    }\n    ptrdiff_t __rbout = -1;\n    ptrdiff_t __rnout = -1;\n    ptrdiff_t __reout = -1;\n    if (__rhs.pbase() != nullptr)\n    {\n        __rbout = __rhs.pbase() - __p;\n        __rnout = __rhs.pptr() - __p;\n        __reout = __rhs.epptr() - __p;\n    }\n    ptrdiff_t __rhm = __rhs.__hm_ == nullptr ? -1 : __rhs.__hm_ - __p;\n    __p = const_cast<char_type*>(__str_.data());\n    ptrdiff_t __lbinp = -1;\n    ptrdiff_t __lninp = -1;\n    ptrdiff_t __leinp = -1;\n    if (this->eback() != nullptr)\n    {\n        __lbinp = this->eback() - __p;\n        __lninp = this->gptr() - __p;\n        __leinp = this->egptr() - __p;\n    }\n    ptrdiff_t __lbout = -1;\n    ptrdiff_t __lnout = -1;\n    ptrdiff_t __leout = -1;\n    if (this->pbase() != nullptr)\n    {\n        __lbout = this->pbase() - __p;\n        __lnout = this->pptr() - __p;\n        __leout = this->epptr() - __p;\n    }\n    ptrdiff_t __lhm = __hm_ == nullptr ? -1 : __hm_ - __p;\n    _VSTD::swap(__mode_, __rhs.__mode_);\n    __str_.swap(__rhs.__str_);\n    __p = const_cast<char_type*>(__str_.data());\n    if (__rbinp != -1)\n        this->setg(__p + __rbinp, __p + __rninp, __p + __reinp);\n    else\n        this->setg(nullptr, nullptr, nullptr);\n    if (__rbout != -1)\n    {\n        this->setp(__p + __rbout, __p + __reout);\n        this->pbump(__rnout);\n    }\n    else\n        this->setp(nullptr, nullptr);\n    __hm_ = __rhm == -1 ? nullptr : __p + __rhm;\n    __p = const_cast<char_type*>(__rhs.__str_.data());\n    if (__lbinp != -1)\n        __rhs.setg(__p + __lbinp, __p + __lninp, __p + __leinp);\n    else\n        __rhs.setg(nullptr, nullptr, nullptr);\n    if (__lbout != -1)\n    {\n        __rhs.setp(__p + __lbout, __p + __leout);\n        __rhs.pbump(__lnout);\n    }\n    else\n        __rhs.setp(nullptr, nullptr);\n    __rhs.__hm_ = __lhm == -1 ? nullptr : __p + __lhm;\n    locale __tl = __rhs.getloc();\n    __rhs.pubimbue(this->getloc());\n    this->pubimbue(__tl);\n}\n\ntemplate <class _CharT, class _Traits, class _Allocator>\ninline _LIBCPP_INLINE_VISIBILITY\nvoid\nswap(basic_stringbuf<_CharT, _Traits, _Allocator>& __x,\n     basic_stringbuf<_CharT, _Traits, _Allocator>& __y)\n{\n    __x.swap(__y);\n}\n\ntemplate <class _CharT, class _Traits, class _Allocator>\nbasic_string<_CharT, _Traits, _Allocator>\nbasic_stringbuf<_CharT, _Traits, _Allocator>::str() const\n{\n    if (__mode_ & ios_base::out)\n    {\n        if (__hm_ < this->pptr())\n            __hm_ = this->pptr();\n        return string_type(this->pbase(), __hm_, __str_.get_allocator());\n    }\n    else if (__mode_ & ios_base::in)\n        return string_type(this->eback(), this->egptr(), __str_.get_allocator());\n    return string_type(__str_.get_allocator());\n}\n\ntemplate <class _CharT, class _Traits, class _Allocator>\nvoid\nbasic_stringbuf<_CharT, _Traits, _Allocator>::str(const string_type& __s)\n{\n    __str_ = __s;\n    __hm_ = 0;\n    if (__mode_ & ios_base::in)\n    {\n        __hm_ = const_cast<char_type*>(__str_.data()) + __str_.size();\n        this->setg(const_cast<char_type*>(__str_.data()),\n                   const_cast<char_type*>(__str_.data()),\n                   __hm_);\n    }\n    if (__mode_ & ios_base::out)\n    {\n        typename string_type::size_type __sz = __str_.size();\n        __hm_ = const_cast<char_type*>(__str_.data()) + __sz;\n        __str_.resize(__str_.capacity());\n        this->setp(const_cast<char_type*>(__str_.data()),\n                   const_cast<char_type*>(__str_.data()) + __str_.size());\n        if (__mode_ & (ios_base::app | ios_base::ate))\n            this->pbump(__sz);\n    }\n}\n\ntemplate <class _CharT, class _Traits, class _Allocator>\ntypename basic_stringbuf<_CharT, _Traits, _Allocator>::int_type\nbasic_stringbuf<_CharT, _Traits, _Allocator>::underflow()\n{\n    if (__hm_ < this->pptr())\n        __hm_ = this->pptr();\n    if (__mode_ & ios_base::in)\n    {\n        if (this->egptr() < __hm_)\n            this->setg(this->eback(), this->gptr(), __hm_);\n        if (this->gptr() < this->egptr())\n            return traits_type::to_int_type(*this->gptr());\n    }\n    return traits_type::eof();\n}\n\ntemplate <class _CharT, class _Traits, class _Allocator>\ntypename basic_stringbuf<_CharT, _Traits, _Allocator>::int_type\nbasic_stringbuf<_CharT, _Traits, _Allocator>::pbackfail(int_type __c)\n{\n    if (__hm_ < this->pptr())\n        __hm_ = this->pptr();\n    if (this->eback() < this->gptr())\n    {\n        if (traits_type::eq_int_type(__c, traits_type::eof()))\n        {\n            this->setg(this->eback(), this->gptr()-1, __hm_);\n            return traits_type::not_eof(__c);\n        }\n        if ((__mode_ & ios_base::out) ||\n            traits_type::eq(traits_type::to_char_type(__c), this->gptr()[-1]))\n        {\n            this->setg(this->eback(), this->gptr()-1, __hm_);\n            *this->gptr() = traits_type::to_char_type(__c);\n            return __c;\n        }\n    }\n    return traits_type::eof();\n}\n\ntemplate <class _CharT, class _Traits, class _Allocator>\ntypename basic_stringbuf<_CharT, _Traits, _Allocator>::int_type\nbasic_stringbuf<_CharT, _Traits, _Allocator>::overflow(int_type __c)\n{\n    if (!traits_type::eq_int_type(__c, traits_type::eof()))\n    {\n        ptrdiff_t __ninp = this->gptr()  - this->eback();\n        if (this->pptr() == this->epptr())\n        {\n            if (!(__mode_ & ios_base::out))\n                return traits_type::eof();\n#ifndef _LIBCPP_NO_EXCEPTIONS\n            try\n            {\n#endif  // _LIBCPP_NO_EXCEPTIONS\n                ptrdiff_t __nout = this->pptr()  - this->pbase();\n                ptrdiff_t __hm = __hm_ - this->pbase();\n                __str_.push_back(char_type());\n                __str_.resize(__str_.capacity());\n                char_type* __p = const_cast<char_type*>(__str_.data());\n                this->setp(__p, __p + __str_.size());\n                this->pbump(__nout);\n                __hm_ = this->pbase() + __hm;\n#ifndef _LIBCPP_NO_EXCEPTIONS\n            }\n            catch (...)\n            {\n                return traits_type::eof();\n            }\n#endif  // _LIBCPP_NO_EXCEPTIONS\n        }\n        __hm_ = _VSTD::max(this->pptr() + 1, __hm_);\n        if (__mode_ & ios_base::in)\n        {\n            char_type* __p = const_cast<char_type*>(__str_.data());\n            this->setg(__p, __p + __ninp, __hm_);\n        }\n        return this->sputc(__c);\n    }\n    return traits_type::not_eof(__c);\n}\n\ntemplate <class _CharT, class _Traits, class _Allocator>\ntypename basic_stringbuf<_CharT, _Traits, _Allocator>::pos_type\nbasic_stringbuf<_CharT, _Traits, _Allocator>::seekoff(off_type __off,\n                                                      ios_base::seekdir __way,\n                                                      ios_base::openmode __wch)\n{\n    if (__hm_ < this->pptr())\n        __hm_ = this->pptr();\n    if ((__wch & (ios_base::in | ios_base::out)) == 0)\n        return pos_type(-1);\n    if ((__wch & (ios_base::in | ios_base::out)) == (ios_base::in | ios_base::out)\n        && __way == ios_base::cur)\n        return pos_type(-1);\n    off_type __noff;\n    switch (__way)\n    {\n    case ios_base::beg:\n        __noff = 0;\n        break;\n    case ios_base::cur:\n        if (__wch & ios_base::in)\n            __noff = this->gptr() - this->eback();\n        else\n            __noff = this->pptr() - this->pbase();\n        break;\n    case ios_base::end:\n        __noff = __hm_ - __str_.data();\n        break;\n    default:\n        return pos_type(-1);\n    }\n    __noff += __off;\n    if (__noff < 0 || __hm_ - __str_.data() < __noff)\n        return pos_type(-1);\n    if (__noff != 0)\n    {\n        if ((__wch & ios_base::in) && this->gptr() == 0)\n            return pos_type(-1);\n        if ((__wch & ios_base::out) && this->pptr() == 0)\n            return pos_type(-1);\n    }\n    if (__wch & ios_base::in)\n        this->setg(this->eback(), this->eback() + __noff, __hm_);\n    if (__wch & ios_base::out)\n    {\n        this->setp(this->pbase(), this->epptr());\n        this->pbump(__noff);\n    }\n    return pos_type(__noff);\n}\n\ntemplate <class _CharT, class _Traits, class _Allocator>\ntypename basic_stringbuf<_CharT, _Traits, _Allocator>::pos_type\nbasic_stringbuf<_CharT, _Traits, _Allocator>::seekpos(pos_type __sp,\n                                                      ios_base::openmode __wch)\n{\n    return seekoff(__sp, ios_base::beg, __wch);\n}\n\n// basic_istringstream\n\ntemplate <class _CharT, class _Traits, class _Allocator>\nclass _LIBCPP_TEMPLATE_VIS basic_istringstream\n    : public basic_istream<_CharT, _Traits>\n{\npublic:\n    typedef _CharT                         char_type;\n    typedef _Traits                        traits_type;\n    typedef typename traits_type::int_type int_type;\n    typedef typename traits_type::pos_type pos_type;\n    typedef typename traits_type::off_type off_type;\n    typedef _Allocator                     allocator_type;\n\n    typedef basic_string<char_type, traits_type, allocator_type> string_type;\n\nprivate:\n    basic_stringbuf<char_type, traits_type, allocator_type> __sb_;\n\npublic:\n    // 27.8.2.1 Constructors:\n    inline _LIBCPP_INLINE_VISIBILITY\n    explicit basic_istringstream(ios_base::openmode __wch = ios_base::in);\n    inline _LIBCPP_INLINE_VISIBILITY\n    explicit basic_istringstream(const string_type& __s,\n                                 ios_base::openmode __wch = ios_base::in);\n#ifndef _LIBCPP_HAS_NO_RVALUE_REFERENCES\n    inline _LIBCPP_INLINE_VISIBILITY\n    basic_istringstream(basic_istringstream&& __rhs);\n\n    // 27.8.2.2 Assign and swap:\n    basic_istringstream& operator=(basic_istringstream&& __rhs);\n#endif  // _LIBCPP_HAS_NO_RVALUE_REFERENCES\n    inline _LIBCPP_INLINE_VISIBILITY\n    void swap(basic_istringstream& __rhs);\n\n    // 27.8.2.3 Members:\n    inline _LIBCPP_INLINE_VISIBILITY\n    basic_stringbuf<char_type, traits_type, allocator_type>* rdbuf() const;\n    inline _LIBCPP_INLINE_VISIBILITY\n    string_type str() const;\n    inline _LIBCPP_INLINE_VISIBILITY\n    void str(const string_type& __s);\n};\n\ntemplate <class _CharT, class _Traits, class _Allocator>\nbasic_istringstream<_CharT, _Traits, _Allocator>::basic_istringstream(ios_base::openmode __wch)\n    : basic_istream<_CharT, _Traits>(&__sb_),\n      __sb_(__wch | ios_base::in)\n{\n}\n\ntemplate <class _CharT, class _Traits, class _Allocator>\nbasic_istringstream<_CharT, _Traits, _Allocator>::basic_istringstream(const string_type& __s,\n                                                                      ios_base::openmode __wch)\n    : basic_istream<_CharT, _Traits>(&__sb_),\n      __sb_(__s, __wch | ios_base::in)\n{\n}\n\n#ifndef _LIBCPP_HAS_NO_RVALUE_REFERENCES\n\ntemplate <class _CharT, class _Traits, class _Allocator>\nbasic_istringstream<_CharT, _Traits, _Allocator>::basic_istringstream(basic_istringstream&& __rhs)\n    : basic_istream<_CharT, _Traits>(_VSTD::move(__rhs)),\n      __sb_(_VSTD::move(__rhs.__sb_))\n{\n    basic_istream<_CharT, _Traits>::set_rdbuf(&__sb_);\n}\n\ntemplate <class _CharT, class _Traits, class _Allocator>\nbasic_istringstream<_CharT, _Traits, _Allocator>&\nbasic_istringstream<_CharT, _Traits, _Allocator>::operator=(basic_istringstream&& __rhs)\n{\n    basic_istream<char_type, traits_type>::operator=(_VSTD::move(__rhs));\n    __sb_ = _VSTD::move(__rhs.__sb_);\n    return *this;\n}\n\n#endif  // _LIBCPP_HAS_NO_RVALUE_REFERENCES\n\ntemplate <class _CharT, class _Traits, class _Allocator>\nvoid basic_istringstream<_CharT, _Traits, _Allocator>::swap(basic_istringstream& __rhs)\n{\n    basic_istream<char_type, traits_type>::swap(__rhs);\n    __sb_.swap(__rhs.__sb_);\n}\n\ntemplate <class _CharT, class _Traits, class _Allocator>\ninline _LIBCPP_INLINE_VISIBILITY\nvoid\nswap(basic_istringstream<_CharT, _Traits, _Allocator>& __x,\n     basic_istringstream<_CharT, _Traits, _Allocator>& __y)\n{\n    __x.swap(__y);\n}\n\ntemplate <class _CharT, class _Traits, class _Allocator>\nbasic_stringbuf<_CharT, _Traits, _Allocator>*\nbasic_istringstream<_CharT, _Traits, _Allocator>::rdbuf() const\n{\n    return const_cast<basic_stringbuf<char_type, traits_type, allocator_type>*>(&__sb_);\n}\n\ntemplate <class _CharT, class _Traits, class _Allocator>\nbasic_string<_CharT, _Traits, _Allocator>\nbasic_istringstream<_CharT, _Traits, _Allocator>::str() const\n{\n    return __sb_.str();\n}\n\ntemplate <class _CharT, class _Traits, class _Allocator>\nvoid basic_istringstream<_CharT, _Traits, _Allocator>::str(const string_type& __s)\n{\n    __sb_.str(__s);\n}\n\n// basic_ostringstream\n\ntemplate <class _CharT, class _Traits, class _Allocator>\nclass _LIBCPP_TEMPLATE_VIS basic_ostringstream\n    : public basic_ostream<_CharT, _Traits>\n{\npublic:\n    typedef _CharT                         char_type;\n    typedef _Traits                        traits_type;\n    typedef typename traits_type::int_type int_type;\n    typedef typename traits_type::pos_type pos_type;\n    typedef typename traits_type::off_type off_type;\n    typedef _Allocator                     allocator_type;\n\n    typedef basic_string<char_type, traits_type, allocator_type> string_type;\n\nprivate:\n    basic_stringbuf<char_type, traits_type, allocator_type> __sb_;\n\npublic:\n    // 27.8.2.1 Constructors:\n    inline _LIBCPP_INLINE_VISIBILITY\n    explicit basic_ostringstream(ios_base::openmode __wch = ios_base::out);\n    inline _LIBCPP_INLINE_VISIBILITY\n    explicit basic_ostringstream(const string_type& __s,\n                                 ios_base::openmode __wch = ios_base::out);\n#ifndef _LIBCPP_HAS_NO_RVALUE_REFERENCES\n    inline _LIBCPP_INLINE_VISIBILITY\n    basic_ostringstream(basic_ostringstream&& __rhs);\n\n    // 27.8.2.2 Assign and swap:\n    basic_ostringstream& operator=(basic_ostringstream&& __rhs);\n#endif  // _LIBCPP_HAS_NO_RVALUE_REFERENCES\n    inline _LIBCPP_INLINE_VISIBILITY\n    void swap(basic_ostringstream& __rhs);\n\n    // 27.8.2.3 Members:\n    inline _LIBCPP_INLINE_VISIBILITY\n    basic_stringbuf<char_type, traits_type, allocator_type>* rdbuf() const;\n    inline _LIBCPP_INLINE_VISIBILITY\n    string_type str() const;\n    inline _LIBCPP_INLINE_VISIBILITY\n    void str(const string_type& __s);\n};\n\ntemplate <class _CharT, class _Traits, class _Allocator>\nbasic_ostringstream<_CharT, _Traits, _Allocator>::basic_ostringstream(ios_base::openmode __wch)\n    : basic_ostream<_CharT, _Traits>(&__sb_),\n      __sb_(__wch | ios_base::out)\n{\n}\n\ntemplate <class _CharT, class _Traits, class _Allocator>\nbasic_ostringstream<_CharT, _Traits, _Allocator>::basic_ostringstream(const string_type& __s,\n                                                                      ios_base::openmode __wch)\n    : basic_ostream<_CharT, _Traits>(&__sb_),\n      __sb_(__s, __wch | ios_base::out)\n{\n}\n\n#ifndef _LIBCPP_HAS_NO_RVALUE_REFERENCES\n\ntemplate <class _CharT, class _Traits, class _Allocator>\nbasic_ostringstream<_CharT, _Traits, _Allocator>::basic_ostringstream(basic_ostringstream&& __rhs)\n    : basic_ostream<_CharT, _Traits>(_VSTD::move(__rhs)),\n      __sb_(_VSTD::move(__rhs.__sb_))\n{\n    basic_ostream<_CharT, _Traits>::set_rdbuf(&__sb_);\n}\n\ntemplate <class _CharT, class _Traits, class _Allocator>\nbasic_ostringstream<_CharT, _Traits, _Allocator>&\nbasic_ostringstream<_CharT, _Traits, _Allocator>::operator=(basic_ostringstream&& __rhs)\n{\n    basic_ostream<char_type, traits_type>::operator=(_VSTD::move(__rhs));\n    __sb_ = _VSTD::move(__rhs.__sb_);\n    return *this;\n}\n\n#endif  // _LIBCPP_HAS_NO_RVALUE_REFERENCES\n\ntemplate <class _CharT, class _Traits, class _Allocator>\nvoid\nbasic_ostringstream<_CharT, _Traits, _Allocator>::swap(basic_ostringstream& __rhs)\n{\n    basic_ostream<char_type, traits_type>::swap(__rhs);\n    __sb_.swap(__rhs.__sb_);\n}\n\ntemplate <class _CharT, class _Traits, class _Allocator>\ninline _LIBCPP_INLINE_VISIBILITY\nvoid\nswap(basic_ostringstream<_CharT, _Traits, _Allocator>& __x,\n     basic_ostringstream<_CharT, _Traits, _Allocator>& __y)\n{\n    __x.swap(__y);\n}\n\ntemplate <class _CharT, class _Traits, class _Allocator>\nbasic_stringbuf<_CharT, _Traits, _Allocator>*\nbasic_ostringstream<_CharT, _Traits, _Allocator>::rdbuf() const\n{\n    return const_cast<basic_stringbuf<char_type, traits_type, allocator_type>*>(&__sb_);\n}\n\ntemplate <class _CharT, class _Traits, class _Allocator>\nbasic_string<_CharT, _Traits, _Allocator>\nbasic_ostringstream<_CharT, _Traits, _Allocator>::str() const\n{\n    return __sb_.str();\n}\n\ntemplate <class _CharT, class _Traits, class _Allocator>\nvoid\nbasic_ostringstream<_CharT, _Traits, _Allocator>::str(const string_type& __s)\n{\n    __sb_.str(__s);\n}\n\n// basic_stringstream\n\ntemplate <class _CharT, class _Traits, class _Allocator>\nclass _LIBCPP_TEMPLATE_VIS basic_stringstream\n    : public basic_iostream<_CharT, _Traits>\n{\npublic:\n    typedef _CharT                         char_type;\n    typedef _Traits                        traits_type;\n    typedef typename traits_type::int_type int_type;\n    typedef typename traits_type::pos_type pos_type;\n    typedef typename traits_type::off_type off_type;\n    typedef _Allocator                     allocator_type;\n\n    typedef basic_string<char_type, traits_type, allocator_type> string_type;\n\nprivate:\n    basic_stringbuf<char_type, traits_type, allocator_type> __sb_;\n\npublic:\n    // 27.8.2.1 Constructors:\n    inline _LIBCPP_INLINE_VISIBILITY\n    explicit basic_stringstream(ios_base::openmode __wch = ios_base::in | ios_base::out);\n    inline _LIBCPP_INLINE_VISIBILITY\n    explicit basic_stringstream(const string_type& __s,\n                                ios_base::openmode __wch = ios_base::in | ios_base::out);\n#ifndef _LIBCPP_HAS_NO_RVALUE_REFERENCES\n    inline _LIBCPP_INLINE_VISIBILITY\n    basic_stringstream(basic_stringstream&& __rhs);\n\n    // 27.8.2.2 Assign and swap:\n    basic_stringstream& operator=(basic_stringstream&& __rhs);\n#endif  // _LIBCPP_HAS_NO_RVALUE_REFERENCES\n    inline _LIBCPP_INLINE_VISIBILITY\n    void swap(basic_stringstream& __rhs);\n\n    // 27.8.2.3 Members:\n    inline _LIBCPP_INLINE_VISIBILITY\n    basic_stringbuf<char_type, traits_type, allocator_type>* rdbuf() const;\n    inline _LIBCPP_INLINE_VISIBILITY\n    string_type str() const;\n    inline _LIBCPP_INLINE_VISIBILITY\n    void str(const string_type& __s);\n};\n\ntemplate <class _CharT, class _Traits, class _Allocator>\nbasic_stringstream<_CharT, _Traits, _Allocator>::basic_stringstream(ios_base::openmode __wch)\n    : basic_iostream<_CharT, _Traits>(&__sb_),\n      __sb_(__wch)\n{\n}\n\ntemplate <class _CharT, class _Traits, class _Allocator>\nbasic_stringstream<_CharT, _Traits, _Allocator>::basic_stringstream(const string_type& __s,\n                                                                    ios_base::openmode __wch)\n    : basic_iostream<_CharT, _Traits>(&__sb_),\n      __sb_(__s, __wch)\n{\n}\n\n#ifndef _LIBCPP_HAS_NO_RVALUE_REFERENCES\n\ntemplate <class _CharT, class _Traits, class _Allocator>\nbasic_stringstream<_CharT, _Traits, _Allocator>::basic_stringstream(basic_stringstream&& __rhs)\n    : basic_iostream<_CharT, _Traits>(_VSTD::move(__rhs)),\n      __sb_(_VSTD::move(__rhs.__sb_))\n{\n    basic_istream<_CharT, _Traits>::set_rdbuf(&__sb_);\n}\n\ntemplate <class _CharT, class _Traits, class _Allocator>\nbasic_stringstream<_CharT, _Traits, _Allocator>&\nbasic_stringstream<_CharT, _Traits, _Allocator>::operator=(basic_stringstream&& __rhs)\n{\n    basic_iostream<char_type, traits_type>::operator=(_VSTD::move(__rhs));\n    __sb_ = _VSTD::move(__rhs.__sb_);\n    return *this;\n}\n\n#endif  // _LIBCPP_HAS_NO_RVALUE_REFERENCES\n\ntemplate <class _CharT, class _Traits, class _Allocator>\nvoid\nbasic_stringstream<_CharT, _Traits, _Allocator>::swap(basic_stringstream& __rhs)\n{\n    basic_iostream<char_type, traits_type>::swap(__rhs);\n    __sb_.swap(__rhs.__sb_);\n}\n\ntemplate <class _CharT, class _Traits, class _Allocator>\ninline _LIBCPP_INLINE_VISIBILITY\nvoid\nswap(basic_stringstream<_CharT, _Traits, _Allocator>& __x,\n     basic_stringstream<_CharT, _Traits, _Allocator>& __y)\n{\n    __x.swap(__y);\n}\n\ntemplate <class _CharT, class _Traits, class _Allocator>\nbasic_stringbuf<_CharT, _Traits, _Allocator>*\nbasic_stringstream<_CharT, _Traits, _Allocator>::rdbuf() const\n{\n    return const_cast<basic_stringbuf<char_type, traits_type, allocator_type>*>(&__sb_);\n}\n\ntemplate <class _CharT, class _Traits, class _Allocator>\nbasic_string<_CharT, _Traits, _Allocator>\nbasic_stringstream<_CharT, _Traits, _Allocator>::str() const\n{\n    return __sb_.str();\n}\n\ntemplate <class _CharT, class _Traits, class _Allocator>\nvoid\nbasic_stringstream<_CharT, _Traits, _Allocator>::str(const string_type& __s)\n{\n    __sb_.str(__s);\n}\n\n_LIBCPP_END_NAMESPACE_STD\n\n#endif  // _LIBCPP_SSTREAM\n","#include <dlfcn.h>\n#include <sstream>\n#include <iostream>\n\n#include \"FFI.h\"\n#include \"Error.h\"\n#include \"Runner.h\"\n#include \"Debug.h\"\n\n// TODO: MAKE THIS WORK ON MORE THAN JUST LINUX\n\nFFI::FFI() {\n\n}\n\nvoid FFI::loadMutateFFI(std::string charmName, std::string libPath, std::string sym) {\n    void* library = dlopen(libPath.c_str(), RTLD_NOW);\n    if (library == nullptr) {\n        std::ostringstream e;\n        e << \"FFI: Couldn't open library `\" << libPath << \"`\" << std::endl;\n        e << dlerror();\n        runtime_die(e.str());\n    }\n    void* func = dlsym(library, sym.c_str());\n    if (func == nullptr) {\n        std::ostringstream e;\n        e << \"FFI: Couldn't find function `\" << sym << \"`\" << std::endl;\n        e << dlerror();\n        runtime_die(e.str());\n    }\n    ONLYDEBUG printf(\"ADDING FUNCTION %s TO mutateFFIFuncs\\n\", charmName.c_str());\n    mutateFFIFuncs[charmName] = reinterpret_cast<MutateFFI>(func);\n    if (DEBUGMODE) {\n        puts(\"mutateFFIFuncs now contains:\");\n        for (auto it : mutateFFIFuncs)\n            std::cout << \"    \" << it.first << std::endl;\n    }\n}\n\nvoid FFI::runFFI(std::string f, Runner* r) {\n    ONLYDEBUG printf(\"LOOKING FOR FFI FUNCTION %s\\n\", f.c_str());\n    auto func = mutateFFIFuncs.find(f);\n    if (func == mutateFFIFuncs.end()) {\n        std::ostringstream e;\n        e << \"FFI: Couldn't find supposedly loaded function `\" << f << \"`\";\n        runtime_die(e.str());\n    }\n    try {\n        (func->second)(r);\n    } catch (std::exception &e) {\n        printf(\"FFI: Failed to run FFI function `%s`.\\n\", f.c_str());\n        printf(\"Error: %s\\n\\n\", e.what());\n    }\n\n}\n","// -*- C++ -*-\n//===--------------------------- iosfwd -----------------------------------===//\n//\n//                     The LLVM Compiler Infrastructure\n//\n// This file is dual licensed under the MIT and the University of Illinois Open\n// Source Licenses. See LICENSE.TXT for details.\n//\n//===----------------------------------------------------------------------===//\n\n#ifndef _LIBCPP_IOSFWD\n#define _LIBCPP_IOSFWD\n\n/*\n    iosfwd synopsis\n\nnamespace std\n{\n\ntemplate<class charT> struct char_traits;\ntemplate<class T>     class allocator;\n\nclass ios_base;\ntemplate <class charT, class traits = char_traits<charT> > class basic_ios;\n\ntemplate <class charT, class traits = char_traits<charT> > class basic_streambuf;\ntemplate <class charT, class traits = char_traits<charT> > class basic_istream;\ntemplate <class charT, class traits = char_traits<charT> > class basic_ostream;\ntemplate <class charT, class traits = char_traits<charT> > class basic_iostream;\n\ntemplate <class charT, class traits = char_traits<charT>, class Allocator = allocator<charT> >\n    class basic_stringbuf;\ntemplate <class charT, class traits = char_traits<charT>, class Allocator = allocator<charT> >\n    class basic_istringstream;\ntemplate <class charT, class traits = char_traits<charT>, class Allocator = allocator<charT> >\n    class basic_ostringstream;\ntemplate <class charT, class traits = char_traits<charT>, class Allocator = allocator<charT> >\n    class basic_stringstream;\n\ntemplate <class charT, class traits = char_traits<charT> > class basic_filebuf;\ntemplate <class charT, class traits = char_traits<charT> > class basic_ifstream;\ntemplate <class charT, class traits = char_traits<charT> > class basic_ofstream;\ntemplate <class charT, class traits = char_traits<charT> > class basic_fstream;\n\ntemplate <class charT, class traits = char_traits<charT> > class istreambuf_iterator;\ntemplate <class charT, class traits = char_traits<charT> > class ostreambuf_iterator;\n\ntypedef basic_ios<char>              ios;\ntypedef basic_ios<wchar_t>           wios;\n\ntypedef basic_streambuf<char>        streambuf;\ntypedef basic_istream<char>          istream;\ntypedef basic_ostream<char>          ostream;\ntypedef basic_iostream<char>         iostream;\n\ntypedef basic_stringbuf<char>        stringbuf;\ntypedef basic_istringstream<char>    istringstream;\ntypedef basic_ostringstream<char>    ostringstream;\ntypedef basic_stringstream<char>     stringstream;\n\ntypedef basic_filebuf<char>          filebuf;\ntypedef basic_ifstream<char>         ifstream;\ntypedef basic_ofstream<char>         ofstream;\ntypedef basic_fstream<char>          fstream;\n\ntypedef basic_streambuf<wchar_t>     wstreambuf;\ntypedef basic_istream<wchar_t>       wistream;\ntypedef basic_ostream<wchar_t>       wostream;\ntypedef basic_iostream<wchar_t>      wiostream;\n\ntypedef basic_stringbuf<wchar_t>     wstringbuf;\ntypedef basic_istringstream<wchar_t> wistringstream;\ntypedef basic_ostringstream<wchar_t> wostringstream;\ntypedef basic_stringstream<wchar_t>  wstringstream;\n\ntypedef basic_filebuf<wchar_t>       wfilebuf;\ntypedef basic_ifstream<wchar_t>      wifstream;\ntypedef basic_ofstream<wchar_t>      wofstream;\ntypedef basic_fstream<wchar_t>       wfstream;\n\ntemplate <class state> class fpos;\ntypedef fpos<char_traits<char>::state_type>    streampos;\ntypedef fpos<char_traits<wchar_t>::state_type> wstreampos;\n\n}  // std\n\n*/\n\n#include <__config>\n#include <wchar.h>  // for mbstate_t\n\n#if !defined(_LIBCPP_HAS_NO_PRAGMA_SYSTEM_HEADER)\n#pragma GCC system_header\n#endif\n\n_LIBCPP_BEGIN_NAMESPACE_STD\n\nclass _LIBCPP_TYPE_VIS ios_base;\n\ntemplate<class _CharT>  struct _LIBCPP_TEMPLATE_VIS char_traits;\ntemplate<class _Tp>     class _LIBCPP_TEMPLATE_VIS allocator;\n\ntemplate <class _CharT, class _Traits = char_traits<_CharT> >\n    class _LIBCPP_TEMPLATE_VIS basic_ios;\n\ntemplate <class _CharT, class _Traits = char_traits<_CharT> >\n    class _LIBCPP_TEMPLATE_VIS basic_streambuf;\ntemplate <class _CharT, class _Traits = char_traits<_CharT> >\n    class _LIBCPP_TEMPLATE_VIS basic_istream;\ntemplate <class _CharT, class _Traits = char_traits<_CharT> >\n    class _LIBCPP_TEMPLATE_VIS basic_ostream;\ntemplate <class _CharT, class _Traits = char_traits<_CharT> >\n    class _LIBCPP_TEMPLATE_VIS basic_iostream;\n\ntemplate <class _CharT, class _Traits = char_traits<_CharT>,\n          class _Allocator = allocator<_CharT> >\n    class _LIBCPP_TEMPLATE_VIS basic_stringbuf;\ntemplate <class _CharT, class _Traits = char_traits<_CharT>,\n          class _Allocator = allocator<_CharT> >\n    class _LIBCPP_TEMPLATE_VIS basic_istringstream;\ntemplate <class _CharT, class _Traits = char_traits<_CharT>,\n          class _Allocator = allocator<_CharT> >\n    class _LIBCPP_TEMPLATE_VIS basic_ostringstream;\ntemplate <class _CharT, class _Traits = char_traits<_CharT>,\n          class _Allocator = allocator<_CharT> >\n    class _LIBCPP_TEMPLATE_VIS basic_stringstream;\n\ntemplate <class _CharT, class _Traits = char_traits<_CharT> >\n    class _LIBCPP_TEMPLATE_VIS basic_filebuf;\ntemplate <class _CharT, class _Traits = char_traits<_CharT> >\n    class _LIBCPP_TEMPLATE_VIS basic_ifstream;\ntemplate <class _CharT, class _Traits = char_traits<_CharT> >\n    class _LIBCPP_TEMPLATE_VIS basic_ofstream;\ntemplate <class _CharT, class _Traits = char_traits<_CharT> >\n    class _LIBCPP_TEMPLATE_VIS basic_fstream;\n\ntemplate <class _CharT, class _Traits = char_traits<_CharT> >\n    class _LIBCPP_TEMPLATE_VIS istreambuf_iterator;\ntemplate <class _CharT, class _Traits = char_traits<_CharT> >\n    class _LIBCPP_TEMPLATE_VIS ostreambuf_iterator;\n\ntypedef basic_ios<char>              ios;\ntypedef basic_ios<wchar_t>           wios;\n\ntypedef basic_streambuf<char>        streambuf;\ntypedef basic_istream<char>          istream;\ntypedef basic_ostream<char>          ostream;\ntypedef basic_iostream<char>         iostream;\n\ntypedef basic_stringbuf<char>        stringbuf;\ntypedef basic_istringstream<char>    istringstream;\ntypedef basic_ostringstream<char>    ostringstream;\ntypedef basic_stringstream<char>     stringstream;\n\ntypedef basic_filebuf<char>          filebuf;\ntypedef basic_ifstream<char>         ifstream;\ntypedef basic_ofstream<char>         ofstream;\ntypedef basic_fstream<char>          fstream;\n\ntypedef basic_streambuf<wchar_t>     wstreambuf;\ntypedef basic_istream<wchar_t>       wistream;\ntypedef basic_ostream<wchar_t>       wostream;\ntypedef basic_iostream<wchar_t>      wiostream;\n\ntypedef basic_stringbuf<wchar_t>     wstringbuf;\ntypedef basic_istringstream<wchar_t> wistringstream;\ntypedef basic_ostringstream<wchar_t> wostringstream;\ntypedef basic_stringstream<wchar_t>  wstringstream;\n\ntypedef basic_filebuf<wchar_t>       wfilebuf;\ntypedef basic_ifstream<wchar_t>      wifstream;\ntypedef basic_ofstream<wchar_t>      wofstream;\ntypedef basic_fstream<wchar_t>       wfstream;\n\ntemplate <class _State>             class _LIBCPP_TEMPLATE_VIS fpos;\ntypedef fpos<mbstate_t>    streampos;\ntypedef fpos<mbstate_t>    wstreampos;\n#ifndef _LIBCPP_HAS_NO_UNICODE_CHARS\ntypedef fpos<mbstate_t>    u16streampos;\ntypedef fpos<mbstate_t>    u32streampos;\n#endif  // _LIBCPP_HAS_NO_UNICODE_CHARS\n\n#if defined(_NEWLIB_VERSION)\n// On newlib, off_t is 'long int'\ntypedef long int streamoff;         // for char_traits in <string>\n#else\ntypedef long long streamoff;        // for char_traits in <string>\n#endif\n\ntemplate <class _CharT,             // for <stdexcept>\n          class _Traits = char_traits<_CharT>,\n          class _Allocator = allocator<_CharT> >\n    class _LIBCPP_TEMPLATE_VIS basic_string;\ntypedef basic_string<char, char_traits<char>, allocator<char> > string;\ntypedef basic_string<wchar_t, char_traits<wchar_t>, allocator<wchar_t> > wstring;\n\n\n// Include other forward declarations here\ntemplate <class _Tp, class _Alloc = allocator<_Tp> >\nclass _LIBCPP_TEMPLATE_VIS vector;\n\n_LIBCPP_END_NAMESPACE_STD\n\n#endif  // _LIBCPP_IOSFWD\n","// -*- C++ -*-\n//===-------------------------- utility -----------------------------------===//\n//\n//                     The LLVM Compiler Infrastructure\n//\n// This file is dual licensed under the MIT and the University of Illinois Open\n// Source Licenses. See LICENSE.TXT for details.\n//\n//===----------------------------------------------------------------------===//\n\n#ifndef _LIBCPP_UTILITY\n#define _LIBCPP_UTILITY\n\n/*\n    utility synopsis\n\nnamespace std\n{\n\ntemplate <class T>\n    void\n    swap(T& a, T& b);\n\nnamespace rel_ops\n{\n    template<class T> bool operator!=(const T&, const T&);\n    template<class T> bool operator> (const T&, const T&);\n    template<class T> bool operator<=(const T&, const T&);\n    template<class T> bool operator>=(const T&, const T&);\n}\n\ntemplate<class T>\nvoid\nswap(T& a, T& b) noexcept(is_nothrow_move_constructible<T>::value &&\n                          is_nothrow_move_assignable<T>::value);\n\ntemplate <class T, size_t N>\nvoid\nswap(T (&a)[N], T (&b)[N]) noexcept(noexcept(swap(*a, *b)));\n\ntemplate <class T> T&& forward(typename remove_reference<T>::type& t) noexcept;  // constexpr in C++14\ntemplate <class T> T&& forward(typename remove_reference<T>::type&& t) noexcept; // constexpr in C++14\n\ntemplate <class T> typename remove_reference<T>::type&& move(T&&) noexcept;      // constexpr in C++14\n\ntemplate <class T>\n    typename conditional\n    <\n        !is_nothrow_move_constructible<T>::value && is_copy_constructible<T>::value,\n        const T&,\n        T&&\n    >::type\n    move_if_noexcept(T& x) noexcept; // constexpr in C++14\n\ntemplate <class T> constexpr add_const<T>_t& as_const(T& t) noexcept;      // C++17\ntemplate <class T>                      void as_const(const T&&) = delete; // C++17\n\ntemplate <class T> typename add_rvalue_reference<T>::type declval() noexcept;\n\ntemplate <class T1, class T2>\nstruct pair\n{\n    typedef T1 first_type;\n    typedef T2 second_type;\n\n    T1 first;\n    T2 second;\n\n    pair(const pair&) = default;\n    pair(pair&&) = default;\n    constexpr pair();\n    pair(const T1& x, const T2& y);                          // constexpr in C++14\n    template <class U, class V> pair(U&& x, V&& y);          // constexpr in C++14\n    template <class U, class V> pair(const pair<U, V>& p);   // constexpr in C++14\n    template <class U, class V> pair(pair<U, V>&& p);        // constexpr in C++14\n    template <class... Args1, class... Args2>\n        pair(piecewise_construct_t, tuple<Args1...> first_args,\n             tuple<Args2...> second_args);\n\n    template <class U, class V> pair& operator=(const pair<U, V>& p);\n    pair& operator=(pair&& p) noexcept(is_nothrow_move_assignable<T1>::value &&\n                                       is_nothrow_move_assignable<T2>::value);\n    template <class U, class V> pair& operator=(pair<U, V>&& p);\n\n    void swap(pair& p) noexcept(is_nothrow_swappable_v<T1> &&\n                                is_nothrow_swappable_v<T2>);\n};\n\ntemplate <class T1, class T2> bool operator==(const pair<T1,T2>&, const pair<T1,T2>&); // constexpr in C++14\ntemplate <class T1, class T2> bool operator!=(const pair<T1,T2>&, const pair<T1,T2>&); // constexpr in C++14\ntemplate <class T1, class T2> bool operator< (const pair<T1,T2>&, const pair<T1,T2>&); // constexpr in C++14\ntemplate <class T1, class T2> bool operator> (const pair<T1,T2>&, const pair<T1,T2>&); // constexpr in C++14\ntemplate <class T1, class T2> bool operator>=(const pair<T1,T2>&, const pair<T1,T2>&); // constexpr in C++14\ntemplate <class T1, class T2> bool operator<=(const pair<T1,T2>&, const pair<T1,T2>&); // constexpr in C++14\n\ntemplate <class T1, class T2> pair<V1, V2> make_pair(T1&&, T2&&);   // constexpr in C++14\ntemplate <class T1, class T2>\nvoid\nswap(pair<T1, T2>& x, pair<T1, T2>& y) noexcept(noexcept(x.swap(y)));\n\nstruct piecewise_construct_t { };\nconstexpr piecewise_construct_t piecewise_construct = piecewise_construct_t();\n\ntemplate <class T> class tuple_size;\ntemplate <size_t I, class T> class tuple_element;\n\ntemplate <class T1, class T2> struct tuple_size<pair<T1, T2> >;\ntemplate <class T1, class T2> struct tuple_element<0, pair<T1, T2> >;\ntemplate <class T1, class T2> struct tuple_element<1, pair<T1, T2> >;\n\ntemplate<size_t I, class T1, class T2>\n    typename tuple_element<I, pair<T1, T2> >::type&\n    get(pair<T1, T2>&) noexcept; // constexpr in C++14\n\ntemplate<size_t I, class T1, class T2>\n    const typename tuple_element<I, pair<T1, T2> >::type&\n    get(const pair<T1, T2>&) noexcept; // constexpr in C++14\n\ntemplate<size_t I, class T1, class T2>\n    typename tuple_element<I, pair<T1, T2> >::type&&\n    get(pair<T1, T2>&&) noexcept; // constexpr in C++14\n\ntemplate<size_t I, class T1, class T2>\n    const typename tuple_element<I, pair<T1, T2> >::type&&\n    get(const pair<T1, T2>&&) noexcept; // constexpr in C++14\n\ntemplate<class T1, class T2>\n    constexpr T1& get(pair<T1, T2>&) noexcept; // C++14\n\ntemplate<class T1, class T2>\n    constexpr const T1& get(const pair<T1, T2>&) noexcept; // C++14\n\ntemplate<class T1, class T2>\n    constexpr T1&& get(pair<T1, T2>&&) noexcept; // C++14\n\ntemplate<class T1, class T2>\n    constexpr const T1&& get(const pair<T1, T2>&&) noexcept; // C++14\n\ntemplate<class T1, class T2>\n    constexpr T1& get(pair<T2, T1>&) noexcept; // C++14\n\ntemplate<class T1, class T2>\n    constexpr const T1& get(const pair<T2, T1>&) noexcept; // C++14\n\ntemplate<class T1, class T2>\n    constexpr T1&& get(pair<T2, T1>&&) noexcept; // C++14\n\ntemplate<class T1, class T2>\n    constexpr const T1&& get(const pair<T2, T1>&&) noexcept; // C++14\n\n// C++14\n\ntemplate<class T, T... I>\nstruct integer_sequence\n{\n    typedef T value_type;\n\n    static constexpr size_t size() noexcept;\n};\n\ntemplate<size_t... I>\n  using index_sequence = integer_sequence<size_t, I...>;\n\ntemplate<class T, T N>\n  using make_integer_sequence = integer_sequence<T, 0, 1, ..., N-1>;\ntemplate<size_t N>\n  using make_index_sequence = make_integer_sequence<size_t, N>;\n\ntemplate<class... T>\n  using index_sequence_for = make_index_sequence<sizeof...(T)>;\n\ntemplate<class T, class U=T>\n    T exchange(T& obj, U&& new_value);\n\n// 20.2.7, in-place construction // C++17\nstruct in_place_t {\n  explicit in_place_t() = default;\n};\ninline constexpr in_place_t in_place{};\ntemplate <class T>\n  struct in_place_type_t {\n    explicit in_place_type_t() = default;\n  };\ntemplate <class T>\n  inline constexpr in_place_type_t<T> in_place_type{};\ntemplate <size_t I>\n  struct in_place_index_t {\n    explicit in_place_index_t() = default;\n  };\ntemplate <size_t I>\n  inline constexpr in_place_index_t<I> in_place_index{};\n\n}  // std\n\n*/\n\n#include <__config>\n#include <__tuple>\n#include <type_traits>\n#include <initializer_list>\n#include <__debug>\n\n#if !defined(_LIBCPP_HAS_NO_PRAGMA_SYSTEM_HEADER)\n#pragma GCC system_header\n#endif\n\n_LIBCPP_BEGIN_NAMESPACE_STD\n\nnamespace rel_ops\n{\n\ntemplate<class _Tp>\ninline _LIBCPP_INLINE_VISIBILITY\nbool\noperator!=(const _Tp& __x, const _Tp& __y)\n{\n    return !(__x == __y);\n}\n\ntemplate<class _Tp>\ninline _LIBCPP_INLINE_VISIBILITY\nbool\noperator> (const _Tp& __x, const _Tp& __y)\n{\n    return __y < __x;\n}\n\ntemplate<class _Tp>\ninline _LIBCPP_INLINE_VISIBILITY\nbool\noperator<=(const _Tp& __x, const _Tp& __y)\n{\n    return !(__y < __x);\n}\n\ntemplate<class _Tp>\ninline _LIBCPP_INLINE_VISIBILITY\nbool\noperator>=(const _Tp& __x, const _Tp& __y)\n{\n    return !(__x < __y);\n}\n\n}  // rel_ops\n\n// swap_ranges\n\n\ntemplate <class _ForwardIterator1, class _ForwardIterator2>\ninline _LIBCPP_INLINE_VISIBILITY\n_ForwardIterator2\nswap_ranges(_ForwardIterator1 __first1, _ForwardIterator1 __last1, _ForwardIterator2 __first2)\n{\n    for(; __first1 != __last1; ++__first1, (void) ++__first2)\n        swap(*__first1, *__first2);\n    return __first2;\n}\n\n// forward declared in <type_traits>\ntemplate<class _Tp, size_t _Np>\ninline _LIBCPP_INLINE_VISIBILITY\ntypename enable_if<\n    __is_swappable<_Tp>::value\n>::type\nswap(_Tp (&__a)[_Np], _Tp (&__b)[_Np]) _NOEXCEPT_(__is_nothrow_swappable<_Tp>::value)\n{\n    _VSTD::swap_ranges(__a, __a + _Np, __b);\n}\n\ntemplate <class _Tp>\ninline _LIBCPP_INLINE_VISIBILITY _LIBCPP_CONSTEXPR_AFTER_CXX11\n#ifndef _LIBCPP_HAS_NO_RVALUE_REFERENCES\ntypename conditional\n<\n    !is_nothrow_move_constructible<_Tp>::value && is_copy_constructible<_Tp>::value,\n    const _Tp&,\n    _Tp&&\n>::type\n#else  // _LIBCPP_HAS_NO_RVALUE_REFERENCES\nconst _Tp&\n#endif\nmove_if_noexcept(_Tp& __x) _NOEXCEPT\n{\n    return _VSTD::move(__x);\n}\n\n#if _LIBCPP_STD_VER > 14\ntemplate <class _Tp> constexpr add_const_t<_Tp>& as_const(_Tp& __t) noexcept { return __t; }\ntemplate <class _Tp>                        void as_const(const _Tp&&) = delete;\n#endif\n\nstruct _LIBCPP_TEMPLATE_VIS piecewise_construct_t { };\n#if defined(_LIBCPP_HAS_NO_CONSTEXPR) || defined(_LIBCPP_BUILDING_UTILITY)\nextern const piecewise_construct_t piecewise_construct;// = piecewise_construct_t();\n#else\nconstexpr piecewise_construct_t piecewise_construct = piecewise_construct_t();\n#endif\n\n#if defined(_LIBCPP_DEPRECATED_ABI_DISABLE_PAIR_TRIVIAL_COPY_CTOR)\nstruct __non_trivially_copyable_base {\n  _LIBCPP_CONSTEXPR _LIBCPP_INLINE_VISIBILITY\n  __non_trivially_copyable_base() _NOEXCEPT {}\n  _LIBCPP_CONSTEXPR_AFTER_CXX11 _LIBCPP_INLINE_VISIBILITY\n  __non_trivially_copyable_base(__non_trivially_copyable_base const&) _NOEXCEPT {}\n};\n#endif\n\ntemplate <class _T1, class _T2>\nstruct _LIBCPP_TEMPLATE_VIS pair\n#if defined(_LIBCPP_DEPRECATED_ABI_DISABLE_PAIR_TRIVIAL_COPY_CTOR)\n: private __non_trivially_copyable_base\n#endif\n{\n    typedef _T1 first_type;\n    typedef _T2 second_type;\n\n    _T1 first;\n    _T2 second;\n\n#if !defined(_LIBCPP_CXX03_LANG)\n    pair(pair const&) = default;\n    pair(pair&&) = default;\n#else\n  // Use the implicitly declared copy constructor in C++03\n#endif\n\n#ifdef _LIBCPP_CXX03_LANG\n    _LIBCPP_INLINE_VISIBILITY\n    pair() : first(), second() {}\n\n    _LIBCPP_INLINE_VISIBILITY\n    pair(_T1 const& __t1, _T2 const& __t2) : first(__t1), second(__t2) {}\n\n    template <class _U1, class _U2>\n    _LIBCPP_INLINE_VISIBILITY\n    pair(const pair<_U1, _U2>& __p) : first(__p.first), second(__p.second) {}\n\n    _LIBCPP_INLINE_VISIBILITY\n    pair& operator=(pair const& __p) {\n        first = __p.first;\n        second = __p.second;\n        return *this;\n    }\n#else\n    template <bool _Val>\n    using _EnableB = typename enable_if<_Val, bool>::type;\n\n    struct _CheckArgs {\n      template <class _U1, class _U2>\n      static constexpr bool __enable_default() {\n          return is_default_constructible<_U1>::value\n              && is_default_constructible<_U2>::value;\n      }\n\n      template <class _U1, class _U2>\n      static constexpr bool __enable_explicit() {\n          return is_constructible<first_type, _U1>::value\n              && is_constructible<second_type, _U2>::value\n              && (!is_convertible<_U1, first_type>::value\n                  || !is_convertible<_U2, second_type>::value);\n      }\n\n      template <class _U1, class _U2>\n      static constexpr bool __enable_implicit() {\n          return is_constructible<first_type, _U1>::value\n              && is_constructible<second_type, _U2>::value\n              && is_convertible<_U1, first_type>::value\n              && is_convertible<_U2, second_type>::value;\n      }\n    };\n\n    template <bool _MaybeEnable>\n    using _CheckArgsDep = typename conditional<\n      _MaybeEnable, _CheckArgs, __check_tuple_constructor_fail>::type;\n\n    struct _CheckTupleLikeConstructor {\n        template <class _Tuple>\n        static constexpr bool __enable_implicit() {\n            return __tuple_convertible<_Tuple, pair>::value;\n        }\n\n        template <class _Tuple>\n        static constexpr bool __enable_explicit() {\n            return __tuple_constructible<_Tuple, pair>::value\n               && !__tuple_convertible<_Tuple, pair>::value;\n        }\n\n        template <class _Tuple>\n        static constexpr bool __enable_assign() {\n            return __tuple_assignable<_Tuple, pair>::value;\n        }\n    };\n\n    template <class _Tuple>\n    using _CheckTLC = typename conditional<\n        __tuple_like_with_size<_Tuple, 2>::value\n            && !is_same<typename decay<_Tuple>::type, pair>::value,\n        _CheckTupleLikeConstructor,\n        __check_tuple_constructor_fail\n    >::type;\n\n    template<bool _Dummy = true, _EnableB<\n            _CheckArgsDep<_Dummy>::template __enable_default<_T1, _T2>()\n    > = false>\n    _LIBCPP_INLINE_VISIBILITY _LIBCPP_CONSTEXPR\n    pair() : first(), second() {}\n\n    template <bool _Dummy = true, _EnableB<\n             _CheckArgsDep<_Dummy>::template __enable_explicit<_T1 const&, _T2 const&>()\n    > = false>\n    _LIBCPP_INLINE_VISIBILITY _LIBCPP_CONSTEXPR_AFTER_CXX11\n    explicit pair(_T1 const& __t1, _T2 const& __t2)\n        : first(__t1), second(__t2) {}\n\n    template<bool _Dummy = true, _EnableB<\n            _CheckArgsDep<_Dummy>::template __enable_implicit<_T1 const&, _T2 const&>()\n    > = false>\n    _LIBCPP_INLINE_VISIBILITY _LIBCPP_CONSTEXPR_AFTER_CXX11\n    pair(_T1 const& __t1, _T2 const& __t2)\n        : first(__t1), second(__t2) {}\n\n    template<class _U1, class _U2, _EnableB<\n             _CheckArgs::template __enable_explicit<_U1, _U2>()\n    > = false>\n    _LIBCPP_INLINE_VISIBILITY _LIBCPP_CONSTEXPR_AFTER_CXX11\n    explicit pair(_U1&& __u1, _U2&& __u2)\n        : first(_VSTD::forward<_U1>(__u1)), second(_VSTD::forward<_U2>(__u2)) {}\n\n    template<class _U1, class _U2, _EnableB<\n            _CheckArgs::template __enable_implicit<_U1, _U2>()\n    > = false>\n    _LIBCPP_INLINE_VISIBILITY _LIBCPP_CONSTEXPR_AFTER_CXX11\n    pair(_U1&& __u1, _U2&& __u2)\n        : first(_VSTD::forward<_U1>(__u1)), second(_VSTD::forward<_U2>(__u2)) {}\n\n    template<class _U1, class _U2, _EnableB<\n            _CheckArgs::template __enable_explicit<_U1 const&, _U2 const&>()\n    > = false>\n    _LIBCPP_INLINE_VISIBILITY _LIBCPP_CONSTEXPR_AFTER_CXX11\n    explicit pair(pair<_U1, _U2> const& __p)\n        : first(__p.first), second(__p.second) {}\n\n    template<class _U1, class _U2, _EnableB<\n            _CheckArgs::template __enable_implicit<_U1 const&, _U2 const&>()\n    > = false>\n    _LIBCPP_INLINE_VISIBILITY _LIBCPP_CONSTEXPR_AFTER_CXX11\n    pair(pair<_U1, _U2> const& __p)\n        : first(__p.first), second(__p.second) {}\n\n    template<class _U1, class _U2, _EnableB<\n            _CheckArgs::template __enable_explicit<_U1, _U2>()\n    > = false>\n    _LIBCPP_INLINE_VISIBILITY _LIBCPP_CONSTEXPR_AFTER_CXX11\n    explicit pair(pair<_U1, _U2>&&__p)\n        : first(_VSTD::forward<_U1>(__p.first)), second(_VSTD::forward<_U2>(__p.second)) {}\n\n    template<class _U1, class _U2, _EnableB<\n            _CheckArgs::template __enable_implicit<_U1, _U2>()\n    > = false>\n    _LIBCPP_INLINE_VISIBILITY _LIBCPP_CONSTEXPR_AFTER_CXX11\n    pair(pair<_U1, _U2>&& __p)\n        : first(_VSTD::forward<_U1>(__p.first)), second(_VSTD::forward<_U2>(__p.second)) {}\n\n    template<class _Tuple, _EnableB<\n            _CheckTLC<_Tuple>::template __enable_explicit<_Tuple>()\n    > = false>\n    _LIBCPP_INLINE_VISIBILITY _LIBCPP_CONSTEXPR_AFTER_CXX11\n    explicit pair(_Tuple&& __p)\n        : first(_VSTD::get<0>(_VSTD::forward<_Tuple>(__p))),\n          second(_VSTD::get<1>(_VSTD::forward<_Tuple>(__p))) {}\n\n    template<class _Tuple, _EnableB<\n            _CheckTLC<_Tuple>::template __enable_implicit<_Tuple>()\n    > = false>\n    _LIBCPP_INLINE_VISIBILITY _LIBCPP_CONSTEXPR_AFTER_CXX11\n    pair(_Tuple&& __p)\n        : first(_VSTD::get<0>(_VSTD::forward<_Tuple>(__p))),\n          second(_VSTD::get<1>(_VSTD::forward<_Tuple>(__p))) {}\n\n    template <class... _Args1, class... _Args2>\n    _LIBCPP_INLINE_VISIBILITY\n    pair(piecewise_construct_t __pc,\n         tuple<_Args1...> __first_args, tuple<_Args2...> __second_args)\n        : pair(__pc, __first_args, __second_args,\n                typename __make_tuple_indices<sizeof...(_Args1)>::type(),\n                typename __make_tuple_indices<sizeof...(_Args2) >::type()) {}\n\n    _LIBCPP_INLINE_VISIBILITY\n    pair& operator=(typename conditional<\n                        is_copy_assignable<first_type>::value &&\n                        is_copy_assignable<second_type>::value,\n                    pair, __nat>::type const& __p)\n        _NOEXCEPT_(is_nothrow_copy_assignable<first_type>::value &&\n                   is_nothrow_copy_assignable<second_type>::value)\n    {\n        first = __p.first;\n        second = __p.second;\n        return *this;\n    }\n\n    _LIBCPP_INLINE_VISIBILITY\n    pair& operator=(typename conditional<\n                        is_move_assignable<first_type>::value &&\n                        is_move_assignable<second_type>::value,\n                    pair, __nat>::type&& __p)\n        _NOEXCEPT_(is_nothrow_move_assignable<first_type>::value &&\n                   is_nothrow_move_assignable<second_type>::value)\n    {\n        first = _VSTD::forward<first_type>(__p.first);\n        second = _VSTD::forward<second_type>(__p.second);\n        return *this;\n    }\n\n    template <class _Tuple, _EnableB<\n            _CheckTLC<_Tuple>::template __enable_assign<_Tuple>()\n     > = false>\n    _LIBCPP_INLINE_VISIBILITY\n    pair& operator=(_Tuple&& __p) {\n        first = _VSTD::get<0>(_VSTD::forward<_Tuple>(__p));\n        second = _VSTD::get<1>(_VSTD::forward<_Tuple>(__p));\n        return *this;\n    }\n#endif\n\n    _LIBCPP_INLINE_VISIBILITY\n    void\n    swap(pair& __p) _NOEXCEPT_(__is_nothrow_swappable<first_type>::value &&\n                               __is_nothrow_swappable<second_type>::value)\n    {\n        using _VSTD::swap;\n        swap(first,  __p.first);\n        swap(second, __p.second);\n    }\nprivate:\n\n#ifndef _LIBCPP_CXX03_LANG\n    template <class... _Args1, class... _Args2, size_t... _I1, size_t... _I2>\n        _LIBCPP_INLINE_VISIBILITY\n        pair(piecewise_construct_t,\n             tuple<_Args1...>& __first_args, tuple<_Args2...>& __second_args,\n             __tuple_indices<_I1...>, __tuple_indices<_I2...>);\n#endif\n};\n\ntemplate <class _T1, class _T2>\ninline _LIBCPP_INLINE_VISIBILITY _LIBCPP_CONSTEXPR_AFTER_CXX11\nbool\noperator==(const pair<_T1,_T2>& __x, const pair<_T1,_T2>& __y)\n{\n    return __x.first == __y.first && __x.second == __y.second;\n}\n\ntemplate <class _T1, class _T2>\ninline _LIBCPP_INLINE_VISIBILITY _LIBCPP_CONSTEXPR_AFTER_CXX11\nbool\noperator!=(const pair<_T1,_T2>& __x, const pair<_T1,_T2>& __y)\n{\n    return !(__x == __y);\n}\n\ntemplate <class _T1, class _T2>\ninline _LIBCPP_INLINE_VISIBILITY _LIBCPP_CONSTEXPR_AFTER_CXX11\nbool\noperator< (const pair<_T1,_T2>& __x, const pair<_T1,_T2>& __y)\n{\n    return __x.first < __y.first || (!(__y.first < __x.first) && __x.second < __y.second);\n}\n\ntemplate <class _T1, class _T2>\ninline _LIBCPP_INLINE_VISIBILITY _LIBCPP_CONSTEXPR_AFTER_CXX11\nbool\noperator> (const pair<_T1,_T2>& __x, const pair<_T1,_T2>& __y)\n{\n    return __y < __x;\n}\n\ntemplate <class _T1, class _T2>\ninline _LIBCPP_INLINE_VISIBILITY _LIBCPP_CONSTEXPR_AFTER_CXX11\nbool\noperator>=(const pair<_T1,_T2>& __x, const pair<_T1,_T2>& __y)\n{\n    return !(__x < __y);\n}\n\ntemplate <class _T1, class _T2>\ninline _LIBCPP_INLINE_VISIBILITY _LIBCPP_CONSTEXPR_AFTER_CXX11\nbool\noperator<=(const pair<_T1,_T2>& __x, const pair<_T1,_T2>& __y)\n{\n    return !(__y < __x);\n}\n\ntemplate <class _T1, class _T2>\ninline _LIBCPP_INLINE_VISIBILITY\ntypename enable_if\n<\n    __is_swappable<_T1>::value &&\n    __is_swappable<_T2>::value,\n    void\n>::type\nswap(pair<_T1, _T2>& __x, pair<_T1, _T2>& __y)\n                     _NOEXCEPT_((__is_nothrow_swappable<_T1>::value &&\n                                 __is_nothrow_swappable<_T2>::value))\n{\n    __x.swap(__y);\n}\n\n#ifndef _LIBCPP_HAS_NO_RVALUE_REFERENCES\n\n\ntemplate <class _Tp>\nstruct __make_pair_return_impl\n{\n    typedef _Tp type;\n};\n\ntemplate <class _Tp>\nstruct __make_pair_return_impl<reference_wrapper<_Tp>>\n{\n    typedef _Tp& type;\n};\n\ntemplate <class _Tp>\nstruct __make_pair_return\n{\n    typedef typename __make_pair_return_impl<typename decay<_Tp>::type>::type type;\n};\n\ntemplate <class _T1, class _T2>\ninline _LIBCPP_INLINE_VISIBILITY _LIBCPP_CONSTEXPR_AFTER_CXX11\npair<typename __make_pair_return<_T1>::type, typename __make_pair_return<_T2>::type>\nmake_pair(_T1&& __t1, _T2&& __t2)\n{\n    return pair<typename __make_pair_return<_T1>::type, typename __make_pair_return<_T2>::type>\n               (_VSTD::forward<_T1>(__t1), _VSTD::forward<_T2>(__t2));\n}\n\n#else  // _LIBCPP_HAS_NO_RVALUE_REFERENCES\n\ntemplate <class _T1, class _T2>\ninline _LIBCPP_INLINE_VISIBILITY\npair<_T1,_T2>\nmake_pair(_T1 __x, _T2 __y)\n{\n    return pair<_T1, _T2>(__x, __y);\n}\n\n#endif  // _LIBCPP_HAS_NO_RVALUE_REFERENCES\n\ntemplate <class _T1, class _T2>\n  class _LIBCPP_TEMPLATE_VIS tuple_size<pair<_T1, _T2> >\n    : public integral_constant<size_t, 2> {};\n\ntemplate <class _T1, class _T2>\nclass _LIBCPP_TEMPLATE_VIS tuple_element<0, pair<_T1, _T2> >\n{\npublic:\n    typedef _T1 type;\n};\n\ntemplate <class _T1, class _T2>\nclass _LIBCPP_TEMPLATE_VIS tuple_element<1, pair<_T1, _T2> >\n{\npublic:\n    typedef _T2 type;\n};\n\ntemplate <size_t _Ip> struct __get_pair;\n\ntemplate <>\nstruct __get_pair<0>\n{\n    template <class _T1, class _T2>\n    static\n    _LIBCPP_INLINE_VISIBILITY _LIBCPP_CONSTEXPR_AFTER_CXX11\n    _T1&\n    get(pair<_T1, _T2>& __p) _NOEXCEPT {return __p.first;}\n\n    template <class _T1, class _T2>\n    static\n    _LIBCPP_INLINE_VISIBILITY _LIBCPP_CONSTEXPR_AFTER_CXX11\n    const _T1&\n    get(const pair<_T1, _T2>& __p) _NOEXCEPT {return __p.first;}\n\n#ifndef _LIBCPP_HAS_NO_RVALUE_REFERENCES\n\n    template <class _T1, class _T2>\n    static\n    _LIBCPP_INLINE_VISIBILITY _LIBCPP_CONSTEXPR_AFTER_CXX11\n    _T1&&\n    get(pair<_T1, _T2>&& __p) _NOEXCEPT {return _VSTD::forward<_T1>(__p.first);}\n\n    template <class _T1, class _T2>\n    static\n    _LIBCPP_INLINE_VISIBILITY _LIBCPP_CONSTEXPR_AFTER_CXX11\n    const _T1&&\n    get(const pair<_T1, _T2>&& __p) _NOEXCEPT {return _VSTD::forward<const _T1>(__p.first);}\n\n#endif  // _LIBCPP_HAS_NO_RVALUE_REFERENCES\n};\n\ntemplate <>\nstruct __get_pair<1>\n{\n    template <class _T1, class _T2>\n    static\n    _LIBCPP_INLINE_VISIBILITY _LIBCPP_CONSTEXPR_AFTER_CXX11\n    _T2&\n    get(pair<_T1, _T2>& __p) _NOEXCEPT {return __p.second;}\n\n    template <class _T1, class _T2>\n    static\n    _LIBCPP_INLINE_VISIBILITY _LIBCPP_CONSTEXPR_AFTER_CXX11\n    const _T2&\n    get(const pair<_T1, _T2>& __p) _NOEXCEPT {return __p.second;}\n\n#ifndef _LIBCPP_HAS_NO_RVALUE_REFERENCES\n\n    template <class _T1, class _T2>\n    static\n    _LIBCPP_INLINE_VISIBILITY _LIBCPP_CONSTEXPR_AFTER_CXX11\n    _T2&&\n    get(pair<_T1, _T2>&& __p) _NOEXCEPT {return _VSTD::forward<_T2>(__p.second);}\n\n    template <class _T1, class _T2>\n    static\n    _LIBCPP_INLINE_VISIBILITY _LIBCPP_CONSTEXPR_AFTER_CXX11\n    const _T2&&\n    get(const pair<_T1, _T2>&& __p) _NOEXCEPT {return _VSTD::forward<const _T2>(__p.second);}\n\n#endif  // _LIBCPP_HAS_NO_RVALUE_REFERENCES\n};\n\ntemplate <size_t _Ip, class _T1, class _T2>\ninline _LIBCPP_INLINE_VISIBILITY _LIBCPP_CONSTEXPR_AFTER_CXX11\ntypename tuple_element<_Ip, pair<_T1, _T2> >::type&\nget(pair<_T1, _T2>& __p) _NOEXCEPT\n{\n    return __get_pair<_Ip>::get(__p);\n}\n\ntemplate <size_t _Ip, class _T1, class _T2>\ninline _LIBCPP_INLINE_VISIBILITY _LIBCPP_CONSTEXPR_AFTER_CXX11\nconst typename tuple_element<_Ip, pair<_T1, _T2> >::type&\nget(const pair<_T1, _T2>& __p) _NOEXCEPT\n{\n    return __get_pair<_Ip>::get(__p);\n}\n\n#ifndef _LIBCPP_HAS_NO_RVALUE_REFERENCES\n\ntemplate <size_t _Ip, class _T1, class _T2>\ninline _LIBCPP_INLINE_VISIBILITY _LIBCPP_CONSTEXPR_AFTER_CXX11\ntypename tuple_element<_Ip, pair<_T1, _T2> >::type&&\nget(pair<_T1, _T2>&& __p) _NOEXCEPT\n{\n    return __get_pair<_Ip>::get(_VSTD::move(__p));\n}\n\ntemplate <size_t _Ip, class _T1, class _T2>\ninline _LIBCPP_INLINE_VISIBILITY _LIBCPP_CONSTEXPR_AFTER_CXX11\nconst typename tuple_element<_Ip, pair<_T1, _T2> >::type&&\nget(const pair<_T1, _T2>&& __p) _NOEXCEPT\n{\n    return __get_pair<_Ip>::get(_VSTD::move(__p));\n}\n\n#endif  // _LIBCPP_HAS_NO_RVALUE_REFERENCES\n\n#if _LIBCPP_STD_VER > 11\ntemplate <class _T1, class _T2>\ninline _LIBCPP_INLINE_VISIBILITY\nconstexpr _T1 & get(pair<_T1, _T2>& __p) _NOEXCEPT\n{\n    return __get_pair<0>::get(__p);\n}\n\ntemplate <class _T1, class _T2>\ninline _LIBCPP_INLINE_VISIBILITY\nconstexpr _T1 const & get(pair<_T1, _T2> const& __p) _NOEXCEPT\n{\n    return __get_pair<0>::get(__p);\n}\n\ntemplate <class _T1, class _T2>\ninline _LIBCPP_INLINE_VISIBILITY\nconstexpr _T1 && get(pair<_T1, _T2>&& __p) _NOEXCEPT\n{\n    return __get_pair<0>::get(_VSTD::move(__p));\n}\n\ntemplate <class _T1, class _T2>\ninline _LIBCPP_INLINE_VISIBILITY\nconstexpr _T1 const && get(pair<_T1, _T2> const&& __p) _NOEXCEPT\n{\n    return __get_pair<0>::get(_VSTD::move(__p));\n}\n\ntemplate <class _T1, class _T2>\ninline _LIBCPP_INLINE_VISIBILITY\nconstexpr _T1 & get(pair<_T2, _T1>& __p) _NOEXCEPT\n{\n    return __get_pair<1>::get(__p);\n}\n\ntemplate <class _T1, class _T2>\ninline _LIBCPP_INLINE_VISIBILITY\nconstexpr _T1 const & get(pair<_T2, _T1> const& __p) _NOEXCEPT\n{\n    return __get_pair<1>::get(__p);\n}\n\ntemplate <class _T1, class _T2>\ninline _LIBCPP_INLINE_VISIBILITY\nconstexpr _T1 && get(pair<_T2, _T1>&& __p) _NOEXCEPT\n{\n    return __get_pair<1>::get(_VSTD::move(__p));\n}\n\ntemplate <class _T1, class _T2>\ninline _LIBCPP_INLINE_VISIBILITY\nconstexpr _T1 const && get(pair<_T2, _T1> const&& __p) _NOEXCEPT\n{\n    return __get_pair<1>::get(_VSTD::move(__p));\n}\n\n#endif\n\n#if _LIBCPP_STD_VER > 11\n\ntemplate<class _Tp, _Tp... _Ip>\nstruct _LIBCPP_TEMPLATE_VIS integer_sequence\n{\n    typedef _Tp value_type;\n    static_assert( is_integral<_Tp>::value,\n                  \"std::integer_sequence can only be instantiated with an integral type\" );\n    static\n    _LIBCPP_INLINE_VISIBILITY\n    constexpr\n    size_t\n    size() noexcept { return sizeof...(_Ip); }\n};\n\ntemplate<size_t... _Ip>\n    using index_sequence = integer_sequence<size_t, _Ip...>;\n\n#if __has_builtin(__make_integer_seq) && !defined(_LIBCPP_TESTING_FALLBACK_MAKE_INTEGER_SEQUENCE)\n\ntemplate <class _Tp, _Tp _Ep>\nusing __make_integer_sequence = __make_integer_seq<integer_sequence, _Tp, _Ep>;\n\n#else\n\ntemplate<typename _Tp, _Tp _Np> using __make_integer_sequence_unchecked =\n  typename __detail::__make<_Np>::type::template __convert<integer_sequence, _Tp>;\n\ntemplate <class _Tp, _Tp _Ep>\nstruct __make_integer_sequence_checked\n{\n    static_assert(is_integral<_Tp>::value,\n                  \"std::make_integer_sequence can only be instantiated with an integral type\" );\n    static_assert(0 <= _Ep, \"std::make_integer_sequence must have a non-negative sequence length\");\n    // Workaround GCC bug by preventing bad installations when 0 <= _Ep\n    // https://gcc.gnu.org/bugzilla/show_bug.cgi?id=68929\n    typedef __make_integer_sequence_unchecked<_Tp, 0 <= _Ep ? _Ep : 0> type;\n};\n\ntemplate <class _Tp, _Tp _Ep>\nusing __make_integer_sequence = typename __make_integer_sequence_checked<_Tp, _Ep>::type;\n\n#endif\n\ntemplate<class _Tp, _Tp _Np>\n    using make_integer_sequence = __make_integer_sequence<_Tp, _Np>;\n\ntemplate<size_t _Np>\n    using make_index_sequence = make_integer_sequence<size_t, _Np>;\n\ntemplate<class... _Tp>\n    using index_sequence_for = make_index_sequence<sizeof...(_Tp)>;\n\n#endif  // _LIBCPP_STD_VER > 11\n\n#if _LIBCPP_STD_VER > 11\ntemplate<class _T1, class _T2 = _T1>\ninline _LIBCPP_INLINE_VISIBILITY\n_T1 exchange(_T1& __obj, _T2 && __new_value)\n{\n    _T1 __old_value = _VSTD::move(__obj);\n    __obj = _VSTD::forward<_T2>(__new_value);\n    return __old_value;\n}\n#endif  // _LIBCPP_STD_VER > 11\n\n#if _LIBCPP_STD_VER > 14\n\nstruct _LIBCPP_TYPE_VIS in_place_t {\n    explicit in_place_t() = default;\n};\n#ifndef _LIBCPP_HAS_NO_INLINE_VARIABLES\ninline\n#endif\nconstexpr in_place_t in_place{};\n\ntemplate <class _Tp>\nstruct _LIBCPP_TYPE_VIS in_place_type_t {\n    explicit in_place_type_t() = default;\n};\ntemplate <class _Tp>\n#ifndef _LIBCPP_HAS_NO_INLINE_VARIABLES\ninline\n#endif\nconstexpr in_place_type_t<_Tp> in_place_type{};\n\ntemplate <size_t _Idx>\nstruct _LIBCPP_TYPE_VIS in_place_index_t {\n    explicit in_place_index_t() = default;\n};\ntemplate <size_t _Idx>\n#ifndef _LIBCPP_HAS_NO_INLINE_VARIABLES\ninline\n#endif\nconstexpr in_place_index_t<_Idx> in_place_index{};\n\ntemplate <class _Tp> struct __is_inplace_type_imp : false_type {};\ntemplate <class _Tp> struct __is_inplace_type_imp<in_place_type_t<_Tp>> : true_type {};\n\ntemplate <class _Tp>\nusing __is_inplace_type = __is_inplace_type_imp<__uncvref_t<_Tp>>;\n\n#endif // _LIBCPP_STD_VER > 14\n\n_LIBCPP_END_NAMESPACE_STD\n\n#endif  // _LIBCPP_UTILITY\n","#pragma once\n#include \"ParserTypes.h\"\n#include <deque>\n\nclass Stack {\nprivate:\n\t//says how much of the stack was changed, for printing n stuff\n\tunsigned long long modifiedStackArea;\npublic:\n    CharmFunction name;\n    Stack(unsigned long long size, CharmFunction name);\n    //the stack is automatically initialized to MAX_INT zero ints\n    CHARM_STACK_TYPE stack;\n    //check to see if the stack name is equal\n    //to some CharmFunction passed in. this is so\n    //runner can properly select its current stack\n    bool isNameEqualTo(CharmFunction f);\n    //update the modifiedStackArea, really only called on swap\n    //because swap is the only one that's hard to predict\n\tvoid updateModifiedStackArea();\n    //a helper function to see if a charm function is a number / an int\n    static bool isInt(CharmFunction f);\n    static bool isFloat(CharmFunction f);\n    //return a CharmFunction that for all intents and purposes is zero\n    static CharmFunction zeroF();\n    //push to top of stack\n    void push(CharmFunction f);\n    //pop off top of stack\n    CharmFunction pop();\n    //swap values at index n1 and n2 from the top (zero-indexed)\n    void swap(unsigned long long n1, unsigned long long n2);\n    unsigned int getModifiedStackArea();\n};\n","// -*- C++ -*-\n//===-------------------------- ostream -----------------------------------===//\n//\n//                     The LLVM Compiler Infrastructure\n//\n// This file is dual licensed under the MIT and the University of Illinois Open\n// Source Licenses. See LICENSE.TXT for details.\n//\n//===----------------------------------------------------------------------===//\n\n#ifndef _LIBCPP_OSTREAM\n#define _LIBCPP_OSTREAM\n\n/*\n    ostream synopsis\n\ntemplate <class charT, class traits = char_traits<charT> >\nclass basic_ostream\n    : virtual public basic_ios<charT,traits>\n{\npublic:\n    // types (inherited from basic_ios (27.5.4)):\n    typedef charT                          char_type;\n    typedef traits                         traits_type;\n    typedef typename traits_type::int_type int_type;\n    typedef typename traits_type::pos_type pos_type;\n    typedef typename traits_type::off_type off_type;\n\n    // 27.7.2.2 Constructor/destructor:\n    explicit basic_ostream(basic_streambuf<char_type,traits>* sb);\n    basic_ostream(basic_ostream&& rhs);\n    virtual ~basic_ostream();\n\n    // 27.7.2.3 Assign/swap\n    basic_ostream& operator=(const basic_ostream& rhs) = delete; // C++14\n    basic_ostream& operator=(basic_ostream&& rhs);\n    void swap(basic_ostream& rhs);\n\n    // 27.7.2.4 Prefix/suffix:\n    class sentry;\n\n    // 27.7.2.6 Formatted output:\n    basic_ostream& operator<<(basic_ostream& (*pf)(basic_ostream&));\n    basic_ostream& operator<<(basic_ios<charT, traits>& (*pf)(basic_ios<charT,traits>&));\n    basic_ostream& operator<<(ios_base& (*pf)(ios_base&));\n    basic_ostream& operator<<(bool n);\n    basic_ostream& operator<<(short n);\n    basic_ostream& operator<<(unsigned short n);\n    basic_ostream& operator<<(int n);\n    basic_ostream& operator<<(unsigned int n);\n    basic_ostream& operator<<(long n);\n    basic_ostream& operator<<(unsigned long n);\n    basic_ostream& operator<<(long long n);\n    basic_ostream& operator<<(unsigned long long n);\n    basic_ostream& operator<<(float f);\n    basic_ostream& operator<<(double f);\n    basic_ostream& operator<<(long double f);\n    basic_ostream& operator<<(const void* p);\n    basic_ostream& operator<<(basic_streambuf<char_type,traits>* sb);\n\n    // 27.7.2.7 Unformatted output:\n    basic_ostream& put(char_type c);\n    basic_ostream& write(const char_type* s, streamsize n);\n    basic_ostream& flush();\n\n    // 27.7.2.5 seeks:\n    pos_type tellp();\n    basic_ostream& seekp(pos_type);\n    basic_ostream& seekp(off_type, ios_base::seekdir);\nprotected:\n    basic_ostream(const basic_ostream& rhs) = delete;\n    basic_ostream(basic_ostream&& rhs);\n    // 27.7.3.3 Assign/swap\n    basic_ostream& operator=(basic_ostream& rhs) = delete;\n    basic_ostream& operator=(const basic_ostream&& rhs);\n    void swap(basic_ostream& rhs);\n};\n\n// 27.7.2.6.4 character inserters\n\ntemplate<class charT, class traits>\n  basic_ostream<charT,traits>& operator<<(basic_ostream<charT,traits>&, charT);\n\ntemplate<class charT, class traits>\n  basic_ostream<charT,traits>& operator<<(basic_ostream<charT,traits>&, char);\n\ntemplate<class traits>\n  basic_ostream<char,traits>& operator<<(basic_ostream<char,traits>&, char);\n\n// signed and unsigned\n\ntemplate<class traits>\n  basic_ostream<char,traits>& operator<<(basic_ostream<char,traits>&, signed char);\n\ntemplate<class traits>\n  basic_ostream<char,traits>& operator<<(basic_ostream<char,traits>&, unsigned char);\n\n// NTBS\ntemplate<class charT, class traits>\n  basic_ostream<charT,traits>& operator<<(basic_ostream<charT,traits>&, const charT*);\n\ntemplate<class charT, class traits>\n  basic_ostream<charT,traits>& operator<<(basic_ostream<charT,traits>&, const char*);\n\ntemplate<class traits>\n  basic_ostream<char,traits>& operator<<(basic_ostream<char,traits>&, const char*);\n\n// signed and unsigned\ntemplate<class traits>\nbasic_ostream<char,traits>& operator<<(basic_ostream<char,traits>&, const signed char*);\n\ntemplate<class traits>\n  basic_ostream<char,traits>& operator<<(basic_ostream<char,traits>&, const unsigned char*);\n\n// swap:\ntemplate <class charT, class traits>\n  void swap(basic_ostream<charT, traits>& x, basic_ostream<charT, traits>& y);\n\ntemplate <class charT, class traits>\n  basic_ostream<charT,traits>& endl(basic_ostream<charT,traits>& os);\n\ntemplate <class charT, class traits>\n  basic_ostream<charT,traits>& ends(basic_ostream<charT,traits>& os);\n\ntemplate <class charT, class traits>\n  basic_ostream<charT,traits>& flush(basic_ostream<charT,traits>& os);\n\n// rvalue stream insertion\ntemplate <class charT, class traits, class T>\n  basic_ostream<charT, traits>&\n  operator<<(basic_ostream<charT, traits>&& os, const T& x);\n\n}  // std\n\n*/\n\n#include <__config>\n#include <ios>\n#include <streambuf>\n#include <locale>\n#include <iterator>\n#include <bitset>\n\n#if !defined(_LIBCPP_HAS_NO_PRAGMA_SYSTEM_HEADER)\n#pragma GCC system_header\n#endif\n\n_LIBCPP_BEGIN_NAMESPACE_STD\n\ntemplate <class _CharT, class _Traits>\nclass _LIBCPP_TEMPLATE_VIS basic_ostream\n    : virtual public basic_ios<_CharT, _Traits>\n{\npublic:\n    // types (inherited from basic_ios (27.5.4)):\n    typedef _CharT                         char_type;\n    typedef _Traits                        traits_type;\n    typedef typename traits_type::int_type int_type;\n    typedef typename traits_type::pos_type pos_type;\n    typedef typename traits_type::off_type off_type;\n\n    // 27.7.2.2 Constructor/destructor:\n    inline _LIBCPP_EXTERN_TEMPLATE_INLINE_VISIBILITY\n    explicit basic_ostream(basic_streambuf<char_type, traits_type>* __sb)\n    { this->init(__sb); }\n    virtual ~basic_ostream();\nprotected:\n#ifndef _LIBCPP_HAS_NO_RVALUE_REFERENCES\n    inline _LIBCPP_INLINE_VISIBILITY\n    basic_ostream(basic_ostream&& __rhs);\n#endif\n\n    // 27.7.2.3 Assign/swap\n#ifndef _LIBCPP_HAS_NO_RVALUE_REFERENCES\n    inline _LIBCPP_INLINE_VISIBILITY\n    basic_ostream& operator=(basic_ostream&& __rhs);\n#endif\n    inline _LIBCPP_EXTERN_TEMPLATE_INLINE_VISIBILITY\n    void swap(basic_ostream& __rhs)\n    { basic_ios<char_type, traits_type>::swap(__rhs); }\n\n#ifndef _LIBCPP_CXX03_LANG\n    basic_ostream           (const basic_ostream& __rhs) = delete;\n    basic_ostream& operator=(const basic_ostream& __rhs) = delete;\n#else\n    basic_ostream           (const basic_ostream& __rhs); // not defined\n    basic_ostream& operator=(const basic_ostream& __rhs); // not defined\n#endif\npublic:\n\n    // 27.7.2.4 Prefix/suffix:\n    class _LIBCPP_TEMPLATE_VIS sentry;\n\n    // 27.7.2.6 Formatted output:\n    inline _LIBCPP_EXTERN_TEMPLATE_INLINE_VISIBILITY\n    basic_ostream& operator<<(basic_ostream& (*__pf)(basic_ostream&))\n    { return __pf(*this); }\n\n    inline _LIBCPP_EXTERN_TEMPLATE_INLINE_VISIBILITY\n    basic_ostream& operator<<(basic_ios<char_type, traits_type>&\n                              (*__pf)(basic_ios<char_type,traits_type>&))\n    { __pf(*this); return *this; }\n\n    inline _LIBCPP_EXTERN_TEMPLATE_INLINE_VISIBILITY\n    basic_ostream& operator<<(ios_base& (*__pf)(ios_base&))\n    { __pf(*this); return *this; }\n\n    basic_ostream& operator<<(bool __n);\n    basic_ostream& operator<<(short __n);\n    basic_ostream& operator<<(unsigned short __n);\n    basic_ostream& operator<<(int __n);\n    basic_ostream& operator<<(unsigned int __n);\n    basic_ostream& operator<<(long __n);\n    basic_ostream& operator<<(unsigned long __n);\n    basic_ostream& operator<<(long long __n);\n    basic_ostream& operator<<(unsigned long long __n);\n    basic_ostream& operator<<(float __f);\n    basic_ostream& operator<<(double __f);\n    basic_ostream& operator<<(long double __f);\n    basic_ostream& operator<<(const void* __p);\n    basic_ostream& operator<<(basic_streambuf<char_type, traits_type>* __sb);\n\n    // 27.7.2.7 Unformatted output:\n    basic_ostream& put(char_type __c);\n    basic_ostream& write(const char_type* __s, streamsize __n);\n    basic_ostream& flush();\n\n    // 27.7.2.5 seeks:\n    inline _LIBCPP_EXTERN_TEMPLATE_INLINE_VISIBILITY\n    pos_type tellp();\n    inline _LIBCPP_EXTERN_TEMPLATE_INLINE_VISIBILITY\n    basic_ostream& seekp(pos_type __pos);\n    inline _LIBCPP_EXTERN_TEMPLATE_INLINE_VISIBILITY\n    basic_ostream& seekp(off_type __off, ios_base::seekdir __dir);\n\nprotected:\n    _LIBCPP_ALWAYS_INLINE\n    basic_ostream() {}  // extension, intentially does not initialize\n};\n\ntemplate <class _CharT, class _Traits>\nclass _LIBCPP_TEMPLATE_VIS basic_ostream<_CharT, _Traits>::sentry\n{\n    bool __ok_;\n    basic_ostream<_CharT, _Traits>& __os_;\n\n    sentry(const sentry&); // = delete;\n    sentry& operator=(const sentry&); // = delete;\n\npublic:\n    explicit sentry(basic_ostream<_CharT, _Traits>& __os);\n    ~sentry();\n\n    _LIBCPP_ALWAYS_INLINE\n        _LIBCPP_EXPLICIT\n        operator bool() const {return __ok_;}\n};\n\ntemplate <class _CharT, class _Traits>\nbasic_ostream<_CharT, _Traits>::sentry::sentry(basic_ostream<_CharT, _Traits>& __os)\n    : __ok_(false),\n      __os_(__os)\n{\n    if (__os.good())\n    {\n        if (__os.tie())\n            __os.tie()->flush();\n        __ok_ = true;\n    }\n}\n\ntemplate <class _CharT, class _Traits>\nbasic_ostream<_CharT, _Traits>::sentry::~sentry()\n{\n    if (__os_.rdbuf() && __os_.good() && (__os_.flags() & ios_base::unitbuf)\n                      && !uncaught_exception())\n    {\n#ifndef _LIBCPP_NO_EXCEPTIONS\n        try\n        {\n#endif  // _LIBCPP_NO_EXCEPTIONS\n            if (__os_.rdbuf()->pubsync() == -1)\n                __os_.setstate(ios_base::badbit);\n#ifndef _LIBCPP_NO_EXCEPTIONS\n        }\n        catch (...)\n        {\n        }\n#endif  // _LIBCPP_NO_EXCEPTIONS\n    }\n}\n\n#ifndef _LIBCPP_HAS_NO_RVALUE_REFERENCES\n\ntemplate <class _CharT, class _Traits>\nbasic_ostream<_CharT, _Traits>::basic_ostream(basic_ostream&& __rhs)\n{\n    this->move(__rhs);\n}\n\ntemplate <class _CharT, class _Traits>\nbasic_ostream<_CharT, _Traits>&\nbasic_ostream<_CharT, _Traits>::operator=(basic_ostream&& __rhs)\n{\n    swap(__rhs);\n    return *this;\n}\n\n#endif  // _LIBCPP_HAS_NO_RVALUE_REFERENCES\n\ntemplate <class _CharT, class _Traits>\nbasic_ostream<_CharT, _Traits>::~basic_ostream()\n{\n}\n\ntemplate <class _CharT, class _Traits>\nbasic_ostream<_CharT, _Traits>&\nbasic_ostream<_CharT, _Traits>::operator<<(basic_streambuf<char_type, traits_type>* __sb)\n{\n#ifndef _LIBCPP_NO_EXCEPTIONS\n    try\n    {\n#endif  // _LIBCPP_NO_EXCEPTIONS\n        sentry __s(*this);\n        if (__s)\n        {\n            if (__sb)\n            {\n#ifndef _LIBCPP_NO_EXCEPTIONS\n                try\n                {\n#endif  // _LIBCPP_NO_EXCEPTIONS\n                    typedef istreambuf_iterator<_CharT, _Traits> _Ip;\n                    typedef ostreambuf_iterator<_CharT, _Traits> _Op;\n                    _Ip __i(__sb);\n                    _Ip __eof;\n                    _Op __o(*this);\n                    size_t __c = 0;\n                    for (; __i != __eof; ++__i, ++__o, ++__c)\n                    {\n                        *__o = *__i;\n                        if (__o.failed())\n                            break;\n                    }\n                    if (__c == 0)\n                        this->setstate(ios_base::failbit);\n#ifndef _LIBCPP_NO_EXCEPTIONS\n                }\n                catch (...)\n                {\n                    this->__set_failbit_and_consider_rethrow();\n                }\n#endif  // _LIBCPP_NO_EXCEPTIONS\n            }\n            else\n                this->setstate(ios_base::badbit);\n        }\n#ifndef _LIBCPP_NO_EXCEPTIONS\n    }\n    catch (...)\n    {\n        this->__set_badbit_and_consider_rethrow();\n    }\n#endif  // _LIBCPP_NO_EXCEPTIONS\n    return *this;\n}\n\ntemplate <class _CharT, class _Traits>\nbasic_ostream<_CharT, _Traits>&\nbasic_ostream<_CharT, _Traits>::operator<<(bool __n)\n{\n#ifndef _LIBCPP_NO_EXCEPTIONS\n    try\n    {\n#endif  // _LIBCPP_NO_EXCEPTIONS\n        sentry __s(*this);\n        if (__s)\n        {\n            typedef num_put<char_type, ostreambuf_iterator<char_type, traits_type> > _Fp;\n            const _Fp& __f = use_facet<_Fp>(this->getloc());\n            if (__f.put(*this, *this, this->fill(), __n).failed())\n                this->setstate(ios_base::badbit | ios_base::failbit);\n        }\n#ifndef _LIBCPP_NO_EXCEPTIONS\n    }\n    catch (...)\n    {\n        this->__set_badbit_and_consider_rethrow();\n    }\n#endif  // _LIBCPP_NO_EXCEPTIONS\n    return *this;\n}\n\ntemplate <class _CharT, class _Traits>\nbasic_ostream<_CharT, _Traits>&\nbasic_ostream<_CharT, _Traits>::operator<<(short __n)\n{\n#ifndef _LIBCPP_NO_EXCEPTIONS\n    try\n    {\n#endif  // _LIBCPP_NO_EXCEPTIONS\n        sentry __s(*this);\n        if (__s)\n        {\n            ios_base::fmtflags __flags = ios_base::flags() & ios_base::basefield;\n            typedef num_put<char_type, ostreambuf_iterator<char_type, traits_type> > _Fp;\n            const _Fp& __f = use_facet<_Fp>(this->getloc());\n            if (__f.put(*this, *this, this->fill(),\n                        __flags == ios_base::oct || __flags == ios_base::hex ?\n                        static_cast<long>(static_cast<unsigned short>(__n))  :\n                        static_cast<long>(__n)).failed())\n                this->setstate(ios_base::badbit | ios_base::failbit);\n        }\n#ifndef _LIBCPP_NO_EXCEPTIONS\n    }\n    catch (...)\n    {\n        this->__set_badbit_and_consider_rethrow();\n    }\n#endif  // _LIBCPP_NO_EXCEPTIONS\n    return *this;\n}\n\ntemplate <class _CharT, class _Traits>\nbasic_ostream<_CharT, _Traits>&\nbasic_ostream<_CharT, _Traits>::operator<<(unsigned short __n)\n{\n#ifndef _LIBCPP_NO_EXCEPTIONS\n    try\n    {\n#endif  // _LIBCPP_NO_EXCEPTIONS\n        sentry __s(*this);\n        if (__s)\n        {\n            typedef num_put<char_type, ostreambuf_iterator<char_type, traits_type> > _Fp;\n            const _Fp& __f = use_facet<_Fp>(this->getloc());\n            if (__f.put(*this, *this, this->fill(), static_cast<unsigned long>(__n)).failed())\n                this->setstate(ios_base::badbit | ios_base::failbit);\n        }\n#ifndef _LIBCPP_NO_EXCEPTIONS\n    }\n    catch (...)\n    {\n        this->__set_badbit_and_consider_rethrow();\n    }\n#endif  // _LIBCPP_NO_EXCEPTIONS\n    return *this;\n}\n\ntemplate <class _CharT, class _Traits>\nbasic_ostream<_CharT, _Traits>&\nbasic_ostream<_CharT, _Traits>::operator<<(int __n)\n{\n#ifndef _LIBCPP_NO_EXCEPTIONS\n    try\n    {\n#endif  // _LIBCPP_NO_EXCEPTIONS\n        sentry __s(*this);\n        if (__s)\n        {\n            ios_base::fmtflags __flags = ios_base::flags() & ios_base::basefield;\n            typedef num_put<char_type, ostreambuf_iterator<char_type, traits_type> > _Fp;\n            const _Fp& __f = use_facet<_Fp>(this->getloc());\n            if (__f.put(*this, *this, this->fill(),\n                        __flags == ios_base::oct || __flags == ios_base::hex ?\n                        static_cast<long>(static_cast<unsigned int>(__n))  :\n                        static_cast<long>(__n)).failed())\n                this->setstate(ios_base::badbit | ios_base::failbit);\n        }\n#ifndef _LIBCPP_NO_EXCEPTIONS\n    }\n    catch (...)\n    {\n        this->__set_badbit_and_consider_rethrow();\n    }\n#endif  // _LIBCPP_NO_EXCEPTIONS\n    return *this;\n}\n\ntemplate <class _CharT, class _Traits>\nbasic_ostream<_CharT, _Traits>&\nbasic_ostream<_CharT, _Traits>::operator<<(unsigned int __n)\n{\n#ifndef _LIBCPP_NO_EXCEPTIONS\n    try\n    {\n#endif  // _LIBCPP_NO_EXCEPTIONS\n        sentry __s(*this);\n        if (__s)\n        {\n            typedef num_put<char_type, ostreambuf_iterator<char_type, traits_type> > _Fp;\n            const _Fp& __f = use_facet<_Fp>(this->getloc());\n            if (__f.put(*this, *this, this->fill(), static_cast<unsigned long>(__n)).failed())\n                this->setstate(ios_base::badbit | ios_base::failbit);\n        }\n#ifndef _LIBCPP_NO_EXCEPTIONS\n    }\n    catch (...)\n    {\n        this->__set_badbit_and_consider_rethrow();\n    }\n#endif  // _LIBCPP_NO_EXCEPTIONS\n    return *this;\n}\n\ntemplate <class _CharT, class _Traits>\nbasic_ostream<_CharT, _Traits>&\nbasic_ostream<_CharT, _Traits>::operator<<(long __n)\n{\n#ifndef _LIBCPP_NO_EXCEPTIONS\n    try\n    {\n#endif  // _LIBCPP_NO_EXCEPTIONS\n        sentry __s(*this);\n        if (__s)\n        {\n            typedef num_put<char_type, ostreambuf_iterator<char_type, traits_type> > _Fp;\n            const _Fp& __f = use_facet<_Fp>(this->getloc());\n            if (__f.put(*this, *this, this->fill(), __n).failed())\n                this->setstate(ios_base::badbit | ios_base::failbit);\n        }\n#ifndef _LIBCPP_NO_EXCEPTIONS\n    }\n    catch (...)\n    {\n        this->__set_badbit_and_consider_rethrow();\n    }\n#endif  // _LIBCPP_NO_EXCEPTIONS\n    return *this;\n}\n\ntemplate <class _CharT, class _Traits>\nbasic_ostream<_CharT, _Traits>&\nbasic_ostream<_CharT, _Traits>::operator<<(unsigned long __n)\n{\n#ifndef _LIBCPP_NO_EXCEPTIONS\n    try\n    {\n#endif  // _LIBCPP_NO_EXCEPTIONS\n        sentry __s(*this);\n        if (__s)\n        {\n            typedef num_put<char_type, ostreambuf_iterator<char_type, traits_type> > _Fp;\n            const _Fp& __f = use_facet<_Fp>(this->getloc());\n            if (__f.put(*this, *this, this->fill(), __n).failed())\n                this->setstate(ios_base::badbit | ios_base::failbit);\n        }\n#ifndef _LIBCPP_NO_EXCEPTIONS\n    }\n    catch (...)\n    {\n        this->__set_badbit_and_consider_rethrow();\n    }\n#endif  // _LIBCPP_NO_EXCEPTIONS\n    return *this;\n}\n\ntemplate <class _CharT, class _Traits>\nbasic_ostream<_CharT, _Traits>&\nbasic_ostream<_CharT, _Traits>::operator<<(long long __n)\n{\n#ifndef _LIBCPP_NO_EXCEPTIONS\n    try\n    {\n#endif  // _LIBCPP_NO_EXCEPTIONS\n        sentry __s(*this);\n        if (__s)\n        {\n            typedef num_put<char_type, ostreambuf_iterator<char_type, traits_type> > _Fp;\n            const _Fp& __f = use_facet<_Fp>(this->getloc());\n            if (__f.put(*this, *this, this->fill(), __n).failed())\n                this->setstate(ios_base::badbit | ios_base::failbit);\n        }\n#ifndef _LIBCPP_NO_EXCEPTIONS\n    }\n    catch (...)\n    {\n        this->__set_badbit_and_consider_rethrow();\n    }\n#endif  // _LIBCPP_NO_EXCEPTIONS\n    return *this;\n}\n\ntemplate <class _CharT, class _Traits>\nbasic_ostream<_CharT, _Traits>&\nbasic_ostream<_CharT, _Traits>::operator<<(unsigned long long __n)\n{\n#ifndef _LIBCPP_NO_EXCEPTIONS\n    try\n    {\n#endif  // _LIBCPP_NO_EXCEPTIONS\n        sentry __s(*this);\n        if (__s)\n        {\n            typedef num_put<char_type, ostreambuf_iterator<char_type, traits_type> > _Fp;\n            const _Fp& __f = use_facet<_Fp>(this->getloc());\n            if (__f.put(*this, *this, this->fill(), __n).failed())\n                this->setstate(ios_base::badbit | ios_base::failbit);\n        }\n#ifndef _LIBCPP_NO_EXCEPTIONS\n    }\n    catch (...)\n    {\n        this->__set_badbit_and_consider_rethrow();\n    }\n#endif  // _LIBCPP_NO_EXCEPTIONS\n    return *this;\n}\n\ntemplate <class _CharT, class _Traits>\nbasic_ostream<_CharT, _Traits>&\nbasic_ostream<_CharT, _Traits>::operator<<(float __n)\n{\n#ifndef _LIBCPP_NO_EXCEPTIONS\n    try\n    {\n#endif  // _LIBCPP_NO_EXCEPTIONS\n        sentry __s(*this);\n        if (__s)\n        {\n            typedef num_put<char_type, ostreambuf_iterator<char_type, traits_type> > _Fp;\n            const _Fp& __f = use_facet<_Fp>(this->getloc());\n            if (__f.put(*this, *this, this->fill(), static_cast<double>(__n)).failed())\n                this->setstate(ios_base::badbit | ios_base::failbit);\n        }\n#ifndef _LIBCPP_NO_EXCEPTIONS\n    }\n    catch (...)\n    {\n        this->__set_badbit_and_consider_rethrow();\n    }\n#endif  // _LIBCPP_NO_EXCEPTIONS\n    return *this;\n}\n\ntemplate <class _CharT, class _Traits>\nbasic_ostream<_CharT, _Traits>&\nbasic_ostream<_CharT, _Traits>::operator<<(double __n)\n{\n#ifndef _LIBCPP_NO_EXCEPTIONS\n    try\n    {\n#endif  // _LIBCPP_NO_EXCEPTIONS\n        sentry __s(*this);\n        if (__s)\n        {\n            typedef num_put<char_type, ostreambuf_iterator<char_type, traits_type> > _Fp;\n            const _Fp& __f = use_facet<_Fp>(this->getloc());\n            if (__f.put(*this, *this, this->fill(), __n).failed())\n                this->setstate(ios_base::badbit | ios_base::failbit);\n        }\n#ifndef _LIBCPP_NO_EXCEPTIONS\n    }\n    catch (...)\n    {\n        this->__set_badbit_and_consider_rethrow();\n    }\n#endif  // _LIBCPP_NO_EXCEPTIONS\n    return *this;\n}\n\ntemplate <class _CharT, class _Traits>\nbasic_ostream<_CharT, _Traits>&\nbasic_ostream<_CharT, _Traits>::operator<<(long double __n)\n{\n#ifndef _LIBCPP_NO_EXCEPTIONS\n    try\n    {\n#endif  // _LIBCPP_NO_EXCEPTIONS\n        sentry __s(*this);\n        if (__s)\n        {\n            typedef num_put<char_type, ostreambuf_iterator<char_type, traits_type> > _Fp;\n            const _Fp& __f = use_facet<_Fp>(this->getloc());\n            if (__f.put(*this, *this, this->fill(), __n).failed())\n                this->setstate(ios_base::badbit | ios_base::failbit);\n        }\n#ifndef _LIBCPP_NO_EXCEPTIONS\n    }\n    catch (...)\n    {\n        this->__set_badbit_and_consider_rethrow();\n    }\n#endif  // _LIBCPP_NO_EXCEPTIONS\n    return *this;\n}\n\ntemplate <class _CharT, class _Traits>\nbasic_ostream<_CharT, _Traits>&\nbasic_ostream<_CharT, _Traits>::operator<<(const void* __n)\n{\n#ifndef _LIBCPP_NO_EXCEPTIONS\n    try\n    {\n#endif  // _LIBCPP_NO_EXCEPTIONS\n        sentry __s(*this);\n        if (__s)\n        {\n            typedef num_put<char_type, ostreambuf_iterator<char_type, traits_type> > _Fp;\n            const _Fp& __f = use_facet<_Fp>(this->getloc());\n            if (__f.put(*this, *this, this->fill(), __n).failed())\n                this->setstate(ios_base::badbit | ios_base::failbit);\n        }\n#ifndef _LIBCPP_NO_EXCEPTIONS\n    }\n    catch (...)\n    {\n        this->__set_badbit_and_consider_rethrow();\n    }\n#endif  // _LIBCPP_NO_EXCEPTIONS\n    return *this;\n}\n\ntemplate<class _CharT, class _Traits>\nbasic_ostream<_CharT, _Traits>&\n__put_character_sequence(basic_ostream<_CharT, _Traits>& __os,\n                          const _CharT* __str, size_t __len)\n{\n#ifndef _LIBCPP_NO_EXCEPTIONS\n    try\n    {\n#endif  // _LIBCPP_NO_EXCEPTIONS\n        typename basic_ostream<_CharT, _Traits>::sentry __s(__os);\n        if (__s)\n        {\n            typedef ostreambuf_iterator<_CharT, _Traits> _Ip;\n            if (__pad_and_output(_Ip(__os),\n                                 __str,\n                                 (__os.flags() & ios_base::adjustfield) == ios_base::left ?\n                                     __str + __len :\n                                     __str,\n                                 __str + __len,\n                                 __os,\n                                 __os.fill()).failed())\n                __os.setstate(ios_base::badbit | ios_base::failbit);\n        }\n#ifndef _LIBCPP_NO_EXCEPTIONS\n    }\n    catch (...)\n    {\n        __os.__set_badbit_and_consider_rethrow();\n    }\n#endif  // _LIBCPP_NO_EXCEPTIONS\n    return __os;\n}\n\n\ntemplate<class _CharT, class _Traits>\nbasic_ostream<_CharT, _Traits>&\noperator<<(basic_ostream<_CharT, _Traits>& __os, _CharT __c)\n{\n    return _VSTD::__put_character_sequence(__os, &__c, 1);\n}\n\ntemplate<class _CharT, class _Traits>\nbasic_ostream<_CharT, _Traits>&\noperator<<(basic_ostream<_CharT, _Traits>& __os, char __cn)\n{\n#ifndef _LIBCPP_NO_EXCEPTIONS\n    try\n    {\n#endif  // _LIBCPP_NO_EXCEPTIONS\n        typename basic_ostream<_CharT, _Traits>::sentry __s(__os);\n        if (__s)\n        {\n            _CharT __c = __os.widen(__cn);\n            typedef ostreambuf_iterator<_CharT, _Traits> _Ip;\n            if (__pad_and_output(_Ip(__os),\n                                 &__c,\n                                 (__os.flags() & ios_base::adjustfield) == ios_base::left ?\n                                     &__c + 1 :\n                                     &__c,\n                                 &__c + 1,\n                                 __os,\n                                 __os.fill()).failed())\n                __os.setstate(ios_base::badbit | ios_base::failbit);\n        }\n#ifndef _LIBCPP_NO_EXCEPTIONS\n    }\n    catch (...)\n    {\n        __os.__set_badbit_and_consider_rethrow();\n    }\n#endif  // _LIBCPP_NO_EXCEPTIONS\n    return __os;\n}\n\ntemplate<class _Traits>\nbasic_ostream<char, _Traits>&\noperator<<(basic_ostream<char, _Traits>& __os, char __c)\n{\n    return _VSTD::__put_character_sequence(__os, &__c, 1);\n}\n\ntemplate<class _Traits>\nbasic_ostream<char, _Traits>&\noperator<<(basic_ostream<char, _Traits>& __os, signed char __c)\n{\n    return _VSTD::__put_character_sequence(__os, (char *) &__c, 1);\n}\n\ntemplate<class _Traits>\nbasic_ostream<char, _Traits>&\noperator<<(basic_ostream<char, _Traits>& __os, unsigned char __c)\n{\n    return _VSTD::__put_character_sequence(__os, (char *) &__c, 1);\n}\n\ntemplate<class _CharT, class _Traits>\nbasic_ostream<_CharT, _Traits>&\noperator<<(basic_ostream<_CharT, _Traits>& __os, const _CharT* __str)\n{\n    return _VSTD::__put_character_sequence(__os, __str, _Traits::length(__str));\n}\n\ntemplate<class _CharT, class _Traits>\nbasic_ostream<_CharT, _Traits>&\noperator<<(basic_ostream<_CharT, _Traits>& __os, const char* __strn)\n{\n#ifndef _LIBCPP_NO_EXCEPTIONS\n    try\n    {\n#endif  // _LIBCPP_NO_EXCEPTIONS\n        typename basic_ostream<_CharT, _Traits>::sentry __s(__os);\n        if (__s)\n        {\n            typedef ostreambuf_iterator<_CharT, _Traits> _Ip;\n            size_t __len = char_traits<char>::length(__strn);\n            const int __bs = 100;\n            _CharT __wbb[__bs];\n            _CharT* __wb = __wbb;\n            unique_ptr<_CharT, void(*)(void*)> __h(0, free);\n            if (__len > __bs)\n            {\n                __wb = (_CharT*)malloc(__len*sizeof(_CharT));\n                if (__wb == 0)\n                    __throw_bad_alloc();\n                __h.reset(__wb);\n            }\n            for (_CharT* __p = __wb; *__strn != '\\0'; ++__strn, ++__p)\n                *__p = __os.widen(*__strn);\n            if (__pad_and_output(_Ip(__os),\n                                 __wb,\n                                 (__os.flags() & ios_base::adjustfield) == ios_base::left ?\n                                     __wb + __len :\n                                     __wb,\n                                 __wb + __len,\n                                 __os,\n                                 __os.fill()).failed())\n                __os.setstate(ios_base::badbit | ios_base::failbit);\n        }\n#ifndef _LIBCPP_NO_EXCEPTIONS\n    }\n    catch (...)\n    {\n        __os.__set_badbit_and_consider_rethrow();\n    }\n#endif  // _LIBCPP_NO_EXCEPTIONS\n    return __os;\n}\n\ntemplate<class _Traits>\nbasic_ostream<char, _Traits>&\noperator<<(basic_ostream<char, _Traits>& __os, const char* __str)\n{\n    return _VSTD::__put_character_sequence(__os, __str, _Traits::length(__str));\n}\n\ntemplate<class _Traits>\nbasic_ostream<char, _Traits>&\noperator<<(basic_ostream<char, _Traits>& __os, const signed char* __str)\n{\n    const char *__s = (const char *) __str;\n    return _VSTD::__put_character_sequence(__os, __s, _Traits::length(__s));\n}\n\ntemplate<class _Traits>\nbasic_ostream<char, _Traits>&\noperator<<(basic_ostream<char, _Traits>& __os, const unsigned char* __str)\n{\n    const char *__s = (const char *) __str;\n    return _VSTD::__put_character_sequence(__os, __s, _Traits::length(__s));\n}\n\ntemplate <class _CharT, class _Traits>\nbasic_ostream<_CharT, _Traits>&\nbasic_ostream<_CharT, _Traits>::put(char_type __c)\n{\n#ifndef _LIBCPP_NO_EXCEPTIONS\n    try\n    {\n#endif  // _LIBCPP_NO_EXCEPTIONS\n        sentry __s(*this);\n        if (__s)\n        {\n            typedef ostreambuf_iterator<_CharT, _Traits> _Op;\n            _Op __o(*this);\n            *__o = __c;\n            if (__o.failed())\n                this->setstate(ios_base::badbit);\n        }\n#ifndef _LIBCPP_NO_EXCEPTIONS\n    }\n    catch (...)\n    {\n        this->__set_badbit_and_consider_rethrow();\n    }\n#endif  // _LIBCPP_NO_EXCEPTIONS\n    return *this;\n}\n\ntemplate <class _CharT, class _Traits>\nbasic_ostream<_CharT, _Traits>&\nbasic_ostream<_CharT, _Traits>::write(const char_type* __s, streamsize __n)\n{\n#ifndef _LIBCPP_NO_EXCEPTIONS\n    try\n    {\n#endif  // _LIBCPP_NO_EXCEPTIONS\n        sentry __sen(*this);\n        if (__sen && __n)\n        {\n            if (this->rdbuf()->sputn(__s, __n) != __n)\n                this->setstate(ios_base::badbit);\n        }\n#ifndef _LIBCPP_NO_EXCEPTIONS\n    }\n    catch (...)\n    {\n        this->__set_badbit_and_consider_rethrow();\n    }\n#endif  // _LIBCPP_NO_EXCEPTIONS\n    return *this;\n}\n\ntemplate <class _CharT, class _Traits>\nbasic_ostream<_CharT, _Traits>&\nbasic_ostream<_CharT, _Traits>::flush()\n{\n#ifndef _LIBCPP_NO_EXCEPTIONS\n    try\n    {\n#endif  // _LIBCPP_NO_EXCEPTIONS\n        if (this->rdbuf())\n        {\n            sentry __s(*this);\n            if (__s)\n            {\n                if (this->rdbuf()->pubsync() == -1)\n                    this->setstate(ios_base::badbit);\n            }\n        }\n#ifndef _LIBCPP_NO_EXCEPTIONS\n    }\n    catch (...)\n    {\n        this->__set_badbit_and_consider_rethrow();\n    }\n#endif  // _LIBCPP_NO_EXCEPTIONS\n    return *this;\n}\n\ntemplate <class _CharT, class _Traits>\ntypename basic_ostream<_CharT, _Traits>::pos_type\nbasic_ostream<_CharT, _Traits>::tellp()\n{\n    if (this->fail())\n        return pos_type(-1);\n    return this->rdbuf()->pubseekoff(0, ios_base::cur, ios_base::out);\n}\n\ntemplate <class _CharT, class _Traits>\nbasic_ostream<_CharT, _Traits>&\nbasic_ostream<_CharT, _Traits>::seekp(pos_type __pos)\n{\n    sentry __s(*this);\n    if (!this->fail())\n    {\n        if (this->rdbuf()->pubseekpos(__pos, ios_base::out) == pos_type(-1))\n            this->setstate(ios_base::failbit);\n    }\n    return *this;\n}\n\ntemplate <class _CharT, class _Traits>\nbasic_ostream<_CharT, _Traits>&\nbasic_ostream<_CharT, _Traits>::seekp(off_type __off, ios_base::seekdir __dir)\n{\n    sentry __s(*this);\n    if (!this->fail())\n    {\n        if (this->rdbuf()->pubseekoff(__off, __dir, ios_base::out) == pos_type(-1))\n            this->setstate(ios_base::failbit);\n    }\n    return *this;\n}\n\ntemplate <class _CharT, class _Traits>\ninline _LIBCPP_INLINE_VISIBILITY\nbasic_ostream<_CharT, _Traits>&\nendl(basic_ostream<_CharT, _Traits>& __os)\n{\n    __os.put(__os.widen('\\n'));\n    __os.flush();\n    return __os;\n}\n\ntemplate <class _CharT, class _Traits>\ninline _LIBCPP_INLINE_VISIBILITY\nbasic_ostream<_CharT, _Traits>&\nends(basic_ostream<_CharT, _Traits>& __os)\n{\n    __os.put(_CharT());\n    return __os;\n}\n\ntemplate <class _CharT, class _Traits>\ninline _LIBCPP_INLINE_VISIBILITY\nbasic_ostream<_CharT, _Traits>&\nflush(basic_ostream<_CharT, _Traits>& __os)\n{\n    __os.flush();\n    return __os;\n}\n\n#ifndef _LIBCPP_HAS_NO_RVALUE_REFERENCES\n\ntemplate <class _Stream, class _Tp>\ninline _LIBCPP_INLINE_VISIBILITY\ntypename enable_if\n<\n    !is_lvalue_reference<_Stream>::value &&\n    is_base_of<ios_base, _Stream>::value,\n    _Stream&&\n>::type\noperator<<(_Stream&& __os, const _Tp& __x)\n{\n    __os << __x;\n    return _VSTD::move(__os);\n}\n\n#endif  // _LIBCPP_HAS_NO_RVALUE_REFERENCES\n\ntemplate<class _CharT, class _Traits, class _Allocator>\nbasic_ostream<_CharT, _Traits>&\noperator<<(basic_ostream<_CharT, _Traits>& __os,\n           const basic_string<_CharT, _Traits, _Allocator>& __str)\n{\n    return _VSTD::__put_character_sequence(__os, __str.data(), __str.size());\n}\n\ntemplate<class _CharT, class _Traits>\nbasic_ostream<_CharT, _Traits>&\noperator<<(basic_ostream<_CharT, _Traits>& __os,\n           const basic_string_view<_CharT, _Traits> __sv)\n{\n    return _VSTD::__put_character_sequence(__os, __sv.data(), __sv.size());\n}\n\ntemplate <class _CharT, class _Traits>\ninline _LIBCPP_INLINE_VISIBILITY\nbasic_ostream<_CharT, _Traits>&\noperator<<(basic_ostream<_CharT, _Traits>& __os, const error_code& __ec)\n{\n    return __os << __ec.category().name() << ':' << __ec.value();\n}\n\ntemplate<class _CharT, class _Traits, class _Yp>\ninline _LIBCPP_INLINE_VISIBILITY\nbasic_ostream<_CharT, _Traits>&\noperator<<(basic_ostream<_CharT, _Traits>& __os, shared_ptr<_Yp> const& __p)\n{\n    return __os << __p.get();\n}\n\ntemplate <class _CharT, class _Traits, size_t _Size>\nbasic_ostream<_CharT, _Traits>&\noperator<<(basic_ostream<_CharT, _Traits>& __os, const bitset<_Size>& __x)\n{\n    return __os << __x.template to_string<_CharT, _Traits>\n                        (use_facet<ctype<_CharT> >(__os.getloc()).widen('0'),\n                         use_facet<ctype<_CharT> >(__os.getloc()).widen('1'));\n}\n\n_LIBCPP_EXTERN_TEMPLATE(class _LIBCPP_EXTERN_TEMPLATE_TYPE_VIS basic_ostream<char>)\n_LIBCPP_EXTERN_TEMPLATE(class _LIBCPP_EXTERN_TEMPLATE_TYPE_VIS basic_ostream<wchar_t>)\n\n_LIBCPP_END_NAMESPACE_STD\n\n#endif  // _LIBCPP_OSTREAM\n","// -*- C++ -*-\n//===----------------------------------------------------------------------===//\n//\n//                     The LLVM Compiler Infrastructure\n//\n// This file is dual licensed under the MIT and the University of Illinois Open\n// Source Licenses. See LICENSE.TXT for details.\n//\n//===----------------------------------------------------------------------===//\n\n#ifndef _LIBCPP___LOCALE\n#define _LIBCPP___LOCALE\n\n#include <__config>\n#include <string>\n#include <memory>\n#include <utility>\n#include <mutex>\n#include <cstdint>\n#include <cctype>\n#include <locale.h>\n#if defined(_LIBCPP_MSVCRT) || defined(__MINGW32__)\n# include <support/win32/locale_win32.h>\n#elif defined(_AIX)\n# include <support/ibm/xlocale.h>\n#elif defined(__ANDROID__)\n// Android gained the locale aware functions in L (API level 21)\n# include <android/api-level.h>\n# if __ANDROID_API__ <= 20\n#  include <support/android/locale_bionic.h>\n# endif\n#elif defined(__sun__)\n# include <xlocale.h>\n# include <support/solaris/xlocale.h>\n#elif defined(_NEWLIB_VERSION)\n# include <support/newlib/xlocale.h>\n#elif (defined(__GLIBC__) || defined(__APPLE__)      || defined(__FreeBSD__) \\\n    || defined(__EMSCRIPTEN__) || defined(__IBMCPP__))\n# include <xlocale.h>\n#elif defined(_LIBCPP_HAS_MUSL_LIBC)\n# include <support/musl/xlocale.h>\n#endif // __GLIBC__ || __APPLE__ || __FreeBSD__ || __sun__ || __EMSCRIPTEN__ || __IBMCPP__\n\n#if !defined(_LIBCPP_HAS_NO_PRAGMA_SYSTEM_HEADER)\n#pragma GCC system_header\n#endif\n\n_LIBCPP_BEGIN_NAMESPACE_STD\n\nclass _LIBCPP_TYPE_VIS locale;\n\ntemplate <class _Facet>\n_LIBCPP_INLINE_VISIBILITY\nbool\nhas_facet(const locale&) _NOEXCEPT;\n\ntemplate <class _Facet>\n_LIBCPP_INLINE_VISIBILITY\nconst _Facet&\nuse_facet(const locale&);\n\nclass _LIBCPP_TYPE_VIS locale\n{\npublic:\n    // types:\n    class _LIBCPP_TYPE_VIS facet;\n    class _LIBCPP_TYPE_VIS id;\n\n    typedef int category;\n    static const category // values assigned here are for exposition only\n        none     = 0,\n        collate  = LC_COLLATE_MASK,\n        ctype    = LC_CTYPE_MASK,\n        monetary = LC_MONETARY_MASK,\n        numeric  = LC_NUMERIC_MASK,\n        time     = LC_TIME_MASK,\n        messages = LC_MESSAGES_MASK,\n        all = collate | ctype | monetary | numeric | time | messages;\n\n    // construct/copy/destroy:\n    locale()  _NOEXCEPT;\n    locale(const locale&)  _NOEXCEPT;\n    explicit locale(const char*);\n    explicit locale(const string&);\n    locale(const locale&, const char*, category);\n    locale(const locale&, const string&, category);\n    template <class _Facet>\n        _LIBCPP_INLINE_VISIBILITY locale(const locale&, _Facet*);\n    locale(const locale&, const locale&, category);\n\n    ~locale();\n\n    const locale& operator=(const locale&)  _NOEXCEPT;\n\n    template <class _Facet> locale combine(const locale&) const;\n\n    // locale operations:\n    string name() const;\n    bool operator==(const locale&) const;\n    bool operator!=(const locale& __y) const {return !(*this == __y);}\n    template <class _CharT, class _Traits, class _Allocator>\n      bool operator()(const basic_string<_CharT, _Traits, _Allocator>&,\n                      const basic_string<_CharT, _Traits, _Allocator>&) const;\n\n    // global locale objects:\n    static locale global(const locale&);\n    static const locale& classic();\n\nprivate:\n    class __imp;\n    __imp* __locale_;\n\n    void __install_ctor(const locale&, facet*, long);\n    static locale& __global();\n    bool has_facet(id&) const;\n    const facet* use_facet(id&) const;\n\n    template <class _Facet> friend bool has_facet(const locale&)  _NOEXCEPT;\n    template <class _Facet> friend const _Facet& use_facet(const locale&);\n};\n\nclass _LIBCPP_TYPE_VIS locale::facet\n    : public __shared_count\n{\nprotected:\n    _LIBCPP_INLINE_VISIBILITY\n    explicit facet(size_t __refs = 0)\n        : __shared_count(static_cast<long>(__refs)-1) {}\n\n    virtual ~facet();\n\n//    facet(const facet&) = delete;     // effectively done in __shared_count\n//    void operator=(const facet&) = delete;\nprivate:\n    virtual void __on_zero_shared() _NOEXCEPT;\n};\n\nclass _LIBCPP_TYPE_VIS locale::id\n{\n    once_flag      __flag_;\n    int32_t        __id_;\n\n    static int32_t __next_id;\npublic:\n    _LIBCPP_INLINE_VISIBILITY _LIBCPP_CONSTEXPR id() :__id_(0) {}\nprivate:\n    void __init();\n    void operator=(const id&); // = delete;\n    id(const id&); // = delete;\npublic:  // only needed for tests\n    long __get();\n\n    friend class locale;\n    friend class locale::__imp;\n};\n\ntemplate <class _Facet>\ninline _LIBCPP_INLINE_VISIBILITY\nlocale::locale(const locale& __other, _Facet* __f)\n{\n    __install_ctor(__other, __f, __f ? __f->id.__get() : 0);\n}\n\ntemplate <class _Facet>\nlocale\nlocale::combine(const locale& __other) const\n{\n    if (!_VSTD::has_facet<_Facet>(__other))\n        __throw_runtime_error(\"locale::combine: locale missing facet\");\n\n    return locale(*this, &const_cast<_Facet&>(_VSTD::use_facet<_Facet>(__other)));\n}\n\ntemplate <class _Facet>\ninline _LIBCPP_INLINE_VISIBILITY\nbool\nhas_facet(const locale& __l)  _NOEXCEPT\n{\n    return __l.has_facet(_Facet::id);\n}\n\ntemplate <class _Facet>\ninline _LIBCPP_INLINE_VISIBILITY\nconst _Facet&\nuse_facet(const locale& __l)\n{\n    return static_cast<const _Facet&>(*__l.use_facet(_Facet::id));\n}\n\n// template <class _CharT> class collate;\n\ntemplate <class _CharT>\nclass _LIBCPP_TEMPLATE_VIS collate\n    : public locale::facet\n{\npublic:\n    typedef _CharT char_type;\n    typedef basic_string<char_type> string_type;\n\n    _LIBCPP_INLINE_VISIBILITY\n    explicit collate(size_t __refs = 0)\n        : locale::facet(__refs) {}\n\n    _LIBCPP_INLINE_VISIBILITY\n    int compare(const char_type* __lo1, const char_type* __hi1,\n                const char_type* __lo2, const char_type* __hi2) const\n    {\n        return do_compare(__lo1, __hi1, __lo2, __hi2);\n    }\n\n    _LIBCPP_INLINE_VISIBILITY\n    string_type transform(const char_type* __lo, const char_type* __hi) const\n    {\n        return do_transform(__lo, __hi);\n    }\n\n    _LIBCPP_INLINE_VISIBILITY\n    long hash(const char_type* __lo, const char_type* __hi) const\n    {\n        return do_hash(__lo, __hi);\n    }\n\n    static locale::id id;\n\nprotected:\n    ~collate();\n    virtual int do_compare(const char_type* __lo1, const char_type* __hi1,\n                           const char_type* __lo2, const char_type* __hi2) const;\n    virtual string_type do_transform(const char_type* __lo, const char_type* __hi) const\n        {return string_type(__lo, __hi);}\n    virtual long do_hash(const char_type* __lo, const char_type* __hi) const;\n};\n\ntemplate <class _CharT> locale::id collate<_CharT>::id;\n\ntemplate <class _CharT>\ncollate<_CharT>::~collate()\n{\n}\n\ntemplate <class _CharT>\nint\ncollate<_CharT>::do_compare(const char_type* __lo1, const char_type* __hi1,\n                            const char_type* __lo2, const char_type* __hi2) const\n{\n    for (; __lo2 != __hi2; ++__lo1, ++__lo2)\n    {\n        if (__lo1 == __hi1 || *__lo1 < *__lo2)\n            return -1;\n        if (*__lo2 < *__lo1)\n            return 1;\n    }\n    return __lo1 != __hi1;\n}\n\ntemplate <class _CharT>\nlong\ncollate<_CharT>::do_hash(const char_type* __lo, const char_type* __hi) const\n{\n    size_t __h = 0;\n    const size_t __sr = __CHAR_BIT__ * sizeof(size_t) - 8;\n    const size_t __mask = size_t(0xF) << (__sr + 4);\n    for(const char_type* __p = __lo; __p != __hi; ++__p)\n    {\n        __h = (__h << 4) + static_cast<size_t>(*__p);\n        size_t __g = __h & __mask;\n        __h ^= __g | (__g >> __sr);\n    }\n    return static_cast<long>(__h);\n}\n\n_LIBCPP_EXTERN_TEMPLATE2(class _LIBCPP_EXTERN_TEMPLATE_TYPE_VIS collate<char>)\n_LIBCPP_EXTERN_TEMPLATE2(class _LIBCPP_EXTERN_TEMPLATE_TYPE_VIS collate<wchar_t>)\n\n// template <class CharT> class collate_byname;\n\ntemplate <class _CharT> class _LIBCPP_TEMPLATE_VIS collate_byname;\n\ntemplate <>\nclass _LIBCPP_TYPE_VIS collate_byname<char>\n    : public collate<char>\n{\n    locale_t __l;\npublic:\n    typedef char char_type;\n    typedef basic_string<char_type> string_type;\n\n    explicit collate_byname(const char* __n, size_t __refs = 0);\n    explicit collate_byname(const string& __n, size_t __refs = 0);\n\nprotected:\n    ~collate_byname();\n    virtual int do_compare(const char_type* __lo1, const char_type* __hi1,\n                           const char_type* __lo2, const char_type* __hi2) const;\n    virtual string_type do_transform(const char_type* __lo, const char_type* __hi) const;\n};\n\ntemplate <>\nclass _LIBCPP_TYPE_VIS collate_byname<wchar_t>\n    : public collate<wchar_t>\n{\n    locale_t __l;\npublic:\n    typedef wchar_t char_type;\n    typedef basic_string<char_type> string_type;\n\n    explicit collate_byname(const char* __n, size_t __refs = 0);\n    explicit collate_byname(const string& __n, size_t __refs = 0);\n\nprotected:\n    ~collate_byname();\n\n    virtual int do_compare(const char_type* __lo1, const char_type* __hi1,\n                           const char_type* __lo2, const char_type* __hi2) const;\n    virtual string_type do_transform(const char_type* __lo, const char_type* __hi) const;\n};\n\ntemplate <class _CharT, class _Traits, class _Allocator>\nbool\nlocale::operator()(const basic_string<_CharT, _Traits, _Allocator>& __x,\n                   const basic_string<_CharT, _Traits, _Allocator>& __y) const\n{\n    return _VSTD::use_facet<_VSTD::collate<_CharT> >(*this).compare(\n                                       __x.data(), __x.data() + __x.size(),\n                                       __y.data(), __y.data() + __y.size()) < 0;\n}\n\n// template <class charT> class ctype\n\nclass _LIBCPP_TYPE_VIS ctype_base\n{\npublic:\n#if defined(__GLIBC__)\n    typedef unsigned short mask;\n    static const mask space  = _ISspace;\n    static const mask print  = _ISprint;\n    static const mask cntrl  = _IScntrl;\n    static const mask upper  = _ISupper;\n    static const mask lower  = _ISlower;\n    static const mask alpha  = _ISalpha;\n    static const mask digit  = _ISdigit;\n    static const mask punct  = _ISpunct;\n    static const mask xdigit = _ISxdigit;\n    static const mask blank  = _ISblank;\n#elif defined(_LIBCPP_MSVCRT)\n    typedef unsigned short mask;\n    static const mask space  = _SPACE;\n    static const mask print  = _BLANK|_PUNCT|_ALPHA|_DIGIT;\n    static const mask cntrl  = _CONTROL;\n    static const mask upper  = _UPPER;\n    static const mask lower  = _LOWER;\n    static const mask alpha  = _ALPHA;\n    static const mask digit  = _DIGIT;\n    static const mask punct  = _PUNCT;\n    static const mask xdigit = _HEX;\n    static const mask blank  = _BLANK;\n# define _LIBCPP_CTYPE_MASK_IS_COMPOSITE_PRINT\n#elif defined(__APPLE__) || defined(__FreeBSD__) || defined(__EMSCRIPTEN__) || defined(__NetBSD__)\n# ifdef __APPLE__\n    typedef __uint32_t mask;\n# elif defined(__FreeBSD__)\n    typedef unsigned long mask;\n# elif defined(__EMSCRIPTEN__) || defined(__NetBSD__)\n    typedef unsigned short mask;\n# endif\n    static const mask space  = _CTYPE_S;\n    static const mask print  = _CTYPE_R;\n    static const mask cntrl  = _CTYPE_C;\n    static const mask upper  = _CTYPE_U;\n    static const mask lower  = _CTYPE_L;\n    static const mask alpha  = _CTYPE_A;\n    static const mask digit  = _CTYPE_D;\n    static const mask punct  = _CTYPE_P;\n    static const mask xdigit = _CTYPE_X;\n\n# if defined(__NetBSD__)\n    static const mask blank  = _CTYPE_BL;\n# else\n    static const mask blank  = _CTYPE_B;\n# endif\n#elif defined(__sun__) || defined(_AIX)\n    typedef unsigned int mask;\n    static const mask space  = _ISSPACE;\n    static const mask print  = _ISPRINT;\n    static const mask cntrl  = _ISCNTRL;\n    static const mask upper  = _ISUPPER;\n    static const mask lower  = _ISLOWER;\n    static const mask alpha  = _ISALPHA;\n    static const mask digit  = _ISDIGIT;\n    static const mask punct  = _ISPUNCT;\n    static const mask xdigit = _ISXDIGIT;\n    static const mask blank  = _ISBLANK;\n#elif defined(_NEWLIB_VERSION)\n    // Same type as Newlib's _ctype_ array in newlib/libc/include/ctype.h.\n    typedef char mask;\n    static const mask space  = _S;\n    static const mask print  = _P | _U | _L | _N | _B;\n    static const mask cntrl  = _C;\n    static const mask upper  = _U;\n    static const mask lower  = _L;\n    static const mask alpha  = _U | _L;\n    static const mask digit  = _N;\n    static const mask punct  = _P;\n    static const mask xdigit = _X | _N;\n    static const mask blank  = _B;\n# define _LIBCPP_CTYPE_MASK_IS_COMPOSITE_PRINT\n# define _LIBCPP_CTYPE_MASK_IS_COMPOSITE_ALPHA\n# define _LIBCPP_CTYPE_MASK_IS_COMPOSITE_XDIGIT\n#else\n    typedef unsigned long mask;\n    static const mask space  = 1<<0;\n    static const mask print  = 1<<1;\n    static const mask cntrl  = 1<<2;\n    static const mask upper  = 1<<3;\n    static const mask lower  = 1<<4;\n    static const mask alpha  = 1<<5;\n    static const mask digit  = 1<<6;\n    static const mask punct  = 1<<7;\n    static const mask xdigit = 1<<8;\n    static const mask blank  = 1<<9;\n#endif\n    static const mask alnum  = alpha | digit;\n    static const mask graph  = alnum | punct;\n\n    _LIBCPP_ALWAYS_INLINE ctype_base() {}\n};\n\ntemplate <class _CharT> class _LIBCPP_TEMPLATE_VIS ctype;\n\ntemplate <>\nclass _LIBCPP_TYPE_VIS ctype<wchar_t>\n    : public locale::facet,\n      public ctype_base\n{\npublic:\n    typedef wchar_t char_type;\n\n    _LIBCPP_ALWAYS_INLINE\n    explicit ctype(size_t __refs = 0)\n        : locale::facet(__refs) {}\n\n    _LIBCPP_ALWAYS_INLINE\n    bool is(mask __m, char_type __c) const\n    {\n        return do_is(__m, __c);\n    }\n\n    _LIBCPP_ALWAYS_INLINE\n    const char_type* is(const char_type* __low, const char_type* __high, mask* __vec) const\n    {\n        return do_is(__low, __high, __vec);\n    }\n\n    _LIBCPP_ALWAYS_INLINE\n    const char_type* scan_is(mask __m, const char_type* __low, const char_type* __high) const\n    {\n        return do_scan_is(__m, __low, __high);\n    }\n\n    _LIBCPP_ALWAYS_INLINE\n    const char_type* scan_not(mask __m, const char_type* __low, const char_type* __high) const\n    {\n        return do_scan_not(__m, __low, __high);\n    }\n\n    _LIBCPP_ALWAYS_INLINE\n    char_type toupper(char_type __c) const\n    {\n        return do_toupper(__c);\n    }\n\n    _LIBCPP_ALWAYS_INLINE\n    const char_type* toupper(char_type* __low, const char_type* __high) const\n    {\n        return do_toupper(__low, __high);\n    }\n\n    _LIBCPP_ALWAYS_INLINE\n    char_type tolower(char_type __c) const\n    {\n        return do_tolower(__c);\n    }\n\n    _LIBCPP_ALWAYS_INLINE\n    const char_type* tolower(char_type* __low, const char_type* __high) const\n    {\n        return do_tolower(__low, __high);\n    }\n\n    _LIBCPP_ALWAYS_INLINE\n    char_type widen(char __c) const\n    {\n        return do_widen(__c);\n    }\n\n    _LIBCPP_ALWAYS_INLINE\n    const char* widen(const char* __low, const char* __high, char_type* __to) const\n    {\n        return do_widen(__low, __high, __to);\n    }\n\n    _LIBCPP_ALWAYS_INLINE\n    char narrow(char_type __c, char __dfault) const\n    {\n        return do_narrow(__c, __dfault);\n    }\n\n    _LIBCPP_ALWAYS_INLINE\n    const char_type* narrow(const char_type* __low, const char_type* __high, char __dfault, char* __to) const\n    {\n        return do_narrow(__low, __high, __dfault, __to);\n    }\n\n    static locale::id id;\n\nprotected:\n    ~ctype();\n    virtual bool do_is(mask __m, char_type __c) const;\n    virtual const char_type* do_is(const char_type* __low, const char_type* __high, mask* __vec) const;\n    virtual const char_type* do_scan_is(mask __m, const char_type* __low, const char_type* __high) const;\n    virtual const char_type* do_scan_not(mask __m, const char_type* __low, const char_type* __high) const;\n    virtual char_type do_toupper(char_type) const;\n    virtual const char_type* do_toupper(char_type* __low, const char_type* __high) const;\n    virtual char_type do_tolower(char_type) const;\n    virtual const char_type* do_tolower(char_type* __low, const char_type* __high) const;\n    virtual char_type do_widen(char) const;\n    virtual const char* do_widen(const char* __low, const char* __high, char_type* __dest) const;\n    virtual char do_narrow(char_type, char __dfault) const;\n    virtual const char_type* do_narrow(const char_type* __low, const char_type* __high, char __dfault, char* __dest) const;\n};\n\ntemplate <>\nclass _LIBCPP_TYPE_VIS ctype<char>\n    : public locale::facet, public ctype_base\n{\n    const mask* __tab_;\n    bool        __del_;\npublic:\n    typedef char char_type;\n\n    explicit ctype(const mask* __tab = 0, bool __del = false, size_t __refs = 0);\n\n    _LIBCPP_ALWAYS_INLINE\n    bool is(mask __m, char_type __c) const\n    {\n        return isascii(__c) ? (__tab_[static_cast<int>(__c)] & __m) !=0 : false;\n    }\n\n    _LIBCPP_ALWAYS_INLINE\n    const char_type* is(const char_type* __low, const char_type* __high, mask* __vec) const\n    {\n        for (; __low != __high; ++__low, ++__vec)\n            *__vec = isascii(*__low) ? __tab_[static_cast<int>(*__low)] : 0;\n        return __low;\n    }\n\n    _LIBCPP_ALWAYS_INLINE\n    const char_type* scan_is (mask __m, const char_type* __low, const char_type* __high) const\n    {\n        for (; __low != __high; ++__low)\n            if (isascii(*__low) && (__tab_[static_cast<int>(*__low)] & __m))\n                break;\n        return __low;\n    }\n\n    _LIBCPP_ALWAYS_INLINE\n    const char_type* scan_not(mask __m, const char_type* __low, const char_type* __high) const\n    {\n        for (; __low != __high; ++__low)\n            if (!(isascii(*__low) && (__tab_[static_cast<int>(*__low)] & __m)))\n                break;\n        return __low;\n    }\n\n    _LIBCPP_ALWAYS_INLINE\n    char_type toupper(char_type __c) const\n    {\n        return do_toupper(__c);\n    }\n\n    _LIBCPP_ALWAYS_INLINE\n    const char_type* toupper(char_type* __low, const char_type* __high) const\n    {\n        return do_toupper(__low, __high);\n    }\n\n    _LIBCPP_ALWAYS_INLINE\n    char_type tolower(char_type __c) const\n    {\n        return do_tolower(__c);\n    }\n\n    _LIBCPP_ALWAYS_INLINE\n    const char_type* tolower(char_type* __low, const char_type* __high) const\n    {\n        return do_tolower(__low, __high);\n    }\n\n    _LIBCPP_ALWAYS_INLINE\n    char_type widen(char __c) const\n    {\n        return do_widen(__c);\n    }\n\n    _LIBCPP_ALWAYS_INLINE\n    const char* widen(const char* __low, const char* __high, char_type* __to) const\n    {\n        return do_widen(__low, __high, __to);\n    }\n\n    _LIBCPP_ALWAYS_INLINE\n    char narrow(char_type __c, char __dfault) const\n    {\n        return do_narrow(__c, __dfault);\n    }\n\n    _LIBCPP_ALWAYS_INLINE\n    const char* narrow(const char_type* __low, const char_type* __high, char __dfault, char* __to) const\n    {\n        return do_narrow(__low, __high, __dfault, __to);\n    }\n\n    static locale::id id;\n\n#ifdef _CACHED_RUNES\n    static const size_t table_size = _CACHED_RUNES;\n#else\n    static const size_t table_size = 256;  // FIXME: Don't hardcode this.\n#endif\n    _LIBCPP_ALWAYS_INLINE const mask* table() const  _NOEXCEPT {return __tab_;}\n    static const mask* classic_table()  _NOEXCEPT;\n#if defined(__GLIBC__) || defined(__EMSCRIPTEN__)\n    static const int* __classic_upper_table() _NOEXCEPT;\n    static const int* __classic_lower_table() _NOEXCEPT;\n#endif\n#if defined(__NetBSD__)\n    static const short* __classic_upper_table() _NOEXCEPT;\n    static const short* __classic_lower_table() _NOEXCEPT;\n#endif\n\nprotected:\n    ~ctype();\n    virtual char_type do_toupper(char_type __c) const;\n    virtual const char_type* do_toupper(char_type* __low, const char_type* __high) const;\n    virtual char_type do_tolower(char_type __c) const;\n    virtual const char_type* do_tolower(char_type* __low, const char_type* __high) const;\n    virtual char_type do_widen(char __c) const;\n    virtual const char* do_widen(const char* __low, const char* __high, char_type* __to) const;\n    virtual char do_narrow(char_type __c, char __dfault) const;\n    virtual const char* do_narrow(const char_type* __low, const char_type* __high, char __dfault, char* __to) const;\n};\n\n// template <class CharT> class ctype_byname;\n\ntemplate <class _CharT> class _LIBCPP_TEMPLATE_VIS ctype_byname;\n\ntemplate <>\nclass _LIBCPP_TYPE_VIS ctype_byname<char>\n    : public ctype<char>\n{\n    locale_t __l;\n\npublic:\n    explicit ctype_byname(const char*, size_t = 0);\n    explicit ctype_byname(const string&, size_t = 0);\n\nprotected:\n    ~ctype_byname();\n    virtual char_type do_toupper(char_type) const;\n    virtual const char_type* do_toupper(char_type* __low, const char_type* __high) const;\n    virtual char_type do_tolower(char_type) const;\n    virtual const char_type* do_tolower(char_type* __low, const char_type* __high) const;\n};\n\ntemplate <>\nclass _LIBCPP_TYPE_VIS ctype_byname<wchar_t>\n    : public ctype<wchar_t>\n{\n    locale_t __l;\n\npublic:\n    explicit ctype_byname(const char*, size_t = 0);\n    explicit ctype_byname(const string&, size_t = 0);\n\nprotected:\n    ~ctype_byname();\n    virtual bool do_is(mask __m, char_type __c) const;\n    virtual const char_type* do_is(const char_type* __low, const char_type* __high, mask* __vec) const;\n    virtual const char_type* do_scan_is(mask __m, const char_type* __low, const char_type* __high) const;\n    virtual const char_type* do_scan_not(mask __m, const char_type* __low, const char_type* __high) const;\n    virtual char_type do_toupper(char_type) const;\n    virtual const char_type* do_toupper(char_type* __low, const char_type* __high) const;\n    virtual char_type do_tolower(char_type) const;\n    virtual const char_type* do_tolower(char_type* __low, const char_type* __high) const;\n    virtual char_type do_widen(char) const;\n    virtual const char* do_widen(const char* __low, const char* __high, char_type* __dest) const;\n    virtual char do_narrow(char_type, char __dfault) const;\n    virtual const char_type* do_narrow(const char_type* __low, const char_type* __high, char __dfault, char* __dest) const;\n};\n\ntemplate <class _CharT>\ninline _LIBCPP_INLINE_VISIBILITY\nbool\nisspace(_CharT __c, const locale& __loc)\n{\n    return use_facet<ctype<_CharT> >(__loc).is(ctype_base::space, __c);\n}\n\ntemplate <class _CharT>\ninline _LIBCPP_INLINE_VISIBILITY\nbool\nisprint(_CharT __c, const locale& __loc)\n{\n    return use_facet<ctype<_CharT> >(__loc).is(ctype_base::print, __c);\n}\n\ntemplate <class _CharT>\ninline _LIBCPP_INLINE_VISIBILITY\nbool\niscntrl(_CharT __c, const locale& __loc)\n{\n    return use_facet<ctype<_CharT> >(__loc).is(ctype_base::cntrl, __c);\n}\n\ntemplate <class _CharT>\ninline _LIBCPP_INLINE_VISIBILITY\nbool\nisupper(_CharT __c, const locale& __loc)\n{\n    return use_facet<ctype<_CharT> >(__loc).is(ctype_base::upper, __c);\n}\n\ntemplate <class _CharT>\ninline _LIBCPP_INLINE_VISIBILITY\nbool\nislower(_CharT __c, const locale& __loc)\n{\n    return use_facet<ctype<_CharT> >(__loc).is(ctype_base::lower, __c);\n}\n\ntemplate <class _CharT>\ninline _LIBCPP_INLINE_VISIBILITY\nbool\nisalpha(_CharT __c, const locale& __loc)\n{\n    return use_facet<ctype<_CharT> >(__loc).is(ctype_base::alpha, __c);\n}\n\ntemplate <class _CharT>\ninline _LIBCPP_INLINE_VISIBILITY\nbool\nisdigit(_CharT __c, const locale& __loc)\n{\n    return use_facet<ctype<_CharT> >(__loc).is(ctype_base::digit, __c);\n}\n\ntemplate <class _CharT>\ninline _LIBCPP_INLINE_VISIBILITY\nbool\nispunct(_CharT __c, const locale& __loc)\n{\n    return use_facet<ctype<_CharT> >(__loc).is(ctype_base::punct, __c);\n}\n\ntemplate <class _CharT>\ninline _LIBCPP_INLINE_VISIBILITY\nbool\nisxdigit(_CharT __c, const locale& __loc)\n{\n    return use_facet<ctype<_CharT> >(__loc).is(ctype_base::xdigit, __c);\n}\n\ntemplate <class _CharT>\ninline _LIBCPP_INLINE_VISIBILITY\nbool\nisalnum(_CharT __c, const locale& __loc)\n{\n    return use_facet<ctype<_CharT> >(__loc).is(ctype_base::alnum, __c);\n}\n\ntemplate <class _CharT>\ninline _LIBCPP_INLINE_VISIBILITY\nbool\nisgraph(_CharT __c, const locale& __loc)\n{\n    return use_facet<ctype<_CharT> >(__loc).is(ctype_base::graph, __c);\n}\n\ntemplate <class _CharT>\ninline _LIBCPP_INLINE_VISIBILITY\n_CharT\ntoupper(_CharT __c, const locale& __loc)\n{\n    return use_facet<ctype<_CharT> >(__loc).toupper(__c);\n}\n\ntemplate <class _CharT>\ninline _LIBCPP_INLINE_VISIBILITY\n_CharT\ntolower(_CharT __c, const locale& __loc)\n{\n    return use_facet<ctype<_CharT> >(__loc).tolower(__c);\n}\n\n// codecvt_base\n\nclass _LIBCPP_TYPE_VIS codecvt_base\n{\npublic:\n    _LIBCPP_ALWAYS_INLINE codecvt_base() {}\n    enum result {ok, partial, error, noconv};\n};\n\n// template <class internT, class externT, class stateT> class codecvt;\n\ntemplate <class _InternT, class _ExternT, class _StateT> class _LIBCPP_TEMPLATE_VIS codecvt;\n\n// template <> class codecvt<char, char, mbstate_t>\n\ntemplate <>\nclass _LIBCPP_TYPE_VIS codecvt<char, char, mbstate_t>\n    : public locale::facet,\n      public codecvt_base\n{\npublic:\n    typedef char      intern_type;\n    typedef char      extern_type;\n    typedef mbstate_t state_type;\n\n    _LIBCPP_ALWAYS_INLINE\n    explicit codecvt(size_t __refs = 0)\n        : locale::facet(__refs) {}\n\n    _LIBCPP_ALWAYS_INLINE\n    result out(state_type& __st,\n               const intern_type* __frm, const intern_type* __frm_end, const intern_type*& __frm_nxt,\n               extern_type* __to, extern_type* __to_end, extern_type*& __to_nxt) const\n    {\n        return do_out(__st, __frm, __frm_end, __frm_nxt, __to, __to_end, __to_nxt);\n    }\n\n    _LIBCPP_ALWAYS_INLINE\n    result unshift(state_type& __st,\n                   extern_type* __to, extern_type* __to_end, extern_type*& __to_nxt) const\n    {\n        return do_unshift(__st, __to, __to_end, __to_nxt);\n    }\n\n    _LIBCPP_ALWAYS_INLINE\n    result in(state_type& __st,\n              const extern_type* __frm, const extern_type* __frm_end, const extern_type*& __frm_nxt,\n              intern_type* __to, intern_type* __to_end, intern_type*& __to_nxt) const\n    {\n        return do_in(__st, __frm, __frm_end, __frm_nxt, __to, __to_end, __to_nxt);\n    }\n\n    _LIBCPP_ALWAYS_INLINE\n    int encoding() const  _NOEXCEPT\n    {\n        return do_encoding();\n    }\n\n    _LIBCPP_ALWAYS_INLINE\n    bool always_noconv() const  _NOEXCEPT\n    {\n        return do_always_noconv();\n    }\n\n    _LIBCPP_ALWAYS_INLINE\n    int length(state_type& __st, const extern_type* __frm, const extern_type* __end, size_t __mx) const\n    {\n        return do_length(__st, __frm, __end, __mx);\n    }\n\n    _LIBCPP_ALWAYS_INLINE\n    int max_length() const  _NOEXCEPT\n    {\n        return do_max_length();\n    }\n\n    static locale::id id;\n\nprotected:\n    _LIBCPP_ALWAYS_INLINE\n    explicit codecvt(const char*, size_t __refs = 0)\n        : locale::facet(__refs) {}\n\n    ~codecvt();\n\n    virtual result do_out(state_type& __st,\n                          const intern_type* __frm, const intern_type* __frm_end, const intern_type*& __frm_nxt,\n                          extern_type* __to, extern_type* __to_end, extern_type*& __to_nxt) const;\n    virtual result do_in(state_type& __st,\n                         const extern_type* __frm, const extern_type* __frm_end, const extern_type*& __frm_nxt,\n                         intern_type* __to, intern_type* __to_end, intern_type*& __to_nxt) const;\n    virtual result do_unshift(state_type& __st,\n                              extern_type* __to, extern_type* __to_end, extern_type*& __to_nxt) const;\n    virtual int do_encoding() const  _NOEXCEPT;\n    virtual bool do_always_noconv() const  _NOEXCEPT;\n    virtual int do_length(state_type& __st, const extern_type* __frm, const extern_type* __end, size_t __mx) const;\n    virtual int do_max_length() const  _NOEXCEPT;\n};\n\n// template <> class codecvt<wchar_t, char, mbstate_t>\n\ntemplate <>\nclass _LIBCPP_TYPE_VIS codecvt<wchar_t, char, mbstate_t>\n    : public locale::facet,\n      public codecvt_base\n{\n    locale_t __l;\npublic:\n    typedef wchar_t   intern_type;\n    typedef char      extern_type;\n    typedef mbstate_t state_type;\n\n    explicit codecvt(size_t __refs = 0);\n\n    _LIBCPP_ALWAYS_INLINE\n    result out(state_type& __st,\n               const intern_type* __frm, const intern_type* __frm_end, const intern_type*& __frm_nxt,\n               extern_type* __to, extern_type* __to_end, extern_type*& __to_nxt) const\n    {\n        return do_out(__st, __frm, __frm_end, __frm_nxt, __to, __to_end, __to_nxt);\n    }\n\n    _LIBCPP_ALWAYS_INLINE\n    result unshift(state_type& __st,\n                   extern_type* __to, extern_type* __to_end, extern_type*& __to_nxt) const\n    {\n        return do_unshift(__st, __to, __to_end, __to_nxt);\n    }\n\n    _LIBCPP_ALWAYS_INLINE\n    result in(state_type& __st,\n              const extern_type* __frm, const extern_type* __frm_end, const extern_type*& __frm_nxt,\n              intern_type* __to, intern_type* __to_end, intern_type*& __to_nxt) const\n    {\n        return do_in(__st, __frm, __frm_end, __frm_nxt, __to, __to_end, __to_nxt);\n    }\n\n    _LIBCPP_ALWAYS_INLINE\n    int encoding() const  _NOEXCEPT\n    {\n        return do_encoding();\n    }\n\n    _LIBCPP_ALWAYS_INLINE\n    bool always_noconv() const  _NOEXCEPT\n    {\n        return do_always_noconv();\n    }\n\n    _LIBCPP_ALWAYS_INLINE\n    int length(state_type& __st, const extern_type* __frm, const extern_type* __end, size_t __mx) const\n    {\n        return do_length(__st, __frm, __end, __mx);\n    }\n\n    _LIBCPP_ALWAYS_INLINE\n    int max_length() const  _NOEXCEPT\n    {\n        return do_max_length();\n    }\n\n    static locale::id id;\n\nprotected:\n    explicit codecvt(const char*, size_t __refs = 0);\n\n    ~codecvt();\n\n    virtual result do_out(state_type& __st,\n                          const intern_type* __frm, const intern_type* __frm_end, const intern_type*& __frm_nxt,\n                          extern_type* __to, extern_type* __to_end, extern_type*& __to_nxt) const;\n    virtual result do_in(state_type& __st,\n                         const extern_type* __frm, const extern_type* __frm_end, const extern_type*& __frm_nxt,\n                         intern_type* __to, intern_type* __to_end, intern_type*& __to_nxt) const;\n    virtual result do_unshift(state_type& __st,\n                              extern_type* __to, extern_type* __to_end, extern_type*& __to_nxt) const;\n    virtual int do_encoding() const  _NOEXCEPT;\n    virtual bool do_always_noconv() const  _NOEXCEPT;\n    virtual int do_length(state_type&, const extern_type* __frm, const extern_type* __end, size_t __mx) const;\n    virtual int do_max_length() const  _NOEXCEPT;\n};\n\n// template <> class codecvt<char16_t, char, mbstate_t>\n\ntemplate <>\nclass _LIBCPP_TYPE_VIS codecvt<char16_t, char, mbstate_t>\n    : public locale::facet,\n      public codecvt_base\n{\npublic:\n    typedef char16_t  intern_type;\n    typedef char      extern_type;\n    typedef mbstate_t state_type;\n\n    _LIBCPP_ALWAYS_INLINE\n    explicit codecvt(size_t __refs = 0)\n        : locale::facet(__refs) {}\n\n    _LIBCPP_ALWAYS_INLINE\n    result out(state_type& __st,\n               const intern_type* __frm, const intern_type* __frm_end, const intern_type*& __frm_nxt,\n               extern_type* __to, extern_type* __to_end, extern_type*& __to_nxt) const\n    {\n        return do_out(__st, __frm, __frm_end, __frm_nxt, __to, __to_end, __to_nxt);\n    }\n\n    _LIBCPP_ALWAYS_INLINE\n    result unshift(state_type& __st,\n                   extern_type* __to, extern_type* __to_end, extern_type*& __to_nxt) const\n    {\n        return do_unshift(__st, __to, __to_end, __to_nxt);\n    }\n\n    _LIBCPP_ALWAYS_INLINE\n    result in(state_type& __st,\n              const extern_type* __frm, const extern_type* __frm_end, const extern_type*& __frm_nxt,\n              intern_type* __to, intern_type* __to_end, intern_type*& __to_nxt) const\n    {\n        return do_in(__st, __frm, __frm_end, __frm_nxt, __to, __to_end, __to_nxt);\n    }\n\n    _LIBCPP_ALWAYS_INLINE\n    int encoding() const  _NOEXCEPT\n    {\n        return do_encoding();\n    }\n\n    _LIBCPP_ALWAYS_INLINE\n    bool always_noconv() const  _NOEXCEPT\n    {\n        return do_always_noconv();\n    }\n\n    _LIBCPP_ALWAYS_INLINE\n    int length(state_type& __st, const extern_type* __frm, const extern_type* __end, size_t __mx) const\n    {\n        return do_length(__st, __frm, __end, __mx);\n    }\n\n    _LIBCPP_ALWAYS_INLINE\n    int max_length() const  _NOEXCEPT\n    {\n        return do_max_length();\n    }\n\n    static locale::id id;\n\nprotected:\n    _LIBCPP_ALWAYS_INLINE\n    explicit codecvt(const char*, size_t __refs = 0)\n        : locale::facet(__refs) {}\n\n    ~codecvt();\n\n    virtual result do_out(state_type& __st,\n                          const intern_type* __frm, const intern_type* __frm_end, const intern_type*& __frm_nxt,\n                          extern_type* __to, extern_type* __to_end, extern_type*& __to_nxt) const;\n    virtual result do_in(state_type& __st,\n                         const extern_type* __frm, const extern_type* __frm_end, const extern_type*& __frm_nxt,\n                         intern_type* __to, intern_type* __to_end, intern_type*& __to_nxt) const;\n    virtual result do_unshift(state_type& __st,\n                              extern_type* __to, extern_type* __to_end, extern_type*& __to_nxt) const;\n    virtual int do_encoding() const  _NOEXCEPT;\n    virtual bool do_always_noconv() const  _NOEXCEPT;\n    virtual int do_length(state_type&, const extern_type* __frm, const extern_type* __end, size_t __mx) const;\n    virtual int do_max_length() const  _NOEXCEPT;\n};\n\n// template <> class codecvt<char32_t, char, mbstate_t>\n\ntemplate <>\nclass _LIBCPP_TYPE_VIS codecvt<char32_t, char, mbstate_t>\n    : public locale::facet,\n      public codecvt_base\n{\npublic:\n    typedef char32_t  intern_type;\n    typedef char      extern_type;\n    typedef mbstate_t state_type;\n\n    _LIBCPP_ALWAYS_INLINE\n    explicit codecvt(size_t __refs = 0)\n        : locale::facet(__refs) {}\n\n    _LIBCPP_ALWAYS_INLINE\n    result out(state_type& __st,\n               const intern_type* __frm, const intern_type* __frm_end, const intern_type*& __frm_nxt,\n               extern_type* __to, extern_type* __to_end, extern_type*& __to_nxt) const\n    {\n        return do_out(__st, __frm, __frm_end, __frm_nxt, __to, __to_end, __to_nxt);\n    }\n\n    _LIBCPP_ALWAYS_INLINE\n    result unshift(state_type& __st,\n                   extern_type* __to, extern_type* __to_end, extern_type*& __to_nxt) const\n    {\n        return do_unshift(__st, __to, __to_end, __to_nxt);\n    }\n\n    _LIBCPP_ALWAYS_INLINE\n    result in(state_type& __st,\n              const extern_type* __frm, const extern_type* __frm_end, const extern_type*& __frm_nxt,\n              intern_type* __to, intern_type* __to_end, intern_type*& __to_nxt) const\n    {\n        return do_in(__st, __frm, __frm_end, __frm_nxt, __to, __to_end, __to_nxt);\n    }\n\n    _LIBCPP_ALWAYS_INLINE\n    int encoding() const  _NOEXCEPT\n    {\n        return do_encoding();\n    }\n\n    _LIBCPP_ALWAYS_INLINE\n    bool always_noconv() const  _NOEXCEPT\n    {\n        return do_always_noconv();\n    }\n\n    _LIBCPP_ALWAYS_INLINE\n    int length(state_type& __st, const extern_type* __frm, const extern_type* __end, size_t __mx) const\n    {\n        return do_length(__st, __frm, __end, __mx);\n    }\n\n    _LIBCPP_ALWAYS_INLINE\n    int max_length() const  _NOEXCEPT\n    {\n        return do_max_length();\n    }\n\n    static locale::id id;\n\nprotected:\n    _LIBCPP_ALWAYS_INLINE\n    explicit codecvt(const char*, size_t __refs = 0)\n        : locale::facet(__refs) {}\n\n    ~codecvt();\n\n    virtual result do_out(state_type& __st,\n                          const intern_type* __frm, const intern_type* __frm_end, const intern_type*& __frm_nxt,\n                          extern_type* __to, extern_type* __to_end, extern_type*& __to_nxt) const;\n    virtual result do_in(state_type& __st,\n                         const extern_type* __frm, const extern_type* __frm_end, const extern_type*& __frm_nxt,\n                         intern_type* __to, intern_type* __to_end, intern_type*& __to_nxt) const;\n    virtual result do_unshift(state_type& __st,\n                              extern_type* __to, extern_type* __to_end, extern_type*& __to_nxt) const;\n    virtual int do_encoding() const  _NOEXCEPT;\n    virtual bool do_always_noconv() const  _NOEXCEPT;\n    virtual int do_length(state_type&, const extern_type* __frm, const extern_type* __end, size_t __mx) const;\n    virtual int do_max_length() const  _NOEXCEPT;\n};\n\n// template <class _InternT, class _ExternT, class _StateT> class codecvt_byname\n\ntemplate <class _InternT, class _ExternT, class _StateT>\nclass _LIBCPP_TEMPLATE_VIS codecvt_byname\n    : public codecvt<_InternT, _ExternT, _StateT>\n{\npublic:\n    _LIBCPP_ALWAYS_INLINE\n    explicit codecvt_byname(const char* __nm, size_t __refs = 0)\n        : codecvt<_InternT, _ExternT, _StateT>(__nm, __refs) {}\n    _LIBCPP_ALWAYS_INLINE\n    explicit codecvt_byname(const string& __nm, size_t __refs = 0)\n        : codecvt<_InternT, _ExternT, _StateT>(__nm.c_str(), __refs) {}\nprotected:\n    ~codecvt_byname();\n};\n\ntemplate <class _InternT, class _ExternT, class _StateT>\ncodecvt_byname<_InternT, _ExternT, _StateT>::~codecvt_byname()\n{\n}\n\n_LIBCPP_EXTERN_TEMPLATE2(class _LIBCPP_EXTERN_TEMPLATE_TYPE_VIS codecvt_byname<char, char, mbstate_t>)\n_LIBCPP_EXTERN_TEMPLATE2(class _LIBCPP_EXTERN_TEMPLATE_TYPE_VIS codecvt_byname<wchar_t, char, mbstate_t>)\n_LIBCPP_EXTERN_TEMPLATE2(class _LIBCPP_EXTERN_TEMPLATE_TYPE_VIS codecvt_byname<char16_t, char, mbstate_t>)\n_LIBCPP_EXTERN_TEMPLATE2(class _LIBCPP_EXTERN_TEMPLATE_TYPE_VIS codecvt_byname<char32_t, char, mbstate_t>)\n\n_LIBCPP_NORETURN _LIBCPP_FUNC_VIS void __throw_runtime_error(const char*);\n\ntemplate <size_t _Np>\nstruct __narrow_to_utf8\n{\n    template <class _OutputIterator, class _CharT>\n    _OutputIterator\n    operator()(_OutputIterator __s, const _CharT* __wb, const _CharT* __we) const;\n};\n\ntemplate <>\nstruct __narrow_to_utf8<8>\n{\n    template <class _OutputIterator, class _CharT>\n    _LIBCPP_ALWAYS_INLINE\n    _OutputIterator\n    operator()(_OutputIterator __s, const _CharT* __wb, const _CharT* __we) const\n    {\n        for (; __wb < __we; ++__wb, ++__s)\n            *__s = *__wb;\n        return __s;\n    }\n};\n\ntemplate <>\nstruct __narrow_to_utf8<16>\n    : public codecvt<char16_t, char, mbstate_t>\n{\n    _LIBCPP_ALWAYS_INLINE\n    __narrow_to_utf8() : codecvt<char16_t, char, mbstate_t>(1) {}\n\n    ~__narrow_to_utf8();\n\n    template <class _OutputIterator, class _CharT>\n    _LIBCPP_ALWAYS_INLINE\n    _OutputIterator\n    operator()(_OutputIterator __s, const _CharT* __wb, const _CharT* __we) const\n    {\n        result __r = ok;\n        mbstate_t __mb;\n        while (__wb < __we && __r != error)\n        {\n            const int __sz = 32;\n            char __buf[__sz];\n            char* __bn;\n            const char16_t* __wn = (const char16_t*)__wb;\n            __r = do_out(__mb, (const char16_t*)__wb, (const char16_t*)__we, __wn,\n                         __buf, __buf+__sz, __bn);\n            if (__r == codecvt_base::error || __wn == (const char16_t*)__wb)\n                __throw_runtime_error(\"locale not supported\");\n            for (const char* __p = __buf; __p < __bn; ++__p, ++__s)\n                *__s = *__p;\n            __wb = (const _CharT*)__wn;\n        }\n        return __s;\n    }\n};\n\ntemplate <>\nstruct __narrow_to_utf8<32>\n    : public codecvt<char32_t, char, mbstate_t>\n{\n    _LIBCPP_ALWAYS_INLINE\n    __narrow_to_utf8() : codecvt<char32_t, char, mbstate_t>(1) {}\n\n    ~__narrow_to_utf8();\n\n    template <class _OutputIterator, class _CharT>\n    _LIBCPP_ALWAYS_INLINE\n    _OutputIterator\n    operator()(_OutputIterator __s, const _CharT* __wb, const _CharT* __we) const\n    {\n        result __r = ok;\n        mbstate_t __mb;\n        while (__wb < __we && __r != error)\n        {\n            const int __sz = 32;\n            char __buf[__sz];\n            char* __bn;\n            const char32_t* __wn = (const char32_t*)__wb;\n            __r = do_out(__mb, (const char32_t*)__wb, (const char32_t*)__we, __wn,\n                         __buf, __buf+__sz, __bn);\n            if (__r == codecvt_base::error || __wn == (const char32_t*)__wb)\n                __throw_runtime_error(\"locale not supported\");\n            for (const char* __p = __buf; __p < __bn; ++__p, ++__s)\n                *__s = *__p;\n            __wb = (const _CharT*)__wn;\n        }\n        return __s;\n    }\n};\n\ntemplate <size_t _Np>\nstruct __widen_from_utf8\n{\n    template <class _OutputIterator>\n    _OutputIterator\n    operator()(_OutputIterator __s, const char* __nb, const char* __ne) const;\n};\n\ntemplate <>\nstruct __widen_from_utf8<8>\n{\n    template <class _OutputIterator>\n    _LIBCPP_ALWAYS_INLINE\n    _OutputIterator\n    operator()(_OutputIterator __s, const char* __nb, const char* __ne) const\n    {\n        for (; __nb < __ne; ++__nb, ++__s)\n            *__s = *__nb;\n        return __s;\n    }\n};\n\ntemplate <>\nstruct __widen_from_utf8<16>\n    : public codecvt<char16_t, char, mbstate_t>\n{\n    _LIBCPP_ALWAYS_INLINE\n    __widen_from_utf8() : codecvt<char16_t, char, mbstate_t>(1) {}\n\n    ~__widen_from_utf8();\n\n    template <class _OutputIterator>\n    _LIBCPP_ALWAYS_INLINE\n    _OutputIterator\n    operator()(_OutputIterator __s, const char* __nb, const char* __ne) const\n    {\n        result __r = ok;\n        mbstate_t __mb;\n        while (__nb < __ne && __r != error)\n        {\n            const int __sz = 32;\n            char16_t __buf[__sz];\n            char16_t* __bn;\n            const char* __nn = __nb;\n            __r = do_in(__mb, __nb, __ne - __nb > __sz ? __nb+__sz : __ne, __nn,\n                        __buf, __buf+__sz, __bn);\n            if (__r == codecvt_base::error || __nn == __nb)\n                __throw_runtime_error(\"locale not supported\");\n            for (const char16_t* __p = __buf; __p < __bn; ++__p, ++__s)\n                *__s = (wchar_t)*__p;\n            __nb = __nn;\n        }\n        return __s;\n    }\n};\n\ntemplate <>\nstruct __widen_from_utf8<32>\n    : public codecvt<char32_t, char, mbstate_t>\n{\n    _LIBCPP_ALWAYS_INLINE\n    __widen_from_utf8() : codecvt<char32_t, char, mbstate_t>(1) {}\n\n    ~__widen_from_utf8();\n\n    template <class _OutputIterator>\n    _LIBCPP_ALWAYS_INLINE\n    _OutputIterator\n    operator()(_OutputIterator __s, const char* __nb, const char* __ne) const\n    {\n        result __r = ok;\n        mbstate_t __mb;\n        while (__nb < __ne && __r != error)\n        {\n            const int __sz = 32;\n            char32_t __buf[__sz];\n            char32_t* __bn;\n            const char* __nn = __nb;\n            __r = do_in(__mb, __nb, __ne - __nb > __sz ? __nb+__sz : __ne, __nn,\n                        __buf, __buf+__sz, __bn);\n            if (__r == codecvt_base::error || __nn == __nb)\n                __throw_runtime_error(\"locale not supported\");\n            for (const char32_t* __p = __buf; __p < __bn; ++__p, ++__s)\n                *__s = (wchar_t)*__p;\n            __nb = __nn;\n        }\n        return __s;\n    }\n};\n\n// template <class charT> class numpunct\n\ntemplate <class _CharT> class _LIBCPP_TEMPLATE_VIS numpunct;\n\ntemplate <>\nclass _LIBCPP_TYPE_VIS numpunct<char>\n    : public locale::facet\n{\npublic:\n    typedef char char_type;\n    typedef basic_string<char_type> string_type;\n\n    explicit numpunct(size_t __refs = 0);\n\n    _LIBCPP_ALWAYS_INLINE char_type decimal_point() const {return do_decimal_point();}\n    _LIBCPP_ALWAYS_INLINE char_type thousands_sep() const {return do_thousands_sep();}\n    _LIBCPP_ALWAYS_INLINE string grouping() const         {return do_grouping();}\n    _LIBCPP_ALWAYS_INLINE string_type truename() const    {return do_truename();}\n    _LIBCPP_ALWAYS_INLINE string_type falsename() const   {return do_falsename();}\n\n    static locale::id id;\n\nprotected:\n    ~numpunct();\n    virtual char_type do_decimal_point() const;\n    virtual char_type do_thousands_sep() const;\n    virtual string do_grouping() const;\n    virtual string_type do_truename() const;\n    virtual string_type do_falsename() const;\n\n    char_type __decimal_point_;\n    char_type __thousands_sep_;\n    string __grouping_;\n};\n\ntemplate <>\nclass _LIBCPP_TYPE_VIS numpunct<wchar_t>\n    : public locale::facet\n{\npublic:\n    typedef wchar_t char_type;\n    typedef basic_string<char_type> string_type;\n\n    explicit numpunct(size_t __refs = 0);\n\n    _LIBCPP_ALWAYS_INLINE char_type decimal_point() const {return do_decimal_point();}\n    _LIBCPP_ALWAYS_INLINE char_type thousands_sep() const {return do_thousands_sep();}\n    _LIBCPP_ALWAYS_INLINE string grouping() const         {return do_grouping();}\n    _LIBCPP_ALWAYS_INLINE string_type truename() const    {return do_truename();}\n    _LIBCPP_ALWAYS_INLINE string_type falsename() const   {return do_falsename();}\n\n    static locale::id id;\n\nprotected:\n    ~numpunct();\n    virtual char_type do_decimal_point() const;\n    virtual char_type do_thousands_sep() const;\n    virtual string do_grouping() const;\n    virtual string_type do_truename() const;\n    virtual string_type do_falsename() const;\n\n    char_type __decimal_point_;\n    char_type __thousands_sep_;\n    string __grouping_;\n};\n\n// template <class charT> class numpunct_byname\n\ntemplate <class _CharT> class _LIBCPP_TEMPLATE_VIS numpunct_byname;\n\ntemplate <>\nclass _LIBCPP_TYPE_VIS numpunct_byname<char>\n: public numpunct<char>\n{\npublic:\n    typedef char char_type;\n    typedef basic_string<char_type> string_type;\n\n    explicit numpunct_byname(const char* __nm, size_t __refs = 0);\n    explicit numpunct_byname(const string& __nm, size_t __refs = 0);\n\nprotected:\n    ~numpunct_byname();\n\nprivate:\n    void __init(const char*);\n};\n\ntemplate <>\nclass _LIBCPP_TYPE_VIS numpunct_byname<wchar_t>\n: public numpunct<wchar_t>\n{\npublic:\n    typedef wchar_t char_type;\n    typedef basic_string<char_type> string_type;\n\n    explicit numpunct_byname(const char* __nm, size_t __refs = 0);\n    explicit numpunct_byname(const string& __nm, size_t __refs = 0);\n\nprotected:\n    ~numpunct_byname();\n\nprivate:\n    void __init(const char*);\n};\n\n_LIBCPP_END_NAMESPACE_STD\n\n#endif  // _LIBCPP___LOCALE\n","#pragma once\n#include <stdexcept>\n#if USE_READLINE == true\n#define runtime_die(arg) throw std::runtime_error(arg)\n#else\n#include <iostream>\n//we may be in a noninteractive environment, so manually print the errors\nstatic inline void runtime_die(std::string arg) {\n    std::cout << arg << std::endl;\n    throw std::runtime_error(arg);\n}\n#endif\n","// -*- C++ -*-\n//===------------------------- fstream ------------------------------------===//\n//\n//                     The LLVM Compiler Infrastructure\n//\n// This file is dual licensed under the MIT and the University of Illinois Open\n// Source Licenses. See LICENSE.TXT for details.\n//\n//===----------------------------------------------------------------------===//\n\n#ifndef _LIBCPP_FSTREAM\n#define _LIBCPP_FSTREAM\n\n/*\n    fstream synopsis\n\ntemplate <class charT, class traits = char_traits<charT> >\nclass basic_filebuf\n    : public basic_streambuf<charT, traits>\n{\npublic:\n    typedef charT                          char_type;\n    typedef traits                         traits_type;\n    typedef typename traits_type::int_type int_type;\n    typedef typename traits_type::pos_type pos_type;\n    typedef typename traits_type::off_type off_type;\n\n    // 27.9.1.2 Constructors/destructor:\n    basic_filebuf();\n    basic_filebuf(basic_filebuf&& rhs);\n    virtual ~basic_filebuf();\n\n    // 27.9.1.3 Assign/swap:\n    basic_filebuf& operator=(basic_filebuf&& rhs);\n    void swap(basic_filebuf& rhs);\n\n    // 27.9.1.4 Members:\n    bool is_open() const;\n    basic_filebuf* open(const char* s, ios_base::openmode mode);\n    basic_filebuf* open(const string& s, ios_base::openmode mode);\n    basic_filebuf* close();\n\nprotected:\n    // 27.9.1.5 Overridden virtual functions:\n    virtual streamsize showmanyc();\n    virtual int_type underflow();\n    virtual int_type uflow();\n    virtual int_type pbackfail(int_type c = traits_type::eof());\n    virtual int_type overflow (int_type c = traits_type::eof());\n    virtual basic_streambuf<char_type, traits_type>* setbuf(char_type* s, streamsize n);\n    virtual pos_type seekoff(off_type off, ios_base::seekdir way,\n                             ios_base::openmode which = ios_base::in | ios_base::out);\n    virtual pos_type seekpos(pos_type sp,\n                             ios_base::openmode which = ios_base::in | ios_base::out);\n    virtual int sync();\n    virtual void imbue(const locale& loc);\n};\n\ntemplate <class charT, class traits>\n  void\n  swap(basic_filebuf<charT, traits>& x, basic_filebuf<charT, traits>& y);\n\ntypedef basic_filebuf<char>    filebuf;\ntypedef basic_filebuf<wchar_t> wfilebuf;\n\ntemplate <class charT, class traits = char_traits<charT> >\nclass basic_ifstream\n    : public basic_istream<charT,traits>\n{\npublic:\n    typedef charT                          char_type;\n    typedef traits                         traits_type;\n    typedef typename traits_type::int_type int_type;\n    typedef typename traits_type::pos_type pos_type;\n    typedef typename traits_type::off_type off_type;\n\n    basic_ifstream();\n    explicit basic_ifstream(const char* s, ios_base::openmode mode = ios_base::in);\n    explicit basic_ifstream(const string& s, ios_base::openmode mode = ios_base::in);\n    basic_ifstream(basic_ifstream&& rhs);\n\n    basic_ifstream& operator=(basic_ifstream&& rhs);\n    void swap(basic_ifstream& rhs);\n\n    basic_filebuf<char_type, traits_type>* rdbuf() const;\n    bool is_open() const;\n    void open(const char* s, ios_base::openmode mode = ios_base::in);\n    void open(const string& s, ios_base::openmode mode = ios_base::in);\n    void close();\n};\n\ntemplate <class charT, class traits>\n  void\n  swap(basic_ifstream<charT, traits>& x, basic_ifstream<charT, traits>& y);\n\ntypedef basic_ifstream<char>    ifstream;\ntypedef basic_ifstream<wchar_t> wifstream;\n\ntemplate <class charT, class traits = char_traits<charT> >\nclass basic_ofstream\n    : public basic_ostream<charT,traits>\n{\npublic:\n    typedef charT                          char_type;\n    typedef traits                         traits_type;\n    typedef typename traits_type::int_type int_type;\n    typedef typename traits_type::pos_type pos_type;\n    typedef typename traits_type::off_type off_type;\n\n    basic_ofstream();\n    explicit basic_ofstream(const char* s, ios_base::openmode mode = ios_base::out);\n    explicit basic_ofstream(const string& s, ios_base::openmode mode = ios_base::out);\n    basic_ofstream(basic_ofstream&& rhs);\n\n    basic_ofstream& operator=(basic_ofstream&& rhs);\n    void swap(basic_ofstream& rhs);\n\n    basic_filebuf<char_type, traits_type>* rdbuf() const;\n    bool is_open() const;\n    void open(const char* s, ios_base::openmode mode = ios_base::out);\n    void open(const string& s, ios_base::openmode mode = ios_base::out);\n    void close();\n};\n\ntemplate <class charT, class traits>\n  void\n  swap(basic_ofstream<charT, traits>& x, basic_ofstream<charT, traits>& y);\n\ntypedef basic_ofstream<char>    ofstream;\ntypedef basic_ofstream<wchar_t> wofstream;\n\ntemplate <class charT, class traits=char_traits<charT> >\nclass basic_fstream\n    : public basic_iostream<charT,traits>\n{\npublic:\n    typedef charT                          char_type;\n    typedef traits                         traits_type;\n    typedef typename traits_type::int_type int_type;\n    typedef typename traits_type::pos_type pos_type;\n    typedef typename traits_type::off_type off_type;\n\n    basic_fstream();\n    explicit basic_fstream(const char* s, ios_base::openmode mode = ios_base::in|ios_base::out);\n    explicit basic_fstream(const string& s, ios_base::openmode mode = ios_base::in|ios_base::out);\n    basic_fstream(basic_fstream&& rhs);\n\n    basic_fstream& operator=(basic_fstream&& rhs);\n    void swap(basic_fstream& rhs);\n\n    basic_filebuf<char_type, traits_type>* rdbuf() const;\n    bool is_open() const;\n    void open(const char* s, ios_base::openmode mode = ios_base::in|ios_base::out);\n    void open(const string& s, ios_base::openmode mode = ios_base::in|ios_base::out);\n    void close();\n};\n\ntemplate <class charT, class traits>\n  void swap(basic_fstream<charT, traits>& x, basic_fstream<charT, traits>& y);\n\ntypedef basic_fstream<char>    fstream;\ntypedef basic_fstream<wchar_t> wfstream;\n\n}  // std\n\n*/\n\n#include <__config>\n#include <ostream>\n#include <istream>\n#include <__locale>\n#include <cstdio>\n\n#include <__undef_min_max>\n\n#if !defined(_LIBCPP_HAS_NO_PRAGMA_SYSTEM_HEADER)\n#pragma GCC system_header\n#endif\n\n_LIBCPP_BEGIN_NAMESPACE_STD\n\ntemplate <class _CharT, class _Traits>\nclass _LIBCPP_TEMPLATE_VIS basic_filebuf\n    : public basic_streambuf<_CharT, _Traits>\n{\npublic:\n    typedef _CharT                           char_type;\n    typedef _Traits                          traits_type;\n    typedef typename traits_type::int_type   int_type;\n    typedef typename traits_type::pos_type   pos_type;\n    typedef typename traits_type::off_type   off_type;\n    typedef typename traits_type::state_type state_type;\n\n    // 27.9.1.2 Constructors/destructor:\n    basic_filebuf();\n#ifndef _LIBCPP_HAS_NO_RVALUE_REFERENCES\n    basic_filebuf(basic_filebuf&& __rhs);\n#endif\n    virtual ~basic_filebuf();\n\n    // 27.9.1.3 Assign/swap:\n#ifndef _LIBCPP_HAS_NO_RVALUE_REFERENCES\n    _LIBCPP_INLINE_VISIBILITY\n    basic_filebuf& operator=(basic_filebuf&& __rhs);\n#endif\n    void swap(basic_filebuf& __rhs);\n\n    // 27.9.1.4 Members:\n    _LIBCPP_INLINE_VISIBILITY\n    bool is_open() const;\n#ifndef _LIBCPP_HAS_NO_GLOBAL_FILESYSTEM_NAMESPACE\n    basic_filebuf* open(const char* __s, ios_base::openmode __mode);\n    _LIBCPP_INLINE_VISIBILITY\n    basic_filebuf* open(const string& __s, ios_base::openmode __mode);\n#endif\n    basic_filebuf* close();\n\nprotected:\n    // 27.9.1.5 Overridden virtual functions:\n    virtual int_type underflow();\n    virtual int_type pbackfail(int_type __c = traits_type::eof());\n    virtual int_type overflow (int_type __c = traits_type::eof());\n    virtual basic_streambuf<char_type, traits_type>* setbuf(char_type* __s, streamsize __n);\n    virtual pos_type seekoff(off_type __off, ios_base::seekdir __way,\n                             ios_base::openmode __wch = ios_base::in | ios_base::out);\n    virtual pos_type seekpos(pos_type __sp,\n                             ios_base::openmode __wch = ios_base::in | ios_base::out);\n    virtual int sync();\n    virtual void imbue(const locale& __loc);\n\nprivate:\n    char*       __extbuf_;\n    const char* __extbufnext_;\n    const char* __extbufend_;\n    char __extbuf_min_[8];\n    size_t __ebs_;\n    char_type* __intbuf_;\n    size_t __ibs_;\n    FILE* __file_;\n    const codecvt<char_type, char, state_type>* __cv_;\n    state_type __st_;\n    state_type __st_last_;\n    ios_base::openmode __om_;\n    ios_base::openmode __cm_;\n    bool __owns_eb_;\n    bool __owns_ib_;\n    bool __always_noconv_;\n\n    bool __read_mode();\n    void __write_mode();\n};\n\ntemplate <class _CharT, class _Traits>\nbasic_filebuf<_CharT, _Traits>::basic_filebuf()\n    : __extbuf_(0),\n      __extbufnext_(0),\n      __extbufend_(0),\n      __ebs_(0),\n      __intbuf_(0),\n      __ibs_(0),\n      __file_(0),\n      __cv_(nullptr),\n      __st_(),\n      __st_last_(),\n      __om_(0),\n      __cm_(0),\n      __owns_eb_(false),\n      __owns_ib_(false),\n      __always_noconv_(false)\n{\n    if (has_facet<codecvt<char_type, char, state_type> >(this->getloc()))\n    {\n        __cv_ = &use_facet<codecvt<char_type, char, state_type> >(this->getloc());\n        __always_noconv_ = __cv_->always_noconv();\n    }\n    setbuf(0, 4096);\n}\n\n#ifndef _LIBCPP_HAS_NO_RVALUE_REFERENCES\n\ntemplate <class _CharT, class _Traits>\nbasic_filebuf<_CharT, _Traits>::basic_filebuf(basic_filebuf&& __rhs)\n    : basic_streambuf<_CharT, _Traits>(__rhs)\n{\n    if (__rhs.__extbuf_ == __rhs.__extbuf_min_)\n    {\n        __extbuf_ = __extbuf_min_;\n        __extbufnext_ = __extbuf_ + (__rhs.__extbufnext_ - __rhs.__extbuf_);\n        __extbufend_ = __extbuf_ + (__rhs.__extbufend_ - __rhs.__extbuf_);\n    }\n    else\n    {\n        __extbuf_ = __rhs.__extbuf_;\n        __extbufnext_ = __rhs.__extbufnext_;\n        __extbufend_ = __rhs.__extbufend_;\n    }\n    __ebs_ = __rhs.__ebs_;\n    __intbuf_ = __rhs.__intbuf_;\n    __ibs_ = __rhs.__ibs_;\n    __file_ = __rhs.__file_;\n    __cv_ = __rhs.__cv_;\n    __st_ = __rhs.__st_;\n    __st_last_ = __rhs.__st_last_;\n    __om_ = __rhs.__om_;\n    __cm_ = __rhs.__cm_;\n    __owns_eb_ = __rhs.__owns_eb_;\n    __owns_ib_ = __rhs.__owns_ib_;\n    __always_noconv_ = __rhs.__always_noconv_;\n    if (__rhs.pbase())\n    {\n        if (__rhs.pbase() == __rhs.__intbuf_)\n            this->setp(__intbuf_, __intbuf_ + (__rhs. epptr() - __rhs.pbase()));\n        else\n            this->setp((char_type*)__extbuf_,\n                       (char_type*)__extbuf_ + (__rhs. epptr() - __rhs.pbase()));\n        this->pbump(__rhs. pptr() - __rhs.pbase());\n    }\n    else if (__rhs.eback())\n    {\n        if (__rhs.eback() == __rhs.__intbuf_)\n            this->setg(__intbuf_, __intbuf_ + (__rhs.gptr() - __rhs.eback()),\n                                  __intbuf_ + (__rhs.egptr() - __rhs.eback()));\n        else\n            this->setg((char_type*)__extbuf_,\n                       (char_type*)__extbuf_ + (__rhs.gptr() - __rhs.eback()),\n                       (char_type*)__extbuf_ + (__rhs.egptr() - __rhs.eback()));\n    }\n    __rhs.__extbuf_ = 0;\n    __rhs.__extbufnext_ = 0;\n    __rhs.__extbufend_ = 0;\n    __rhs.__ebs_ = 0;\n    __rhs.__intbuf_ = 0;\n    __rhs.__ibs_ = 0;\n    __rhs.__file_ = 0;\n    __rhs.__st_ = state_type();\n    __rhs.__st_last_ = state_type();\n    __rhs.__om_ = 0;\n    __rhs.__cm_ = 0;\n    __rhs.__owns_eb_ = false;\n    __rhs.__owns_ib_ = false;\n    __rhs.setg(0, 0, 0);\n    __rhs.setp(0, 0);\n}\n\ntemplate <class _CharT, class _Traits>\ninline\nbasic_filebuf<_CharT, _Traits>&\nbasic_filebuf<_CharT, _Traits>::operator=(basic_filebuf&& __rhs)\n{\n    close();\n    swap(__rhs);\n    return *this;\n}\n\n#endif  // _LIBCPP_HAS_NO_RVALUE_REFERENCES\n\ntemplate <class _CharT, class _Traits>\nbasic_filebuf<_CharT, _Traits>::~basic_filebuf()\n{\n#ifndef _LIBCPP_NO_EXCEPTIONS\n    try\n    {\n#endif  // _LIBCPP_NO_EXCEPTIONS\n        close();\n#ifndef _LIBCPP_NO_EXCEPTIONS\n    }\n    catch (...)\n    {\n    }\n#endif  // _LIBCPP_NO_EXCEPTIONS\n    if (__owns_eb_)\n        delete [] __extbuf_;\n    if (__owns_ib_)\n        delete [] __intbuf_;\n}\n\ntemplate <class _CharT, class _Traits>\nvoid\nbasic_filebuf<_CharT, _Traits>::swap(basic_filebuf& __rhs)\n{\n    basic_streambuf<char_type, traits_type>::swap(__rhs);\n    if (__extbuf_ != __extbuf_min_ && __rhs.__extbuf_ != __rhs.__extbuf_min_)\n    {\n        _VSTD::swap(__extbuf_, __rhs.__extbuf_);\n        _VSTD::swap(__extbufnext_, __rhs.__extbufnext_);\n        _VSTD::swap(__extbufend_, __rhs.__extbufend_);\n    }\n    else\n    {\n        ptrdiff_t __ln = __extbufnext_ - __extbuf_;\n        ptrdiff_t __le = __extbufend_ - __extbuf_;\n        ptrdiff_t __rn = __rhs.__extbufnext_ - __rhs.__extbuf_;\n        ptrdiff_t __re = __rhs.__extbufend_ - __rhs.__extbuf_;\n        if (__extbuf_ == __extbuf_min_ && __rhs.__extbuf_ != __rhs.__extbuf_min_)\n        {\n            __extbuf_ = __rhs.__extbuf_;\n            __rhs.__extbuf_ = __rhs.__extbuf_min_;\n        }\n        else if (__extbuf_ != __extbuf_min_ && __rhs.__extbuf_ == __rhs.__extbuf_min_)\n        {\n            __rhs.__extbuf_ = __extbuf_;\n            __extbuf_ = __extbuf_min_;\n        }\n        __extbufnext_ = __extbuf_ + __rn;\n        __extbufend_ = __extbuf_ + __re;\n        __rhs.__extbufnext_ = __rhs.__extbuf_ + __ln;\n        __rhs.__extbufend_ = __rhs.__extbuf_ + __le;\n    }\n    _VSTD::swap(__ebs_, __rhs.__ebs_);\n    _VSTD::swap(__intbuf_, __rhs.__intbuf_);\n    _VSTD::swap(__ibs_, __rhs.__ibs_);\n    _VSTD::swap(__file_, __rhs.__file_);\n    _VSTD::swap(__cv_, __rhs.__cv_);\n    _VSTD::swap(__st_, __rhs.__st_);\n    _VSTD::swap(__st_last_, __rhs.__st_last_);\n    _VSTD::swap(__om_, __rhs.__om_);\n    _VSTD::swap(__cm_, __rhs.__cm_);\n    _VSTD::swap(__owns_eb_, __rhs.__owns_eb_);\n    _VSTD::swap(__owns_ib_, __rhs.__owns_ib_);\n    _VSTD::swap(__always_noconv_, __rhs.__always_noconv_);\n    if (this->eback() == (char_type*)__rhs.__extbuf_min_)\n    {\n        ptrdiff_t __n = this->gptr() - this->eback();\n        ptrdiff_t __e = this->egptr() - this->eback();\n        this->setg((char_type*)__extbuf_min_,\n                   (char_type*)__extbuf_min_ + __n,\n                   (char_type*)__extbuf_min_ + __e);\n    }\n    else if (this->pbase() == (char_type*)__rhs.__extbuf_min_)\n    {\n        ptrdiff_t __n = this->pptr() - this->pbase();\n        ptrdiff_t __e = this->epptr() - this->pbase();\n        this->setp((char_type*)__extbuf_min_,\n                   (char_type*)__extbuf_min_ + __e);\n        this->pbump(__n);\n    }\n    if (__rhs.eback() == (char_type*)__extbuf_min_)\n    {\n        ptrdiff_t __n = __rhs.gptr() - __rhs.eback();\n        ptrdiff_t __e = __rhs.egptr() - __rhs.eback();\n        __rhs.setg((char_type*)__rhs.__extbuf_min_,\n                   (char_type*)__rhs.__extbuf_min_ + __n,\n                   (char_type*)__rhs.__extbuf_min_ + __e);\n    }\n    else if (__rhs.pbase() == (char_type*)__extbuf_min_)\n    {\n        ptrdiff_t __n = __rhs.pptr() - __rhs.pbase();\n        ptrdiff_t __e = __rhs.epptr() - __rhs.pbase();\n        __rhs.setp((char_type*)__rhs.__extbuf_min_,\n                   (char_type*)__rhs.__extbuf_min_ + __e);\n        __rhs.pbump(__n);\n    }\n}\n\ntemplate <class _CharT, class _Traits>\ninline _LIBCPP_INLINE_VISIBILITY\nvoid\nswap(basic_filebuf<_CharT, _Traits>& __x, basic_filebuf<_CharT, _Traits>& __y)\n{\n    __x.swap(__y);\n}\n\ntemplate <class _CharT, class _Traits>\ninline\nbool\nbasic_filebuf<_CharT, _Traits>::is_open() const\n{\n    return __file_ != 0;\n}\n\n#ifndef _LIBCPP_HAS_NO_GLOBAL_FILESYSTEM_NAMESPACE\ntemplate <class _CharT, class _Traits>\nbasic_filebuf<_CharT, _Traits>*\nbasic_filebuf<_CharT, _Traits>::open(const char* __s, ios_base::openmode __mode)\n{\n    basic_filebuf<_CharT, _Traits>* __rt = 0;\n    if (__file_ == 0)\n    {\n        __rt = this;\n        const char* __mdstr;\n        switch (__mode & ~ios_base::ate)\n        {\n        case ios_base::out:\n        case ios_base::out | ios_base::trunc:\n            __mdstr = \"w\";\n            break;\n        case ios_base::out | ios_base::app:\n        case ios_base::app:\n            __mdstr = \"a\";\n            break;\n        case ios_base::in:\n            __mdstr = \"r\";\n            break;\n        case ios_base::in | ios_base::out:\n            __mdstr = \"r+\";\n            break;\n        case ios_base::in | ios_base::out | ios_base::trunc:\n            __mdstr = \"w+\";\n            break;\n        case ios_base::in | ios_base::out | ios_base::app:\n        case ios_base::in | ios_base::app:\n            __mdstr = \"a+\";\n            break;\n        case ios_base::out | ios_base::binary:\n        case ios_base::out | ios_base::trunc | ios_base::binary:\n            __mdstr = \"wb\";\n            break;\n        case ios_base::out | ios_base::app | ios_base::binary:\n        case ios_base::app | ios_base::binary:\n            __mdstr = \"ab\";\n            break;\n        case ios_base::in | ios_base::binary:\n            __mdstr = \"rb\";\n            break;\n        case ios_base::in | ios_base::out | ios_base::binary:\n            __mdstr = \"r+b\";\n            break;\n        case ios_base::in | ios_base::out | ios_base::trunc | ios_base::binary:\n            __mdstr = \"w+b\";\n            break;\n        case ios_base::in | ios_base::out | ios_base::app | ios_base::binary:\n        case ios_base::in | ios_base::app | ios_base::binary:\n            __mdstr = \"a+b\";\n            break;\n        default:\n            __rt = 0;\n            break;\n        }\n        if (__rt)\n        {\n            __file_ = fopen(__s, __mdstr);\n            if (__file_)\n            {\n                __om_ = __mode;\n                if (__mode & ios_base::ate)\n                {\n                    if (fseek(__file_, 0, SEEK_END))\n                    {\n                        fclose(__file_);\n                        __file_ = 0;\n                        __rt = 0;\n                    }\n                }\n            }\n            else\n                __rt = 0;\n        }\n    }\n    return __rt;\n}\n\ntemplate <class _CharT, class _Traits>\ninline\nbasic_filebuf<_CharT, _Traits>*\nbasic_filebuf<_CharT, _Traits>::open(const string& __s, ios_base::openmode __mode)\n{\n    return open(__s.c_str(), __mode);\n}\n#endif\n\ntemplate <class _CharT, class _Traits>\nbasic_filebuf<_CharT, _Traits>*\nbasic_filebuf<_CharT, _Traits>::close()\n{\n    basic_filebuf<_CharT, _Traits>* __rt = 0;\n    if (__file_)\n    {\n        __rt = this;\n        unique_ptr<FILE, int(*)(FILE*)> __h(__file_, fclose);\n        if (sync())\n            __rt = 0;\n        if (fclose(__h.release()) == 0)\n            __file_ = 0;\n        else\n            __rt = 0;\n    }\n    return __rt;\n}\n\ntemplate <class _CharT, class _Traits>\ntypename basic_filebuf<_CharT, _Traits>::int_type\nbasic_filebuf<_CharT, _Traits>::underflow()\n{\n    if (__file_ == 0)\n        return traits_type::eof();\n    bool __initial = __read_mode();\n    char_type __1buf;\n    if (this->gptr() == 0)\n        this->setg(&__1buf, &__1buf+1, &__1buf+1);\n    const size_t __unget_sz = __initial ? 0 : min<size_t>((this->egptr() - this->eback()) / 2, 4);\n    int_type __c = traits_type::eof();\n    if (this->gptr() == this->egptr())\n    {\n        memmove(this->eback(), this->egptr() - __unget_sz, __unget_sz * sizeof(char_type));\n        if (__always_noconv_)\n        {\n            size_t __nmemb = static_cast<size_t>(this->egptr() - this->eback() - __unget_sz);\n            __nmemb = fread(this->eback() + __unget_sz, 1, __nmemb, __file_);\n            if (__nmemb != 0)\n            {\n                this->setg(this->eback(),\n                           this->eback() + __unget_sz,\n                           this->eback() + __unget_sz + __nmemb);\n                __c = traits_type::to_int_type(*this->gptr());\n            }\n        }\n        else\n        {\n            _LIBCPP_ASSERT ( !(__extbufnext_ == NULL && (__extbufend_ != __extbufnext_)), \"underflow moving from NULL\" );\n            if (__extbufend_ != __extbufnext_)\n                memmove(__extbuf_, __extbufnext_, __extbufend_ - __extbufnext_);\n            __extbufnext_ = __extbuf_ + (__extbufend_ - __extbufnext_);\n            __extbufend_ = __extbuf_ + (__extbuf_ == __extbuf_min_ ? sizeof(__extbuf_min_) : __ebs_);\n            size_t __nmemb = _VSTD::min(static_cast<size_t>(__ibs_ - __unget_sz),\n                                 static_cast<size_t>(__extbufend_ - __extbufnext_));\n            codecvt_base::result __r;\n            __st_last_ = __st_;\n            size_t __nr = fread((void*)__extbufnext_, 1, __nmemb, __file_);\n            if (__nr != 0)\n            {\n                if (!__cv_)\n                    __throw_bad_cast();\n\n                __extbufend_ = __extbufnext_ + __nr;\n                char_type*  __inext;\n                __r = __cv_->in(__st_, __extbuf_, __extbufend_, __extbufnext_,\n                                       this->eback() + __unget_sz,\n                                       this->eback() + __ibs_, __inext);\n                if (__r == codecvt_base::noconv)\n                {\n                    this->setg((char_type*)__extbuf_, (char_type*)__extbuf_, (char_type*)__extbufend_);\n                    __c = traits_type::to_int_type(*this->gptr());\n                }\n                else if (__inext != this->eback() + __unget_sz)\n                {\n                    this->setg(this->eback(), this->eback() + __unget_sz, __inext);\n                    __c = traits_type::to_int_type(*this->gptr());\n                }\n            }\n        }\n    }\n    else\n        __c = traits_type::to_int_type(*this->gptr());\n    if (this->eback() == &__1buf)\n        this->setg(0, 0, 0);\n    return __c;\n}\n\ntemplate <class _CharT, class _Traits>\ntypename basic_filebuf<_CharT, _Traits>::int_type\nbasic_filebuf<_CharT, _Traits>::pbackfail(int_type __c)\n{\n    if (__file_ && this->eback() < this->gptr())\n    {\n        if (traits_type::eq_int_type(__c, traits_type::eof()))\n        {\n            this->gbump(-1);\n            return traits_type::not_eof(__c);\n        }\n        if ((__om_ & ios_base::out) ||\n            traits_type::eq(traits_type::to_char_type(__c), this->gptr()[-1]))\n        {\n            this->gbump(-1);\n            *this->gptr() = traits_type::to_char_type(__c);\n            return __c;\n        }\n    }\n    return traits_type::eof();\n}\n\ntemplate <class _CharT, class _Traits>\ntypename basic_filebuf<_CharT, _Traits>::int_type\nbasic_filebuf<_CharT, _Traits>::overflow(int_type __c)\n{\n    if (__file_ == 0)\n        return traits_type::eof();\n    __write_mode();\n    char_type __1buf;\n    char_type* __pb_save = this->pbase();\n    char_type* __epb_save = this->epptr();\n    if (!traits_type::eq_int_type(__c, traits_type::eof()))\n    {\n        if (this->pptr() == 0)\n            this->setp(&__1buf, &__1buf+1);\n        *this->pptr() = traits_type::to_char_type(__c);\n        this->pbump(1);\n    }\n    if (this->pptr() != this->pbase())\n    {\n        if (__always_noconv_)\n        {\n            size_t __nmemb = static_cast<size_t>(this->pptr() - this->pbase());\n            if (fwrite(this->pbase(), sizeof(char_type), __nmemb, __file_) != __nmemb)\n                return traits_type::eof();\n        }\n        else\n        {\n            char* __extbe = __extbuf_;\n            codecvt_base::result __r;\n            do\n            {\n                if (!__cv_)\n                    __throw_bad_cast();\n\n                const char_type* __e;\n                __r = __cv_->out(__st_, this->pbase(), this->pptr(), __e,\n                                        __extbuf_, __extbuf_ + __ebs_, __extbe);\n                if (__e == this->pbase())\n                    return traits_type::eof();\n                if (__r == codecvt_base::noconv)\n                {\n                    size_t __nmemb = static_cast<size_t>(this->pptr() - this->pbase());\n                    if (fwrite(this->pbase(), 1, __nmemb, __file_) != __nmemb)\n                        return traits_type::eof();\n                }\n                else if (__r == codecvt_base::ok || __r == codecvt_base::partial)\n                {\n                    size_t __nmemb = static_cast<size_t>(__extbe - __extbuf_);\n                    if (fwrite(__extbuf_, 1, __nmemb, __file_) != __nmemb)\n                        return traits_type::eof();\n                    if (__r == codecvt_base::partial)\n                    {\n                        this->setp((char_type*)__e, this->pptr());\n                        this->pbump(this->epptr() - this->pbase());\n                    }\n                }\n                else\n                    return traits_type::eof();\n            } while (__r == codecvt_base::partial);\n        }\n        this->setp(__pb_save, __epb_save);\n    }\n    return traits_type::not_eof(__c);\n}\n\ntemplate <class _CharT, class _Traits>\nbasic_streambuf<_CharT, _Traits>*\nbasic_filebuf<_CharT, _Traits>::setbuf(char_type* __s, streamsize __n)\n{\n    this->setg(0, 0, 0);\n    this->setp(0, 0);\n    if (__owns_eb_)\n        delete [] __extbuf_;\n    if (__owns_ib_)\n        delete [] __intbuf_;\n    __ebs_ = __n;\n    if (__ebs_ > sizeof(__extbuf_min_))\n    {\n        if (__always_noconv_ && __s)\n        {\n            __extbuf_ = (char*)__s;\n            __owns_eb_ = false;\n        }\n        else\n        {\n            __extbuf_ = new char[__ebs_];\n            __owns_eb_ = true;\n        }\n    }\n    else\n    {\n        __extbuf_ = __extbuf_min_;\n        __ebs_ = sizeof(__extbuf_min_);\n        __owns_eb_ = false;\n    }\n    if (!__always_noconv_)\n    {\n        __ibs_ = max<streamsize>(__n, sizeof(__extbuf_min_));\n        if (__s && __ibs_ >= sizeof(__extbuf_min_))\n        {\n            __intbuf_ = __s;\n            __owns_ib_ = false;\n        }\n        else\n        {\n            __intbuf_ = new char_type[__ibs_];\n            __owns_ib_ = true;\n        }\n    }\n    else\n    {\n        __ibs_ = 0;\n        __intbuf_ = 0;\n        __owns_ib_ = false;\n    }\n    return this;\n}\n\ntemplate <class _CharT, class _Traits>\ntypename basic_filebuf<_CharT, _Traits>::pos_type\nbasic_filebuf<_CharT, _Traits>::seekoff(off_type __off, ios_base::seekdir __way,\n                                        ios_base::openmode)\n{\n    if (!__cv_)\n        __throw_bad_cast();\n\n    int __width = __cv_->encoding();\n    if (__file_ == 0 || (__width <= 0 && __off != 0) || sync())\n        return pos_type(off_type(-1));\n    // __width > 0 || __off == 0\n    int __whence;\n    switch (__way)\n    {\n    case ios_base::beg:\n        __whence = SEEK_SET;\n        break;\n    case ios_base::cur:\n        __whence = SEEK_CUR;\n        break;\n    case ios_base::end:\n        __whence = SEEK_END;\n        break;\n    default:\n        return pos_type(off_type(-1));\n    }\n#if defined(_LIBCPP_HAS_NO_OFF_T_FUNCTIONS)\n    if (fseek(__file_, __width > 0 ? __width * __off : 0, __whence))\n        return pos_type(off_type(-1));\n    pos_type __r = ftell(__file_);\n#else\n    if (fseeko(__file_, __width > 0 ? __width * __off : 0, __whence))\n        return pos_type(off_type(-1));\n    pos_type __r = ftello(__file_);\n#endif\n    __r.state(__st_);\n    return __r;\n}\n\ntemplate <class _CharT, class _Traits>\ntypename basic_filebuf<_CharT, _Traits>::pos_type\nbasic_filebuf<_CharT, _Traits>::seekpos(pos_type __sp, ios_base::openmode)\n{\n    if (__file_ == 0 || sync())\n        return pos_type(off_type(-1));\n#if defined(_LIBCPP_HAS_NO_OFF_T_FUNCTIONS)\n    if (fseek(__file_, __sp, SEEK_SET))\n        return pos_type(off_type(-1));\n#else\n    if (fseeko(__file_, __sp, SEEK_SET))\n        return pos_type(off_type(-1));\n#endif\n    __st_ = __sp.state();\n    return __sp;\n}\n\ntemplate <class _CharT, class _Traits>\nint\nbasic_filebuf<_CharT, _Traits>::sync()\n{\n    if (__file_ == 0)\n        return 0;\n    if (!__cv_)\n        __throw_bad_cast();\n\n    if (__cm_ & ios_base::out)\n    {\n        if (this->pptr() != this->pbase())\n            if (overflow() == traits_type::eof())\n                return -1;\n        codecvt_base::result __r;\n        do\n        {\n            char* __extbe;\n            __r = __cv_->unshift(__st_, __extbuf_, __extbuf_ + __ebs_, __extbe);\n            size_t __nmemb = static_cast<size_t>(__extbe - __extbuf_);\n            if (fwrite(__extbuf_, 1, __nmemb, __file_) != __nmemb)\n                return -1;\n        } while (__r == codecvt_base::partial);\n        if (__r == codecvt_base::error)\n            return -1;\n        if (fflush(__file_))\n            return -1;\n    }\n    else if (__cm_ & ios_base::in)\n    {\n        off_type __c;\n        state_type __state = __st_last_;\n        bool __update_st = false;\n        if (__always_noconv_)\n            __c = this->egptr() - this->gptr();\n        else\n        {\n            int __width = __cv_->encoding();\n            __c = __extbufend_ - __extbufnext_;\n            if (__width > 0)\n                __c += __width * (this->egptr() - this->gptr());\n            else\n            {\n                if (this->gptr() != this->egptr())\n                {\n                    const int __off =  __cv_->length(__state, __extbuf_,\n                                                     __extbufnext_,\n                                                     this->gptr() - this->eback());\n                    __c += __extbufnext_ - __extbuf_ - __off;\n                    __update_st = true;\n                }\n            }\n        }\n#if defined(_LIBCPP_HAS_NO_OFF_T_FUNCTIONS)\n        if (fseek(__file_, -__c, SEEK_CUR))\n            return -1;\n#else\n        if (fseeko(__file_, -__c, SEEK_CUR))\n            return -1;\n#endif\n        if (__update_st)\n            __st_ = __state;\n        __extbufnext_ = __extbufend_ = __extbuf_;\n        this->setg(0, 0, 0);\n        __cm_ = 0;\n    }\n    return 0;\n}\n\ntemplate <class _CharT, class _Traits>\nvoid\nbasic_filebuf<_CharT, _Traits>::imbue(const locale& __loc)\n{\n    sync();\n    __cv_ = &use_facet<codecvt<char_type, char, state_type> >(__loc);\n    bool __old_anc = __always_noconv_;\n    __always_noconv_ = __cv_->always_noconv();\n    if (__old_anc != __always_noconv_)\n    {\n        this->setg(0, 0, 0);\n        this->setp(0, 0);\n        // invariant, char_type is char, else we couldn't get here\n        if (__always_noconv_)  // need to dump __intbuf_\n        {\n            if (__owns_eb_)\n                delete [] __extbuf_;\n            __owns_eb_ = __owns_ib_;\n            __ebs_ = __ibs_;\n            __extbuf_ = (char*)__intbuf_;\n            __ibs_ = 0;\n            __intbuf_ = 0;\n            __owns_ib_ = false;\n        }\n        else  // need to obtain an __intbuf_.\n        {     // If __extbuf_ is user-supplied, use it, else new __intbuf_\n            if (!__owns_eb_ && __extbuf_ != __extbuf_min_)\n            {\n                __ibs_ = __ebs_;\n                __intbuf_ = (char_type*)__extbuf_;\n                __owns_ib_ = false;\n                __extbuf_ = new char[__ebs_];\n                __owns_eb_ = true;\n            }\n            else\n            {\n                __ibs_ = __ebs_;\n                __intbuf_ = new char_type[__ibs_];\n                __owns_ib_ = true;\n            }\n        }\n    }\n}\n\ntemplate <class _CharT, class _Traits>\nbool\nbasic_filebuf<_CharT, _Traits>::__read_mode()\n{\n    if (!(__cm_ & ios_base::in))\n    {\n        this->setp(0, 0);\n        if (__always_noconv_)\n            this->setg((char_type*)__extbuf_,\n                       (char_type*)__extbuf_ + __ebs_,\n                       (char_type*)__extbuf_ + __ebs_);\n        else\n            this->setg(__intbuf_, __intbuf_ + __ibs_, __intbuf_ + __ibs_);\n        __cm_ = ios_base::in;\n        return true;\n    }\n    return false;\n}\n\ntemplate <class _CharT, class _Traits>\nvoid\nbasic_filebuf<_CharT, _Traits>::__write_mode()\n{\n    if (!(__cm_ & ios_base::out))\n    {\n        this->setg(0, 0, 0);\n        if (__ebs_ > sizeof(__extbuf_min_))\n        {\n            if (__always_noconv_)\n                this->setp((char_type*)__extbuf_,\n                           (char_type*)__extbuf_ + (__ebs_ - 1));\n            else\n                this->setp(__intbuf_, __intbuf_ + (__ibs_ - 1));\n        }\n        else\n            this->setp(0, 0);\n        __cm_ = ios_base::out;\n    }\n}\n\n// basic_ifstream\n\ntemplate <class _CharT, class _Traits>\nclass _LIBCPP_TEMPLATE_VIS basic_ifstream\n    : public basic_istream<_CharT, _Traits>\n{\npublic:\n    typedef _CharT                         char_type;\n    typedef _Traits                        traits_type;\n    typedef typename traits_type::int_type int_type;\n    typedef typename traits_type::pos_type pos_type;\n    typedef typename traits_type::off_type off_type;\n\n    _LIBCPP_INLINE_VISIBILITY\n    basic_ifstream();\n#ifndef _LIBCPP_HAS_NO_GLOBAL_FILESYSTEM_NAMESPACE\n    _LIBCPP_INLINE_VISIBILITY\n    explicit basic_ifstream(const char* __s, ios_base::openmode __mode = ios_base::in);\n    _LIBCPP_INLINE_VISIBILITY\n    explicit basic_ifstream(const string& __s, ios_base::openmode __mode = ios_base::in);\n#endif\n#ifndef _LIBCPP_HAS_NO_RVALUE_REFERENCES\n    _LIBCPP_INLINE_VISIBILITY\n    basic_ifstream(basic_ifstream&& __rhs);\n#endif\n\n#ifndef _LIBCPP_HAS_NO_RVALUE_REFERENCES\n    _LIBCPP_INLINE_VISIBILITY\n    basic_ifstream& operator=(basic_ifstream&& __rhs);\n#endif\n    _LIBCPP_INLINE_VISIBILITY\n    void swap(basic_ifstream& __rhs);\n\n    _LIBCPP_INLINE_VISIBILITY\n    basic_filebuf<char_type, traits_type>* rdbuf() const;\n    _LIBCPP_INLINE_VISIBILITY\n    bool is_open() const;\n#ifndef _LIBCPP_HAS_NO_GLOBAL_FILESYSTEM_NAMESPACE\n    void open(const char* __s, ios_base::openmode __mode = ios_base::in);\n    void open(const string& __s, ios_base::openmode __mode = ios_base::in);\n#endif\n    _LIBCPP_INLINE_VISIBILITY\n    void close();\n\nprivate:\n    basic_filebuf<char_type, traits_type> __sb_;\n};\n\ntemplate <class _CharT, class _Traits>\ninline\nbasic_ifstream<_CharT, _Traits>::basic_ifstream()\n    : basic_istream<char_type, traits_type>(&__sb_)\n{\n}\n\n#ifndef _LIBCPP_HAS_NO_GLOBAL_FILESYSTEM_NAMESPACE\ntemplate <class _CharT, class _Traits>\ninline\nbasic_ifstream<_CharT, _Traits>::basic_ifstream(const char* __s, ios_base::openmode __mode)\n    : basic_istream<char_type, traits_type>(&__sb_)\n{\n    if (__sb_.open(__s, __mode | ios_base::in) == 0)\n        this->setstate(ios_base::failbit);\n}\n\ntemplate <class _CharT, class _Traits>\ninline\nbasic_ifstream<_CharT, _Traits>::basic_ifstream(const string& __s, ios_base::openmode __mode)\n    : basic_istream<char_type, traits_type>(&__sb_)\n{\n    if (__sb_.open(__s, __mode | ios_base::in) == 0)\n        this->setstate(ios_base::failbit);\n}\n#endif\n\n#ifndef _LIBCPP_HAS_NO_RVALUE_REFERENCES\n\ntemplate <class _CharT, class _Traits>\ninline\nbasic_ifstream<_CharT, _Traits>::basic_ifstream(basic_ifstream&& __rhs)\n    : basic_istream<char_type, traits_type>(_VSTD::move(__rhs)),\n      __sb_(_VSTD::move(__rhs.__sb_))\n{\n    this->set_rdbuf(&__sb_);\n}\n\ntemplate <class _CharT, class _Traits>\ninline\nbasic_ifstream<_CharT, _Traits>&\nbasic_ifstream<_CharT, _Traits>::operator=(basic_ifstream&& __rhs)\n{\n    basic_istream<char_type, traits_type>::operator=(_VSTD::move(__rhs));\n    __sb_ = _VSTD::move(__rhs.__sb_);\n    return *this;\n}\n\n#endif  // _LIBCPP_HAS_NO_RVALUE_REFERENCES\n\ntemplate <class _CharT, class _Traits>\ninline\nvoid\nbasic_ifstream<_CharT, _Traits>::swap(basic_ifstream& __rhs)\n{\n    basic_istream<char_type, traits_type>::swap(__rhs);\n    __sb_.swap(__rhs.__sb_);\n}\n\ntemplate <class _CharT, class _Traits>\ninline _LIBCPP_INLINE_VISIBILITY\nvoid\nswap(basic_ifstream<_CharT, _Traits>& __x, basic_ifstream<_CharT, _Traits>& __y)\n{\n    __x.swap(__y);\n}\n\ntemplate <class _CharT, class _Traits>\ninline\nbasic_filebuf<_CharT, _Traits>*\nbasic_ifstream<_CharT, _Traits>::rdbuf() const\n{\n    return const_cast<basic_filebuf<char_type, traits_type>*>(&__sb_);\n}\n\ntemplate <class _CharT, class _Traits>\ninline\nbool\nbasic_ifstream<_CharT, _Traits>::is_open() const\n{\n    return __sb_.is_open();\n}\n\n#ifndef _LIBCPP_HAS_NO_GLOBAL_FILESYSTEM_NAMESPACE\ntemplate <class _CharT, class _Traits>\nvoid\nbasic_ifstream<_CharT, _Traits>::open(const char* __s, ios_base::openmode __mode)\n{\n    if (__sb_.open(__s, __mode | ios_base::in))\n        this->clear();\n    else\n        this->setstate(ios_base::failbit);\n}\n\ntemplate <class _CharT, class _Traits>\nvoid\nbasic_ifstream<_CharT, _Traits>::open(const string& __s, ios_base::openmode __mode)\n{\n    if (__sb_.open(__s, __mode | ios_base::in))\n        this->clear();\n    else\n        this->setstate(ios_base::failbit);\n}\n#endif\n\ntemplate <class _CharT, class _Traits>\ninline\nvoid\nbasic_ifstream<_CharT, _Traits>::close()\n{\n    if (__sb_.close() == 0)\n        this->setstate(ios_base::failbit);\n}\n\n// basic_ofstream\n\ntemplate <class _CharT, class _Traits>\nclass _LIBCPP_TEMPLATE_VIS basic_ofstream\n    : public basic_ostream<_CharT, _Traits>\n{\npublic:\n    typedef _CharT                         char_type;\n    typedef _Traits                        traits_type;\n    typedef typename traits_type::int_type int_type;\n    typedef typename traits_type::pos_type pos_type;\n    typedef typename traits_type::off_type off_type;\n\n    _LIBCPP_INLINE_VISIBILITY\n    basic_ofstream();\n    _LIBCPP_INLINE_VISIBILITY\n    explicit basic_ofstream(const char* __s, ios_base::openmode __mode = ios_base::out);\n    _LIBCPP_INLINE_VISIBILITY\n    explicit basic_ofstream(const string& __s, ios_base::openmode __mode = ios_base::out);\n#ifndef _LIBCPP_HAS_NO_RVALUE_REFERENCES\n    _LIBCPP_INLINE_VISIBILITY\n    basic_ofstream(basic_ofstream&& __rhs);\n#endif\n\n#ifndef _LIBCPP_HAS_NO_RVALUE_REFERENCES\n    _LIBCPP_INLINE_VISIBILITY\n    basic_ofstream& operator=(basic_ofstream&& __rhs);\n#endif\n    _LIBCPP_INLINE_VISIBILITY\n    void swap(basic_ofstream& __rhs);\n\n    _LIBCPP_INLINE_VISIBILITY\n    basic_filebuf<char_type, traits_type>* rdbuf() const;\n    _LIBCPP_INLINE_VISIBILITY\n    bool is_open() const;\n#ifndef _LIBCPP_HAS_NO_GLOBAL_FILESYSTEM_NAMESPACE\n    void open(const char* __s, ios_base::openmode __mode = ios_base::out);\n    void open(const string& __s, ios_base::openmode __mode = ios_base::out);\n#endif\n    _LIBCPP_INLINE_VISIBILITY\n    void close();\n\nprivate:\n    basic_filebuf<char_type, traits_type> __sb_;\n};\n\ntemplate <class _CharT, class _Traits>\ninline\nbasic_ofstream<_CharT, _Traits>::basic_ofstream()\n    : basic_ostream<char_type, traits_type>(&__sb_)\n{\n}\n\n#ifndef _LIBCPP_HAS_NO_GLOBAL_FILESYSTEM_NAMESPACE\ntemplate <class _CharT, class _Traits>\ninline\nbasic_ofstream<_CharT, _Traits>::basic_ofstream(const char* __s, ios_base::openmode __mode)\n    : basic_ostream<char_type, traits_type>(&__sb_)\n{\n    if (__sb_.open(__s, __mode | ios_base::out) == 0)\n        this->setstate(ios_base::failbit);\n}\n\ntemplate <class _CharT, class _Traits>\ninline\nbasic_ofstream<_CharT, _Traits>::basic_ofstream(const string& __s, ios_base::openmode __mode)\n    : basic_ostream<char_type, traits_type>(&__sb_)\n{\n    if (__sb_.open(__s, __mode | ios_base::out) == 0)\n        this->setstate(ios_base::failbit);\n}\n#endif\n\n#ifndef _LIBCPP_HAS_NO_RVALUE_REFERENCES\n\ntemplate <class _CharT, class _Traits>\ninline\nbasic_ofstream<_CharT, _Traits>::basic_ofstream(basic_ofstream&& __rhs)\n    : basic_ostream<char_type, traits_type>(_VSTD::move(__rhs)),\n      __sb_(_VSTD::move(__rhs.__sb_))\n{\n    this->set_rdbuf(&__sb_);\n}\n\ntemplate <class _CharT, class _Traits>\ninline\nbasic_ofstream<_CharT, _Traits>&\nbasic_ofstream<_CharT, _Traits>::operator=(basic_ofstream&& __rhs)\n{\n    basic_ostream<char_type, traits_type>::operator=(_VSTD::move(__rhs));\n    __sb_ = _VSTD::move(__rhs.__sb_);\n    return *this;\n}\n\n#endif  // _LIBCPP_HAS_NO_RVALUE_REFERENCES\n\ntemplate <class _CharT, class _Traits>\ninline\nvoid\nbasic_ofstream<_CharT, _Traits>::swap(basic_ofstream& __rhs)\n{\n    basic_ostream<char_type, traits_type>::swap(__rhs);\n    __sb_.swap(__rhs.__sb_);\n}\n\ntemplate <class _CharT, class _Traits>\ninline _LIBCPP_INLINE_VISIBILITY\nvoid\nswap(basic_ofstream<_CharT, _Traits>& __x, basic_ofstream<_CharT, _Traits>& __y)\n{\n    __x.swap(__y);\n}\n\ntemplate <class _CharT, class _Traits>\ninline\nbasic_filebuf<_CharT, _Traits>*\nbasic_ofstream<_CharT, _Traits>::rdbuf() const\n{\n    return const_cast<basic_filebuf<char_type, traits_type>*>(&__sb_);\n}\n\ntemplate <class _CharT, class _Traits>\ninline\nbool\nbasic_ofstream<_CharT, _Traits>::is_open() const\n{\n    return __sb_.is_open();\n}\n\n#ifndef _LIBCPP_HAS_NO_GLOBAL_FILESYSTEM_NAMESPACE\ntemplate <class _CharT, class _Traits>\nvoid\nbasic_ofstream<_CharT, _Traits>::open(const char* __s, ios_base::openmode __mode)\n{\n    if (__sb_.open(__s, __mode | ios_base::out))\n        this->clear();\n    else\n        this->setstate(ios_base::failbit);\n}\n\ntemplate <class _CharT, class _Traits>\nvoid\nbasic_ofstream<_CharT, _Traits>::open(const string& __s, ios_base::openmode __mode)\n{\n    if (__sb_.open(__s, __mode | ios_base::out))\n        this->clear();\n    else\n        this->setstate(ios_base::failbit);\n}\n#endif\n\ntemplate <class _CharT, class _Traits>\ninline\nvoid\nbasic_ofstream<_CharT, _Traits>::close()\n{\n    if (__sb_.close() == 0)\n        this->setstate(ios_base::failbit);\n}\n\n// basic_fstream\n\ntemplate <class _CharT, class _Traits>\nclass _LIBCPP_TEMPLATE_VIS basic_fstream\n    : public basic_iostream<_CharT, _Traits>\n{\npublic:\n    typedef _CharT                         char_type;\n    typedef _Traits                        traits_type;\n    typedef typename traits_type::int_type int_type;\n    typedef typename traits_type::pos_type pos_type;\n    typedef typename traits_type::off_type off_type;\n\n    _LIBCPP_INLINE_VISIBILITY\n    basic_fstream();\n#ifndef _LIBCPP_HAS_NO_GLOBAL_FILESYSTEM_NAMESPACE\n    _LIBCPP_INLINE_VISIBILITY\n    explicit basic_fstream(const char* __s, ios_base::openmode __mode = ios_base::in | ios_base::out);\n    _LIBCPP_INLINE_VISIBILITY\n    explicit basic_fstream(const string& __s, ios_base::openmode __mode = ios_base::in | ios_base::out);\n#endif\n#ifndef _LIBCPP_HAS_NO_RVALUE_REFERENCES\n    _LIBCPP_INLINE_VISIBILITY\n    basic_fstream(basic_fstream&& __rhs);\n#endif\n\n#ifndef _LIBCPP_HAS_NO_RVALUE_REFERENCES\n    _LIBCPP_INLINE_VISIBILITY\n    basic_fstream& operator=(basic_fstream&& __rhs);\n#endif\n    _LIBCPP_INLINE_VISIBILITY\n    void swap(basic_fstream& __rhs);\n\n    _LIBCPP_INLINE_VISIBILITY\n    basic_filebuf<char_type, traits_type>* rdbuf() const;\n    _LIBCPP_INLINE_VISIBILITY\n    bool is_open() const;\n#ifndef _LIBCPP_HAS_NO_GLOBAL_FILESYSTEM_NAMESPACE\n    void open(const char* __s, ios_base::openmode __mode = ios_base::in | ios_base::out);\n    void open(const string& __s, ios_base::openmode __mode = ios_base::in | ios_base::out);\n#endif\n    _LIBCPP_INLINE_VISIBILITY\n    void close();\n\nprivate:\n    basic_filebuf<char_type, traits_type> __sb_;\n};\n\ntemplate <class _CharT, class _Traits>\ninline\nbasic_fstream<_CharT, _Traits>::basic_fstream()\n    : basic_iostream<char_type, traits_type>(&__sb_)\n{\n}\n\n#ifndef _LIBCPP_HAS_NO_GLOBAL_FILESYSTEM_NAMESPACE\ntemplate <class _CharT, class _Traits>\ninline\nbasic_fstream<_CharT, _Traits>::basic_fstream(const char* __s, ios_base::openmode __mode)\n    : basic_iostream<char_type, traits_type>(&__sb_)\n{\n    if (__sb_.open(__s, __mode) == 0)\n        this->setstate(ios_base::failbit);\n}\n\ntemplate <class _CharT, class _Traits>\ninline\nbasic_fstream<_CharT, _Traits>::basic_fstream(const string& __s, ios_base::openmode __mode)\n    : basic_iostream<char_type, traits_type>(&__sb_)\n{\n    if (__sb_.open(__s, __mode) == 0)\n        this->setstate(ios_base::failbit);\n}\n#endif\n\n#ifndef _LIBCPP_HAS_NO_RVALUE_REFERENCES\n\ntemplate <class _CharT, class _Traits>\ninline\nbasic_fstream<_CharT, _Traits>::basic_fstream(basic_fstream&& __rhs)\n    : basic_iostream<char_type, traits_type>(_VSTD::move(__rhs)),\n      __sb_(_VSTD::move(__rhs.__sb_))\n{\n    this->set_rdbuf(&__sb_);\n}\n\ntemplate <class _CharT, class _Traits>\ninline\nbasic_fstream<_CharT, _Traits>&\nbasic_fstream<_CharT, _Traits>::operator=(basic_fstream&& __rhs)\n{\n    basic_iostream<char_type, traits_type>::operator=(_VSTD::move(__rhs));\n    __sb_ = _VSTD::move(__rhs.__sb_);\n    return *this;\n}\n\n#endif  // _LIBCPP_HAS_NO_RVALUE_REFERENCES\n\ntemplate <class _CharT, class _Traits>\ninline\nvoid\nbasic_fstream<_CharT, _Traits>::swap(basic_fstream& __rhs)\n{\n    basic_iostream<char_type, traits_type>::swap(__rhs);\n    __sb_.swap(__rhs.__sb_);\n}\n\ntemplate <class _CharT, class _Traits>\ninline _LIBCPP_INLINE_VISIBILITY\nvoid\nswap(basic_fstream<_CharT, _Traits>& __x, basic_fstream<_CharT, _Traits>& __y)\n{\n    __x.swap(__y);\n}\n\ntemplate <class _CharT, class _Traits>\ninline\nbasic_filebuf<_CharT, _Traits>*\nbasic_fstream<_CharT, _Traits>::rdbuf() const\n{\n    return const_cast<basic_filebuf<char_type, traits_type>*>(&__sb_);\n}\n\ntemplate <class _CharT, class _Traits>\ninline\nbool\nbasic_fstream<_CharT, _Traits>::is_open() const\n{\n    return __sb_.is_open();\n}\n\n#ifndef _LIBCPP_HAS_NO_GLOBAL_FILESYSTEM_NAMESPACE\ntemplate <class _CharT, class _Traits>\nvoid\nbasic_fstream<_CharT, _Traits>::open(const char* __s, ios_base::openmode __mode)\n{\n    if (__sb_.open(__s, __mode))\n        this->clear();\n    else\n        this->setstate(ios_base::failbit);\n}\n\ntemplate <class _CharT, class _Traits>\nvoid\nbasic_fstream<_CharT, _Traits>::open(const string& __s, ios_base::openmode __mode)\n{\n    if (__sb_.open(__s, __mode))\n        this->clear();\n    else\n        this->setstate(ios_base::failbit);\n}\n#endif\n\ntemplate <class _CharT, class _Traits>\ninline\nvoid\nbasic_fstream<_CharT, _Traits>::close()\n{\n    if (__sb_.close() == 0)\n        this->setstate(ios_base::failbit);\n}\n\n_LIBCPP_END_NAMESPACE_STD\n\n#endif  // _LIBCPP_FSTREAM\n","// -*- C++ -*-\n//===------------------------- streambuf ----------------------------------===//\n//\n//                     The LLVM Compiler Infrastructure\n//\n// This file is dual licensed under the MIT and the University of Illinois Open\n// Source Licenses. See LICENSE.TXT for details.\n//\n//===----------------------------------------------------------------------===//\n\n#ifndef _LIBCPP_STEAMBUF\n#define _LIBCPP_STEAMBUF\n\n/*\n    streambuf synopsis\n\nnamespace std\n{\n\ntemplate <class charT, class traits = char_traits<charT> >\nclass basic_streambuf\n{\npublic:\n    // types:\n    typedef charT char_type;\n    typedef traits traits_type;\n    typedef typename traits_type::int_type int_type;\n    typedef typename traits_type::pos_type pos_type;\n    typedef typename traits_type::off_type off_type;\n\n    virtual ~basic_streambuf();\n\n    // 27.6.2.2.1 locales:\n    locale pubimbue(const locale& loc);\n    locale getloc() const;\n\n    // 27.6.2.2.2 buffer and positioning:\n    basic_streambuf* pubsetbuf(char_type* s, streamsize n);\n    pos_type pubseekoff(off_type off, ios_base::seekdir way,\n                        ios_base::openmode which = ios_base::in | ios_base::out);\n    pos_type pubseekpos(pos_type sp,\n                        ios_base::openmode which = ios_base::in | ios_base::out);\n    int pubsync();\n\n    // Get and put areas:\n    // 27.6.2.2.3 Get area:\n    streamsize in_avail();\n    int_type snextc();\n    int_type sbumpc();\n    int_type sgetc();\n    streamsize sgetn(char_type* s, streamsize n);\n\n    // 27.6.2.2.4 Putback:\n    int_type sputbackc(char_type c);\n    int_type sungetc();\n\n    // 27.6.2.2.5 Put area:\n    int_type sputc(char_type c);\n    streamsize sputn(const char_type* s, streamsize n);\n\nprotected:\n    basic_streambuf();\n    basic_streambuf(const basic_streambuf& rhs);\n    basic_streambuf& operator=(const basic_streambuf& rhs);\n    void swap(basic_streambuf& rhs);\n\n    // 27.6.2.3.2 Get area:\n    char_type* eback() const;\n    char_type* gptr() const;\n    char_type* egptr() const;\n    void gbump(int n);\n    void setg(char_type* gbeg, char_type* gnext, char_type* gend);\n\n    // 27.6.2.3.3 Put area:\n    char_type* pbase() const;\n    char_type* pptr() const;\n    char_type* epptr() const;\n    void pbump(int n);\n    void setp(char_type* pbeg, char_type* pend);\n\n    // 27.6.2.4 virtual functions:\n    // 27.6.2.4.1 Locales:\n    virtual void imbue(const locale& loc);\n\n    // 27.6.2.4.2 Buffer management and positioning:\n    virtual basic_streambuf* setbuf(char_type* s, streamsize n);\n    virtual pos_type seekoff(off_type off, ios_base::seekdir way,\n                             ios_base::openmode which = ios_base::in | ios_base::out);\n    virtual pos_type seekpos(pos_type sp,\n                             ios_base::openmode which = ios_base::in | ios_base::out);\n    virtual int sync();\n\n    // 27.6.2.4.3 Get area:\n    virtual streamsize showmanyc();\n    virtual streamsize xsgetn(char_type* s, streamsize n);\n    virtual int_type underflow();\n    virtual int_type uflow();\n\n    // 27.6.2.4.4 Putback:\n    virtual int_type pbackfail(int_type c = traits_type::eof());\n\n    // 27.6.2.4.5 Put area:\n    virtual streamsize xsputn(const char_type* s, streamsize n);\n    virtual int_type overflow (int_type c = traits_type::eof());\n};\n\n}  // std\n\n*/\n\n#include <__config>\n#include <iosfwd>\n#include <ios>\n\n#if !defined(_LIBCPP_HAS_NO_PRAGMA_SYSTEM_HEADER)\n#pragma GCC system_header\n#endif\n\n_LIBCPP_BEGIN_NAMESPACE_STD\n\ntemplate <class _CharT, class _Traits>\nclass _LIBCPP_TEMPLATE_VIS basic_streambuf\n{\npublic:\n    // types:\n    typedef _CharT                         char_type;\n    typedef _Traits                        traits_type;\n    typedef typename traits_type::int_type int_type;\n    typedef typename traits_type::pos_type pos_type;\n    typedef typename traits_type::off_type off_type;\n\n    virtual ~basic_streambuf();\n\n    // 27.6.2.2.1 locales:\n    inline _LIBCPP_EXTERN_TEMPLATE_INLINE_VISIBILITY\n    locale pubimbue(const locale& __loc) {\n        imbue(__loc);\n        locale __r = __loc_;\n        __loc_ = __loc;\n        return __r;\n    }\n\n    inline _LIBCPP_EXTERN_TEMPLATE_INLINE_VISIBILITY\n    locale getloc() const { return __loc_; }\n\n    // 27.6.2.2.2 buffer and positioning:\n    inline _LIBCPP_EXTERN_TEMPLATE_INLINE_VISIBILITY\n    basic_streambuf* pubsetbuf(char_type* __s, streamsize __n)\n    { return setbuf(__s, __n); }\n\n    inline _LIBCPP_EXTERN_TEMPLATE_INLINE_VISIBILITY\n    pos_type pubseekoff(off_type __off, ios_base::seekdir __way,\n                        ios_base::openmode __which = ios_base::in | ios_base::out)\n    { return seekoff(__off, __way, __which); }\n\n    inline _LIBCPP_EXTERN_TEMPLATE_INLINE_VISIBILITY\n    pos_type pubseekpos(pos_type __sp,\n                        ios_base::openmode __which = ios_base::in | ios_base::out)\n    { return seekpos(__sp, __which); }\n\n    inline _LIBCPP_EXTERN_TEMPLATE_INLINE_VISIBILITY\n    int pubsync() { return sync(); }\n\n    // Get and put areas:\n    // 27.6.2.2.3 Get area:\n    inline _LIBCPP_EXTERN_TEMPLATE_INLINE_VISIBILITY\n    streamsize in_avail() {\n        if (__ninp_ < __einp_)\n            return static_cast<streamsize>(__einp_ - __ninp_);\n        return showmanyc();\n    }\n\n    inline _LIBCPP_EXTERN_TEMPLATE_INLINE_VISIBILITY\n    int_type snextc() {\n        if (sbumpc() == traits_type::eof())\n            return traits_type::eof();\n        return sgetc();\n    }\n\n    inline _LIBCPP_EXTERN_TEMPLATE_INLINE_VISIBILITY\n    int_type sbumpc() {\n        if (__ninp_ == __einp_)\n            return uflow();\n        return traits_type::to_int_type(*__ninp_++);\n    }\n\n    inline _LIBCPP_EXTERN_TEMPLATE_INLINE_VISIBILITY\n    int_type sgetc() {\n        if (__ninp_ == __einp_)\n            return underflow();\n        return traits_type::to_int_type(*__ninp_);\n    }\n\n    inline _LIBCPP_EXTERN_TEMPLATE_INLINE_VISIBILITY\n    streamsize sgetn(char_type* __s, streamsize __n)\n    { return xsgetn(__s, __n); }\n\n    // 27.6.2.2.4 Putback:\n    inline _LIBCPP_EXTERN_TEMPLATE_INLINE_VISIBILITY\n    int_type sputbackc(char_type __c) {\n        if (__binp_ == __ninp_ || !traits_type::eq(__c, __ninp_[-1]))\n            return pbackfail(traits_type::to_int_type(__c));\n        return traits_type::to_int_type(*--__ninp_);\n    }\n\n    inline _LIBCPP_EXTERN_TEMPLATE_INLINE_VISIBILITY\n    int_type sungetc() {\n        if (__binp_ == __ninp_)\n          return pbackfail();\n        return traits_type::to_int_type(*--__ninp_);\n    }\n\n    // 27.6.2.2.5 Put area:\n    inline _LIBCPP_EXTERN_TEMPLATE_INLINE_VISIBILITY\n    int_type sputc(char_type __c) {\n        if (__nout_ == __eout_)\n            return overflow(traits_type::to_int_type(__c));\n        *__nout_++ = __c;\n        return traits_type::to_int_type(__c);\n    }\n\n    inline _LIBCPP_EXTERN_TEMPLATE_INLINE_VISIBILITY\n    streamsize sputn(const char_type* __s, streamsize __n)\n    { return xsputn(__s, __n); }\n\nprotected:\n    basic_streambuf();\n    basic_streambuf(const basic_streambuf& __rhs);\n    basic_streambuf& operator=(const basic_streambuf& __rhs);\n    void swap(basic_streambuf& __rhs);\n\n    // 27.6.2.3.2 Get area:\n    _LIBCPP_ALWAYS_INLINE char_type* eback() const {return __binp_;}\n    _LIBCPP_ALWAYS_INLINE char_type* gptr()  const {return __ninp_;}\n    _LIBCPP_ALWAYS_INLINE char_type* egptr() const {return __einp_;}\n\n    inline _LIBCPP_EXTERN_TEMPLATE_INLINE_VISIBILITY\n    void gbump(int __n) { __ninp_ += __n; }\n\n    inline _LIBCPP_EXTERN_TEMPLATE_INLINE_VISIBILITY\n    void setg(char_type* __gbeg, char_type* __gnext, char_type* __gend) {\n        __binp_ = __gbeg;\n        __ninp_ = __gnext;\n        __einp_ = __gend;\n    }\n\n    // 27.6.2.3.3 Put area:\n    _LIBCPP_ALWAYS_INLINE char_type* pbase() const {return __bout_;}\n    _LIBCPP_ALWAYS_INLINE char_type* pptr()  const {return __nout_;}\n    _LIBCPP_ALWAYS_INLINE char_type* epptr() const {return __eout_;}\n\n    inline _LIBCPP_EXTERN_TEMPLATE_INLINE_VISIBILITY\n    void pbump(int __n) { __nout_ += __n; }\n\n    inline _LIBCPP_EXTERN_TEMPLATE_INLINE_VISIBILITY\n    void setp(char_type* __pbeg, char_type* __pend) {\n        __bout_ = __nout_ = __pbeg;\n        __eout_ = __pend;\n    }\n\n    // 27.6.2.4 virtual functions:\n    // 27.6.2.4.1 Locales:\n    virtual void imbue(const locale& __loc);\n\n    // 27.6.2.4.2 Buffer management and positioning:\n    virtual basic_streambuf* setbuf(char_type* __s, streamsize __n);\n    virtual pos_type seekoff(off_type __off, ios_base::seekdir __way,\n                             ios_base::openmode __which = ios_base::in | ios_base::out);\n    virtual pos_type seekpos(pos_type __sp,\n                             ios_base::openmode __which = ios_base::in | ios_base::out);\n    virtual int sync();\n\n    // 27.6.2.4.3 Get area:\n    virtual streamsize showmanyc();\n    virtual streamsize xsgetn(char_type* __s, streamsize __n);\n    virtual int_type underflow();\n    virtual int_type uflow();\n\n    // 27.6.2.4.4 Putback:\n    virtual int_type pbackfail(int_type __c = traits_type::eof());\n\n    // 27.6.2.4.5 Put area:\n    virtual streamsize xsputn(const char_type* __s, streamsize __n);\n    virtual int_type overflow(int_type __c = traits_type::eof());\n\nprivate:\n    locale __loc_;\n    char_type* __binp_;\n    char_type* __ninp_;\n    char_type* __einp_;\n    char_type* __bout_;\n    char_type* __nout_;\n    char_type* __eout_;\n};\n\ntemplate <class _CharT, class _Traits>\nbasic_streambuf<_CharT, _Traits>::~basic_streambuf()\n{\n}\n\ntemplate <class _CharT, class _Traits>\nbasic_streambuf<_CharT, _Traits>::basic_streambuf()\n    : __binp_(0),\n      __ninp_(0),\n      __einp_(0),\n      __bout_(0),\n      __nout_(0),\n      __eout_(0)\n{\n}\n\ntemplate <class _CharT, class _Traits>\nbasic_streambuf<_CharT, _Traits>::basic_streambuf(const basic_streambuf& __sb)\n    : __loc_(__sb.__loc_),\n      __binp_(__sb.__binp_),\n      __ninp_(__sb.__ninp_),\n      __einp_(__sb.__einp_),\n      __bout_(__sb.__bout_),\n      __nout_(__sb.__nout_),\n      __eout_(__sb.__eout_)\n{\n}\n\ntemplate <class _CharT, class _Traits>\nbasic_streambuf<_CharT, _Traits>&\nbasic_streambuf<_CharT, _Traits>::operator=(const basic_streambuf& __sb)\n{\n    __loc_ = __sb.__loc_;\n    __binp_ = __sb.__binp_;\n    __ninp_ = __sb.__ninp_;\n    __einp_ = __sb.__einp_;\n    __bout_ = __sb.__bout_;\n    __nout_ = __sb.__nout_;\n    __eout_ = __sb.__eout_;\n    return *this;\n}\n\ntemplate <class _CharT, class _Traits>\nvoid\nbasic_streambuf<_CharT, _Traits>::swap(basic_streambuf& __sb)\n{\n    _VSTD::swap(__loc_, __sb.__loc_);\n    _VSTD::swap(__binp_, __sb.__binp_);\n    _VSTD::swap(__ninp_, __sb.__ninp_);\n    _VSTD::swap(__einp_, __sb.__einp_);\n    _VSTD::swap(__bout_, __sb.__bout_);\n    _VSTD::swap(__nout_, __sb.__nout_);\n    _VSTD::swap(__eout_, __sb.__eout_);\n}\n\ntemplate <class _CharT, class _Traits>\nvoid\nbasic_streambuf<_CharT, _Traits>::imbue(const locale&)\n{\n}\n\ntemplate <class _CharT, class _Traits>\nbasic_streambuf<_CharT, _Traits>*\nbasic_streambuf<_CharT, _Traits>::setbuf(char_type*, streamsize)\n{\n    return this;\n}\n\ntemplate <class _CharT, class _Traits>\ntypename basic_streambuf<_CharT, _Traits>::pos_type\nbasic_streambuf<_CharT, _Traits>::seekoff(off_type, ios_base::seekdir,\n                                          ios_base::openmode)\n{\n    return pos_type(off_type(-1));\n}\n\ntemplate <class _CharT, class _Traits>\ntypename basic_streambuf<_CharT, _Traits>::pos_type\nbasic_streambuf<_CharT, _Traits>::seekpos(pos_type, ios_base::openmode)\n{\n    return pos_type(off_type(-1));\n}\n\ntemplate <class _CharT, class _Traits>\nint\nbasic_streambuf<_CharT, _Traits>::sync()\n{\n    return 0;\n}\n\ntemplate <class _CharT, class _Traits>\nstreamsize\nbasic_streambuf<_CharT, _Traits>::showmanyc()\n{\n    return 0;\n}\n\ntemplate <class _CharT, class _Traits>\nstreamsize\nbasic_streambuf<_CharT, _Traits>::xsgetn(char_type* __s, streamsize __n)\n{\n    const int_type __eof = traits_type::eof();\n    int_type __c;\n    streamsize __i = 0;\n    while(__i < __n)\n    {\n        if (__ninp_ < __einp_)\n        {\n            const streamsize __len = _VSTD::min(__einp_ - __ninp_, __n - __i);\n            traits_type::copy(__s, __ninp_, __len);\n            __s +=  __len;\n            __i +=  __len;\n            this->gbump(__len);\n        }\n        else if ((__c = uflow()) != __eof)\n        {\n            *__s = traits_type::to_char_type(__c);\n            ++__s;\n            ++__i;\n        }\n        else\n            break;\n    }\n    return __i;\n}\n\ntemplate <class _CharT, class _Traits>\ntypename basic_streambuf<_CharT, _Traits>::int_type\nbasic_streambuf<_CharT, _Traits>::underflow()\n{\n    return traits_type::eof();\n}\n\ntemplate <class _CharT, class _Traits>\ntypename basic_streambuf<_CharT, _Traits>::int_type\nbasic_streambuf<_CharT, _Traits>::uflow()\n{\n    if (underflow() == traits_type::eof())\n        return traits_type::eof();\n    return traits_type::to_int_type(*__ninp_++);\n}\n\ntemplate <class _CharT, class _Traits>\ntypename basic_streambuf<_CharT, _Traits>::int_type\nbasic_streambuf<_CharT, _Traits>::pbackfail(int_type)\n{\n    return traits_type::eof();\n}\n\ntemplate <class _CharT, class _Traits>\nstreamsize\nbasic_streambuf<_CharT, _Traits>::xsputn(const char_type* __s, streamsize __n)\n{\n    streamsize __i = 0;\n    int_type __eof = traits_type::eof();\n    while( __i < __n)\n    {\n        if (__nout_ >= __eout_)\n        {\n            if (overflow(traits_type::to_int_type(*__s)) == __eof)\n                break;\n            ++__s;\n            ++__i;\n        }\n        else\n        {\n            streamsize __chunk_size = _VSTD::min(__eout_ - __nout_, __n - __i);\n            traits_type::copy(__nout_, __s, __chunk_size);\n            __nout_ += __chunk_size;\n            __s     += __chunk_size;\n            __i     += __chunk_size;\n        }\n    }\n    return __i;\n}\n\ntemplate <class _CharT, class _Traits>\ntypename basic_streambuf<_CharT, _Traits>::int_type\nbasic_streambuf<_CharT, _Traits>::overflow(int_type)\n{\n    return traits_type::eof();\n}\n\n_LIBCPP_EXTERN_TEMPLATE(class _LIBCPP_EXTERN_TEMPLATE_TYPE_VIS basic_streambuf<char>)\n_LIBCPP_EXTERN_TEMPLATE(class _LIBCPP_EXTERN_TEMPLATE_TYPE_VIS basic_streambuf<wchar_t>)\n\n_LIBCPP_EXTERN_TEMPLATE(class _LIBCPP_EXTERN_TEMPLATE_TYPE_VIS basic_ios<char>)\n_LIBCPP_EXTERN_TEMPLATE(class _LIBCPP_EXTERN_TEMPLATE_TYPE_VIS basic_ios<wchar_t>)\n\n_LIBCPP_END_NAMESPACE_STD\n\n#endif  // _LIBCPP_STEAMBUF\n","// -*- C++ -*-\n//===--------------------------- tuple ------------------------------------===//\n//\n//                     The LLVM Compiler Infrastructure\n//\n// This file is distributed under the University of Illinois Open Source\n// License. See LICENSE.TXT for details.\n//\n//===----------------------------------------------------------------------===//\n\n#ifndef _LIBCPP_TUPLE\n#define _LIBCPP_TUPLE\n\n/*\n    tuple synopsis\n\nnamespace std\n{\n\ntemplate <class... T>\nclass tuple {\npublic:\n    constexpr tuple();\n    explicit tuple(const T&...);  // constexpr in C++14\n    template <class... U>\n        explicit tuple(U&&...);  // constexpr in C++14\n    tuple(const tuple&) = default;\n    tuple(tuple&&) = default;\n    template <class... U>\n        tuple(const tuple<U...>&);  // constexpr in C++14\n    template <class... U>\n        tuple(tuple<U...>&&);  // constexpr in C++14\n    template <class U1, class U2>\n        tuple(const pair<U1, U2>&); // iff sizeof...(T) == 2 // constexpr in C++14\n    template <class U1, class U2>\n        tuple(pair<U1, U2>&&); // iff sizeof...(T) == 2  // constexpr in C++14\n\n    // allocator-extended constructors\n    template <class Alloc>\n        tuple(allocator_arg_t, const Alloc& a);\n    template <class Alloc>\n        tuple(allocator_arg_t, const Alloc& a, const T&...);\n    template <class Alloc, class... U>\n        tuple(allocator_arg_t, const Alloc& a, U&&...);\n    template <class Alloc>\n        tuple(allocator_arg_t, const Alloc& a, const tuple&);\n    template <class Alloc>\n        tuple(allocator_arg_t, const Alloc& a, tuple&&);\n    template <class Alloc, class... U>\n        tuple(allocator_arg_t, const Alloc& a, const tuple<U...>&);\n    template <class Alloc, class... U>\n        tuple(allocator_arg_t, const Alloc& a, tuple<U...>&&);\n    template <class Alloc, class U1, class U2>\n        tuple(allocator_arg_t, const Alloc& a, const pair<U1, U2>&);\n    template <class Alloc, class U1, class U2>\n        tuple(allocator_arg_t, const Alloc& a, pair<U1, U2>&&);\n\n    tuple& operator=(const tuple&);\n    tuple&\n        operator=(tuple&&) noexcept(AND(is_nothrow_move_assignable<T>::value ...));\n    template <class... U>\n        tuple& operator=(const tuple<U...>&);\n    template <class... U>\n        tuple& operator=(tuple<U...>&&);\n    template <class U1, class U2>\n        tuple& operator=(const pair<U1, U2>&); // iff sizeof...(T) == 2\n    template <class U1, class U2>\n        tuple& operator=(pair<U1, U2>&&); //iffsizeof...(T) == 2\n\n    void swap(tuple&) noexcept(AND(swap(declval<T&>(), declval<T&>())...));\n};\n\nconst unspecified ignore;\n\ntemplate <class... T> tuple<V...>  make_tuple(T&&...); // constexpr in C++14\ntemplate <class... T> tuple<ATypes...> forward_as_tuple(T&&...) noexcept; // constexpr in C++14\ntemplate <class... T> tuple<T&...> tie(T&...) noexcept; // constexpr in C++14\ntemplate <class... Tuples> tuple<CTypes...> tuple_cat(Tuples&&... tpls); // constexpr in C++14\n\n// [tuple.apply], calling a function with a tuple of arguments:\ntemplate <class F, class Tuple>\n  constexpr decltype(auto) apply(F&& f, Tuple&& t); // C++17\ntemplate <class T, class Tuple>\n  constexpr T make_from_tuple(Tuple&& t); // C++17\n\n// 20.4.1.4, tuple helper classes:\ntemplate <class T> class tuple_size; // undefined\ntemplate <class... T> class tuple_size<tuple<T...>>;\ntemplate <class T>\n constexpr size_t tuple_size_v = tuple_size<T>::value; // C++17\ntemplate <size_t I, class T> class tuple_element; // undefined\ntemplate <size_t I, class... T> class tuple_element<I, tuple<T...>>;\ntemplate <size_t I, class T>\n  using tuple_element_t = typename tuple_element <I, T>::type; // C++14\n\n// 20.4.1.5, element access:\ntemplate <size_t I, class... T>\n    typename tuple_element<I, tuple<T...>>::type&\n    get(tuple<T...>&) noexcept; // constexpr in C++14\ntemplate <size_t I, class... T>\n    const typename tuple_element<I, tuple<T...>>::type&\n    get(const tuple<T...>&) noexcept; // constexpr in C++14\ntemplate <size_t I, class... T>\n    typename tuple_element<I, tuple<T...>>::type&&\n    get(tuple<T...>&&) noexcept; // constexpr in C++14\ntemplate <size_t I, class... T>\n    const typename tuple_element<I, tuple<T...>>::type&&\n    get(const tuple<T...>&&) noexcept; // constexpr in C++14\n\ntemplate <class T1, class... T>\n    constexpr T1& get(tuple<T...>&) noexcept;  // C++14\ntemplate <class T1, class... T>\n    constexpr const T1& get(const tuple<T...>&) noexcept;   // C++14\ntemplate <class T1, class... T>\n    constexpr T1&& get(tuple<T...>&&) noexcept;   // C++14\ntemplate <class T1, class... T>\n    constexpr const T1&& get(const tuple<T...>&&) noexcept;   // C++14\n\n// 20.4.1.6, relational operators:\ntemplate<class... T, class... U> bool operator==(const tuple<T...>&, const tuple<U...>&); // constexpr in C++14\ntemplate<class... T, class... U> bool operator<(const tuple<T...>&, const tuple<U...>&);  // constexpr in C++14\ntemplate<class... T, class... U> bool operator!=(const tuple<T...>&, const tuple<U...>&); // constexpr in C++14\ntemplate<class... T, class... U> bool operator>(const tuple<T...>&, const tuple<U...>&);  // constexpr in C++14\ntemplate<class... T, class... U> bool operator<=(const tuple<T...>&, const tuple<U...>&); // constexpr in C++14\ntemplate<class... T, class... U> bool operator>=(const tuple<T...>&, const tuple<U...>&); // constexpr in C++14\n\ntemplate <class... Types, class Alloc>\n  struct uses_allocator<tuple<Types...>, Alloc>;\n\ntemplate <class... Types>\n  void\n  swap(tuple<Types...>& x, tuple<Types...>& y) noexcept(noexcept(x.swap(y)));\n\n}  // std\n\n*/\n\n#include <__config>\n#include <__tuple>\n#include <cstddef>\n#include <type_traits>\n#include <__functional_base>\n#include <utility>\n\n#if !defined(_LIBCPP_HAS_NO_PRAGMA_SYSTEM_HEADER)\n#pragma GCC system_header\n#endif\n\n_LIBCPP_BEGIN_NAMESPACE_STD\n\n#ifndef _LIBCPP_HAS_NO_VARIADICS\n\n\n// __tuple_leaf\n\ntemplate <size_t _Ip, class _Hp,\n          bool=is_empty<_Hp>::value && !__libcpp_is_final<_Hp>::value\n         >\nclass __tuple_leaf;\n\ntemplate <size_t _Ip, class _Hp, bool _Ep>\ninline _LIBCPP_INLINE_VISIBILITY\nvoid swap(__tuple_leaf<_Ip, _Hp, _Ep>& __x, __tuple_leaf<_Ip, _Hp, _Ep>& __y)\n    _NOEXCEPT_(__is_nothrow_swappable<_Hp>::value)\n{\n    swap(__x.get(), __y.get());\n}\n\ntemplate <size_t _Ip, class _Hp, bool>\nclass __tuple_leaf\n{\n    _Hp value;\n\n    template <class _Tp>\n    static constexpr bool __can_bind_reference() {\n        using _RawTp = typename remove_reference<_Tp>::type;\n        using _RawHp = typename remove_reference<_Hp>::type;\n        using _CheckLValueArg = integral_constant<bool,\n            is_lvalue_reference<_Tp>::value\n        ||  is_same<_RawTp, reference_wrapper<_RawHp>>::value\n        ||  is_same<_RawTp, reference_wrapper<typename remove_const<_RawHp>::type>>::value\n        >;\n        return  !is_reference<_Hp>::value\n            || (is_lvalue_reference<_Hp>::value && _CheckLValueArg::value)\n            || (is_rvalue_reference<_Hp>::value && !is_lvalue_reference<_Tp>::value);\n    }\n\n    __tuple_leaf& operator=(const __tuple_leaf&);\npublic:\n    _LIBCPP_INLINE_VISIBILITY _LIBCPP_CONSTEXPR __tuple_leaf()\n             _NOEXCEPT_(is_nothrow_default_constructible<_Hp>::value) : value()\n       {static_assert(!is_reference<_Hp>::value,\n              \"Attempted to default construct a reference element in a tuple\");}\n\n    template <class _Alloc>\n        _LIBCPP_INLINE_VISIBILITY\n        __tuple_leaf(integral_constant<int, 0>, const _Alloc&)\n            : value()\n        {static_assert(!is_reference<_Hp>::value,\n              \"Attempted to default construct a reference element in a tuple\");}\n\n    template <class _Alloc>\n        _LIBCPP_INLINE_VISIBILITY\n        __tuple_leaf(integral_constant<int, 1>, const _Alloc& __a)\n            : value(allocator_arg_t(), __a)\n        {static_assert(!is_reference<_Hp>::value,\n              \"Attempted to default construct a reference element in a tuple\");}\n\n    template <class _Alloc>\n        _LIBCPP_INLINE_VISIBILITY\n        __tuple_leaf(integral_constant<int, 2>, const _Alloc& __a)\n            : value(__a)\n        {static_assert(!is_reference<_Hp>::value,\n              \"Attempted to default construct a reference element in a tuple\");}\n\n    template <class _Tp,\n              class = typename enable_if<\n                  __lazy_and<\n                      __lazy_not<is_same<typename decay<_Tp>::type, __tuple_leaf>>\n                    , is_constructible<_Hp, _Tp>\n                    >::value\n                >::type\n            >\n        _LIBCPP_INLINE_VISIBILITY _LIBCPP_CONSTEXPR_AFTER_CXX11\n        explicit __tuple_leaf(_Tp&& __t) _NOEXCEPT_((is_nothrow_constructible<_Hp, _Tp>::value))\n            : value(_VSTD::forward<_Tp>(__t))\n        {static_assert(__can_bind_reference<_Tp>(),\n       \"Attempted to construct a reference element in a tuple with an rvalue\");}\n\n    template <class _Tp, class _Alloc>\n        _LIBCPP_INLINE_VISIBILITY\n        explicit __tuple_leaf(integral_constant<int, 0>, const _Alloc&, _Tp&& __t)\n            : value(_VSTD::forward<_Tp>(__t))\n        {static_assert(__can_bind_reference<_Tp>(),\n       \"Attempted to construct a reference element in a tuple with an rvalue\");}\n\n    template <class _Tp, class _Alloc>\n        _LIBCPP_INLINE_VISIBILITY\n        explicit __tuple_leaf(integral_constant<int, 1>, const _Alloc& __a, _Tp&& __t)\n            : value(allocator_arg_t(), __a, _VSTD::forward<_Tp>(__t))\n        {static_assert(!is_reference<_Hp>::value,\n            \"Attempted to uses-allocator construct a reference element in a tuple\");}\n\n    template <class _Tp, class _Alloc>\n        _LIBCPP_INLINE_VISIBILITY\n        explicit __tuple_leaf(integral_constant<int, 2>, const _Alloc& __a, _Tp&& __t)\n            : value(_VSTD::forward<_Tp>(__t), __a)\n        {static_assert(!is_reference<_Hp>::value,\n           \"Attempted to uses-allocator construct a reference element in a tuple\");}\n\n    __tuple_leaf(const __tuple_leaf& __t) = default;\n    __tuple_leaf(__tuple_leaf&& __t) = default;\n\n    template <class _Tp>\n        _LIBCPP_INLINE_VISIBILITY\n        __tuple_leaf&\n        operator=(_Tp&& __t) _NOEXCEPT_((is_nothrow_assignable<_Hp&, _Tp>::value))\n        {\n            value = _VSTD::forward<_Tp>(__t);\n            return *this;\n        }\n\n    _LIBCPP_INLINE_VISIBILITY\n    int swap(__tuple_leaf& __t) _NOEXCEPT_(__is_nothrow_swappable<__tuple_leaf>::value)\n    {\n        _VSTD::swap(*this, __t);\n        return 0;\n    }\n\n    _LIBCPP_INLINE_VISIBILITY _LIBCPP_CONSTEXPR_AFTER_CXX11       _Hp& get()       _NOEXCEPT {return value;}\n    _LIBCPP_INLINE_VISIBILITY _LIBCPP_CONSTEXPR_AFTER_CXX11 const _Hp& get() const _NOEXCEPT {return value;}\n};\n\ntemplate <size_t _Ip, class _Hp>\nclass __tuple_leaf<_Ip, _Hp, true>\n    : private _Hp\n{\n\n    __tuple_leaf& operator=(const __tuple_leaf&);\npublic:\n    _LIBCPP_INLINE_VISIBILITY _LIBCPP_CONSTEXPR __tuple_leaf()\n             _NOEXCEPT_(is_nothrow_default_constructible<_Hp>::value) {}\n\n    template <class _Alloc>\n        _LIBCPP_INLINE_VISIBILITY\n        __tuple_leaf(integral_constant<int, 0>, const _Alloc&) {}\n\n    template <class _Alloc>\n        _LIBCPP_INLINE_VISIBILITY\n        __tuple_leaf(integral_constant<int, 1>, const _Alloc& __a)\n            : _Hp(allocator_arg_t(), __a) {}\n\n    template <class _Alloc>\n        _LIBCPP_INLINE_VISIBILITY\n        __tuple_leaf(integral_constant<int, 2>, const _Alloc& __a)\n            : _Hp(__a) {}\n\n    template <class _Tp,\n              class = typename enable_if<\n                  __lazy_and<\n                        __lazy_not<is_same<typename decay<_Tp>::type, __tuple_leaf>>\n                      , is_constructible<_Hp, _Tp>\n                    >::value\n                >::type\n            >\n        _LIBCPP_INLINE_VISIBILITY _LIBCPP_CONSTEXPR_AFTER_CXX11\n        explicit __tuple_leaf(_Tp&& __t) _NOEXCEPT_((is_nothrow_constructible<_Hp, _Tp>::value))\n            : _Hp(_VSTD::forward<_Tp>(__t)) {}\n\n    template <class _Tp, class _Alloc>\n        _LIBCPP_INLINE_VISIBILITY\n        explicit __tuple_leaf(integral_constant<int, 0>, const _Alloc&, _Tp&& __t)\n            : _Hp(_VSTD::forward<_Tp>(__t)) {}\n\n    template <class _Tp, class _Alloc>\n        _LIBCPP_INLINE_VISIBILITY\n        explicit __tuple_leaf(integral_constant<int, 1>, const _Alloc& __a, _Tp&& __t)\n            : _Hp(allocator_arg_t(), __a, _VSTD::forward<_Tp>(__t)) {}\n\n    template <class _Tp, class _Alloc>\n        _LIBCPP_INLINE_VISIBILITY\n        explicit __tuple_leaf(integral_constant<int, 2>, const _Alloc& __a, _Tp&& __t)\n            : _Hp(_VSTD::forward<_Tp>(__t), __a) {}\n\n    __tuple_leaf(__tuple_leaf const &) = default;\n    __tuple_leaf(__tuple_leaf &&) = default;\n\n    template <class _Tp>\n        _LIBCPP_INLINE_VISIBILITY\n        __tuple_leaf&\n        operator=(_Tp&& __t) _NOEXCEPT_((is_nothrow_assignable<_Hp&, _Tp>::value))\n        {\n            _Hp::operator=(_VSTD::forward<_Tp>(__t));\n            return *this;\n        }\n\n    _LIBCPP_INLINE_VISIBILITY\n    int\n    swap(__tuple_leaf& __t) _NOEXCEPT_(__is_nothrow_swappable<__tuple_leaf>::value)\n    {\n        _VSTD::swap(*this, __t);\n        return 0;\n    }\n\n    _LIBCPP_INLINE_VISIBILITY _LIBCPP_CONSTEXPR_AFTER_CXX11       _Hp& get()       _NOEXCEPT {return static_cast<_Hp&>(*this);}\n    _LIBCPP_INLINE_VISIBILITY _LIBCPP_CONSTEXPR_AFTER_CXX11 const _Hp& get() const _NOEXCEPT {return static_cast<const _Hp&>(*this);}\n};\n\ntemplate <class ..._Tp>\n_LIBCPP_INLINE_VISIBILITY\nvoid __swallow(_Tp&&...) _NOEXCEPT {}\n\ntemplate <class ..._Tp>\nstruct __lazy_all : __all<_Tp::value...> {};\n\ntemplate <class _Tp>\nstruct __all_default_constructible;\n\ntemplate <class ..._Tp>\nstruct __all_default_constructible<__tuple_types<_Tp...>>\n    : __all<is_default_constructible<_Tp>::value...>\n{ };\n\n// __tuple_impl\n\ntemplate<class _Indx, class ..._Tp> struct __tuple_impl;\n\ntemplate<size_t ..._Indx, class ..._Tp>\nstruct __tuple_impl<__tuple_indices<_Indx...>, _Tp...>\n    : public __tuple_leaf<_Indx, _Tp>...\n{\n    _LIBCPP_INLINE_VISIBILITY\n    _LIBCPP_CONSTEXPR __tuple_impl()\n        _NOEXCEPT_(__all<is_nothrow_default_constructible<_Tp>::value...>::value) {}\n\n    template <size_t ..._Uf, class ..._Tf,\n              size_t ..._Ul, class ..._Tl, class ..._Up>\n        _LIBCPP_INLINE_VISIBILITY _LIBCPP_CONSTEXPR_AFTER_CXX11\n        explicit\n        __tuple_impl(__tuple_indices<_Uf...>, __tuple_types<_Tf...>,\n                     __tuple_indices<_Ul...>, __tuple_types<_Tl...>,\n                     _Up&&... __u)\n                     _NOEXCEPT_((__all<is_nothrow_constructible<_Tf, _Up>::value...>::value &&\n                                 __all<is_nothrow_default_constructible<_Tl>::value...>::value)) :\n            __tuple_leaf<_Uf, _Tf>(_VSTD::forward<_Up>(__u))...,\n            __tuple_leaf<_Ul, _Tl>()...\n            {}\n\n    template <class _Alloc, size_t ..._Uf, class ..._Tf,\n              size_t ..._Ul, class ..._Tl, class ..._Up>\n        _LIBCPP_INLINE_VISIBILITY\n        explicit\n        __tuple_impl(allocator_arg_t, const _Alloc& __a,\n                     __tuple_indices<_Uf...>, __tuple_types<_Tf...>,\n                     __tuple_indices<_Ul...>, __tuple_types<_Tl...>,\n                     _Up&&... __u) :\n            __tuple_leaf<_Uf, _Tf>(__uses_alloc_ctor<_Tf, _Alloc, _Up>(), __a,\n            _VSTD::forward<_Up>(__u))...,\n            __tuple_leaf<_Ul, _Tl>(__uses_alloc_ctor<_Tl, _Alloc>(), __a)...\n            {}\n\n    template <class _Tuple,\n              class = typename enable_if\n                      <\n                         __tuple_constructible<_Tuple, tuple<_Tp...> >::value\n                      >::type\n             >\n        _LIBCPP_INLINE_VISIBILITY _LIBCPP_CONSTEXPR_AFTER_CXX11\n        __tuple_impl(_Tuple&& __t) _NOEXCEPT_((__all<is_nothrow_constructible<_Tp, typename tuple_element<_Indx,\n                                       typename __make_tuple_types<_Tuple>::type>::type>::value...>::value))\n            : __tuple_leaf<_Indx, _Tp>(_VSTD::forward<typename tuple_element<_Indx,\n                                       typename __make_tuple_types<_Tuple>::type>::type>(_VSTD::get<_Indx>(__t)))...\n            {}\n\n    template <class _Alloc, class _Tuple,\n              class = typename enable_if\n                      <\n                         __tuple_constructible<_Tuple, tuple<_Tp...> >::value\n                      >::type\n             >\n        _LIBCPP_INLINE_VISIBILITY\n        __tuple_impl(allocator_arg_t, const _Alloc& __a, _Tuple&& __t)\n            : __tuple_leaf<_Indx, _Tp>(__uses_alloc_ctor<_Tp, _Alloc, typename tuple_element<_Indx,\n                                       typename __make_tuple_types<_Tuple>::type>::type>(), __a,\n                                       _VSTD::forward<typename tuple_element<_Indx,\n                                       typename __make_tuple_types<_Tuple>::type>::type>(_VSTD::get<_Indx>(__t)))...\n            {}\n\n    template <class _Tuple>\n        _LIBCPP_INLINE_VISIBILITY\n        typename enable_if\n        <\n            __tuple_assignable<_Tuple, tuple<_Tp...> >::value,\n            __tuple_impl&\n        >::type\n        operator=(_Tuple&& __t) _NOEXCEPT_((__all<is_nothrow_assignable<_Tp&, typename tuple_element<_Indx,\n                                       typename __make_tuple_types<_Tuple>::type>::type>::value...>::value))\n        {\n            __swallow(__tuple_leaf<_Indx, _Tp>::operator=(_VSTD::forward<typename tuple_element<_Indx,\n                                       typename __make_tuple_types<_Tuple>::type>::type>(_VSTD::get<_Indx>(__t)))...);\n            return *this;\n        }\n\n    __tuple_impl(const __tuple_impl&) = default;\n    __tuple_impl(__tuple_impl&&) = default;\n\n    _LIBCPP_INLINE_VISIBILITY\n    __tuple_impl&\n    operator=(const __tuple_impl& __t) _NOEXCEPT_((__all<is_nothrow_copy_assignable<_Tp>::value...>::value))\n    {\n        __swallow(__tuple_leaf<_Indx, _Tp>::operator=(static_cast<const __tuple_leaf<_Indx, _Tp>&>(__t).get())...);\n        return *this;\n    }\n\n    _LIBCPP_INLINE_VISIBILITY\n    __tuple_impl&\n    operator=(__tuple_impl&& __t) _NOEXCEPT_((__all<is_nothrow_move_assignable<_Tp>::value...>::value))\n    {\n        __swallow(__tuple_leaf<_Indx, _Tp>::operator=(_VSTD::forward<_Tp>(static_cast<__tuple_leaf<_Indx, _Tp>&>(__t).get()))...);\n        return *this;\n    }\n\n    _LIBCPP_INLINE_VISIBILITY\n    void swap(__tuple_impl& __t)\n        _NOEXCEPT_(__all<__is_nothrow_swappable<_Tp>::value...>::value)\n    {\n        __swallow(__tuple_leaf<_Indx, _Tp>::swap(static_cast<__tuple_leaf<_Indx, _Tp>&>(__t))...);\n    }\n};\n\n\n\ntemplate <class ..._Tp>\nclass _LIBCPP_TEMPLATE_VIS tuple\n{\n    typedef __tuple_impl<typename __make_tuple_indices<sizeof...(_Tp)>::type, _Tp...> base;\n\n    base base_;\n\n#if defined(_LIBCPP_ENABLE_TUPLE_IMPLICIT_REDUCED_ARITY_EXTENSION)\n    static constexpr bool _EnableImplicitReducedArityExtension = true;\n#else\n    static constexpr bool _EnableImplicitReducedArityExtension = false;\n#endif\n\n    template <class ..._Args>\n    struct _PackExpandsToThisTuple : false_type {};\n\n    template <class _Arg>\n    struct _PackExpandsToThisTuple<_Arg>\n        : is_same<typename __uncvref<_Arg>::type, tuple> {};\n\n    template <bool _MaybeEnable, class _Dummy = void>\n    struct _CheckArgsConstructor : __check_tuple_constructor_fail {};\n\n    template <class _Dummy>\n    struct _CheckArgsConstructor<true, _Dummy>\n    {\n        template <class ..._Args>\n        static constexpr bool __enable_default() {\n            return __all<is_default_constructible<_Args>::value...>::value;\n        }\n\n        template <class ..._Args>\n        static constexpr bool __enable_explicit() {\n            return\n                __tuple_constructible<\n                    tuple<_Args...>,\n                    typename __make_tuple_types<tuple,\n                             sizeof...(_Args) < sizeof...(_Tp) ?\n                                 sizeof...(_Args) :\n                                 sizeof...(_Tp)>::type\n                >::value &&\n                !__tuple_convertible<\n                    tuple<_Args...>,\n                    typename __make_tuple_types<tuple,\n                             sizeof...(_Args) < sizeof...(_Tp) ?\n                                 sizeof...(_Args) :\n                                 sizeof...(_Tp)>::type\n                >::value &&\n                __all_default_constructible<\n                    typename __make_tuple_types<tuple, sizeof...(_Tp),\n                             sizeof...(_Args) < sizeof...(_Tp) ?\n                                 sizeof...(_Args) :\n                                 sizeof...(_Tp)>::type\n                >::value;\n        }\n\n        template <class ..._Args>\n        static constexpr bool __enable_implicit() {\n            return\n                __tuple_convertible<\n                    tuple<_Args...>,\n                    typename __make_tuple_types<tuple,\n                             sizeof...(_Args) < sizeof...(_Tp) ?\n                                 sizeof...(_Args) :\n                                 sizeof...(_Tp)>::type\n                >::value &&\n                __all_default_constructible<\n                    typename __make_tuple_types<tuple, sizeof...(_Tp),\n                             sizeof...(_Args) < sizeof...(_Tp) ?\n                                 sizeof...(_Args) :\n                                 sizeof...(_Tp)>::type\n                >::value;\n        }\n    };\n\n    template <bool _MaybeEnable,\n              bool = sizeof...(_Tp) == 1,\n              class _Dummy = void>\n    struct _CheckTupleLikeConstructor : __check_tuple_constructor_fail {};\n\n    template <class _Dummy>\n    struct _CheckTupleLikeConstructor<true, false, _Dummy>\n    {\n        template <class _Tuple>\n        static constexpr bool __enable_implicit() {\n            return __tuple_convertible<_Tuple, tuple>::value;\n        }\n\n        template <class _Tuple>\n        static constexpr bool __enable_explicit() {\n            return __tuple_constructible<_Tuple, tuple>::value\n               && !__tuple_convertible<_Tuple, tuple>::value;\n        }\n    };\n\n    template <class _Dummy>\n    struct _CheckTupleLikeConstructor<true, true, _Dummy>\n    {\n        // This trait is used to disable the tuple-like constructor when\n        // the UTypes... constructor should be selected instead.\n        // See LWG issue #2549.\n        template <class _Tuple>\n        using _PreferTupleLikeConstructor = __lazy_or<\n            // Don't attempt the two checks below if the tuple we are given\n            // has the same type as this tuple.\n            is_same<typename __uncvref<_Tuple>::type, tuple>,\n            __lazy_and<\n                __lazy_not<is_constructible<_Tp..., _Tuple>>,\n                __lazy_not<is_convertible<_Tuple, _Tp...>>\n            >\n        >;\n\n        template <class _Tuple>\n        static constexpr bool __enable_implicit() {\n            return __lazy_and<\n                __tuple_convertible<_Tuple, tuple>,\n                _PreferTupleLikeConstructor<_Tuple>\n            >::value;\n        }\n\n        template <class _Tuple>\n        static constexpr bool __enable_explicit() {\n            return __lazy_and<\n                __tuple_constructible<_Tuple, tuple>,\n                _PreferTupleLikeConstructor<_Tuple>,\n                __lazy_not<__tuple_convertible<_Tuple, tuple>>\n            >::value;\n        }\n    };\n\n    template <size_t _Jp, class ..._Up> friend _LIBCPP_CONSTEXPR_AFTER_CXX11\n        typename tuple_element<_Jp, tuple<_Up...> >::type& get(tuple<_Up...>&) _NOEXCEPT;\n    template <size_t _Jp, class ..._Up> friend _LIBCPP_CONSTEXPR_AFTER_CXX11\n        const typename tuple_element<_Jp, tuple<_Up...> >::type& get(const tuple<_Up...>&) _NOEXCEPT;\n    template <size_t _Jp, class ..._Up> friend _LIBCPP_CONSTEXPR_AFTER_CXX11\n        typename tuple_element<_Jp, tuple<_Up...> >::type&& get(tuple<_Up...>&&) _NOEXCEPT;\n    template <size_t _Jp, class ..._Up> friend _LIBCPP_CONSTEXPR_AFTER_CXX11\n        const typename tuple_element<_Jp, tuple<_Up...> >::type&& get(const tuple<_Up...>&&) _NOEXCEPT;\npublic:\n\n    template <bool _Dummy = true, class = typename enable_if<\n        _CheckArgsConstructor<_Dummy>::template __enable_default<_Tp...>()\n    >::type>\n    _LIBCPP_INLINE_VISIBILITY\n    _LIBCPP_CONSTEXPR tuple()\n        _NOEXCEPT_(__all<is_nothrow_default_constructible<_Tp>::value...>::value) {}\n\n    tuple(tuple const&) = default;\n    tuple(tuple&&) = default;\n\n    template <class _AllocArgT, class _Alloc, bool _Dummy = true, class = typename enable_if<\n        __lazy_and<\n            is_same<allocator_arg_t, _AllocArgT>,\n            __lazy_all<__dependent_type<is_default_constructible<_Tp>, _Dummy>...>\n       >::value\n    >::type>\n    _LIBCPP_INLINE_VISIBILITY\n    tuple(_AllocArgT, _Alloc const& __a)\n      : base_(allocator_arg_t(), __a,\n                    __tuple_indices<>(), __tuple_types<>(),\n                    typename __make_tuple_indices<sizeof...(_Tp), 0>::type(),\n                    __tuple_types<_Tp...>()) {}\n\n    template <bool _Dummy = true,\n              typename enable_if\n                      <\n                         _CheckArgsConstructor<\n                            _Dummy\n                         >::template __enable_implicit<_Tp const&...>(),\n                         bool\n                      >::type = false\n        >\n    _LIBCPP_INLINE_VISIBILITY _LIBCPP_CONSTEXPR_AFTER_CXX11\n    tuple(const _Tp& ... __t) _NOEXCEPT_((__all<is_nothrow_copy_constructible<_Tp>::value...>::value))\n        : base_(typename __make_tuple_indices<sizeof...(_Tp)>::type(),\n                typename __make_tuple_types<tuple, sizeof...(_Tp)>::type(),\n                typename __make_tuple_indices<0>::type(),\n                typename __make_tuple_types<tuple, 0>::type(),\n                __t...\n               ) {}\n\n    template <bool _Dummy = true,\n              typename enable_if\n                      <\n                         _CheckArgsConstructor<\n                            _Dummy\n                         >::template __enable_explicit<_Tp const&...>(),\n                         bool\n                      >::type = false\n        >\n    _LIBCPP_INLINE_VISIBILITY _LIBCPP_CONSTEXPR_AFTER_CXX11\n    explicit tuple(const _Tp& ... __t) _NOEXCEPT_((__all<is_nothrow_copy_constructible<_Tp>::value...>::value))\n        : base_(typename __make_tuple_indices<sizeof...(_Tp)>::type(),\n                typename __make_tuple_types<tuple, sizeof...(_Tp)>::type(),\n                typename __make_tuple_indices<0>::type(),\n                typename __make_tuple_types<tuple, 0>::type(),\n                __t...\n               ) {}\n\n    template <class _Alloc, bool _Dummy = true,\n              typename enable_if\n                      <\n                         _CheckArgsConstructor<\n                            _Dummy\n                         >::template __enable_implicit<_Tp const&...>(),\n                         bool\n                      >::type = false\n        >\n      _LIBCPP_INLINE_VISIBILITY\n      tuple(allocator_arg_t, const _Alloc& __a, const _Tp& ... __t)\n        : base_(allocator_arg_t(), __a,\n                typename __make_tuple_indices<sizeof...(_Tp)>::type(),\n                typename __make_tuple_types<tuple, sizeof...(_Tp)>::type(),\n                typename __make_tuple_indices<0>::type(),\n                typename __make_tuple_types<tuple, 0>::type(),\n                __t...\n               ) {}\n\n    template <class _Alloc, bool _Dummy = true,\n              typename enable_if\n                      <\n                         _CheckArgsConstructor<\n                            _Dummy\n                         >::template __enable_explicit<_Tp const&...>(),\n                         bool\n                      >::type = false\n        >\n      _LIBCPP_INLINE_VISIBILITY\n      explicit\n      tuple(allocator_arg_t, const _Alloc& __a, const _Tp& ... __t)\n        : base_(allocator_arg_t(), __a,\n                typename __make_tuple_indices<sizeof...(_Tp)>::type(),\n                typename __make_tuple_types<tuple, sizeof...(_Tp)>::type(),\n                typename __make_tuple_indices<0>::type(),\n                typename __make_tuple_types<tuple, 0>::type(),\n                __t...\n               ) {}\n\n    template <class ..._Up,\n              bool _PackIsTuple = _PackExpandsToThisTuple<_Up...>::value,\n              typename enable_if\n                      <\n                         _CheckArgsConstructor<\n                             sizeof...(_Up) == sizeof...(_Tp)\n                             && !_PackIsTuple\n                         >::template __enable_implicit<_Up...>() ||\n                        _CheckArgsConstructor<\n                            _EnableImplicitReducedArityExtension\n                            && sizeof...(_Up) < sizeof...(_Tp)\n                            && !_PackIsTuple\n                         >::template __enable_implicit<_Up...>(),\n                         bool\n                      >::type = false\n             >\n        _LIBCPP_INLINE_VISIBILITY _LIBCPP_CONSTEXPR_AFTER_CXX11\n        tuple(_Up&&... __u)\n            _NOEXCEPT_((\n                is_nothrow_constructible<base,\n                    typename __make_tuple_indices<sizeof...(_Up)>::type,\n                    typename __make_tuple_types<tuple, sizeof...(_Up)>::type,\n                    typename __make_tuple_indices<sizeof...(_Tp), sizeof...(_Up)>::type,\n                    typename __make_tuple_types<tuple, sizeof...(_Tp), sizeof...(_Up)>::type,\n                    _Up...\n                >::value\n            ))\n            : base_(typename __make_tuple_indices<sizeof...(_Up)>::type(),\n                    typename __make_tuple_types<tuple, sizeof...(_Up)>::type(),\n                    typename __make_tuple_indices<sizeof...(_Tp), sizeof...(_Up)>::type(),\n                    typename __make_tuple_types<tuple, sizeof...(_Tp), sizeof...(_Up)>::type(),\n                    _VSTD::forward<_Up>(__u)...) {}\n\n    template <class ..._Up,\n              typename enable_if\n                      <\n                         _CheckArgsConstructor<\n                             sizeof...(_Up) <= sizeof...(_Tp)\n                             && !_PackExpandsToThisTuple<_Up...>::value\n                         >::template __enable_explicit<_Up...>() ||\n                         _CheckArgsConstructor<\n                            !_EnableImplicitReducedArityExtension\n                            && sizeof...(_Up) < sizeof...(_Tp)\n                            && !_PackExpandsToThisTuple<_Up...>()\n                         >::template __enable_implicit<_Up...>(),\n                         bool\n                      >::type = false\n             >\n        _LIBCPP_INLINE_VISIBILITY _LIBCPP_CONSTEXPR_AFTER_CXX11\n        explicit\n        tuple(_Up&&... __u)\n            _NOEXCEPT_((\n                is_nothrow_constructible<base,\n                    typename __make_tuple_indices<sizeof...(_Up)>::type,\n                    typename __make_tuple_types<tuple, sizeof...(_Up)>::type,\n                    typename __make_tuple_indices<sizeof...(_Tp), sizeof...(_Up)>::type,\n                    typename __make_tuple_types<tuple, sizeof...(_Tp), sizeof...(_Up)>::type,\n                    _Up...\n                >::value\n            ))\n            : base_(typename __make_tuple_indices<sizeof...(_Up)>::type(),\n                    typename __make_tuple_types<tuple, sizeof...(_Up)>::type(),\n                    typename __make_tuple_indices<sizeof...(_Tp), sizeof...(_Up)>::type(),\n                    typename __make_tuple_types<tuple, sizeof...(_Tp), sizeof...(_Up)>::type(),\n                    _VSTD::forward<_Up>(__u)...) {}\n\n    template <class _Alloc, class ..._Up,\n              typename enable_if\n                      <\n                         _CheckArgsConstructor<\n                             sizeof...(_Up) == sizeof...(_Tp) &&\n                             !_PackExpandsToThisTuple<_Up...>::value\n                         >::template __enable_implicit<_Up...>(),\n                         bool\n                      >::type = false\n             >\n        _LIBCPP_INLINE_VISIBILITY\n        tuple(allocator_arg_t, const _Alloc& __a, _Up&&... __u)\n            : base_(allocator_arg_t(), __a,\n                    typename __make_tuple_indices<sizeof...(_Up)>::type(),\n                    typename __make_tuple_types<tuple, sizeof...(_Up)>::type(),\n                    typename __make_tuple_indices<sizeof...(_Tp), sizeof...(_Up)>::type(),\n                    typename __make_tuple_types<tuple, sizeof...(_Tp), sizeof...(_Up)>::type(),\n                    _VSTD::forward<_Up>(__u)...) {}\n\n    template <class _Alloc, class ..._Up,\n              typename enable_if\n                      <\n                         _CheckArgsConstructor<\n                             sizeof...(_Up) == sizeof...(_Tp) &&\n                             !_PackExpandsToThisTuple<_Up...>::value\n                         >::template __enable_explicit<_Up...>(),\n                         bool\n                      >::type = false\n             >\n        _LIBCPP_INLINE_VISIBILITY\n        explicit\n        tuple(allocator_arg_t, const _Alloc& __a, _Up&&... __u)\n            : base_(allocator_arg_t(), __a,\n                    typename __make_tuple_indices<sizeof...(_Up)>::type(),\n                    typename __make_tuple_types<tuple, sizeof...(_Up)>::type(),\n                    typename __make_tuple_indices<sizeof...(_Tp), sizeof...(_Up)>::type(),\n                    typename __make_tuple_types<tuple, sizeof...(_Tp), sizeof...(_Up)>::type(),\n                    _VSTD::forward<_Up>(__u)...) {}\n\n    template <class _Tuple,\n              typename enable_if\n                      <\n                         _CheckTupleLikeConstructor<\n                             __tuple_like_with_size<_Tuple, sizeof...(_Tp)>::value\n                             && !_PackExpandsToThisTuple<_Tuple>::value\n                         >::template __enable_implicit<_Tuple>(),\n                         bool\n                      >::type = false\n             >\n        _LIBCPP_INLINE_VISIBILITY _LIBCPP_CONSTEXPR_AFTER_CXX11\n        tuple(_Tuple&& __t) _NOEXCEPT_((is_nothrow_constructible<base, _Tuple>::value))\n            : base_(_VSTD::forward<_Tuple>(__t)) {}\n\n    template <class _Tuple,\n              typename enable_if\n                      <\n                         _CheckTupleLikeConstructor<\n                             __tuple_like_with_size<_Tuple, sizeof...(_Tp)>::value\n                             && !_PackExpandsToThisTuple<_Tuple>::value\n                         >::template __enable_explicit<_Tuple>(),\n                         bool\n                      >::type = false\n             >\n        _LIBCPP_INLINE_VISIBILITY _LIBCPP_CONSTEXPR_AFTER_CXX11\n        explicit\n        tuple(_Tuple&& __t) _NOEXCEPT_((is_nothrow_constructible<base, _Tuple>::value))\n            : base_(_VSTD::forward<_Tuple>(__t)) {}\n\n    template <class _Alloc, class _Tuple,\n              typename enable_if\n                      <\n                         _CheckTupleLikeConstructor<\n                             __tuple_like_with_size<_Tuple, sizeof...(_Tp)>::value\n                         >::template __enable_implicit<_Tuple>(),\n                         bool\n                      >::type = false\n             >\n        _LIBCPP_INLINE_VISIBILITY\n        tuple(allocator_arg_t, const _Alloc& __a, _Tuple&& __t)\n            : base_(allocator_arg_t(), __a, _VSTD::forward<_Tuple>(__t)) {}\n\n    template <class _Alloc, class _Tuple,\n              typename enable_if\n                      <\n                         _CheckTupleLikeConstructor<\n                             __tuple_like_with_size<_Tuple, sizeof...(_Tp)>::value\n                         >::template __enable_explicit<_Tuple>(),\n                         bool\n                      >::type = false\n             >\n        _LIBCPP_INLINE_VISIBILITY\n        explicit\n        tuple(allocator_arg_t, const _Alloc& __a, _Tuple&& __t)\n            : base_(allocator_arg_t(), __a, _VSTD::forward<_Tuple>(__t)) {}\n\n    using _CanCopyAssign = __all<is_copy_assignable<_Tp>::value...>;\n    using _CanMoveAssign = __all<is_move_assignable<_Tp>::value...>;\n\n    _LIBCPP_INLINE_VISIBILITY\n    tuple& operator=(typename conditional<_CanCopyAssign::value, tuple, __nat>::type const& __t)\n        _NOEXCEPT_((__all<is_nothrow_copy_assignable<_Tp>::value...>::value))\n    {\n        base_.operator=(__t.base_);\n        return *this;\n    }\n\n    _LIBCPP_INLINE_VISIBILITY\n    tuple& operator=(typename conditional<_CanMoveAssign::value, tuple, __nat>::type&& __t)\n        _NOEXCEPT_((__all<is_nothrow_move_assignable<_Tp>::value...>::value))\n    {\n        base_.operator=(static_cast<base&&>(__t.base_));\n        return *this;\n    }\n\n    template <class _Tuple,\n              class = typename enable_if\n                      <\n                         __tuple_assignable<_Tuple, tuple>::value\n                      >::type\n             >\n        _LIBCPP_INLINE_VISIBILITY\n        tuple&\n        operator=(_Tuple&& __t) _NOEXCEPT_((is_nothrow_assignable<base&, _Tuple>::value))\n        {\n            base_.operator=(_VSTD::forward<_Tuple>(__t));\n            return *this;\n        }\n\n    _LIBCPP_INLINE_VISIBILITY\n    void swap(tuple& __t) _NOEXCEPT_(__all<__is_nothrow_swappable<_Tp>::value...>::value)\n        {base_.swap(__t.base_);}\n};\n\ntemplate <>\nclass _LIBCPP_TEMPLATE_VIS tuple<>\n{\npublic:\n    _LIBCPP_INLINE_VISIBILITY\n    _LIBCPP_CONSTEXPR tuple() _NOEXCEPT {}\n    template <class _Alloc>\n    _LIBCPP_INLINE_VISIBILITY\n        tuple(allocator_arg_t, const _Alloc&) _NOEXCEPT {}\n    template <class _Alloc>\n    _LIBCPP_INLINE_VISIBILITY\n        tuple(allocator_arg_t, const _Alloc&, const tuple&) _NOEXCEPT {}\n    template <class _Up>\n    _LIBCPP_INLINE_VISIBILITY\n        tuple(array<_Up, 0>) _NOEXCEPT {}\n    template <class _Alloc, class _Up>\n    _LIBCPP_INLINE_VISIBILITY\n        tuple(allocator_arg_t, const _Alloc&, array<_Up, 0>) _NOEXCEPT {}\n    _LIBCPP_INLINE_VISIBILITY\n    void swap(tuple&) _NOEXCEPT {}\n};\n\ntemplate <class ..._Tp>\ninline _LIBCPP_INLINE_VISIBILITY\ntypename enable_if\n<\n    __all<__is_swappable<_Tp>::value...>::value,\n    void\n>::type\nswap(tuple<_Tp...>& __t, tuple<_Tp...>& __u)\n                 _NOEXCEPT_(__all<__is_nothrow_swappable<_Tp>::value...>::value)\n    {__t.swap(__u);}\n\n// get\n\ntemplate <size_t _Ip, class ..._Tp>\ninline _LIBCPP_INLINE_VISIBILITY _LIBCPP_CONSTEXPR_AFTER_CXX11\ntypename tuple_element<_Ip, tuple<_Tp...> >::type&\nget(tuple<_Tp...>& __t) _NOEXCEPT\n{\n    typedef typename tuple_element<_Ip, tuple<_Tp...> >::type type;\n    return static_cast<__tuple_leaf<_Ip, type>&>(__t.base_).get();\n}\n\ntemplate <size_t _Ip, class ..._Tp>\ninline _LIBCPP_INLINE_VISIBILITY _LIBCPP_CONSTEXPR_AFTER_CXX11\nconst typename tuple_element<_Ip, tuple<_Tp...> >::type&\nget(const tuple<_Tp...>& __t) _NOEXCEPT\n{\n    typedef typename tuple_element<_Ip, tuple<_Tp...> >::type type;\n    return static_cast<const __tuple_leaf<_Ip, type>&>(__t.base_).get();\n}\n\ntemplate <size_t _Ip, class ..._Tp>\ninline _LIBCPP_INLINE_VISIBILITY _LIBCPP_CONSTEXPR_AFTER_CXX11\ntypename tuple_element<_Ip, tuple<_Tp...> >::type&&\nget(tuple<_Tp...>&& __t) _NOEXCEPT\n{\n    typedef typename tuple_element<_Ip, tuple<_Tp...> >::type type;\n    return static_cast<type&&>(\n             static_cast<__tuple_leaf<_Ip, type>&&>(__t.base_).get());\n}\n\ntemplate <size_t _Ip, class ..._Tp>\ninline _LIBCPP_INLINE_VISIBILITY _LIBCPP_CONSTEXPR_AFTER_CXX11\nconst typename tuple_element<_Ip, tuple<_Tp...> >::type&&\nget(const tuple<_Tp...>&& __t) _NOEXCEPT\n{\n    typedef typename tuple_element<_Ip, tuple<_Tp...> >::type type;\n    return static_cast<const type&&>(\n             static_cast<const __tuple_leaf<_Ip, type>&&>(__t.base_).get());\n}\n\n#if _LIBCPP_STD_VER > 11\n\nnamespace __find_detail {\n\nstatic constexpr size_t __not_found = -1;\nstatic constexpr size_t __ambiguous = __not_found - 1;\n\ninline _LIBCPP_INLINE_VISIBILITY\nconstexpr size_t __find_idx_return(size_t __curr_i, size_t __res, bool __matches) {\n    return !__matches ? __res :\n        (__res == __not_found ? __curr_i : __ambiguous);\n}\n\ntemplate <size_t _Nx>\ninline _LIBCPP_INLINE_VISIBILITY\nconstexpr size_t __find_idx(size_t __i, const bool (&__matches)[_Nx]) {\n  return __i == _Nx ? __not_found :\n      __find_idx_return(__i, __find_idx(__i + 1, __matches), __matches[__i]);\n}\n\ntemplate <class _T1, class ..._Args>\nstruct __find_exactly_one_checked {\n  static constexpr bool __matches[] = {is_same<_T1, _Args>::value...};\n    static constexpr size_t value = __find_detail::__find_idx(0, __matches);\n    static_assert (value != __not_found, \"type not found in type list\" );\n    static_assert(value != __ambiguous,\"type occurs more than once in type list\");\n};\n\ntemplate <class _T1>\nstruct __find_exactly_one_checked<_T1> {\n    static_assert(!is_same<_T1, _T1>::value, \"type not in empty type list\");\n};\n\n} // namespace __find_detail;\n\ntemplate <typename _T1, typename... _Args>\nstruct __find_exactly_one_t\n    : public __find_detail::__find_exactly_one_checked<_T1, _Args...> {\n};\n\ntemplate <class _T1, class... _Args>\ninline _LIBCPP_INLINE_VISIBILITY\nconstexpr _T1& get(tuple<_Args...>& __tup) noexcept\n{\n    return _VSTD::get<__find_exactly_one_t<_T1, _Args...>::value>(__tup);\n}\n\ntemplate <class _T1, class... _Args>\ninline _LIBCPP_INLINE_VISIBILITY\nconstexpr _T1 const& get(tuple<_Args...> const& __tup) noexcept\n{\n    return _VSTD::get<__find_exactly_one_t<_T1, _Args...>::value>(__tup);\n}\n\ntemplate <class _T1, class... _Args>\ninline _LIBCPP_INLINE_VISIBILITY\nconstexpr _T1&& get(tuple<_Args...>&& __tup) noexcept\n{\n    return _VSTD::get<__find_exactly_one_t<_T1, _Args...>::value>(_VSTD::move(__tup));\n}\n\ntemplate <class _T1, class... _Args>\ninline _LIBCPP_INLINE_VISIBILITY\nconstexpr _T1 const&& get(tuple<_Args...> const&& __tup) noexcept\n{\n    return _VSTD::get<__find_exactly_one_t<_T1, _Args...>::value>(_VSTD::move(__tup));\n}\n\n#endif\n\n// tie\n\ntemplate <class ..._Tp>\ninline _LIBCPP_INLINE_VISIBILITY _LIBCPP_CONSTEXPR_AFTER_CXX11\ntuple<_Tp&...>\ntie(_Tp&... __t) _NOEXCEPT\n{\n    return tuple<_Tp&...>(__t...);\n}\n\ntemplate <class _Up>\nstruct __ignore_t\n{\n    template <class _Tp>\n        _LIBCPP_INLINE_VISIBILITY\n        const __ignore_t& operator=(_Tp&&) const {return *this;}\n};\n\nnamespace { const __ignore_t<unsigned char> ignore = __ignore_t<unsigned char>(); }\n\ntemplate <class _Tp>\nstruct __make_tuple_return_impl\n{\n    typedef _Tp type;\n};\n\ntemplate <class _Tp>\nstruct __make_tuple_return_impl<reference_wrapper<_Tp> >\n{\n    typedef _Tp& type;\n};\n\ntemplate <class _Tp>\nstruct __make_tuple_return\n{\n    typedef typename __make_tuple_return_impl<typename decay<_Tp>::type>::type type;\n};\n\ntemplate <class... _Tp>\ninline _LIBCPP_INLINE_VISIBILITY _LIBCPP_CONSTEXPR_AFTER_CXX11\ntuple<typename __make_tuple_return<_Tp>::type...>\nmake_tuple(_Tp&&... __t)\n{\n    return tuple<typename __make_tuple_return<_Tp>::type...>(_VSTD::forward<_Tp>(__t)...);\n}\n\ntemplate <class... _Tp>\ninline _LIBCPP_INLINE_VISIBILITY _LIBCPP_CONSTEXPR_AFTER_CXX11\ntuple<_Tp&&...>\nforward_as_tuple(_Tp&&... __t) _NOEXCEPT\n{\n    return tuple<_Tp&&...>(_VSTD::forward<_Tp>(__t)...);\n}\n\ntemplate <size_t _Ip>\nstruct __tuple_equal\n{\n    template <class _Tp, class _Up>\n    _LIBCPP_INLINE_VISIBILITY _LIBCPP_CONSTEXPR_AFTER_CXX11\n    bool operator()(const _Tp& __x, const _Up& __y)\n    {\n        return __tuple_equal<_Ip - 1>()(__x, __y) && _VSTD::get<_Ip-1>(__x) == _VSTD::get<_Ip-1>(__y);\n    }\n};\n\ntemplate <>\nstruct __tuple_equal<0>\n{\n    template <class _Tp, class _Up>\n    _LIBCPP_INLINE_VISIBILITY _LIBCPP_CONSTEXPR_AFTER_CXX11\n    bool operator()(const _Tp&, const _Up&)\n    {\n        return true;\n    }\n};\n\ntemplate <class ..._Tp, class ..._Up>\ninline _LIBCPP_INLINE_VISIBILITY _LIBCPP_CONSTEXPR_AFTER_CXX11\nbool\noperator==(const tuple<_Tp...>& __x, const tuple<_Up...>& __y)\n{\n    return __tuple_equal<sizeof...(_Tp)>()(__x, __y);\n}\n\ntemplate <class ..._Tp, class ..._Up>\ninline _LIBCPP_INLINE_VISIBILITY _LIBCPP_CONSTEXPR_AFTER_CXX11\nbool\noperator!=(const tuple<_Tp...>& __x, const tuple<_Up...>& __y)\n{\n    return !(__x == __y);\n}\n\ntemplate <size_t _Ip>\nstruct __tuple_less\n{\n    template <class _Tp, class _Up>\n    _LIBCPP_INLINE_VISIBILITY _LIBCPP_CONSTEXPR_AFTER_CXX11\n    bool operator()(const _Tp& __x, const _Up& __y)\n    {\n        const size_t __idx = tuple_size<_Tp>::value - _Ip;\n        if (_VSTD::get<__idx>(__x) < _VSTD::get<__idx>(__y))\n            return true;\n        if (_VSTD::get<__idx>(__y) < _VSTD::get<__idx>(__x))\n            return false;\n        return __tuple_less<_Ip-1>()(__x, __y);\n    }\n};\n\ntemplate <>\nstruct __tuple_less<0>\n{\n    template <class _Tp, class _Up>\n    _LIBCPP_INLINE_VISIBILITY _LIBCPP_CONSTEXPR_AFTER_CXX11\n    bool operator()(const _Tp&, const _Up&)\n    {\n        return false;\n    }\n};\n\ntemplate <class ..._Tp, class ..._Up>\ninline _LIBCPP_INLINE_VISIBILITY _LIBCPP_CONSTEXPR_AFTER_CXX11\nbool\noperator<(const tuple<_Tp...>& __x, const tuple<_Up...>& __y)\n{\n    return __tuple_less<sizeof...(_Tp)>()(__x, __y);\n}\n\ntemplate <class ..._Tp, class ..._Up>\ninline _LIBCPP_INLINE_VISIBILITY _LIBCPP_CONSTEXPR_AFTER_CXX11\nbool\noperator>(const tuple<_Tp...>& __x, const tuple<_Up...>& __y)\n{\n    return __y < __x;\n}\n\ntemplate <class ..._Tp, class ..._Up>\ninline _LIBCPP_INLINE_VISIBILITY _LIBCPP_CONSTEXPR_AFTER_CXX11\nbool\noperator>=(const tuple<_Tp...>& __x, const tuple<_Up...>& __y)\n{\n    return !(__x < __y);\n}\n\ntemplate <class ..._Tp, class ..._Up>\ninline _LIBCPP_INLINE_VISIBILITY _LIBCPP_CONSTEXPR_AFTER_CXX11\nbool\noperator<=(const tuple<_Tp...>& __x, const tuple<_Up...>& __y)\n{\n    return !(__y < __x);\n}\n\n// tuple_cat\n\ntemplate <class _Tp, class _Up> struct __tuple_cat_type;\n\ntemplate <class ..._Ttypes, class ..._Utypes>\nstruct __tuple_cat_type<tuple<_Ttypes...>, __tuple_types<_Utypes...> >\n{\n    typedef tuple<_Ttypes..., _Utypes...> type;\n};\n\ntemplate <class _ResultTuple, bool _Is_Tuple0TupleLike, class ..._Tuples>\nstruct __tuple_cat_return_1\n{\n};\n\ntemplate <class ..._Types, class _Tuple0>\nstruct __tuple_cat_return_1<tuple<_Types...>, true, _Tuple0>\n{\n    typedef typename __tuple_cat_type<tuple<_Types...>,\n            typename __make_tuple_types<typename remove_reference<_Tuple0>::type>::type>::type\n                                                                           type;\n};\n\ntemplate <class ..._Types, class _Tuple0, class _Tuple1, class ..._Tuples>\nstruct __tuple_cat_return_1<tuple<_Types...>, true, _Tuple0, _Tuple1, _Tuples...>\n    : public __tuple_cat_return_1<\n                 typename __tuple_cat_type<\n                     tuple<_Types...>,\n                     typename __make_tuple_types<typename remove_reference<_Tuple0>::type>::type\n                 >::type,\n                 __tuple_like<typename remove_reference<_Tuple1>::type>::value,\n                 _Tuple1, _Tuples...>\n{\n};\n\ntemplate <class ..._Tuples> struct __tuple_cat_return;\n\ntemplate <class _Tuple0, class ..._Tuples>\nstruct __tuple_cat_return<_Tuple0, _Tuples...>\n    : public __tuple_cat_return_1<tuple<>,\n         __tuple_like<typename remove_reference<_Tuple0>::type>::value, _Tuple0,\n                                                                     _Tuples...>\n{\n};\n\ntemplate <>\nstruct __tuple_cat_return<>\n{\n    typedef tuple<> type;\n};\n\ninline _LIBCPP_INLINE_VISIBILITY _LIBCPP_CONSTEXPR_AFTER_CXX11\ntuple<>\ntuple_cat()\n{\n    return tuple<>();\n}\n\ntemplate <class _Rp, class _Indices, class _Tuple0, class ..._Tuples>\nstruct __tuple_cat_return_ref_imp;\n\ntemplate <class ..._Types, size_t ..._I0, class _Tuple0>\nstruct __tuple_cat_return_ref_imp<tuple<_Types...>, __tuple_indices<_I0...>, _Tuple0>\n{\n    typedef typename remove_reference<_Tuple0>::type _T0;\n    typedef tuple<_Types..., typename __apply_cv<_Tuple0,\n                          typename tuple_element<_I0, _T0>::type>::type&&...> type;\n};\n\ntemplate <class ..._Types, size_t ..._I0, class _Tuple0, class _Tuple1, class ..._Tuples>\nstruct __tuple_cat_return_ref_imp<tuple<_Types...>, __tuple_indices<_I0...>,\n                                  _Tuple0, _Tuple1, _Tuples...>\n    : public __tuple_cat_return_ref_imp<\n         tuple<_Types..., typename __apply_cv<_Tuple0,\n               typename tuple_element<_I0,\n                  typename remove_reference<_Tuple0>::type>::type>::type&&...>,\n         typename __make_tuple_indices<tuple_size<typename\n                                 remove_reference<_Tuple1>::type>::value>::type,\n         _Tuple1, _Tuples...>\n{\n};\n\ntemplate <class _Tuple0, class ..._Tuples>\nstruct __tuple_cat_return_ref\n    : public __tuple_cat_return_ref_imp<tuple<>,\n               typename __make_tuple_indices<\n                        tuple_size<typename remove_reference<_Tuple0>::type>::value\n               >::type, _Tuple0, _Tuples...>\n{\n};\n\ntemplate <class _Types, class _I0, class _J0>\nstruct __tuple_cat;\n\ntemplate <class ..._Types, size_t ..._I0, size_t ..._J0>\nstruct __tuple_cat<tuple<_Types...>, __tuple_indices<_I0...>, __tuple_indices<_J0...> >\n{\n    template <class _Tuple0>\n    _LIBCPP_INLINE_VISIBILITY _LIBCPP_CONSTEXPR_AFTER_CXX11\n    typename __tuple_cat_return_ref<tuple<_Types...>&&, _Tuple0&&>::type\n    operator()(tuple<_Types...> __t, _Tuple0&& __t0)\n    {\n        return forward_as_tuple(_VSTD::forward<_Types>(_VSTD::get<_I0>(__t))...,\n                                      _VSTD::get<_J0>(_VSTD::forward<_Tuple0>(__t0))...);\n    }\n\n    template <class _Tuple0, class _Tuple1, class ..._Tuples>\n    _LIBCPP_INLINE_VISIBILITY _LIBCPP_CONSTEXPR_AFTER_CXX11\n    typename __tuple_cat_return_ref<tuple<_Types...>&&, _Tuple0&&, _Tuple1&&, _Tuples&&...>::type\n    operator()(tuple<_Types...> __t, _Tuple0&& __t0, _Tuple1&& __t1, _Tuples&& ...__tpls)\n    {\n        typedef typename remove_reference<_Tuple0>::type _T0;\n        typedef typename remove_reference<_Tuple1>::type _T1;\n        return __tuple_cat<\n           tuple<_Types..., typename __apply_cv<_Tuple0, typename tuple_element<_J0, _T0>::type>::type&&...>,\n           typename __make_tuple_indices<sizeof ...(_Types) + tuple_size<_T0>::value>::type,\n           typename __make_tuple_indices<tuple_size<_T1>::value>::type>()\n                           (forward_as_tuple(\n                              _VSTD::forward<_Types>(_VSTD::get<_I0>(__t))...,\n                              _VSTD::get<_J0>(_VSTD::forward<_Tuple0>(__t0))...\n                            ),\n                            _VSTD::forward<_Tuple1>(__t1),\n                            _VSTD::forward<_Tuples>(__tpls)...);\n    }\n};\n\ntemplate <class _Tuple0, class... _Tuples>\ninline _LIBCPP_INLINE_VISIBILITY _LIBCPP_CONSTEXPR_AFTER_CXX11\ntypename __tuple_cat_return<_Tuple0, _Tuples...>::type\ntuple_cat(_Tuple0&& __t0, _Tuples&&... __tpls)\n{\n    typedef typename remove_reference<_Tuple0>::type _T0;\n    return __tuple_cat<tuple<>, __tuple_indices<>,\n                  typename __make_tuple_indices<tuple_size<_T0>::value>::type>()\n                  (tuple<>(), _VSTD::forward<_Tuple0>(__t0),\n                                            _VSTD::forward<_Tuples>(__tpls)...);\n}\n\ntemplate <class ..._Tp, class _Alloc>\nstruct _LIBCPP_TEMPLATE_VIS uses_allocator<tuple<_Tp...>, _Alloc>\n    : true_type {};\n\n#endif // _LIBCPP_HAS_NO_VARIADICS\n\n#ifndef _LIBCPP_CXX03_LANG\ntemplate <class _T1, class _T2>\ntemplate <class... _Args1, class... _Args2, size_t ..._I1, size_t ..._I2>\ninline _LIBCPP_INLINE_VISIBILITY\npair<_T1, _T2>::pair(piecewise_construct_t,\n                     tuple<_Args1...>& __first_args, tuple<_Args2...>& __second_args,\n                     __tuple_indices<_I1...>, __tuple_indices<_I2...>)\n    :  first(_VSTD::forward<_Args1>(_VSTD::get<_I1>( __first_args))...),\n      second(_VSTD::forward<_Args2>(_VSTD::get<_I2>(__second_args))...)\n{\n}\n#endif // _LIBCPP_CXX03_LANG\n\n#if _LIBCPP_STD_VER > 14\ntemplate <class _Tp>\nconstexpr size_t tuple_size_v = tuple_size<_Tp>::value;\n\n#define _LIBCPP_NOEXCEPT_RETURN(...) noexcept(noexcept(__VA_ARGS__)) { return __VA_ARGS__; }\n\ntemplate <class _Fn, class _Tuple, size_t ..._Id>\ninline _LIBCPP_INLINE_VISIBILITY\nconstexpr decltype(auto) __apply_tuple_impl(_Fn && __f, _Tuple && __t,\n                                            __tuple_indices<_Id...>)\n_LIBCPP_NOEXCEPT_RETURN(\n    _VSTD::__invoke_constexpr(\n        _VSTD::forward<_Fn>(__f),\n        _VSTD::get<_Id>(_VSTD::forward<_Tuple>(__t))...)\n)\n\ntemplate <class _Fn, class _Tuple>\ninline _LIBCPP_INLINE_VISIBILITY\nconstexpr decltype(auto) apply(_Fn && __f, _Tuple && __t)\n_LIBCPP_NOEXCEPT_RETURN(\n    _VSTD::__apply_tuple_impl(\n        _VSTD::forward<_Fn>(__f), _VSTD::forward<_Tuple>(__t),\n        typename __make_tuple_indices<tuple_size_v<decay_t<_Tuple>>>::type{})\n)\n\ntemplate <class _Tp, class _Tuple, size_t... _Idx>\ninline _LIBCPP_INLINE_VISIBILITY\nconstexpr _Tp __make_from_tuple_impl(_Tuple&& __t, __tuple_indices<_Idx...>)\n_LIBCPP_NOEXCEPT_RETURN(\n    _Tp(_VSTD::get<_Idx>(_VSTD::forward<_Tuple>(__t))...)\n)\n\ntemplate <class _Tp, class _Tuple>\ninline _LIBCPP_INLINE_VISIBILITY\nconstexpr _Tp make_from_tuple(_Tuple&& __t)\n_LIBCPP_NOEXCEPT_RETURN(\n    _VSTD::__make_from_tuple_impl<_Tp>(_VSTD::forward<_Tuple>(__t),\n        typename __make_tuple_indices<tuple_size_v<decay_t<_Tuple>>>::type{})\n)\n\n#undef _LIBCPP_NOEXCEPT_RETURN\n\n#endif // _LIBCPP_STD_VER > 14\n\n_LIBCPP_END_NAMESPACE_STD\n\n#endif  // _LIBCPP_TUPLE\n","// -*- C++ -*-\n//===-------------------------- locale ------------------------------------===//\n//\n//                     The LLVM Compiler Infrastructure\n//\n// This file is dual licensed under the MIT and the University of Illinois Open\n// Source Licenses. See LICENSE.TXT for details.\n//\n//===----------------------------------------------------------------------===//\n\n#ifndef _LIBCPP_LOCALE\n#define _LIBCPP_LOCALE\n\n/*\n    locale synopsis\n\nnamespace std\n{\n\nclass locale\n{\npublic:\n    // types:\n    class facet;\n    class id;\n\n    typedef int category;\n    static const category // values assigned here are for exposition only\n        none     = 0x000,\n        collate  = 0x010,\n        ctype    = 0x020,\n        monetary = 0x040,\n        numeric  = 0x080,\n        time     = 0x100,\n        messages = 0x200,\n        all = collate | ctype | monetary | numeric | time | messages;\n\n    // construct/copy/destroy:\n    locale() noexcept;\n    locale(const locale& other) noexcept;\n    explicit locale(const char* std_name);\n    explicit locale(const string& std_name);\n    locale(const locale& other, const char* std_name, category);\n    locale(const locale& other, const string& std_name, category);\n    template <class Facet> locale(const locale& other, Facet* f);\n    locale(const locale& other, const locale& one, category);\n\n    ~locale(); // not virtual\n\n    const locale& operator=(const locale& other) noexcept;\n\n    template <class Facet> locale combine(const locale& other) const;\n\n    // locale operations:\n    basic_string<char> name() const;\n    bool operator==(const locale& other) const;\n    bool operator!=(const locale& other) const;\n    template <class charT, class Traits, class Allocator>\n      bool operator()(const basic_string<charT,Traits,Allocator>& s1,\n                      const basic_string<charT,Traits,Allocator>& s2) const;\n\n    // global locale objects:\n    static locale global(const locale&);\n    static const locale& classic();\n};\n\ntemplate <class Facet> const Facet& use_facet(const locale&);\ntemplate <class Facet> bool has_facet(const locale&) noexcept;\n\n// 22.3.3, convenience interfaces:\ntemplate <class charT> bool isspace (charT c, const locale& loc);\ntemplate <class charT> bool isprint (charT c, const locale& loc);\ntemplate <class charT> bool iscntrl (charT c, const locale& loc);\ntemplate <class charT> bool isupper (charT c, const locale& loc);\ntemplate <class charT> bool islower (charT c, const locale& loc);\ntemplate <class charT> bool isalpha (charT c, const locale& loc);\ntemplate <class charT> bool isdigit (charT c, const locale& loc);\ntemplate <class charT> bool ispunct (charT c, const locale& loc);\ntemplate <class charT> bool isxdigit(charT c, const locale& loc);\ntemplate <class charT> bool isalnum (charT c, const locale& loc);\ntemplate <class charT> bool isgraph (charT c, const locale& loc);\ntemplate <class charT> charT toupper(charT c, const locale& loc);\ntemplate <class charT> charT tolower(charT c, const locale& loc);\n\ntemplate<class Codecvt, class Elem = wchar_t,\n         class Wide_alloc = allocator<Elem>,\n         class Byte_alloc = allocator<char>>\nclass wstring_convert\n{\npublic:\n    typedef basic_string<char, char_traits<char>, Byte_alloc> byte_string;\n    typedef basic_string<Elem, char_traits<Elem>, Wide_alloc> wide_string;\n    typedef typename Codecvt::state_type                      state_type;\n    typedef typename wide_string::traits_type::int_type       int_type;\n\n    explicit wstring_convert(Codecvt* pcvt = new Codecvt);          // explicit in C++14\n    wstring_convert(Codecvt* pcvt, state_type state);\n    explicit wstring_convert(const byte_string& byte_err,           // explicit in C++14\n                    const wide_string& wide_err = wide_string());\n    wstring_convert(const wstring_convert&) = delete;               // C++14\n    wstring_convert & operator=(const wstring_convert &) = delete;  // C++14\n    ~wstring_convert();\n\n    wide_string from_bytes(char byte);\n    wide_string from_bytes(const char* ptr);\n    wide_string from_bytes(const byte_string& str);\n    wide_string from_bytes(const char* first, const char* last);\n\n    byte_string to_bytes(Elem wchar);\n    byte_string to_bytes(const Elem* wptr);\n    byte_string to_bytes(const wide_string& wstr);\n    byte_string to_bytes(const Elem* first, const Elem* last);\n\n    size_t converted() const; // noexcept in C++14\n    state_type state() const;\n};\n\ntemplate <class Codecvt, class Elem = wchar_t, class Tr = char_traits<Elem>>\nclass wbuffer_convert\n    : public basic_streambuf<Elem, Tr>\n{\npublic:\n    typedef typename Tr::state_type state_type;\n\n    explicit wbuffer_convert(streambuf* bytebuf = 0, Codecvt* pcvt = new Codecvt,\n                    state_type state = state_type());       // explicit in C++14\n    wbuffer_convert(const wbuffer_convert&) = delete;               // C++14\n    wbuffer_convert & operator=(const wbuffer_convert &) = delete;  // C++14\n    ~wbuffer_convert();                                             // C++14\n    \n    streambuf* rdbuf() const;\n    streambuf* rdbuf(streambuf* bytebuf);\n\n    state_type state() const;\n};\n\n// 22.4.1 and 22.4.1.3, ctype:\nclass ctype_base;\ntemplate <class charT> class ctype;\ntemplate <> class ctype<char>; // specialization\ntemplate <class charT> class ctype_byname;\ntemplate <> class ctype_byname<char>; // specialization\n\nclass codecvt_base;\ntemplate <class internT, class externT, class stateT> class codecvt;\ntemplate <class internT, class externT, class stateT> class codecvt_byname;\n\n// 22.4.2 and 22.4.3, numeric:\ntemplate <class charT, class InputIterator> class num_get;\ntemplate <class charT, class OutputIterator> class num_put;\ntemplate <class charT> class numpunct;\ntemplate <class charT> class numpunct_byname;\n\n// 22.4.4, col lation:\ntemplate <class charT> class collate;\ntemplate <class charT> class collate_byname;\n\n// 22.4.5, date and time:\nclass time_base;\ntemplate <class charT, class InputIterator> class time_get;\ntemplate <class charT, class InputIterator> class time_get_byname;\ntemplate <class charT, class OutputIterator> class time_put;\ntemplate <class charT, class OutputIterator> class time_put_byname;\n\n// 22.4.6, money:\nclass money_base;\ntemplate <class charT, class InputIterator> class money_get;\ntemplate <class charT, class OutputIterator> class money_put;\ntemplate <class charT, bool Intl> class moneypunct;\ntemplate <class charT, bool Intl> class moneypunct_byname;\n\n// 22.4.7, message retrieval:\nclass messages_base;\ntemplate <class charT> class messages;\ntemplate <class charT> class messages_byname;\n\n}  // std\n\n*/\n\n#include <__config>\n#include <__locale>\n#include <__debug>\n#include <algorithm>\n#include <memory>\n#include <ios>\n#include <streambuf>\n#include <iterator>\n#include <limits>\n#ifndef __APPLE__\n#include <cstdarg>\n#endif\n#include <cstdlib>\n#include <ctime>\n#if defined(_LIBCPP_MSVCRT) || defined(__MINGW32__)\n#include <support/win32/locale_win32.h>\n#elif defined(_NEWLIB_VERSION)\n// FIXME: replace all the uses of _NEWLIB_VERSION with __NEWLIB__ preceded by an\n// include of <sys/cdefs.h> once https://sourceware.org/ml/newlib-cvs/2014-q3/msg00038.html\n// has had a chance to bake for a bit\n#include <support/newlib/xlocale.h>\n#endif\n#ifdef _LIBCPP_HAS_CATOPEN\n#include <nl_types.h>\n#endif\n\n#ifdef __APPLE__\n#include <Availability.h>\n#endif\n\n#include <__undef_min_max>\n\n#if !defined(_LIBCPP_HAS_NO_PRAGMA_SYSTEM_HEADER)\n#pragma GCC system_header\n#endif\n\n#ifdef _LIBCPP_LOCALE__L_EXTENSIONS\n#include <__bsd_locale_defaults.h>\n#else\n#include <__bsd_locale_fallbacks.h>\n#endif\n\n_LIBCPP_BEGIN_NAMESPACE_STD\n\n#if defined(__APPLE__) || defined(__FreeBSD__)\n#  define _LIBCPP_GET_C_LOCALE 0\n#elif defined(__CloudABI__) || defined(__NetBSD__)\n#  define _LIBCPP_GET_C_LOCALE LC_C_LOCALE\n#else\n#  define _LIBCPP_GET_C_LOCALE __cloc()\n   // Get the C locale object\n   _LIBCPP_FUNC_VIS locale_t __cloc();\n#define __cloc_defined\n#endif\n\ntypedef _VSTD::remove_pointer<locale_t>::type __locale_struct;\ntypedef _VSTD::unique_ptr<__locale_struct, decltype(&freelocale)> __locale_unique_ptr;\n\n// __scan_keyword\n// Scans [__b, __e) until a match is found in the basic_strings range\n//  [__kb, __ke) or until it can be shown that there is no match in [__kb, __ke).\n//  __b will be incremented (visibly), consuming CharT until a match is found\n//  or proved to not exist.  A keyword may be \"\", in which will match anything.\n//  If one keyword is a prefix of another, and the next CharT in the input\n//  might match another keyword, the algorithm will attempt to find the longest\n//  matching keyword.  If the longer matching keyword ends up not matching, then\n//  no keyword match is found.  If no keyword match is found, __ke is returned\n//  and failbit is set in __err.\n//  Else an iterator pointing to the matching keyword is found.  If more than\n//  one keyword matches, an iterator to the first matching keyword is returned.\n//  If on exit __b == __e, eofbit is set in __err.  If __case_sensitive is false,\n//  __ct is used to force to lower case before comparing characters.\n//  Examples:\n//  Keywords:  \"a\", \"abb\"\n//  If the input is \"a\", the first keyword matches and eofbit is set.\n//  If the input is \"abc\", no match is found and \"ab\" are consumed.\ntemplate <class _InputIterator, class _ForwardIterator, class _Ctype>\n_LIBCPP_HIDDEN\n_ForwardIterator\n__scan_keyword(_InputIterator& __b, _InputIterator __e,\n               _ForwardIterator __kb, _ForwardIterator __ke,\n               const _Ctype& __ct, ios_base::iostate& __err,\n               bool __case_sensitive = true)\n{\n    typedef typename iterator_traits<_InputIterator>::value_type _CharT;\n    size_t __nkw = static_cast<size_t>(_VSTD::distance(__kb, __ke));\n    const unsigned char __doesnt_match = '\\0';\n    const unsigned char __might_match = '\\1';\n    const unsigned char __does_match = '\\2';\n    unsigned char __statbuf[100];\n    unsigned char* __status = __statbuf;\n    unique_ptr<unsigned char, void(*)(void*)> __stat_hold(0, free);\n    if (__nkw > sizeof(__statbuf))\n    {\n        __status = (unsigned char*)malloc(__nkw);\n        if (__status == 0)\n            __throw_bad_alloc();\n        __stat_hold.reset(__status);\n    }\n    size_t __n_might_match = __nkw;  // At this point, any keyword might match\n    size_t __n_does_match = 0;       // but none of them definitely do\n    // Initialize all statuses to __might_match, except for \"\" keywords are __does_match\n    unsigned char* __st = __status;\n    for (_ForwardIterator __ky = __kb; __ky != __ke; ++__ky, (void) ++__st)\n    {\n        if (!__ky->empty())\n            *__st = __might_match;\n        else\n        {\n            *__st = __does_match;\n            --__n_might_match;\n            ++__n_does_match;\n        }\n    }\n    // While there might be a match, test keywords against the next CharT\n    for (size_t __indx = 0; __b != __e && __n_might_match > 0; ++__indx)\n    {\n        // Peek at the next CharT but don't consume it\n        _CharT __c = *__b;\n        if (!__case_sensitive)\n            __c = __ct.toupper(__c);\n        bool __consume = false;\n        // For each keyword which might match, see if the __indx character is __c\n        // If a match if found, consume __c\n        // If a match is found, and that is the last character in the keyword,\n        //    then that keyword matches.\n        // If the keyword doesn't match this character, then change the keyword\n        //    to doesn't match\n        __st = __status;\n        for (_ForwardIterator __ky = __kb; __ky != __ke; ++__ky, (void) ++__st)\n        {\n            if (*__st == __might_match)\n            {\n                _CharT __kc = (*__ky)[__indx];\n                if (!__case_sensitive)\n                    __kc = __ct.toupper(__kc);\n                if (__c == __kc)\n                {\n                    __consume = true;\n                    if (__ky->size() == __indx+1)\n                    {\n                        *__st = __does_match;\n                        --__n_might_match;\n                        ++__n_does_match;\n                    }\n                }\n                else\n                {\n                    *__st = __doesnt_match;\n                    --__n_might_match;\n                }\n            }\n        }\n        // consume if we matched a character\n        if (__consume)\n        {\n            ++__b;\n            // If we consumed a character and there might be a matched keyword that\n            //   was marked matched on a previous iteration, then such keywords\n            //   which are now marked as not matching.\n            if (__n_might_match + __n_does_match > 1)\n            {\n                __st = __status;\n                for (_ForwardIterator __ky = __kb; __ky != __ke; ++__ky, (void) ++__st)\n                {\n                    if (*__st == __does_match && __ky->size() != __indx+1)\n                    {\n                        *__st = __doesnt_match;\n                        --__n_does_match;\n                    }\n                }\n            }\n        }\n    }\n    // We've exited the loop because we hit eof and/or we have no more \"might matches\".\n    if (__b == __e)\n        __err |= ios_base::eofbit;\n    // Return the first matching result\n    for (__st = __status; __kb != __ke; ++__kb, (void) ++__st)\n        if (*__st == __does_match)\n            break;\n    if (__kb == __ke)\n        __err |= ios_base::failbit;\n    return __kb;\n}\n\nstruct _LIBCPP_TYPE_VIS __num_get_base\n{\n    static const int __num_get_buf_sz = 40;\n\n    static int __get_base(ios_base&);\n    static const char __src[33];\n};\n\n_LIBCPP_FUNC_VIS\nvoid __check_grouping(const string& __grouping, unsigned* __g, unsigned* __g_end,\n                      ios_base::iostate& __err);\n\ntemplate <class _CharT>\nstruct __num_get\n    : protected __num_get_base\n{\n    static string __stage2_int_prep(ios_base& __iob, _CharT* __atoms, _CharT& __thousands_sep);\n    static string __stage2_float_prep(ios_base& __iob, _CharT* __atoms, _CharT& __decimal_point,\n                                      _CharT& __thousands_sep);\n    static int __stage2_int_loop(_CharT __ct, int __base, char* __a, char*& __a_end,\n                  unsigned& __dc, _CharT __thousands_sep, const string& __grouping,\n                  unsigned* __g, unsigned*& __g_end, _CharT* __atoms);\n    static int __stage2_float_loop(_CharT __ct, bool& __in_units, char& __exp,\n                                   char* __a, char*& __a_end,\n                                   _CharT __decimal_point, _CharT __thousands_sep,\n                                   const string& __grouping, unsigned* __g,\n                                   unsigned*& __g_end, unsigned& __dc, _CharT* __atoms);\n};\n\ntemplate <class _CharT>\nstring\n__num_get<_CharT>::__stage2_int_prep(ios_base& __iob, _CharT* __atoms, _CharT& __thousands_sep)\n{\n    locale __loc = __iob.getloc();\n    use_facet<ctype<_CharT> >(__loc).widen(__src, __src + 26, __atoms);\n    const numpunct<_CharT>& __np = use_facet<numpunct<_CharT> >(__loc);\n    __thousands_sep = __np.thousands_sep();\n    return __np.grouping();\n}\n\ntemplate <class _CharT>\nstring\n__num_get<_CharT>::__stage2_float_prep(ios_base& __iob, _CharT* __atoms, _CharT& __decimal_point,\n                    _CharT& __thousands_sep)\n{\n    locale __loc = __iob.getloc();\n    use_facet<ctype<_CharT> >(__loc).widen(__src, __src + 32, __atoms);\n    const numpunct<_CharT>& __np = use_facet<numpunct<_CharT> >(__loc);\n    __decimal_point = __np.decimal_point();\n    __thousands_sep = __np.thousands_sep();\n    return __np.grouping();\n}\n\ntemplate <class _CharT>\nint\n__num_get<_CharT>::__stage2_int_loop(_CharT __ct, int __base, char* __a, char*& __a_end,\n                  unsigned& __dc, _CharT __thousands_sep, const string& __grouping,\n                  unsigned* __g, unsigned*& __g_end, _CharT* __atoms)\n{\n    if (__a_end == __a && (__ct == __atoms[24] || __ct == __atoms[25]))\n    {\n        *__a_end++ = __ct == __atoms[24] ? '+' : '-';\n        __dc = 0;\n        return 0;\n    }\n    if (__grouping.size() != 0 && __ct == __thousands_sep)\n    {\n        if (__g_end-__g < __num_get_buf_sz)\n        {\n            *__g_end++ = __dc;\n            __dc = 0;\n        }\n        return 0;\n    }\n    ptrdiff_t __f = find(__atoms, __atoms + 26, __ct) - __atoms;\n    if (__f >= 24)\n        return -1;\n    switch (__base)\n    {\n    case 8:\n    case 10:\n        if (__f >= __base)\n            return -1;\n        break;\n    case 16:\n        if (__f < 22)\n            break;\n        if (__a_end != __a && __a_end - __a <= 2 && __a_end[-1] == '0')\n        {\n            __dc = 0;\n            *__a_end++ = __src[__f];\n            return 0;\n        }\n        return -1;\n    }\n    *__a_end++ = __src[__f];\n    ++__dc;\n    return 0;\n}\n\ntemplate <class _CharT>\nint\n__num_get<_CharT>::__stage2_float_loop(_CharT __ct, bool& __in_units, char& __exp, char* __a, char*& __a_end,\n                    _CharT __decimal_point, _CharT __thousands_sep, const string& __grouping,\n                    unsigned* __g, unsigned*& __g_end, unsigned& __dc, _CharT* __atoms)\n{\n    if (__ct == __decimal_point)\n    {\n        if (!__in_units)\n            return -1;\n        __in_units = false;\n        *__a_end++ = '.';\n        if (__grouping.size() != 0 && __g_end-__g < __num_get_buf_sz)\n            *__g_end++ = __dc;\n        return 0;\n    }\n    if (__ct == __thousands_sep && __grouping.size() != 0)\n    {\n        if (!__in_units)\n            return -1;\n        if (__g_end-__g < __num_get_buf_sz)\n        {\n            *__g_end++ = __dc;\n            __dc = 0;\n        }\n        return 0;\n    }\n    ptrdiff_t __f = find(__atoms, __atoms + 32, __ct) - __atoms;\n    if (__f >= 32)\n        return -1;\n    char __x = __src[__f];\n    if (__x == '-' || __x == '+')\n    {\n        if (__a_end == __a || (__a_end[-1] & 0x5F) == (__exp & 0x7F))\n        {\n            *__a_end++ = __x;\n            return 0;\n        }\n        return -1;\n    }\n    if (__x == 'x' || __x == 'X')\n        __exp = 'P';\n    else if ((__x & 0x5F) == __exp)\n    {\n        __exp |= 0x80;\n        if (__in_units)\n        {\n            __in_units = false;\n            if (__grouping.size() != 0 && __g_end-__g < __num_get_buf_sz)\n                *__g_end++ = __dc;\n        }\n    }\n    *__a_end++ = __x;\n    if (__f >= 22)\n        return 0;\n    ++__dc;\n    return 0;\n}\n\n_LIBCPP_EXTERN_TEMPLATE2(struct _LIBCPP_EXTERN_TEMPLATE_TYPE_VIS __num_get<char>)\n_LIBCPP_EXTERN_TEMPLATE2(struct _LIBCPP_EXTERN_TEMPLATE_TYPE_VIS __num_get<wchar_t>)\n\ntemplate <class _CharT, class _InputIterator = istreambuf_iterator<_CharT> >\nclass _LIBCPP_TEMPLATE_VIS num_get\n    : public locale::facet,\n      private __num_get<_CharT>\n{\npublic:\n    typedef _CharT char_type;\n    typedef _InputIterator iter_type;\n\n    _LIBCPP_ALWAYS_INLINE\n    explicit num_get(size_t __refs = 0)\n        : locale::facet(__refs) {}\n\n    _LIBCPP_ALWAYS_INLINE\n    iter_type get(iter_type __b, iter_type __e, ios_base& __iob,\n                  ios_base::iostate& __err, bool& __v) const\n    {\n        return do_get(__b, __e, __iob, __err, __v);\n    }\n\n    _LIBCPP_ALWAYS_INLINE\n    iter_type get(iter_type __b, iter_type __e, ios_base& __iob,\n                  ios_base::iostate& __err, long& __v) const\n    {\n        return do_get(__b, __e, __iob, __err, __v);\n    }\n\n    _LIBCPP_ALWAYS_INLINE\n    iter_type get(iter_type __b, iter_type __e, ios_base& __iob,\n                  ios_base::iostate& __err, long long& __v) const\n    {\n        return do_get(__b, __e, __iob, __err, __v);\n    }\n\n    _LIBCPP_ALWAYS_INLINE\n    iter_type get(iter_type __b, iter_type __e, ios_base& __iob,\n                  ios_base::iostate& __err, unsigned short& __v) const\n    {\n        return do_get(__b, __e, __iob, __err, __v);\n    }\n\n    _LIBCPP_ALWAYS_INLINE\n    iter_type get(iter_type __b, iter_type __e, ios_base& __iob,\n                  ios_base::iostate& __err, unsigned int& __v) const\n    {\n        return do_get(__b, __e, __iob, __err, __v);\n    }\n\n    _LIBCPP_ALWAYS_INLINE\n    iter_type get(iter_type __b, iter_type __e, ios_base& __iob,\n                  ios_base::iostate& __err, unsigned long& __v) const\n    {\n        return do_get(__b, __e, __iob, __err, __v);\n    }\n\n    _LIBCPP_ALWAYS_INLINE\n    iter_type get(iter_type __b, iter_type __e, ios_base& __iob,\n                  ios_base::iostate& __err, unsigned long long& __v) const\n    {\n        return do_get(__b, __e, __iob, __err, __v);\n    }\n\n    _LIBCPP_ALWAYS_INLINE\n    iter_type get(iter_type __b, iter_type __e, ios_base& __iob,\n                  ios_base::iostate& __err, float& __v) const\n    {\n        return do_get(__b, __e, __iob, __err, __v);\n    }\n\n    _LIBCPP_ALWAYS_INLINE\n    iter_type get(iter_type __b, iter_type __e, ios_base& __iob,\n                  ios_base::iostate& __err, double& __v) const\n    {\n        return do_get(__b, __e, __iob, __err, __v);\n    }\n\n    _LIBCPP_ALWAYS_INLINE\n    iter_type get(iter_type __b, iter_type __e, ios_base& __iob,\n                  ios_base::iostate& __err, long double& __v) const\n    {\n        return do_get(__b, __e, __iob, __err, __v);\n    }\n\n    _LIBCPP_ALWAYS_INLINE\n    iter_type get(iter_type __b, iter_type __e, ios_base& __iob,\n                  ios_base::iostate& __err, void*& __v) const\n    {\n        return do_get(__b, __e, __iob, __err, __v);\n    }\n\n    static locale::id id;\n\nprotected:\n    _LIBCPP_ALWAYS_INLINE\n    ~num_get() {}\n\n    template <class _Fp>\n    iter_type __do_get_floating_point\n                            (iter_type __b, iter_type __e, ios_base& __iob,\n                             ios_base::iostate& __err, _Fp& __v) const;\n\n    template <class _Signed>\n    iter_type __do_get_signed\n                            (iter_type __b, iter_type __e, ios_base& __iob,\n                             ios_base::iostate& __err, _Signed& __v) const;\n\n    template <class _Unsigned>\n    iter_type __do_get_unsigned\n                            (iter_type __b, iter_type __e, ios_base& __iob,\n                             ios_base::iostate& __err, _Unsigned& __v) const;\n\n\n    virtual iter_type do_get(iter_type __b, iter_type __e, ios_base& __iob,\n                             ios_base::iostate& __err, bool& __v) const;\n\n    virtual iter_type do_get(iter_type __b, iter_type __e, ios_base& __iob,\n                             ios_base::iostate& __err, long& __v) const\n    { return this->__do_get_signed ( __b, __e, __iob, __err, __v ); }\n\n    virtual iter_type do_get(iter_type __b, iter_type __e, ios_base& __iob,\n                             ios_base::iostate& __err, long long& __v) const\n    { return this->__do_get_signed ( __b, __e, __iob, __err, __v ); }\n\n    virtual iter_type do_get(iter_type __b, iter_type __e, ios_base& __iob,\n                             ios_base::iostate& __err, unsigned short& __v) const\n    { return this->__do_get_unsigned ( __b, __e, __iob, __err, __v ); }\n\n    virtual iter_type do_get(iter_type __b, iter_type __e, ios_base& __iob,\n                             ios_base::iostate& __err, unsigned int& __v) const\n    { return this->__do_get_unsigned ( __b, __e, __iob, __err, __v ); }\n\n    virtual iter_type do_get(iter_type __b, iter_type __e, ios_base& __iob,\n                             ios_base::iostate& __err, unsigned long& __v) const\n    { return this->__do_get_unsigned ( __b, __e, __iob, __err, __v ); }\n\n    virtual iter_type do_get(iter_type __b, iter_type __e, ios_base& __iob,\n                             ios_base::iostate& __err, unsigned long long& __v) const\n    { return this->__do_get_unsigned ( __b, __e, __iob, __err, __v ); }\n\n    virtual iter_type do_get(iter_type __b, iter_type __e, ios_base& __iob,\n                             ios_base::iostate& __err, float& __v) const\n    { return this->__do_get_floating_point ( __b, __e, __iob, __err, __v ); }\n\n    virtual iter_type do_get(iter_type __b, iter_type __e, ios_base& __iob,\n                             ios_base::iostate& __err, double& __v) const\n    { return this->__do_get_floating_point ( __b, __e, __iob, __err, __v ); }\n\n    virtual iter_type do_get(iter_type __b, iter_type __e, ios_base& __iob,\n                             ios_base::iostate& __err, long double& __v) const\n    { return this->__do_get_floating_point ( __b, __e, __iob, __err, __v ); }\n\n    virtual iter_type do_get(iter_type __b, iter_type __e, ios_base& __iob,\n                             ios_base::iostate& __err, void*& __v) const;\n};\n\ntemplate <class _CharT, class _InputIterator>\nlocale::id\nnum_get<_CharT, _InputIterator>::id;\n\ntemplate <class _Tp>\n_Tp\n__num_get_signed_integral(const char* __a, const char* __a_end,\n                          ios_base::iostate& __err, int __base)\n{\n    if (__a != __a_end)\n    {\n        typename remove_reference<decltype(errno)>::type __save_errno = errno;\n        errno = 0;\n        char *__p2;\n        long long __ll = strtoll_l(__a, &__p2, __base, _LIBCPP_GET_C_LOCALE);\n        typename remove_reference<decltype(errno)>::type __current_errno = errno;\n        if (__current_errno == 0)\n            errno = __save_errno;\n        if (__p2 != __a_end)\n        {\n            __err = ios_base::failbit;\n            return 0;\n        }\n        else if (__current_errno == ERANGE         ||\n                 __ll < numeric_limits<_Tp>::min() ||\n                 numeric_limits<_Tp>::max() < __ll)\n        {\n            __err = ios_base::failbit;\n            if (__ll > 0)\n                return numeric_limits<_Tp>::max();\n            else\n                return numeric_limits<_Tp>::min();\n        }\n        return static_cast<_Tp>(__ll);\n    }\n    __err = ios_base::failbit;\n    return 0;\n}\n\ntemplate <class _Tp>\n_Tp\n__num_get_unsigned_integral(const char* __a, const char* __a_end,\n                            ios_base::iostate& __err, int __base)\n{\n    if (__a != __a_end)\n    {\n        if (*__a == '-')\n        {\n            __err = ios_base::failbit;\n            return 0;\n        }\n        typename remove_reference<decltype(errno)>::type __save_errno = errno;\n        errno = 0;\n        char *__p2;\n        unsigned long long __ll = strtoull_l(__a, &__p2, __base, _LIBCPP_GET_C_LOCALE);\n        typename remove_reference<decltype(errno)>::type __current_errno = errno;\n        if (__current_errno == 0)\n            errno = __save_errno;\n        if (__p2 != __a_end)\n        {\n            __err = ios_base::failbit;\n            return 0;\n        }\n        else if (__current_errno == ERANGE ||\n                 numeric_limits<_Tp>::max() < __ll)\n        {\n            __err = ios_base::failbit;\n            return numeric_limits<_Tp>::max();\n        }\n        return static_cast<_Tp>(__ll);\n    }\n    __err = ios_base::failbit;\n    return 0;\n}\n\ntemplate <class _Tp>\n_LIBCPP_INLINE_VISIBILITY\n_Tp __do_strtod(const char* __a, char** __p2);\n\ntemplate <>\ninline _LIBCPP_INLINE_VISIBILITY\nfloat __do_strtod<float>(const char* __a, char** __p2) {\n    return strtof_l(__a, __p2, _LIBCPP_GET_C_LOCALE);\n}\n\ntemplate <>\ninline _LIBCPP_INLINE_VISIBILITY\ndouble __do_strtod<double>(const char* __a, char** __p2) {\n    return strtod_l(__a, __p2, _LIBCPP_GET_C_LOCALE);\n}\n\ntemplate <>\ninline _LIBCPP_INLINE_VISIBILITY\nlong double __do_strtod<long double>(const char* __a, char** __p2) {\n    return strtold_l(__a, __p2, _LIBCPP_GET_C_LOCALE);\n}\n\ntemplate <class _Tp>\n_LIBCPP_HIDDEN\n_Tp\n__num_get_float(const char* __a, const char* __a_end, ios_base::iostate& __err)\n{\n    if (__a != __a_end)\n    {\n        typename remove_reference<decltype(errno)>::type __save_errno = errno;\n        errno = 0;\n        char *__p2;\n        _Tp __ld = __do_strtod<_Tp>(__a, &__p2);\n        typename remove_reference<decltype(errno)>::type __current_errno = errno;\n        if (__current_errno == 0)\n            errno = __save_errno;\n        if (__p2 != __a_end)\n        {\n            __err = ios_base::failbit;\n            return 0;\n        }\n        else if (__current_errno == ERANGE)\n            __err = ios_base::failbit;\n        return __ld;\n    }\n    __err = ios_base::failbit;\n    return 0;\n}\n\ntemplate <class _CharT, class _InputIterator>\n_InputIterator\nnum_get<_CharT, _InputIterator>::do_get(iter_type __b, iter_type __e,\n                                        ios_base& __iob,\n                                        ios_base::iostate& __err,\n                                        bool& __v) const\n{\n    if ((__iob.flags() & ios_base::boolalpha) == 0)\n    {\n        long __lv = -1;\n        __b = do_get(__b, __e, __iob, __err, __lv);\n        switch (__lv)\n        {\n        case 0:\n            __v = false;\n            break;\n        case 1:\n            __v = true;\n            break;\n        default:\n            __v = true;\n            __err = ios_base::failbit;\n            break;\n        }\n        return __b;\n    }\n    const ctype<_CharT>& __ct = use_facet<ctype<_CharT> >(__iob.getloc());\n    const numpunct<_CharT>& __np = use_facet<numpunct<_CharT> >(__iob.getloc());\n    typedef typename numpunct<_CharT>::string_type string_type;\n    const string_type __names[2] = {__np.truename(), __np.falsename()};\n    const string_type* __i = __scan_keyword(__b, __e, __names, __names+2,\n                                            __ct, __err);\n    __v = __i == __names;\n    return __b;\n}\n\n// signed\n\ntemplate <class _CharT, class _InputIterator>\ntemplate <class _Signed>\n_InputIterator\nnum_get<_CharT, _InputIterator>::__do_get_signed(iter_type __b, iter_type __e,\n                                        ios_base& __iob,\n                                        ios_base::iostate& __err,\n                                        _Signed& __v) const\n{\n    // Stage 1\n    int __base = this->__get_base(__iob);\n    // Stage 2\n    char_type __atoms[26];\n    char_type __thousands_sep;\n    string __grouping = this->__stage2_int_prep(__iob, __atoms, __thousands_sep);\n    string __buf;\n    __buf.resize(__buf.capacity());\n    char* __a = &__buf[0];\n    char* __a_end = __a;\n    unsigned __g[__num_get_base::__num_get_buf_sz];\n    unsigned* __g_end = __g;\n    unsigned __dc = 0;\n    for (; __b != __e; ++__b)\n    {\n        if (__a_end == __a + __buf.size())\n        {\n            size_t __tmp = __buf.size();\n            __buf.resize(2*__buf.size());\n            __buf.resize(__buf.capacity());\n            __a = &__buf[0];\n            __a_end = __a + __tmp;\n        }\n        if (this->__stage2_int_loop(*__b, __base, __a, __a_end, __dc,\n                                    __thousands_sep, __grouping, __g, __g_end,\n                                    __atoms))\n            break;\n    }\n    if (__grouping.size() != 0 && __g_end-__g < __num_get_base::__num_get_buf_sz)\n        *__g_end++ = __dc;\n    // Stage 3\n    __v = __num_get_signed_integral<_Signed>(__a, __a_end, __err, __base);\n    // Digit grouping checked\n    __check_grouping(__grouping, __g, __g_end, __err);\n    // EOF checked\n    if (__b == __e)\n        __err |= ios_base::eofbit;\n    return __b;\n}\n\n// unsigned\n\ntemplate <class _CharT, class _InputIterator>\ntemplate <class _Unsigned>\n_InputIterator\nnum_get<_CharT, _InputIterator>::__do_get_unsigned(iter_type __b, iter_type __e,\n                                        ios_base& __iob,\n                                        ios_base::iostate& __err,\n                                        _Unsigned& __v) const\n{\n    // Stage 1\n    int __base = this->__get_base(__iob);\n    // Stage 2\n    char_type __atoms[26];\n    char_type __thousands_sep;\n    string __grouping = this->__stage2_int_prep(__iob, __atoms, __thousands_sep);\n    string __buf;\n    __buf.resize(__buf.capacity());\n    char* __a = &__buf[0];\n    char* __a_end = __a;\n    unsigned __g[__num_get_base::__num_get_buf_sz];\n    unsigned* __g_end = __g;\n    unsigned __dc = 0;\n    for (; __b != __e; ++__b)\n    {\n        if (__a_end == __a + __buf.size())\n        {\n            size_t __tmp = __buf.size();\n            __buf.resize(2*__buf.size());\n            __buf.resize(__buf.capacity());\n            __a = &__buf[0];\n            __a_end = __a + __tmp;\n        }\n        if (this->__stage2_int_loop(*__b, __base, __a, __a_end, __dc,\n                                    __thousands_sep, __grouping, __g, __g_end,\n                                    __atoms))\n            break;\n    }\n    if (__grouping.size() != 0 && __g_end-__g < __num_get_base::__num_get_buf_sz)\n        *__g_end++ = __dc;\n    // Stage 3\n    __v = __num_get_unsigned_integral<_Unsigned>(__a, __a_end, __err, __base);\n    // Digit grouping checked\n    __check_grouping(__grouping, __g, __g_end, __err);\n    // EOF checked\n    if (__b == __e)\n        __err |= ios_base::eofbit;\n    return __b;\n}\n\n// floating point\n\ntemplate <class _CharT, class _InputIterator>\ntemplate <class _Fp>\n_InputIterator\nnum_get<_CharT, _InputIterator>::__do_get_floating_point(iter_type __b, iter_type __e,\n                                        ios_base& __iob,\n                                        ios_base::iostate& __err,\n                                        _Fp& __v) const\n{\n    // Stage 1, nothing to do\n    // Stage 2\n    char_type __atoms[32];\n    char_type __decimal_point;\n    char_type __thousands_sep;\n    string __grouping = this->__stage2_float_prep(__iob, __atoms,\n                                                  __decimal_point,\n                                                  __thousands_sep);\n    string __buf;\n    __buf.resize(__buf.capacity());\n    char* __a = &__buf[0];\n    char* __a_end = __a;\n    unsigned __g[__num_get_base::__num_get_buf_sz];\n    unsigned* __g_end = __g;\n    unsigned __dc = 0;\n    bool __in_units = true;\n    char __exp = 'E';\n    for (; __b != __e; ++__b)\n    {\n        if (__a_end == __a + __buf.size())\n        {\n            size_t __tmp = __buf.size();\n            __buf.resize(2*__buf.size());\n            __buf.resize(__buf.capacity());\n            __a = &__buf[0];\n            __a_end = __a + __tmp;\n        }\n        if (this->__stage2_float_loop(*__b, __in_units, __exp, __a, __a_end,\n                                      __decimal_point, __thousands_sep,\n                                      __grouping, __g, __g_end,\n                                      __dc, __atoms))\n            break;\n    }\n    if (__grouping.size() != 0 && __in_units && __g_end-__g < __num_get_base::__num_get_buf_sz)\n        *__g_end++ = __dc;\n    // Stage 3\n    __v = __num_get_float<_Fp>(__a, __a_end, __err);\n    // Digit grouping checked\n    __check_grouping(__grouping, __g, __g_end, __err);\n    // EOF checked\n    if (__b == __e)\n        __err |= ios_base::eofbit;\n    return __b;\n}\n\ntemplate <class _CharT, class _InputIterator>\n_InputIterator\nnum_get<_CharT, _InputIterator>::do_get(iter_type __b, iter_type __e,\n                                        ios_base& __iob,\n                                        ios_base::iostate& __err,\n                                        void*& __v) const\n{\n    // Stage 1\n    int __base = 16;\n    // Stage 2\n    char_type __atoms[26];\n    char_type __thousands_sep = 0;\n    string __grouping;\n    use_facet<ctype<_CharT> >(__iob.getloc()).widen(__num_get_base::__src,\n                                                    __num_get_base::__src + 26, __atoms);\n    string __buf;\n    __buf.resize(__buf.capacity());\n    char* __a = &__buf[0];\n    char* __a_end = __a;\n    unsigned __g[__num_get_base::__num_get_buf_sz];\n    unsigned* __g_end = __g;\n    unsigned __dc = 0;\n    for (; __b != __e; ++__b)\n    {\n        if (__a_end == __a + __buf.size())\n        {\n            size_t __tmp = __buf.size();\n            __buf.resize(2*__buf.size());\n            __buf.resize(__buf.capacity());\n            __a = &__buf[0];\n            __a_end = __a + __tmp;\n        }\n        if (this->__stage2_int_loop(*__b, __base, __a, __a_end, __dc,\n                                    __thousands_sep, __grouping,\n                                    __g, __g_end, __atoms))\n            break;\n    }\n    // Stage 3\n    __buf.resize(__a_end - __a);\n    if (__libcpp_sscanf_l(__buf.c_str(), _LIBCPP_GET_C_LOCALE, \"%p\", &__v) != 1)\n        __err = ios_base::failbit;\n    // EOF checked\n    if (__b == __e)\n        __err |= ios_base::eofbit;\n    return __b;\n}\n\n_LIBCPP_EXTERN_TEMPLATE2(class _LIBCPP_EXTERN_TEMPLATE_TYPE_VIS num_get<char>)\n_LIBCPP_EXTERN_TEMPLATE2(class _LIBCPP_EXTERN_TEMPLATE_TYPE_VIS num_get<wchar_t>)\n\nstruct _LIBCPP_TYPE_VIS __num_put_base\n{\nprotected:\n    static void __format_int(char* __fmt, const char* __len, bool __signd,\n                             ios_base::fmtflags __flags);\n    static bool __format_float(char* __fmt, const char* __len,\n                               ios_base::fmtflags __flags);\n    static char* __identify_padding(char* __nb, char* __ne,\n                                    const ios_base& __iob);\n};\n\ntemplate <class _CharT>\nstruct __num_put\n    : protected __num_put_base\n{\n    static void __widen_and_group_int(char* __nb, char* __np, char* __ne,\n                                      _CharT* __ob, _CharT*& __op, _CharT*& __oe,\n                                      const locale& __loc);\n    static void __widen_and_group_float(char* __nb, char* __np, char* __ne,\n                                        _CharT* __ob, _CharT*& __op, _CharT*& __oe,\n                                        const locale& __loc);\n};\n\ntemplate <class _CharT>\nvoid\n__num_put<_CharT>::__widen_and_group_int(char* __nb, char* __np, char* __ne,\n                                         _CharT* __ob, _CharT*& __op, _CharT*& __oe,\n                                         const locale& __loc)\n{\n    const ctype<_CharT>&    __ct = use_facet<ctype<_CharT> >   (__loc);\n    const numpunct<_CharT>& __npt = use_facet<numpunct<_CharT> >(__loc);\n    string __grouping = __npt.grouping();\n    if (__grouping.empty())\n    {\n        __ct.widen(__nb, __ne, __ob);\n        __oe = __ob + (__ne - __nb);\n    }\n    else\n    {\n        __oe = __ob;\n        char* __nf = __nb;\n        if (*__nf == '-' || *__nf == '+')\n            *__oe++ = __ct.widen(*__nf++);\n        if (__ne - __nf >= 2 && __nf[0] == '0' && (__nf[1] == 'x' ||\n                                                   __nf[1] == 'X'))\n        {\n            *__oe++ = __ct.widen(*__nf++);\n            *__oe++ = __ct.widen(*__nf++);\n        }\n        reverse(__nf, __ne);\n        _CharT __thousands_sep = __npt.thousands_sep();\n        unsigned __dc = 0;\n        unsigned __dg = 0;\n        for (char* __p = __nf; __p < __ne; ++__p)\n        {\n            if (static_cast<unsigned>(__grouping[__dg]) > 0 &&\n                __dc == static_cast<unsigned>(__grouping[__dg]))\n            {\n                *__oe++ = __thousands_sep;\n                __dc = 0;\n                if (__dg < __grouping.size()-1)\n                    ++__dg;\n            }\n            *__oe++ = __ct.widen(*__p);\n            ++__dc;\n        }\n        reverse(__ob + (__nf - __nb), __oe);\n    }\n    if (__np == __ne)\n        __op = __oe;\n    else\n        __op = __ob + (__np - __nb);\n}\n\ntemplate <class _CharT>\nvoid\n__num_put<_CharT>::__widen_and_group_float(char* __nb, char* __np, char* __ne,\n                                           _CharT* __ob, _CharT*& __op, _CharT*& __oe,\n                                           const locale& __loc)\n{\n    const ctype<_CharT>&    __ct = use_facet<ctype<_CharT> >   (__loc);\n    const numpunct<_CharT>& __npt = use_facet<numpunct<_CharT> >(__loc);\n    string __grouping = __npt.grouping();\n    __oe = __ob;\n    char* __nf = __nb;\n    if (*__nf == '-' || *__nf == '+')\n        *__oe++ = __ct.widen(*__nf++);\n    char* __ns;\n    if (__ne - __nf >= 2 && __nf[0] == '0' && (__nf[1] == 'x' ||\n                                               __nf[1] == 'X'))\n    {\n        *__oe++ = __ct.widen(*__nf++);\n        *__oe++ = __ct.widen(*__nf++);\n        for (__ns = __nf; __ns < __ne; ++__ns)\n            if (!isxdigit_l(*__ns, _LIBCPP_GET_C_LOCALE))\n                break;\n    }\n    else\n    {\n        for (__ns = __nf; __ns < __ne; ++__ns)\n            if (!isdigit_l(*__ns, _LIBCPP_GET_C_LOCALE))\n                break;\n    }\n    if (__grouping.empty())\n    {\n        __ct.widen(__nf, __ns, __oe);\n        __oe += __ns - __nf;\n    }\n    else\n    {\n        reverse(__nf, __ns);\n        _CharT __thousands_sep = __npt.thousands_sep();\n        unsigned __dc = 0;\n        unsigned __dg = 0;\n        for (char* __p = __nf; __p < __ns; ++__p)\n        {\n            if (__grouping[__dg] > 0 && __dc == static_cast<unsigned>(__grouping[__dg]))\n            {\n                *__oe++ = __thousands_sep;\n                __dc = 0;\n                if (__dg < __grouping.size()-1)\n                    ++__dg;\n            }\n            *__oe++ = __ct.widen(*__p);\n            ++__dc;\n        }\n        reverse(__ob + (__nf - __nb), __oe);\n    }\n    for (__nf = __ns; __nf < __ne; ++__nf)\n    {\n        if (*__nf == '.')\n        {\n            *__oe++ = __npt.decimal_point();\n            ++__nf;\n            break;\n        }\n        else\n            *__oe++ = __ct.widen(*__nf);\n    }\n    __ct.widen(__nf, __ne, __oe);\n    __oe += __ne - __nf;\n    if (__np == __ne)\n        __op = __oe;\n    else\n        __op = __ob + (__np - __nb);\n}\n\n_LIBCPP_EXTERN_TEMPLATE2(struct _LIBCPP_EXTERN_TEMPLATE_TYPE_VIS __num_put<char>)\n_LIBCPP_EXTERN_TEMPLATE2(struct _LIBCPP_EXTERN_TEMPLATE_TYPE_VIS __num_put<wchar_t>)\n\ntemplate <class _CharT, class _OutputIterator = ostreambuf_iterator<_CharT> >\nclass _LIBCPP_TEMPLATE_VIS num_put\n    : public locale::facet,\n      private __num_put<_CharT>\n{\npublic:\n    typedef _CharT char_type;\n    typedef _OutputIterator iter_type;\n\n    _LIBCPP_ALWAYS_INLINE\n    explicit num_put(size_t __refs = 0)\n        : locale::facet(__refs) {}\n\n    _LIBCPP_ALWAYS_INLINE\n    iter_type put(iter_type __s, ios_base& __iob, char_type __fl,\n                  bool __v) const\n    {\n        return do_put(__s, __iob, __fl, __v);\n    }\n\n    _LIBCPP_ALWAYS_INLINE\n    iter_type put(iter_type __s, ios_base& __iob, char_type __fl,\n                  long __v) const\n    {\n        return do_put(__s, __iob, __fl, __v);\n    }\n\n    _LIBCPP_ALWAYS_INLINE\n    iter_type put(iter_type __s, ios_base& __iob, char_type __fl,\n                  long long __v) const\n    {\n        return do_put(__s, __iob, __fl, __v);\n    }\n\n    _LIBCPP_ALWAYS_INLINE\n    iter_type put(iter_type __s, ios_base& __iob, char_type __fl,\n                  unsigned long __v) const\n    {\n        return do_put(__s, __iob, __fl, __v);\n    }\n\n    _LIBCPP_ALWAYS_INLINE\n    iter_type put(iter_type __s, ios_base& __iob, char_type __fl,\n                  unsigned long long __v) const\n    {\n        return do_put(__s, __iob, __fl, __v);\n    }\n\n    _LIBCPP_ALWAYS_INLINE\n    iter_type put(iter_type __s, ios_base& __iob, char_type __fl,\n                  double __v) const\n    {\n        return do_put(__s, __iob, __fl, __v);\n    }\n\n    _LIBCPP_ALWAYS_INLINE\n    iter_type put(iter_type __s, ios_base& __iob, char_type __fl,\n                  long double __v) const\n    {\n        return do_put(__s, __iob, __fl, __v);\n    }\n\n    _LIBCPP_ALWAYS_INLINE\n    iter_type put(iter_type __s, ios_base& __iob, char_type __fl,\n                  const void* __v) const\n    {\n        return do_put(__s, __iob, __fl, __v);\n    }\n\n    static locale::id id;\n\nprotected:\n    _LIBCPP_ALWAYS_INLINE\n    ~num_put() {}\n\n    virtual iter_type do_put(iter_type __s, ios_base& __iob, char_type __fl,\n                             bool __v) const;\n    virtual iter_type do_put(iter_type __s, ios_base& __iob, char_type __fl,\n                             long __v) const;\n    virtual iter_type do_put(iter_type __s, ios_base& __iob, char_type __fl,\n                             long long __v) const;\n    virtual iter_type do_put(iter_type __s, ios_base& __iob, char_type __fl,\n                             unsigned long) const;\n    virtual iter_type do_put(iter_type __s, ios_base& __iob, char_type __fl,\n                             unsigned long long) const;\n    virtual iter_type do_put(iter_type __s, ios_base& __iob, char_type __fl,\n                             double __v) const;\n    virtual iter_type do_put(iter_type __s, ios_base& __iob, char_type __fl,\n                             long double __v) const;\n    virtual iter_type do_put(iter_type __s, ios_base& __iob, char_type __fl,\n                             const void* __v) const;\n};\n\ntemplate <class _CharT, class _OutputIterator>\nlocale::id\nnum_put<_CharT, _OutputIterator>::id;\n\ntemplate <class _CharT, class _OutputIterator>\n_LIBCPP_HIDDEN\n_OutputIterator\n__pad_and_output(_OutputIterator __s,\n                 const _CharT* __ob, const _CharT* __op, const _CharT* __oe,\n                 ios_base& __iob, _CharT __fl)\n{\n    streamsize __sz = __oe - __ob;\n    streamsize __ns = __iob.width();\n    if (__ns > __sz)\n        __ns -= __sz;\n    else\n        __ns = 0;\n    for (;__ob < __op; ++__ob, ++__s)\n        *__s = *__ob;\n    for (; __ns; --__ns, ++__s)\n        *__s = __fl;\n    for (; __ob < __oe; ++__ob, ++__s)\n        *__s = *__ob;\n    __iob.width(0);\n    return __s;\n}\n\n#if !defined(__APPLE__) || \\\n    (defined(__MAC_OS_X_VERSION_MIN_REQUIRED) && __MAC_OS_X_VERSION_MIN_REQUIRED > __MAC_10_8) || \\\n    (defined(__IPHONE_OS_VERSION_MIN_REQUIRED) && __IPHONE_OS_VERSION_MIN_REQUIRED > __IPHONE_6_0)\n\ntemplate <class _CharT, class _Traits>\n_LIBCPP_HIDDEN\nostreambuf_iterator<_CharT, _Traits>\n__pad_and_output(ostreambuf_iterator<_CharT, _Traits> __s,\n                 const _CharT* __ob, const _CharT* __op, const _CharT* __oe,\n                 ios_base& __iob, _CharT __fl)\n{\n    if (__s.__sbuf_ == nullptr)\n        return __s;\n    streamsize __sz = __oe - __ob;\n    streamsize __ns = __iob.width();\n    if (__ns > __sz)\n        __ns -= __sz;\n    else\n        __ns = 0;\n    streamsize __np = __op - __ob;\n    if (__np > 0)\n    {\n        if (__s.__sbuf_->sputn(__ob, __np) != __np)\n        {\n            __s.__sbuf_ = nullptr;\n            return __s;\n        }\n    }\n    if (__ns > 0)\n    {\n        basic_string<_CharT, _Traits> __sp(__ns, __fl);\n        if (__s.__sbuf_->sputn(__sp.data(), __ns) != __ns)\n        {\n            __s.__sbuf_ = nullptr;\n            return __s;\n        }\n    }\n    __np = __oe - __op;\n    if (__np > 0)\n    {\n        if (__s.__sbuf_->sputn(__op, __np) != __np)\n        {\n            __s.__sbuf_ = nullptr;\n            return __s;\n        }\n    }\n    __iob.width(0);\n    return __s;\n}\n\n#endif\n\ntemplate <class _CharT, class _OutputIterator>\n_OutputIterator\nnum_put<_CharT, _OutputIterator>::do_put(iter_type __s, ios_base& __iob,\n                                         char_type __fl, bool __v) const\n{\n    if ((__iob.flags() & ios_base::boolalpha) == 0)\n        return do_put(__s, __iob, __fl, (unsigned long)__v);\n    const numpunct<char_type>& __np = use_facet<numpunct<char_type> >(__iob.getloc());\n    typedef typename numpunct<char_type>::string_type string_type;\n#if _LIBCPP_DEBUG_LEVEL >= 2\n    string_type __tmp(__v ? __np.truename() : __np.falsename());\n    string_type __nm = _VSTD::move(__tmp);\n#else\n    string_type __nm = __v ? __np.truename() : __np.falsename();\n#endif\n    for (typename string_type::iterator __i = __nm.begin(); __i != __nm.end(); ++__i, ++__s)\n        *__s = *__i;\n    return __s;\n}\n\ntemplate <class _CharT, class _OutputIterator>\n_OutputIterator\nnum_put<_CharT, _OutputIterator>::do_put(iter_type __s, ios_base& __iob,\n                                         char_type __fl, long __v) const\n{\n    // Stage 1 - Get number in narrow char\n    char __fmt[6] = {'%', 0};\n    const char* __len = \"l\";\n    this->__format_int(__fmt+1, __len, true, __iob.flags());\n    const unsigned __nbuf = (numeric_limits<long>::digits / 3)\n                          + ((numeric_limits<long>::digits % 3) != 0)\n                          + 2;\n    char __nar[__nbuf];\n    int __nc = __libcpp_snprintf_l(__nar, sizeof(__nar), _LIBCPP_GET_C_LOCALE, __fmt, __v);\n    char* __ne = __nar + __nc;\n    char* __np = this->__identify_padding(__nar, __ne, __iob);\n    // Stage 2 - Widen __nar while adding thousands separators\n    char_type __o[2*(__nbuf-1) - 1];\n    char_type* __op;  // pad here\n    char_type* __oe;  // end of output\n    this->__widen_and_group_int(__nar, __np, __ne, __o, __op, __oe, __iob.getloc());\n    // [__o, __oe) contains thousands_sep'd wide number\n    // Stage 3 & 4\n    return __pad_and_output(__s, __o, __op, __oe, __iob, __fl);\n}\n\ntemplate <class _CharT, class _OutputIterator>\n_OutputIterator\nnum_put<_CharT, _OutputIterator>::do_put(iter_type __s, ios_base& __iob,\n                                         char_type __fl, long long __v) const\n{\n    // Stage 1 - Get number in narrow char\n    char __fmt[8] = {'%', 0};\n    const char* __len = \"ll\";\n    this->__format_int(__fmt+1, __len, true, __iob.flags());\n    const unsigned __nbuf = (numeric_limits<long long>::digits / 3)\n                          + ((numeric_limits<long long>::digits % 3) != 0)\n                          + 2;\n    char __nar[__nbuf];\n    int __nc = __libcpp_snprintf_l(__nar, sizeof(__nar), _LIBCPP_GET_C_LOCALE, __fmt, __v);\n    char* __ne = __nar + __nc;\n    char* __np = this->__identify_padding(__nar, __ne, __iob);\n    // Stage 2 - Widen __nar while adding thousands separators\n    char_type __o[2*(__nbuf-1) - 1];\n    char_type* __op;  // pad here\n    char_type* __oe;  // end of output\n    this->__widen_and_group_int(__nar, __np, __ne, __o, __op, __oe, __iob.getloc());\n    // [__o, __oe) contains thousands_sep'd wide number\n    // Stage 3 & 4\n    return __pad_and_output(__s, __o, __op, __oe, __iob, __fl);\n}\n\ntemplate <class _CharT, class _OutputIterator>\n_OutputIterator\nnum_put<_CharT, _OutputIterator>::do_put(iter_type __s, ios_base& __iob,\n                                         char_type __fl, unsigned long __v) const\n{\n    // Stage 1 - Get number in narrow char\n    char __fmt[6] = {'%', 0};\n    const char* __len = \"l\";\n    this->__format_int(__fmt+1, __len, false, __iob.flags());\n    const unsigned __nbuf = (numeric_limits<unsigned long>::digits / 3)\n                          + ((numeric_limits<unsigned long>::digits % 3) != 0)\n                          + 1;\n    char __nar[__nbuf];\n    int __nc = __libcpp_snprintf_l(__nar, sizeof(__nar), _LIBCPP_GET_C_LOCALE, __fmt, __v);\n    char* __ne = __nar + __nc;\n    char* __np = this->__identify_padding(__nar, __ne, __iob);\n    // Stage 2 - Widen __nar while adding thousands separators\n    char_type __o[2*(__nbuf-1) - 1];\n    char_type* __op;  // pad here\n    char_type* __oe;  // end of output\n    this->__widen_and_group_int(__nar, __np, __ne, __o, __op, __oe, __iob.getloc());\n    // [__o, __oe) contains thousands_sep'd wide number\n    // Stage 3 & 4\n    return __pad_and_output(__s, __o, __op, __oe, __iob, __fl);\n}\n\ntemplate <class _CharT, class _OutputIterator>\n_OutputIterator\nnum_put<_CharT, _OutputIterator>::do_put(iter_type __s, ios_base& __iob,\n                                         char_type __fl, unsigned long long __v) const\n{\n    // Stage 1 - Get number in narrow char\n    char __fmt[8] = {'%', 0};\n    const char* __len = \"ll\";\n    this->__format_int(__fmt+1, __len, false, __iob.flags());\n    const unsigned __nbuf = (numeric_limits<unsigned long long>::digits / 3)\n                          + ((numeric_limits<unsigned long long>::digits % 3) != 0)\n                          + 1;\n    char __nar[__nbuf];\n    int __nc = __libcpp_snprintf_l(__nar, sizeof(__nar), _LIBCPP_GET_C_LOCALE, __fmt, __v);\n    char* __ne = __nar + __nc;\n    char* __np = this->__identify_padding(__nar, __ne, __iob);\n    // Stage 2 - Widen __nar while adding thousands separators\n    char_type __o[2*(__nbuf-1) - 1];\n    char_type* __op;  // pad here\n    char_type* __oe;  // end of output\n    this->__widen_and_group_int(__nar, __np, __ne, __o, __op, __oe, __iob.getloc());\n    // [__o, __oe) contains thousands_sep'd wide number\n    // Stage 3 & 4\n    return __pad_and_output(__s, __o, __op, __oe, __iob, __fl);\n}\n\ntemplate <class _CharT, class _OutputIterator>\n_OutputIterator\nnum_put<_CharT, _OutputIterator>::do_put(iter_type __s, ios_base& __iob,\n                                         char_type __fl, double __v) const\n{\n    // Stage 1 - Get number in narrow char\n    char __fmt[8] = {'%', 0};\n    const char* __len = \"\";\n    bool __specify_precision = this->__format_float(__fmt+1, __len, __iob.flags());\n    const unsigned __nbuf = 30;\n    char __nar[__nbuf];\n    char* __nb = __nar;\n    int __nc;\n    if (__specify_precision)\n        __nc = __libcpp_snprintf_l(__nb, __nbuf, _LIBCPP_GET_C_LOCALE, __fmt,\n                                   (int)__iob.precision(), __v);\n    else\n        __nc = __libcpp_snprintf_l(__nb, __nbuf, _LIBCPP_GET_C_LOCALE, __fmt, __v);\n    unique_ptr<char, void(*)(void*)> __nbh(0, free);\n    if (__nc > static_cast<int>(__nbuf-1))\n    {\n        if (__specify_precision)\n            __nc = __libcpp_asprintf_l(&__nb, _LIBCPP_GET_C_LOCALE, __fmt, (int)__iob.precision(), __v);\n        else\n            __nc = __libcpp_asprintf_l(&__nb, _LIBCPP_GET_C_LOCALE, __fmt, __v);\n        if (__nb == 0)\n            __throw_bad_alloc();\n        __nbh.reset(__nb);\n    }\n    char* __ne = __nb + __nc;\n    char* __np = this->__identify_padding(__nb, __ne, __iob);\n    // Stage 2 - Widen __nar while adding thousands separators\n    char_type __o[2*(__nbuf-1) - 1];\n    char_type* __ob = __o;\n    unique_ptr<char_type, void(*)(void*)> __obh(0, free);\n    if (__nb != __nar)\n    {\n        __ob = (char_type*)malloc(2*static_cast<size_t>(__nc)*sizeof(char_type));\n        if (__ob == 0)\n            __throw_bad_alloc();\n        __obh.reset(__ob);\n    }\n    char_type* __op;  // pad here\n    char_type* __oe;  // end of output\n    this->__widen_and_group_float(__nb, __np, __ne, __ob, __op, __oe, __iob.getloc());\n    // [__o, __oe) contains thousands_sep'd wide number\n    // Stage 3 & 4\n    __s = __pad_and_output(__s, __ob, __op, __oe, __iob, __fl);\n    return __s;\n}\n\ntemplate <class _CharT, class _OutputIterator>\n_OutputIterator\nnum_put<_CharT, _OutputIterator>::do_put(iter_type __s, ios_base& __iob,\n                                         char_type __fl, long double __v) const\n{\n    // Stage 1 - Get number in narrow char\n    char __fmt[8] = {'%', 0};\n    const char* __len = \"L\";\n    bool __specify_precision = this->__format_float(__fmt+1, __len, __iob.flags());\n    const unsigned __nbuf = 30;\n    char __nar[__nbuf];\n    char* __nb = __nar;\n    int __nc;\n    if (__specify_precision)\n        __nc = __libcpp_snprintf_l(__nb, __nbuf, _LIBCPP_GET_C_LOCALE, __fmt,\n                                   (int)__iob.precision(), __v);\n    else\n        __nc = __libcpp_snprintf_l(__nb, __nbuf, _LIBCPP_GET_C_LOCALE, __fmt, __v);\n    unique_ptr<char, void(*)(void*)> __nbh(0, free);\n    if (__nc > static_cast<int>(__nbuf-1))\n    {\n        if (__specify_precision)\n            __nc = __libcpp_asprintf_l(&__nb, _LIBCPP_GET_C_LOCALE, __fmt, (int)__iob.precision(), __v);\n        else\n            __nc = __libcpp_asprintf_l(&__nb, _LIBCPP_GET_C_LOCALE, __fmt, __v);\n        if (__nb == 0)\n            __throw_bad_alloc();\n        __nbh.reset(__nb);\n    }\n    char* __ne = __nb + __nc;\n    char* __np = this->__identify_padding(__nb, __ne, __iob);\n    // Stage 2 - Widen __nar while adding thousands separators\n    char_type __o[2*(__nbuf-1) - 1];\n    char_type* __ob = __o;\n    unique_ptr<char_type, void(*)(void*)> __obh(0, free);\n    if (__nb != __nar)\n    {\n        __ob = (char_type*)malloc(2*static_cast<size_t>(__nc)*sizeof(char_type));\n        if (__ob == 0)\n            __throw_bad_alloc();\n        __obh.reset(__ob);\n    }\n    char_type* __op;  // pad here\n    char_type* __oe;  // end of output\n    this->__widen_and_group_float(__nb, __np, __ne, __ob, __op, __oe, __iob.getloc());\n    // [__o, __oe) contains thousands_sep'd wide number\n    // Stage 3 & 4\n    __s = __pad_and_output(__s, __ob, __op, __oe, __iob, __fl);\n    return __s;\n}\n\ntemplate <class _CharT, class _OutputIterator>\n_OutputIterator\nnum_put<_CharT, _OutputIterator>::do_put(iter_type __s, ios_base& __iob,\n                                         char_type __fl, const void* __v) const\n{\n    // Stage 1 - Get pointer in narrow char\n    char __fmt[6] = \"%p\";\n    const unsigned __nbuf = 20;\n    char __nar[__nbuf];\n    int __nc = __libcpp_snprintf_l(__nar, sizeof(__nar), _LIBCPP_GET_C_LOCALE, __fmt, __v);\n    char* __ne = __nar + __nc;\n    char* __np = this->__identify_padding(__nar, __ne, __iob);\n    // Stage 2 - Widen __nar\n    char_type __o[2*(__nbuf-1) - 1];\n    char_type* __op;  // pad here\n    char_type* __oe;  // end of output\n    const ctype<char_type>& __ct = use_facet<ctype<char_type> >(__iob.getloc());\n    __ct.widen(__nar, __ne, __o);\n    __oe = __o + (__ne - __nar);\n    if (__np == __ne)\n        __op = __oe;\n    else\n        __op = __o + (__np - __nar);\n    // [__o, __oe) contains wide number\n    // Stage 3 & 4\n    return __pad_and_output(__s, __o, __op, __oe, __iob, __fl);\n}\n\n_LIBCPP_EXTERN_TEMPLATE2(class _LIBCPP_EXTERN_TEMPLATE_TYPE_VIS num_put<char>)\n_LIBCPP_EXTERN_TEMPLATE2(class _LIBCPP_EXTERN_TEMPLATE_TYPE_VIS num_put<wchar_t>)\n\ntemplate <class _CharT, class _InputIterator>\n_LIBCPP_HIDDEN\nint\n__get_up_to_n_digits(_InputIterator& __b, _InputIterator __e,\n                     ios_base::iostate& __err, const ctype<_CharT>& __ct, int __n)\n{\n    // Precondition:  __n >= 1\n    if (__b == __e)\n    {\n        __err |= ios_base::eofbit | ios_base::failbit;\n        return 0;\n    }\n    // get first digit\n    _CharT __c = *__b;\n    if (!__ct.is(ctype_base::digit, __c))\n    {\n        __err |= ios_base::failbit;\n        return 0;\n    }\n    int __r = __ct.narrow(__c, 0) - '0';\n    for (++__b, (void) --__n; __b != __e && __n > 0; ++__b, (void) --__n)\n    {\n        // get next digit\n        __c = *__b;\n        if (!__ct.is(ctype_base::digit, __c))\n            return __r;\n        __r = __r * 10 + __ct.narrow(__c, 0) - '0';\n    }\n    if (__b == __e)\n        __err |= ios_base::eofbit;\n    return __r;\n}\n\nclass _LIBCPP_TYPE_VIS time_base\n{\npublic:\n    enum dateorder {no_order, dmy, mdy, ymd, ydm};\n};\n\ntemplate <class _CharT>\nclass _LIBCPP_TEMPLATE_VIS __time_get_c_storage\n{\nprotected:\n    typedef basic_string<_CharT> string_type;\n\n    virtual const string_type* __weeks() const;\n    virtual const string_type* __months() const;\n    virtual const string_type* __am_pm() const;\n    virtual const string_type& __c() const;\n    virtual const string_type& __r() const;\n    virtual const string_type& __x() const;\n    virtual const string_type& __X() const;\n\n    _LIBCPP_ALWAYS_INLINE\n    ~__time_get_c_storage() {}\n};\n\ntemplate <class _CharT, class _InputIterator = istreambuf_iterator<_CharT> >\nclass _LIBCPP_TEMPLATE_VIS time_get\n    : public locale::facet,\n      public time_base,\n      private __time_get_c_storage<_CharT>\n{\npublic:\n    typedef _CharT                  char_type;\n    typedef _InputIterator          iter_type;\n    typedef time_base::dateorder    dateorder;\n    typedef basic_string<char_type> string_type;\n\n    _LIBCPP_ALWAYS_INLINE\n    explicit time_get(size_t __refs = 0)\n        : locale::facet(__refs) {}\n\n    _LIBCPP_ALWAYS_INLINE\n    dateorder date_order() const\n    {\n        return this->do_date_order();\n    }\n\n    _LIBCPP_ALWAYS_INLINE\n    iter_type get_time(iter_type __b, iter_type __e, ios_base& __iob,\n                       ios_base::iostate& __err, tm* __tm) const\n    {\n        return do_get_time(__b, __e, __iob, __err, __tm);\n    }\n\n    _LIBCPP_ALWAYS_INLINE\n    iter_type get_date(iter_type __b, iter_type __e, ios_base& __iob,\n                       ios_base::iostate& __err, tm* __tm) const\n    {\n        return do_get_date(__b, __e, __iob, __err, __tm);\n    }\n\n    _LIBCPP_ALWAYS_INLINE\n    iter_type get_weekday(iter_type __b, iter_type __e, ios_base& __iob,\n                          ios_base::iostate& __err, tm* __tm) const\n    {\n        return do_get_weekday(__b, __e, __iob, __err, __tm);\n    }\n\n    _LIBCPP_ALWAYS_INLINE\n    iter_type get_monthname(iter_type __b, iter_type __e, ios_base& __iob,\n                            ios_base::iostate& __err, tm* __tm) const\n    {\n        return do_get_monthname(__b, __e, __iob, __err, __tm);\n    }\n\n    _LIBCPP_ALWAYS_INLINE\n    iter_type get_year(iter_type __b, iter_type __e, ios_base& __iob,\n                       ios_base::iostate& __err, tm* __tm) const\n    {\n        return do_get_year(__b, __e, __iob, __err, __tm);\n    }\n\n    _LIBCPP_ALWAYS_INLINE\n    iter_type get(iter_type __b, iter_type __e, ios_base& __iob,\n                  ios_base::iostate& __err, tm *__tm,\n                  char __fmt, char __mod = 0) const\n    {\n        return do_get(__b, __e, __iob, __err, __tm, __fmt, __mod);\n    }\n\n    iter_type get(iter_type __b, iter_type __e, ios_base& __iob,\n                  ios_base::iostate& __err, tm* __tm,\n                  const char_type* __fmtb, const char_type* __fmte) const;\n\n    static locale::id id;\n\nprotected:\n    _LIBCPP_ALWAYS_INLINE\n    ~time_get() {}\n\n    virtual dateorder do_date_order() const;\n    virtual iter_type do_get_time(iter_type __b, iter_type __e, ios_base& __iob,\n                                  ios_base::iostate& __err, tm* __tm) const;\n    virtual iter_type do_get_date(iter_type __b, iter_type __e, ios_base& __iob,\n                                  ios_base::iostate& __err, tm* __tm) const;\n    virtual iter_type do_get_weekday(iter_type __b, iter_type __e, ios_base& __iob,\n                                     ios_base::iostate& __err, tm* __tm) const;\n    virtual iter_type do_get_monthname(iter_type __b, iter_type __e, ios_base& __iob,\n                                       ios_base::iostate& __err, tm* __tm) const;\n    virtual iter_type do_get_year(iter_type __b, iter_type __e, ios_base& __iob,\n                                  ios_base::iostate& __err, tm* __tm) const;\n    virtual iter_type do_get(iter_type __b, iter_type __e, ios_base& __iob,\n                             ios_base::iostate& __err, tm* __tm,\n                             char __fmt, char __mod) const;\nprivate:\n    void __get_white_space(iter_type& __b, iter_type __e,\n                           ios_base::iostate& __err, const ctype<char_type>& __ct) const;\n    void __get_percent(iter_type& __b, iter_type __e, ios_base::iostate& __err,\n                       const ctype<char_type>& __ct) const;\n\n    void __get_weekdayname(int& __m,\n                           iter_type& __b, iter_type __e,\n                           ios_base::iostate& __err,\n                           const ctype<char_type>& __ct) const;\n    void __get_monthname(int& __m,\n                         iter_type& __b, iter_type __e,\n                         ios_base::iostate& __err,\n                         const ctype<char_type>& __ct) const;\n    void __get_day(int& __d,\n                   iter_type& __b, iter_type __e,\n                   ios_base::iostate& __err,\n                   const ctype<char_type>& __ct) const;\n    void __get_month(int& __m,\n                     iter_type& __b, iter_type __e,\n                     ios_base::iostate& __err,\n                     const ctype<char_type>& __ct) const;\n    void __get_year(int& __y,\n                   iter_type& __b, iter_type __e,\n                   ios_base::iostate& __err,\n                   const ctype<char_type>& __ct) const;\n    void __get_year4(int& __y,\n                    iter_type& __b, iter_type __e,\n                    ios_base::iostate& __err,\n                    const ctype<char_type>& __ct) const;\n    void __get_hour(int& __d,\n                    iter_type& __b, iter_type __e,\n                    ios_base::iostate& __err,\n                    const ctype<char_type>& __ct) const;\n    void __get_12_hour(int& __h,\n                       iter_type& __b, iter_type __e,\n                       ios_base::iostate& __err,\n                       const ctype<char_type>& __ct) const;\n    void __get_am_pm(int& __h,\n                     iter_type& __b, iter_type __e,\n                     ios_base::iostate& __err,\n                     const ctype<char_type>& __ct) const;\n    void __get_minute(int& __m,\n                      iter_type& __b, iter_type __e,\n                      ios_base::iostate& __err,\n                      const ctype<char_type>& __ct) const;\n    void __get_second(int& __s,\n                      iter_type& __b, iter_type __e,\n                      ios_base::iostate& __err,\n                      const ctype<char_type>& __ct) const;\n    void __get_weekday(int& __w,\n                       iter_type& __b, iter_type __e,\n                       ios_base::iostate& __err,\n                       const ctype<char_type>& __ct) const;\n    void __get_day_year_num(int& __w,\n                            iter_type& __b, iter_type __e,\n                            ios_base::iostate& __err,\n                            const ctype<char_type>& __ct) const;\n};\n\ntemplate <class _CharT, class _InputIterator>\nlocale::id\ntime_get<_CharT, _InputIterator>::id;\n\n// time_get primitives\n\ntemplate <class _CharT, class _InputIterator>\nvoid\ntime_get<_CharT, _InputIterator>::__get_weekdayname(int& __w,\n                                                    iter_type& __b, iter_type __e,\n                                                    ios_base::iostate& __err,\n                                                    const ctype<char_type>& __ct) const\n{\n    // Note:  ignoring case comes from the POSIX strptime spec\n    const string_type* __wk = this->__weeks();\n    ptrdiff_t __i = __scan_keyword(__b, __e, __wk, __wk+14, __ct, __err, false) - __wk;\n    if (__i < 14)\n        __w = __i % 7;\n}\n\ntemplate <class _CharT, class _InputIterator>\nvoid\ntime_get<_CharT, _InputIterator>::__get_monthname(int& __m,\n                                                  iter_type& __b, iter_type __e,\n                                                  ios_base::iostate& __err,\n                                                  const ctype<char_type>& __ct) const\n{\n    // Note:  ignoring case comes from the POSIX strptime spec\n    const string_type* __month = this->__months();\n    ptrdiff_t __i = __scan_keyword(__b, __e, __month, __month+24, __ct, __err, false) - __month;\n    if (__i < 24)\n        __m = __i % 12;\n}\n\ntemplate <class _CharT, class _InputIterator>\nvoid\ntime_get<_CharT, _InputIterator>::__get_day(int& __d,\n                                            iter_type& __b, iter_type __e,\n                                            ios_base::iostate& __err,\n                                            const ctype<char_type>& __ct) const\n{\n    int __t = __get_up_to_n_digits(__b, __e, __err, __ct, 2);\n    if (!(__err & ios_base::failbit) && 1 <= __t && __t <= 31)\n        __d = __t;\n    else\n        __err |= ios_base::failbit;\n}\n\ntemplate <class _CharT, class _InputIterator>\nvoid\ntime_get<_CharT, _InputIterator>::__get_month(int& __m,\n                                              iter_type& __b, iter_type __e,\n                                              ios_base::iostate& __err,\n                                              const ctype<char_type>& __ct) const\n{\n    int __t = __get_up_to_n_digits(__b, __e, __err, __ct, 2) - 1;\n    if (!(__err & ios_base::failbit) && __t <= 11)\n        __m = __t;\n    else\n        __err |= ios_base::failbit;\n}\n\ntemplate <class _CharT, class _InputIterator>\nvoid\ntime_get<_CharT, _InputIterator>::__get_year(int& __y,\n                                             iter_type& __b, iter_type __e,\n                                             ios_base::iostate& __err,\n                                             const ctype<char_type>& __ct) const\n{\n    int __t = __get_up_to_n_digits(__b, __e, __err, __ct, 4);\n    if (!(__err & ios_base::failbit))\n    {\n        if (__t < 69)\n            __t += 2000;\n        else if (69 <= __t && __t <= 99)\n            __t += 1900;\n        __y = __t - 1900;\n    }\n}\n\ntemplate <class _CharT, class _InputIterator>\nvoid\ntime_get<_CharT, _InputIterator>::__get_year4(int& __y,\n                                              iter_type& __b, iter_type __e,\n                                              ios_base::iostate& __err,\n                                              const ctype<char_type>& __ct) const\n{\n    int __t = __get_up_to_n_digits(__b, __e, __err, __ct, 4);\n    if (!(__err & ios_base::failbit))\n        __y = __t - 1900;\n}\n\ntemplate <class _CharT, class _InputIterator>\nvoid\ntime_get<_CharT, _InputIterator>::__get_hour(int& __h,\n                                             iter_type& __b, iter_type __e,\n                                             ios_base::iostate& __err,\n                                             const ctype<char_type>& __ct) const\n{\n    int __t = __get_up_to_n_digits(__b, __e, __err, __ct, 2);\n    if (!(__err & ios_base::failbit) && __t <= 23)\n        __h = __t;\n    else\n        __err |= ios_base::failbit;\n}\n\ntemplate <class _CharT, class _InputIterator>\nvoid\ntime_get<_CharT, _InputIterator>::__get_12_hour(int& __h,\n                                                iter_type& __b, iter_type __e,\n                                                ios_base::iostate& __err,\n                                                const ctype<char_type>& __ct) const\n{\n    int __t = __get_up_to_n_digits(__b, __e, __err, __ct, 2);\n    if (!(__err & ios_base::failbit) && 1 <= __t && __t <= 12)\n        __h = __t;\n    else\n        __err |= ios_base::failbit;\n}\n\ntemplate <class _CharT, class _InputIterator>\nvoid\ntime_get<_CharT, _InputIterator>::__get_minute(int& __m,\n                                               iter_type& __b, iter_type __e,\n                                               ios_base::iostate& __err,\n                                               const ctype<char_type>& __ct) const\n{\n    int __t = __get_up_to_n_digits(__b, __e, __err, __ct, 2);\n    if (!(__err & ios_base::failbit) && __t <= 59)\n        __m = __t;\n    else\n        __err |= ios_base::failbit;\n}\n\ntemplate <class _CharT, class _InputIterator>\nvoid\ntime_get<_CharT, _InputIterator>::__get_second(int& __s,\n                                               iter_type& __b, iter_type __e,\n                                               ios_base::iostate& __err,\n                                               const ctype<char_type>& __ct) const\n{\n    int __t = __get_up_to_n_digits(__b, __e, __err, __ct, 2);\n    if (!(__err & ios_base::failbit) && __t <= 60)\n        __s = __t;\n    else\n        __err |= ios_base::failbit;\n}\n\ntemplate <class _CharT, class _InputIterator>\nvoid\ntime_get<_CharT, _InputIterator>::__get_weekday(int& __w,\n                                                iter_type& __b, iter_type __e,\n                                                ios_base::iostate& __err,\n                                                const ctype<char_type>& __ct) const\n{\n    int __t = __get_up_to_n_digits(__b, __e, __err, __ct, 1);\n    if (!(__err & ios_base::failbit) && __t <= 6)\n        __w = __t;\n    else\n        __err |= ios_base::failbit;\n}\n\ntemplate <class _CharT, class _InputIterator>\nvoid\ntime_get<_CharT, _InputIterator>::__get_day_year_num(int& __d,\n                                                     iter_type& __b, iter_type __e,\n                                                     ios_base::iostate& __err,\n                                                     const ctype<char_type>& __ct) const\n{\n    int __t = __get_up_to_n_digits(__b, __e, __err, __ct, 3);\n    if (!(__err & ios_base::failbit) && __t <= 365)\n        __d = __t;\n    else\n        __err |= ios_base::failbit;\n}\n\ntemplate <class _CharT, class _InputIterator>\nvoid\ntime_get<_CharT, _InputIterator>::__get_white_space(iter_type& __b, iter_type __e,\n                                                    ios_base::iostate& __err,\n                                                    const ctype<char_type>& __ct) const\n{\n    for (; __b != __e && __ct.is(ctype_base::space, *__b); ++__b)\n        ;\n    if (__b == __e)\n        __err |= ios_base::eofbit;\n}\n\ntemplate <class _CharT, class _InputIterator>\nvoid\ntime_get<_CharT, _InputIterator>::__get_am_pm(int& __h,\n                                              iter_type& __b, iter_type __e,\n                                              ios_base::iostate& __err,\n                                              const ctype<char_type>& __ct) const\n{\n    const string_type* __ap = this->__am_pm();\n    if (__ap[0].size() + __ap[1].size() == 0)\n    {\n        __err |= ios_base::failbit;\n        return;\n    }\n    ptrdiff_t __i = __scan_keyword(__b, __e, __ap, __ap+2, __ct, __err, false) - __ap;\n    if (__i == 0 && __h == 12)\n        __h = 0;\n    else if (__i == 1 && __h < 12)\n        __h += 12;\n}\n\ntemplate <class _CharT, class _InputIterator>\nvoid\ntime_get<_CharT, _InputIterator>::__get_percent(iter_type& __b, iter_type __e,\n                                                ios_base::iostate& __err,\n                                                const ctype<char_type>& __ct) const\n{\n    if (__b == __e)\n    {\n        __err |= ios_base::eofbit | ios_base::failbit;\n        return;\n    }\n    if (__ct.narrow(*__b, 0) != '%')\n        __err |= ios_base::failbit;\n    else if(++__b == __e)\n        __err |= ios_base::eofbit;\n}\n\n// time_get end primitives\n\ntemplate <class _CharT, class _InputIterator>\n_InputIterator\ntime_get<_CharT, _InputIterator>::get(iter_type __b, iter_type __e,\n                                      ios_base& __iob,\n                                      ios_base::iostate& __err, tm* __tm,\n                                      const char_type* __fmtb, const char_type* __fmte) const\n{\n    const ctype<char_type>& __ct = use_facet<ctype<char_type> >(__iob.getloc());\n    __err = ios_base::goodbit;\n    while (__fmtb != __fmte && __err == ios_base::goodbit)\n    {\n        if (__b == __e)\n        {\n            __err = ios_base::failbit;\n            break;\n        }\n        if (__ct.narrow(*__fmtb, 0) == '%')\n        {\n            if (++__fmtb == __fmte)\n            {\n                __err = ios_base::failbit;\n                break;\n            }\n            char __cmd = __ct.narrow(*__fmtb, 0);\n            char __opt = '\\0';\n            if (__cmd == 'E' || __cmd == '0')\n            {\n                if (++__fmtb == __fmte)\n                {\n                    __err = ios_base::failbit;\n                    break;\n                }\n                __opt = __cmd;\n                __cmd = __ct.narrow(*__fmtb, 0);\n            }\n            __b = do_get(__b, __e, __iob, __err, __tm, __cmd, __opt);\n            ++__fmtb;\n        }\n        else if (__ct.is(ctype_base::space, *__fmtb))\n        {\n            for (++__fmtb; __fmtb != __fmte && __ct.is(ctype_base::space, *__fmtb); ++__fmtb)\n                ;\n            for (        ;    __b != __e    && __ct.is(ctype_base::space, *__b);    ++__b)\n                ;\n        }\n        else if (__ct.toupper(*__b) == __ct.toupper(*__fmtb))\n        {\n            ++__b;\n            ++__fmtb;\n        }\n        else\n            __err = ios_base::failbit;\n    }\n    if (__b == __e)\n        __err |= ios_base::eofbit;\n    return __b;\n}\n\ntemplate <class _CharT, class _InputIterator>\ntypename time_get<_CharT, _InputIterator>::dateorder\ntime_get<_CharT, _InputIterator>::do_date_order() const\n{\n    return mdy;\n}\n\ntemplate <class _CharT, class _InputIterator>\n_InputIterator\ntime_get<_CharT, _InputIterator>::do_get_time(iter_type __b, iter_type __e,\n                                              ios_base& __iob,\n                                              ios_base::iostate& __err,\n                                              tm* __tm) const\n{\n    const char_type __fmt[] = {'%', 'H', ':', '%', 'M', ':', '%', 'S'};\n    return get(__b, __e, __iob, __err, __tm, __fmt, __fmt + sizeof(__fmt)/sizeof(__fmt[0]));\n}\n\ntemplate <class _CharT, class _InputIterator>\n_InputIterator\ntime_get<_CharT, _InputIterator>::do_get_date(iter_type __b, iter_type __e,\n                                              ios_base& __iob,\n                                              ios_base::iostate& __err,\n                                              tm* __tm) const\n{\n    const string_type& __fmt = this->__x();\n    return get(__b, __e, __iob, __err, __tm, __fmt.data(), __fmt.data() + __fmt.size());\n}\n\ntemplate <class _CharT, class _InputIterator>\n_InputIterator\ntime_get<_CharT, _InputIterator>::do_get_weekday(iter_type __b, iter_type __e,\n                                                 ios_base& __iob,\n                                                 ios_base::iostate& __err,\n                                                 tm* __tm) const\n{\n    const ctype<char_type>& __ct = use_facet<ctype<char_type> >(__iob.getloc());\n    __get_weekdayname(__tm->tm_wday, __b, __e, __err, __ct);\n    return __b;\n}\n\ntemplate <class _CharT, class _InputIterator>\n_InputIterator\ntime_get<_CharT, _InputIterator>::do_get_monthname(iter_type __b, iter_type __e,\n                                                   ios_base& __iob,\n                                                   ios_base::iostate& __err,\n                                                   tm* __tm) const\n{\n    const ctype<char_type>& __ct = use_facet<ctype<char_type> >(__iob.getloc());\n    __get_monthname(__tm->tm_mon, __b, __e, __err, __ct);\n    return __b;\n}\n\ntemplate <class _CharT, class _InputIterator>\n_InputIterator\ntime_get<_CharT, _InputIterator>::do_get_year(iter_type __b, iter_type __e,\n                                              ios_base& __iob,\n                                              ios_base::iostate& __err,\n                                              tm* __tm) const\n{\n    const ctype<char_type>& __ct = use_facet<ctype<char_type> >(__iob.getloc());\n    __get_year(__tm->tm_year, __b, __e, __err, __ct);\n    return __b;\n}\n\ntemplate <class _CharT, class _InputIterator>\n_InputIterator\ntime_get<_CharT, _InputIterator>::do_get(iter_type __b, iter_type __e,\n                                         ios_base& __iob,\n                                         ios_base::iostate& __err, tm* __tm,\n                                         char __fmt, char) const\n{\n    __err = ios_base::goodbit;\n    const ctype<char_type>& __ct = use_facet<ctype<char_type> >(__iob.getloc());\n    switch (__fmt)\n    {\n    case 'a':\n    case 'A':\n        __get_weekdayname(__tm->tm_wday, __b, __e, __err, __ct);\n        break;\n    case 'b':\n    case 'B':\n    case 'h':\n        __get_monthname(__tm->tm_mon, __b, __e, __err, __ct);\n        break;\n    case 'c':\n        {\n        const string_type& __fm = this->__c();\n        __b = get(__b, __e, __iob, __err, __tm, __fm.data(), __fm.data() + __fm.size());\n        }\n        break;\n    case 'd':\n    case 'e':\n        __get_day(__tm->tm_mday, __b, __e, __err, __ct);\n        break;\n    case 'D':\n        {\n        const char_type __fm[] = {'%', 'm', '/', '%', 'd', '/', '%', 'y'};\n        __b = get(__b, __e, __iob, __err, __tm, __fm, __fm + sizeof(__fm)/sizeof(__fm[0]));\n        }\n        break;\n    case 'F':\n        {\n        const char_type __fm[] = {'%', 'Y', '-', '%', 'm', '-', '%', 'd'};\n        __b = get(__b, __e, __iob, __err, __tm, __fm, __fm + sizeof(__fm)/sizeof(__fm[0]));\n        }\n        break;\n    case 'H':\n        __get_hour(__tm->tm_hour, __b, __e, __err, __ct);\n        break;\n    case 'I':\n        __get_12_hour(__tm->tm_hour, __b, __e, __err, __ct);\n        break;\n    case 'j':\n        __get_day_year_num(__tm->tm_yday, __b, __e, __err, __ct);\n        break;\n    case 'm':\n        __get_month(__tm->tm_mon, __b, __e, __err, __ct);\n        break;\n    case 'M':\n        __get_minute(__tm->tm_min, __b, __e, __err, __ct);\n        break;\n    case 'n':\n    case 't':\n        __get_white_space(__b, __e, __err, __ct);\n        break;\n    case 'p':\n        __get_am_pm(__tm->tm_hour, __b, __e, __err, __ct);\n        break;\n    case 'r':\n        {\n        const char_type __fm[] = {'%', 'I', ':', '%', 'M', ':', '%', 'S', ' ', '%', 'p'};\n        __b = get(__b, __e, __iob, __err, __tm, __fm, __fm + sizeof(__fm)/sizeof(__fm[0]));\n        }\n        break;\n    case 'R':\n        {\n        const char_type __fm[] = {'%', 'H', ':', '%', 'M'};\n        __b = get(__b, __e, __iob, __err, __tm, __fm, __fm + sizeof(__fm)/sizeof(__fm[0]));\n        }\n        break;\n    case 'S':\n        __get_second(__tm->tm_sec, __b, __e, __err, __ct);\n        break;\n    case 'T':\n        {\n        const char_type __fm[] = {'%', 'H', ':', '%', 'M', ':', '%', 'S'};\n        __b = get(__b, __e, __iob, __err, __tm, __fm, __fm + sizeof(__fm)/sizeof(__fm[0]));\n        }\n        break;\n    case 'w':\n        __get_weekday(__tm->tm_wday, __b, __e, __err, __ct);\n        break;\n    case 'x':\n        return do_get_date(__b, __e, __iob, __err, __tm);\n    case 'X':\n        {\n        const string_type& __fm = this->__X();\n        __b = get(__b, __e, __iob, __err, __tm, __fm.data(), __fm.data() + __fm.size());\n        }\n        break;\n    case 'y':\n        __get_year(__tm->tm_year, __b, __e, __err, __ct);\n        break;\n    case 'Y':\n        __get_year4(__tm->tm_year, __b, __e, __err, __ct);\n        break;\n    case '%':\n        __get_percent(__b, __e, __err, __ct);\n        break;\n    default:\n        __err |= ios_base::failbit;\n    }\n    return __b;\n}\n\n_LIBCPP_EXTERN_TEMPLATE2(class _LIBCPP_EXTERN_TEMPLATE_TYPE_VIS time_get<char>)\n_LIBCPP_EXTERN_TEMPLATE2(class _LIBCPP_EXTERN_TEMPLATE_TYPE_VIS time_get<wchar_t>)\n\nclass _LIBCPP_TYPE_VIS __time_get\n{\nprotected:\n    locale_t __loc_;\n\n    __time_get(const char* __nm);\n    __time_get(const string& __nm);\n    ~__time_get();\n};\n\ntemplate <class _CharT>\nclass _LIBCPP_TEMPLATE_VIS __time_get_storage\n    : public __time_get\n{\nprotected:\n    typedef basic_string<_CharT> string_type;\n\n    string_type __weeks_[14];\n    string_type __months_[24];\n    string_type __am_pm_[2];\n    string_type __c_;\n    string_type __r_;\n    string_type __x_;\n    string_type __X_;\n\n    explicit __time_get_storage(const char* __nm);\n    explicit __time_get_storage(const string& __nm);\n\n    _LIBCPP_ALWAYS_INLINE ~__time_get_storage() {}\n\n    time_base::dateorder __do_date_order() const;\n\nprivate:\n    void init(const ctype<_CharT>&);\n    string_type __analyze(char __fmt, const ctype<_CharT>&);\n};\n\ntemplate <class _CharT, class _InputIterator = istreambuf_iterator<_CharT> >\nclass _LIBCPP_TEMPLATE_VIS time_get_byname\n    : public time_get<_CharT, _InputIterator>,\n      private __time_get_storage<_CharT>\n{\npublic:\n    typedef time_base::dateorder    dateorder;\n    typedef _InputIterator          iter_type;\n    typedef _CharT                  char_type;\n    typedef basic_string<char_type> string_type;\n\n    _LIBCPP_INLINE_VISIBILITY\n    explicit time_get_byname(const char* __nm, size_t __refs = 0)\n        : time_get<_CharT, _InputIterator>(__refs),\n          __time_get_storage<_CharT>(__nm) {}\n    _LIBCPP_INLINE_VISIBILITY\n    explicit time_get_byname(const string& __nm, size_t __refs = 0)\n        : time_get<_CharT, _InputIterator>(__refs),\n          __time_get_storage<_CharT>(__nm) {}\n\nprotected:\n    _LIBCPP_INLINE_VISIBILITY\n    ~time_get_byname() {}\n\n    _LIBCPP_INLINE_VISIBILITY\n    virtual dateorder do_date_order() const {return this->__do_date_order();}\nprivate:\n    _LIBCPP_INLINE_VISIBILITY\n    virtual const string_type* __weeks() const  {return this->__weeks_;}\n    _LIBCPP_INLINE_VISIBILITY\n    virtual const string_type* __months() const {return this->__months_;}\n    _LIBCPP_INLINE_VISIBILITY\n    virtual const string_type* __am_pm() const  {return this->__am_pm_;}\n    _LIBCPP_INLINE_VISIBILITY\n    virtual const string_type& __c() const      {return this->__c_;}\n    _LIBCPP_INLINE_VISIBILITY\n    virtual const string_type& __r() const      {return this->__r_;}\n    _LIBCPP_INLINE_VISIBILITY\n    virtual const string_type& __x() const      {return this->__x_;}\n    _LIBCPP_INLINE_VISIBILITY\n    virtual const string_type& __X() const      {return this->__X_;}\n};\n\n_LIBCPP_EXTERN_TEMPLATE2(class _LIBCPP_EXTERN_TEMPLATE_TYPE_VIS time_get_byname<char>)\n_LIBCPP_EXTERN_TEMPLATE2(class _LIBCPP_EXTERN_TEMPLATE_TYPE_VIS time_get_byname<wchar_t>)\n\nclass _LIBCPP_TYPE_VIS __time_put\n{\n    locale_t __loc_;\nprotected:\n    _LIBCPP_ALWAYS_INLINE __time_put() : __loc_(_LIBCPP_GET_C_LOCALE) {}\n    __time_put(const char* __nm);\n    __time_put(const string& __nm);\n    ~__time_put();\n    void __do_put(char* __nb, char*& __ne, const tm* __tm,\n                  char __fmt, char __mod) const;\n    void __do_put(wchar_t* __wb, wchar_t*& __we, const tm* __tm,\n                  char __fmt, char __mod) const;\n};\n\ntemplate <class _CharT, class _OutputIterator = ostreambuf_iterator<_CharT> >\nclass _LIBCPP_TEMPLATE_VIS time_put\n    : public locale::facet,\n      private __time_put\n{\npublic:\n    typedef _CharT char_type;\n    typedef _OutputIterator iter_type;\n\n    _LIBCPP_ALWAYS_INLINE\n    explicit time_put(size_t __refs = 0)\n        : locale::facet(__refs) {}\n\n    iter_type put(iter_type __s, ios_base& __iob, char_type __fl, const tm* __tm,\n                  const char_type* __pb, const char_type* __pe) const;\n\n    _LIBCPP_ALWAYS_INLINE\n    iter_type put(iter_type __s, ios_base& __iob, char_type __fl,\n                  const tm* __tm, char __fmt, char __mod = 0) const\n    {\n        return do_put(__s, __iob, __fl, __tm, __fmt, __mod);\n    }\n\n    static locale::id id;\n\nprotected:\n    _LIBCPP_ALWAYS_INLINE\n    ~time_put() {}\n    virtual iter_type do_put(iter_type __s, ios_base&, char_type, const tm* __tm,\n                             char __fmt, char __mod) const;\n\n    _LIBCPP_ALWAYS_INLINE\n    explicit time_put(const char* __nm, size_t __refs)\n        : locale::facet(__refs),\n          __time_put(__nm) {}\n    _LIBCPP_ALWAYS_INLINE\n    explicit time_put(const string& __nm, size_t __refs)\n        : locale::facet(__refs),\n          __time_put(__nm) {}\n};\n\ntemplate <class _CharT, class _OutputIterator>\nlocale::id\ntime_put<_CharT, _OutputIterator>::id;\n\ntemplate <class _CharT, class _OutputIterator>\n_OutputIterator\ntime_put<_CharT, _OutputIterator>::put(iter_type __s, ios_base& __iob,\n                                       char_type __fl, const tm* __tm,\n                                       const char_type* __pb,\n                                       const char_type* __pe) const\n{\n    const ctype<char_type>& __ct = use_facet<ctype<char_type> >(__iob.getloc());\n    for (; __pb != __pe; ++__pb)\n    {\n        if (__ct.narrow(*__pb, 0) == '%')\n        {\n            if (++__pb == __pe)\n            {\n                *__s++ = __pb[-1];\n                break;\n            }\n            char __mod = 0;\n            char __fmt = __ct.narrow(*__pb, 0);\n            if (__fmt == 'E' || __fmt == 'O')\n            {\n                if (++__pb == __pe)\n                {\n                    *__s++ = __pb[-2];\n                    *__s++ = __pb[-1];\n                    break;\n                }\n                __mod = __fmt;\n                __fmt = __ct.narrow(*__pb, 0);\n            }\n            __s = do_put(__s, __iob, __fl, __tm, __fmt, __mod);\n        }\n        else\n            *__s++ = *__pb;\n    }\n    return __s;\n}\n\ntemplate <class _CharT, class _OutputIterator>\n_OutputIterator\ntime_put<_CharT, _OutputIterator>::do_put(iter_type __s, ios_base&,\n                                          char_type, const tm* __tm,\n                                          char __fmt, char __mod) const\n{\n    char_type __nar[100];\n    char_type* __nb = __nar;\n    char_type* __ne = __nb + 100;\n    __do_put(__nb, __ne, __tm, __fmt, __mod);\n    return _VSTD::copy(__nb, __ne, __s);\n}\n\n_LIBCPP_EXTERN_TEMPLATE2(class _LIBCPP_EXTERN_TEMPLATE_TYPE_VIS time_put<char>)\n_LIBCPP_EXTERN_TEMPLATE2(class _LIBCPP_EXTERN_TEMPLATE_TYPE_VIS time_put<wchar_t>)\n\ntemplate <class _CharT, class _OutputIterator = ostreambuf_iterator<_CharT> >\nclass _LIBCPP_TEMPLATE_VIS time_put_byname\n    : public time_put<_CharT, _OutputIterator>\n{\npublic:\n    _LIBCPP_ALWAYS_INLINE\n    explicit time_put_byname(const char* __nm, size_t __refs = 0)\n        : time_put<_CharT, _OutputIterator>(__nm, __refs) {}\n\n    _LIBCPP_ALWAYS_INLINE\n    explicit time_put_byname(const string& __nm, size_t __refs = 0)\n        : time_put<_CharT, _OutputIterator>(__nm, __refs) {}\n\nprotected:\n    _LIBCPP_ALWAYS_INLINE\n    ~time_put_byname() {}\n};\n\n_LIBCPP_EXTERN_TEMPLATE2(class _LIBCPP_EXTERN_TEMPLATE_TYPE_VIS time_put_byname<char>)\n_LIBCPP_EXTERN_TEMPLATE2(class _LIBCPP_EXTERN_TEMPLATE_TYPE_VIS time_put_byname<wchar_t>)\n\n// money_base\n\nclass _LIBCPP_TYPE_VIS money_base\n{\npublic:\n    enum part {none, space, symbol, sign, value};\n    struct pattern {char field[4];};\n\n    _LIBCPP_ALWAYS_INLINE money_base() {}\n};\n\n// moneypunct\n\ntemplate <class _CharT, bool _International = false>\nclass _LIBCPP_TEMPLATE_VIS moneypunct\n    : public locale::facet,\n      public money_base\n{\npublic:\n    typedef _CharT                  char_type;\n    typedef basic_string<char_type> string_type;\n\n    _LIBCPP_ALWAYS_INLINE\n    explicit moneypunct(size_t __refs = 0)\n        : locale::facet(__refs) {}\n\n    _LIBCPP_ALWAYS_INLINE char_type   decimal_point() const {return do_decimal_point();}\n    _LIBCPP_ALWAYS_INLINE char_type   thousands_sep() const {return do_thousands_sep();}\n    _LIBCPP_ALWAYS_INLINE string      grouping()      const {return do_grouping();}\n    _LIBCPP_ALWAYS_INLINE string_type curr_symbol()   const {return do_curr_symbol();}\n    _LIBCPP_ALWAYS_INLINE string_type positive_sign() const {return do_positive_sign();}\n    _LIBCPP_ALWAYS_INLINE string_type negative_sign() const {return do_negative_sign();}\n    _LIBCPP_ALWAYS_INLINE int         frac_digits()   const {return do_frac_digits();}\n    _LIBCPP_ALWAYS_INLINE pattern     pos_format()    const {return do_pos_format();}\n    _LIBCPP_ALWAYS_INLINE pattern     neg_format()    const {return do_neg_format();}\n\n    static locale::id id;\n    static const bool intl = _International;\n\nprotected:\n    _LIBCPP_ALWAYS_INLINE\n    ~moneypunct() {}\n\n    virtual char_type   do_decimal_point() const {return numeric_limits<char_type>::max();}\n    virtual char_type   do_thousands_sep() const {return numeric_limits<char_type>::max();}\n    virtual string      do_grouping()      const {return string();}\n    virtual string_type do_curr_symbol()   const {return string_type();}\n    virtual string_type do_positive_sign() const {return string_type();}\n    virtual string_type do_negative_sign() const {return string_type(1, '-');}\n    virtual int         do_frac_digits()   const {return 0;}\n    virtual pattern     do_pos_format()    const\n        {pattern __p = {{symbol, sign, none, value}}; return __p;}\n    virtual pattern     do_neg_format()    const\n        {pattern __p = {{symbol, sign, none, value}}; return __p;}\n};\n\ntemplate <class _CharT, bool _International>\nlocale::id\nmoneypunct<_CharT, _International>::id;\n\ntemplate <class _CharT, bool _International>\nconst bool\nmoneypunct<_CharT, _International>::intl;\n\n_LIBCPP_EXTERN_TEMPLATE2(class _LIBCPP_EXTERN_TEMPLATE_TYPE_VIS moneypunct<char, false>)\n_LIBCPP_EXTERN_TEMPLATE2(class _LIBCPP_EXTERN_TEMPLATE_TYPE_VIS moneypunct<char, true>)\n_LIBCPP_EXTERN_TEMPLATE2(class _LIBCPP_EXTERN_TEMPLATE_TYPE_VIS moneypunct<wchar_t, false>)\n_LIBCPP_EXTERN_TEMPLATE2(class _LIBCPP_EXTERN_TEMPLATE_TYPE_VIS moneypunct<wchar_t, true>)\n\n// moneypunct_byname\n\ntemplate <class _CharT, bool _International = false>\nclass _LIBCPP_TEMPLATE_VIS moneypunct_byname\n    : public moneypunct<_CharT, _International>\n{\npublic:\n    typedef money_base::pattern  pattern;\n    typedef _CharT                  char_type;\n    typedef basic_string<char_type> string_type;\n\n    _LIBCPP_ALWAYS_INLINE\n    explicit moneypunct_byname(const char* __nm, size_t __refs = 0)\n        : moneypunct<_CharT, _International>(__refs) {init(__nm);}\n\n    _LIBCPP_ALWAYS_INLINE\n    explicit moneypunct_byname(const string& __nm, size_t __refs = 0)\n        : moneypunct<_CharT, _International>(__refs) {init(__nm.c_str());}\n\nprotected:\n    _LIBCPP_ALWAYS_INLINE\n    ~moneypunct_byname() {}\n\n    virtual char_type   do_decimal_point() const {return __decimal_point_;}\n    virtual char_type   do_thousands_sep() const {return __thousands_sep_;}\n    virtual string      do_grouping()      const {return __grouping_;}\n    virtual string_type do_curr_symbol()   const {return __curr_symbol_;}\n    virtual string_type do_positive_sign() const {return __positive_sign_;}\n    virtual string_type do_negative_sign() const {return __negative_sign_;}\n    virtual int         do_frac_digits()   const {return __frac_digits_;}\n    virtual pattern     do_pos_format()    const {return __pos_format_;}\n    virtual pattern     do_neg_format()    const {return __neg_format_;}\n\nprivate:\n    char_type   __decimal_point_;\n    char_type   __thousands_sep_;\n    string      __grouping_;\n    string_type __curr_symbol_;\n    string_type __positive_sign_;\n    string_type __negative_sign_;\n    int         __frac_digits_;\n    pattern     __pos_format_;\n    pattern     __neg_format_;\n\n    void init(const char*);\n};\n\ntemplate<> void moneypunct_byname<char, false>::init(const char*);\ntemplate<> void moneypunct_byname<char, true>::init(const char*);\ntemplate<> void moneypunct_byname<wchar_t, false>::init(const char*);\ntemplate<> void moneypunct_byname<wchar_t, true>::init(const char*);\n\n_LIBCPP_EXTERN_TEMPLATE2(class _LIBCPP_EXTERN_TEMPLATE_TYPE_VIS moneypunct_byname<char, false>)\n_LIBCPP_EXTERN_TEMPLATE2(class _LIBCPP_EXTERN_TEMPLATE_TYPE_VIS moneypunct_byname<char, true>)\n_LIBCPP_EXTERN_TEMPLATE2(class _LIBCPP_EXTERN_TEMPLATE_TYPE_VIS moneypunct_byname<wchar_t, false>)\n_LIBCPP_EXTERN_TEMPLATE2(class _LIBCPP_EXTERN_TEMPLATE_TYPE_VIS moneypunct_byname<wchar_t, true>)\n\n// money_get\n\ntemplate <class _CharT>\nclass __money_get\n{\nprotected:\n    typedef _CharT                  char_type;\n    typedef basic_string<char_type> string_type;\n\n    _LIBCPP_ALWAYS_INLINE __money_get() {}\n\n    static void __gather_info(bool __intl, const locale& __loc,\n                              money_base::pattern& __pat, char_type& __dp,\n                              char_type& __ts, string& __grp,\n                              string_type& __sym, string_type& __psn,\n                              string_type& __nsn, int& __fd);\n};\n\ntemplate <class _CharT>\nvoid\n__money_get<_CharT>::__gather_info(bool __intl, const locale& __loc,\n                                   money_base::pattern& __pat, char_type& __dp,\n                                   char_type& __ts, string& __grp,\n                                   string_type& __sym, string_type& __psn,\n                                   string_type& __nsn, int& __fd)\n{\n    if (__intl)\n    {\n        const moneypunct<char_type, true>& __mp =\n            use_facet<moneypunct<char_type, true> >(__loc);\n        __pat = __mp.neg_format();\n        __nsn = __mp.negative_sign();\n        __psn = __mp.positive_sign();\n        __dp = __mp.decimal_point();\n        __ts = __mp.thousands_sep();\n        __grp = __mp.grouping();\n        __sym = __mp.curr_symbol();\n        __fd = __mp.frac_digits();\n    }\n    else\n    {\n        const moneypunct<char_type, false>& __mp =\n            use_facet<moneypunct<char_type, false> >(__loc);\n        __pat = __mp.neg_format();\n        __nsn = __mp.negative_sign();\n        __psn = __mp.positive_sign();\n        __dp = __mp.decimal_point();\n        __ts = __mp.thousands_sep();\n        __grp = __mp.grouping();\n        __sym = __mp.curr_symbol();\n        __fd = __mp.frac_digits();\n    }\n}\n\n_LIBCPP_EXTERN_TEMPLATE2(class _LIBCPP_EXTERN_TEMPLATE_TYPE_VIS __money_get<char>)\n_LIBCPP_EXTERN_TEMPLATE2(class _LIBCPP_EXTERN_TEMPLATE_TYPE_VIS __money_get<wchar_t>)\n\ntemplate <class _CharT, class _InputIterator = istreambuf_iterator<_CharT> >\nclass _LIBCPP_TEMPLATE_VIS money_get\n    : public locale::facet,\n      private __money_get<_CharT>\n{\npublic:\n    typedef _CharT                  char_type;\n    typedef _InputIterator          iter_type;\n    typedef basic_string<char_type> string_type;\n\n    _LIBCPP_ALWAYS_INLINE\n    explicit money_get(size_t __refs = 0)\n        : locale::facet(__refs) {}\n\n    _LIBCPP_ALWAYS_INLINE\n    iter_type get(iter_type __b, iter_type __e, bool __intl, ios_base& __iob,\n                  ios_base::iostate& __err, long double& __v) const\n    {\n        return do_get(__b, __e, __intl, __iob, __err, __v);\n    }\n\n    _LIBCPP_ALWAYS_INLINE\n    iter_type get(iter_type __b, iter_type __e, bool __intl, ios_base& __iob,\n                  ios_base::iostate& __err, string_type& __v) const\n    {\n        return do_get(__b, __e, __intl, __iob, __err, __v);\n    }\n\n    static locale::id id;\n\nprotected:\n\n    _LIBCPP_ALWAYS_INLINE\n    ~money_get() {}\n\n    virtual iter_type do_get(iter_type __b, iter_type __e, bool __intl,\n                             ios_base& __iob, ios_base::iostate& __err,\n                             long double& __v) const;\n    virtual iter_type do_get(iter_type __b, iter_type __e, bool __intl,\n                             ios_base& __iob, ios_base::iostate& __err,\n                             string_type& __v) const;\n\nprivate:\n    static bool __do_get(iter_type& __b, iter_type __e,\n                         bool __intl, const locale& __loc,\n                         ios_base::fmtflags __flags, ios_base::iostate& __err,\n                         bool& __neg, const ctype<char_type>& __ct,\n                         unique_ptr<char_type, void(*)(void*)>& __wb,\n                         char_type*& __wn, char_type* __we);\n};\n\ntemplate <class _CharT, class _InputIterator>\nlocale::id\nmoney_get<_CharT, _InputIterator>::id;\n\n_LIBCPP_FUNC_VIS void __do_nothing(void*);\n\ntemplate <class _Tp>\n_LIBCPP_HIDDEN\nvoid\n__double_or_nothing(unique_ptr<_Tp, void(*)(void*)>& __b, _Tp*& __n, _Tp*& __e)\n{\n    bool __owns = __b.get_deleter() != __do_nothing;\n    size_t __cur_cap = static_cast<size_t>(__e-__b.get()) * sizeof(_Tp);\n    size_t __new_cap = __cur_cap < numeric_limits<size_t>::max() / 2 ?\n                       2 * __cur_cap : numeric_limits<size_t>::max();\n    if (__new_cap == 0)\n        __new_cap = sizeof(_Tp);\n    size_t __n_off = static_cast<size_t>(__n - __b.get());\n    _Tp* __t = (_Tp*)realloc(__owns ? __b.get() : 0, __new_cap);\n    if (__t == 0)\n        __throw_bad_alloc();\n    if (__owns)\n        __b.release();\n    __b = unique_ptr<_Tp, void(*)(void*)>(__t, free);\n    __new_cap /= sizeof(_Tp);\n    __n = __b.get() + __n_off;\n    __e = __b.get() + __new_cap;\n}\n\n// true == success\ntemplate <class _CharT, class _InputIterator>\nbool\nmoney_get<_CharT, _InputIterator>::__do_get(iter_type& __b, iter_type __e,\n                                            bool __intl, const locale& __loc,\n                                            ios_base::fmtflags __flags,\n                                            ios_base::iostate& __err,\n                                            bool& __neg,\n                                            const ctype<char_type>& __ct,\n                                            unique_ptr<char_type, void(*)(void*)>& __wb,\n                                            char_type*& __wn, char_type* __we)\n{\n    const unsigned __bz = 100;\n    unsigned __gbuf[__bz];\n    unique_ptr<unsigned, void(*)(void*)> __gb(__gbuf, __do_nothing);\n    unsigned* __gn = __gb.get();\n    unsigned* __ge = __gn + __bz;\n    money_base::pattern __pat;\n    char_type __dp;\n    char_type __ts;\n    string __grp;\n    string_type __sym;\n    string_type __psn;\n    string_type __nsn;\n    // Capture the spaces read into money_base::{space,none} so they\n    // can be compared to initial spaces in __sym.\n    string_type __spaces;\n    int __fd;\n    __money_get<_CharT>::__gather_info(__intl, __loc, __pat, __dp, __ts, __grp,\n                                       __sym, __psn, __nsn, __fd);\n    const string_type* __trailing_sign = 0;\n    __wn = __wb.get();\n    for (unsigned __p = 0; __p < 4 && __b != __e; ++__p)\n    {\n        switch (__pat.field[__p])\n        {\n        case money_base::space:\n            if (__p != 3)\n            {\n                if (__ct.is(ctype_base::space, *__b))\n                    __spaces.push_back(*__b++);\n                else\n                {\n                    __err |= ios_base::failbit;\n                    return false;\n                }\n            }\n            // drop through\n        case money_base::none:\n            if (__p != 3)\n            {\n                while (__b != __e && __ct.is(ctype_base::space, *__b))\n                    __spaces.push_back(*__b++);\n            }\n            break;\n        case money_base::sign:\n            if (__psn.size() + __nsn.size() > 0)\n            {\n                if (__psn.size() == 0 || __nsn.size() == 0)\n                {   // sign is optional\n                    if (__psn.size() > 0)\n                    {   // __nsn.size() == 0\n                        if (*__b == __psn[0])\n                        {\n                            ++__b;\n                            if (__psn.size() > 1)\n                                __trailing_sign = &__psn;\n                        }\n                        else\n                            __neg = true;\n                    }\n                    else if (*__b == __nsn[0])  // __nsn.size() > 0 &&  __psn.size() == 0\n                    {\n                        ++__b;\n                        __neg = true;\n                        if (__nsn.size() > 1)\n                            __trailing_sign = &__nsn;\n                    }\n                }\n                else  // sign is required\n                {\n                    if (*__b == __psn[0])\n                    {\n                        ++__b;\n                        if (__psn.size() > 1)\n                            __trailing_sign = &__psn;\n                    }\n                    else if (*__b == __nsn[0])\n                    {\n                        ++__b;\n                        __neg = true;\n                        if (__nsn.size() > 1)\n                            __trailing_sign = &__nsn;\n                    }\n                    else\n                    {\n                        __err |= ios_base::failbit;\n                        return false;\n                    }\n                }\n            }\n            break;\n        case money_base::symbol:\n            {\n            bool __more_needed = __trailing_sign ||\n                                 (__p < 2)       ||\n                                 (__p == 2 && __pat.field[3] != static_cast<char>(money_base::none));\n            bool __sb = (__flags & ios_base::showbase) != 0;\n            if (__sb || __more_needed)\n            {\n                typename string_type::const_iterator __sym_space_end = __sym.begin();\n                if (__p > 0 && (__pat.field[__p - 1] == money_base::none ||\n                                __pat.field[__p - 1] == money_base::space)) {\n                    // Match spaces we've already read against spaces at\n                    // the beginning of __sym.\n                    while (__sym_space_end != __sym.end() &&\n                           __ct.is(ctype_base::space, *__sym_space_end))\n                        ++__sym_space_end;\n                    const size_t __num_spaces = __sym_space_end - __sym.begin();\n                    if (__num_spaces > __spaces.size() ||\n                        !equal(__spaces.end() - __num_spaces, __spaces.end(),\n                               __sym.begin())) {\n                        // No match. Put __sym_space_end back at the\n                        // beginning of __sym, which will prevent a\n                        // match in the next loop.\n                        __sym_space_end = __sym.begin();\n                    }\n                }\n                typename string_type::const_iterator __sym_curr_char = __sym_space_end;\n                while (__sym_curr_char != __sym.end() && __b != __e &&\n                       *__b == *__sym_curr_char) {\n                    ++__b;\n                    ++__sym_curr_char;\n                }\n                if (__sb && __sym_curr_char != __sym.end())\n                {\n                    __err |= ios_base::failbit;\n                    return false;\n                }\n            }\n            }\n            break;\n        case money_base::value:\n            {\n            unsigned __ng = 0;\n            for (; __b != __e; ++__b)\n            {\n                char_type __c = *__b;\n                if (__ct.is(ctype_base::digit, __c))\n                {\n                    if (__wn == __we)\n                        __double_or_nothing(__wb, __wn, __we);\n                    *__wn++ = __c;\n                    ++__ng;\n                }\n                else if (__grp.size() > 0 && __ng > 0 && __c == __ts)\n                {\n                    if (__gn == __ge)\n                        __double_or_nothing(__gb, __gn, __ge);\n                    *__gn++ = __ng;\n                    __ng = 0;\n                }\n                else\n                    break;\n            }\n            if (__gb.get() != __gn && __ng > 0)\n            {\n                if (__gn == __ge)\n                    __double_or_nothing(__gb, __gn, __ge);\n                *__gn++ = __ng;\n            }\n            if (__fd > 0)\n            {\n                if (__b == __e || *__b != __dp)\n                {\n                    __err |= ios_base::failbit;\n                    return false;\n                }\n                for (++__b; __fd > 0; --__fd, ++__b)\n                {\n                    if (__b == __e || !__ct.is(ctype_base::digit, *__b))\n                    {\n                        __err |= ios_base::failbit;\n                        return false;\n                    }\n                    if (__wn == __we)\n                        __double_or_nothing(__wb, __wn, __we);\n                    *__wn++ = *__b;\n                }\n            }\n            if (__wn == __wb.get())\n            {\n                __err |= ios_base::failbit;\n                return false;\n            }\n            }\n            break;\n        }\n    }\n    if (__trailing_sign)\n    {\n        for (unsigned __i = 1; __i < __trailing_sign->size(); ++__i, ++__b)\n        {\n            if (__b == __e || *__b != (*__trailing_sign)[__i])\n            {\n                __err |= ios_base::failbit;\n                return false;\n            }\n        }\n    }\n    if (__gb.get() != __gn)\n    {\n        ios_base::iostate __et = ios_base::goodbit;\n        __check_grouping(__grp, __gb.get(), __gn, __et);\n        if (__et)\n        {\n            __err |= ios_base::failbit;\n            return false;\n        }\n    }\n    return true;\n}\n\ntemplate <class _CharT, class _InputIterator>\n_InputIterator\nmoney_get<_CharT, _InputIterator>::do_get(iter_type __b, iter_type __e,\n                                          bool __intl, ios_base& __iob,\n                                          ios_base::iostate& __err,\n                                          long double& __v) const\n{\n    const int __bz = 100;\n    char_type __wbuf[__bz];\n    unique_ptr<char_type, void(*)(void*)> __wb(__wbuf, __do_nothing);\n    char_type* __wn;\n    char_type* __we = __wbuf + __bz;\n    locale __loc = __iob.getloc();\n    const ctype<char_type>& __ct = use_facet<ctype<char_type> >(__loc);\n    bool __neg = false;\n    if (__do_get(__b, __e, __intl, __loc, __iob.flags(), __err, __neg, __ct,\n                 __wb, __wn, __we))\n    {\n        const char __src[] = \"0123456789\";\n        char_type __atoms[sizeof(__src)-1];\n        __ct.widen(__src, __src + (sizeof(__src)-1), __atoms);\n        char __nbuf[__bz];\n        char* __nc = __nbuf;\n        unique_ptr<char, void(*)(void*)> __h(0, free);\n        if (__wn - __wb.get() > __bz-2)\n        {\n            __h.reset((char*)malloc(static_cast<size_t>(__wn - __wb.get() + 2)));\n            if (__h.get() == 0)\n                __throw_bad_alloc();\n            __nc = __h.get();\n        }\n        if (__neg)\n            *__nc++ = '-';\n        for (const char_type* __w = __wb.get(); __w < __wn; ++__w, ++__nc)\n            *__nc = __src[find(__atoms, _VSTD::end(__atoms), *__w) - __atoms];\n        *__nc = char();\n        if (sscanf(__nbuf, \"%Lf\", &__v) != 1)\n            __throw_runtime_error(\"money_get error\");\n    }\n    if (__b == __e)\n        __err |= ios_base::eofbit;\n    return __b;\n}\n\ntemplate <class _CharT, class _InputIterator>\n_InputIterator\nmoney_get<_CharT, _InputIterator>::do_get(iter_type __b, iter_type __e,\n                                          bool __intl, ios_base& __iob,\n                                          ios_base::iostate& __err,\n                                          string_type& __v) const\n{\n    const int __bz = 100;\n    char_type __wbuf[__bz];\n    unique_ptr<char_type, void(*)(void*)> __wb(__wbuf, __do_nothing);\n    char_type* __wn;\n    char_type* __we = __wbuf + __bz;\n    locale __loc = __iob.getloc();\n    const ctype<char_type>& __ct = use_facet<ctype<char_type> >(__loc);\n    bool __neg = false;\n    if (__do_get(__b, __e, __intl, __loc, __iob.flags(), __err, __neg, __ct,\n                 __wb, __wn, __we))\n    {\n        __v.clear();\n        if (__neg)\n            __v.push_back(__ct.widen('-'));\n        char_type __z = __ct.widen('0');\n        char_type* __w;\n        for (__w = __wb.get(); __w < __wn-1; ++__w)\n            if (*__w != __z)\n                break;\n        __v.append(__w, __wn);\n    }\n    if (__b == __e)\n        __err |= ios_base::eofbit;\n    return __b;\n}\n\n_LIBCPP_EXTERN_TEMPLATE2(class _LIBCPP_EXTERN_TEMPLATE_TYPE_VIS money_get<char>)\n_LIBCPP_EXTERN_TEMPLATE2(class _LIBCPP_EXTERN_TEMPLATE_TYPE_VIS money_get<wchar_t>)\n\n// money_put\n\ntemplate <class _CharT>\nclass __money_put\n{\nprotected:\n    typedef _CharT                  char_type;\n    typedef basic_string<char_type> string_type;\n\n    _LIBCPP_ALWAYS_INLINE __money_put() {}\n\n    static void __gather_info(bool __intl, bool __neg, const locale& __loc,\n                              money_base::pattern& __pat, char_type& __dp,\n                              char_type& __ts, string& __grp,\n                              string_type& __sym, string_type& __sn,\n                              int& __fd);\n    static void __format(char_type* __mb, char_type*& __mi, char_type*& __me,\n                         ios_base::fmtflags __flags,\n                         const char_type* __db, const char_type* __de,\n                         const ctype<char_type>& __ct, bool __neg,\n                         const money_base::pattern& __pat, char_type __dp,\n                         char_type __ts, const string& __grp,\n                         const string_type& __sym, const string_type& __sn,\n                         int __fd);\n};\n\ntemplate <class _CharT>\nvoid\n__money_put<_CharT>::__gather_info(bool __intl, bool __neg, const locale& __loc,\n                                   money_base::pattern& __pat, char_type& __dp,\n                                   char_type& __ts, string& __grp,\n                                   string_type& __sym, string_type& __sn,\n                                   int& __fd)\n{\n    if (__intl)\n    {\n        const moneypunct<char_type, true>& __mp =\n            use_facet<moneypunct<char_type, true> >(__loc);\n        if (__neg)\n        {\n            __pat = __mp.neg_format();\n            __sn = __mp.negative_sign();\n        }\n        else\n        {\n            __pat = __mp.pos_format();\n            __sn = __mp.positive_sign();\n        }\n        __dp = __mp.decimal_point();\n        __ts = __mp.thousands_sep();\n        __grp = __mp.grouping();\n        __sym = __mp.curr_symbol();\n        __fd = __mp.frac_digits();\n    }\n    else\n    {\n        const moneypunct<char_type, false>& __mp =\n            use_facet<moneypunct<char_type, false> >(__loc);\n        if (__neg)\n        {\n            __pat = __mp.neg_format();\n            __sn = __mp.negative_sign();\n        }\n        else\n        {\n            __pat = __mp.pos_format();\n            __sn = __mp.positive_sign();\n        }\n        __dp = __mp.decimal_point();\n        __ts = __mp.thousands_sep();\n        __grp = __mp.grouping();\n        __sym = __mp.curr_symbol();\n        __fd = __mp.frac_digits();\n    }\n}\n\ntemplate <class _CharT>\nvoid\n__money_put<_CharT>::__format(char_type* __mb, char_type*& __mi, char_type*& __me,\n                              ios_base::fmtflags __flags,\n                              const char_type* __db, const char_type* __de,\n                              const ctype<char_type>& __ct, bool __neg,\n                              const money_base::pattern& __pat, char_type __dp,\n                              char_type __ts, const string& __grp,\n                              const string_type& __sym, const string_type& __sn,\n                              int __fd)\n{\n    __me = __mb;\n    for (unsigned __p = 0; __p < 4; ++__p)\n    {\n        switch (__pat.field[__p])\n        {\n        case money_base::none:\n            __mi = __me;\n            break;\n        case money_base::space:\n            __mi = __me;\n            *__me++ = __ct.widen(' ');\n            break;\n        case money_base::sign:\n            if (!__sn.empty())\n                *__me++ = __sn[0];\n            break;\n        case money_base::symbol:\n            if (!__sym.empty() && (__flags & ios_base::showbase))\n                __me = _VSTD::copy(__sym.begin(), __sym.end(), __me);\n            break;\n        case money_base::value:\n            {\n            // remember start of value so we can reverse it\n            char_type* __t = __me;\n            // find beginning of digits\n            if (__neg)\n                ++__db;\n            // find end of digits\n            const char_type* __d;\n            for (__d = __db; __d < __de; ++__d)\n                if (!__ct.is(ctype_base::digit, *__d))\n                    break;\n            // print fractional part\n            if (__fd > 0)\n            {\n                int __f;\n                for (__f = __fd; __d > __db && __f > 0; --__f)\n                    *__me++ = *--__d;\n                char_type __z = __f > 0 ? __ct.widen('0') : char_type();\n                for (; __f > 0; --__f)\n                    *__me++ = __z;\n                *__me++ = __dp;\n            }\n            // print units part\n            if (__d == __db)\n            {\n                *__me++ = __ct.widen('0');\n            }\n            else\n            {\n                unsigned __ng = 0;\n                unsigned __ig = 0;\n                unsigned __gl = __grp.empty() ? numeric_limits<unsigned>::max()\n                                              : static_cast<unsigned>(__grp[__ig]);\n                while (__d != __db)\n                {\n                    if (__ng == __gl)\n                    {\n                        *__me++ = __ts;\n                        __ng = 0;\n                        if (++__ig < __grp.size())\n                            __gl = __grp[__ig] == numeric_limits<char>::max() ?\n                                        numeric_limits<unsigned>::max() :\n                                        static_cast<unsigned>(__grp[__ig]);\n                    }\n                    *__me++ = *--__d;\n                    ++__ng;\n                }\n            }\n            // reverse it\n            reverse(__t, __me);\n            }\n            break;\n        }\n    }\n    // print rest of sign, if any\n    if (__sn.size() > 1)\n        __me = _VSTD::copy(__sn.begin()+1, __sn.end(), __me);\n    // set alignment\n    if ((__flags & ios_base::adjustfield) == ios_base::left)\n        __mi = __me;\n    else if ((__flags & ios_base::adjustfield) != ios_base::internal)\n        __mi = __mb;\n}\n\n_LIBCPP_EXTERN_TEMPLATE2(class _LIBCPP_EXTERN_TEMPLATE_TYPE_VIS __money_put<char>)\n_LIBCPP_EXTERN_TEMPLATE2(class _LIBCPP_EXTERN_TEMPLATE_TYPE_VIS __money_put<wchar_t>)\n\ntemplate <class _CharT, class _OutputIterator = ostreambuf_iterator<_CharT> >\nclass _LIBCPP_TEMPLATE_VIS money_put\n    : public locale::facet,\n      private __money_put<_CharT>\n{\npublic:\n    typedef _CharT                  char_type;\n    typedef _OutputIterator         iter_type;\n    typedef basic_string<char_type> string_type;\n\n    _LIBCPP_ALWAYS_INLINE\n    explicit money_put(size_t __refs = 0)\n        : locale::facet(__refs) {}\n\n    _LIBCPP_ALWAYS_INLINE\n    iter_type put(iter_type __s, bool __intl, ios_base& __iob, char_type __fl,\n                  long double __units) const\n    {\n        return do_put(__s, __intl, __iob, __fl, __units);\n    }\n\n    _LIBCPP_ALWAYS_INLINE\n    iter_type put(iter_type __s, bool __intl, ios_base& __iob, char_type __fl,\n                  const string_type& __digits) const\n    {\n        return do_put(__s, __intl, __iob, __fl, __digits);\n    }\n\n    static locale::id id;\n\nprotected:\n    _LIBCPP_ALWAYS_INLINE\n    ~money_put() {}\n\n    virtual iter_type do_put(iter_type __s, bool __intl, ios_base& __iob,\n                             char_type __fl, long double __units) const;\n    virtual iter_type do_put(iter_type __s, bool __intl, ios_base& __iob,\n                             char_type __fl, const string_type& __digits) const;\n};\n\ntemplate <class _CharT, class _OutputIterator>\nlocale::id\nmoney_put<_CharT, _OutputIterator>::id;\n\ntemplate <class _CharT, class _OutputIterator>\n_OutputIterator\nmoney_put<_CharT, _OutputIterator>::do_put(iter_type __s, bool __intl,\n                                           ios_base& __iob, char_type __fl,\n                                           long double __units) const\n{\n    // convert to char\n    const size_t __bs = 100;\n    char __buf[__bs];\n    char* __bb = __buf;\n    char_type __digits[__bs];\n    char_type* __db = __digits;\n    size_t __n = static_cast<size_t>(snprintf(__bb, __bs, \"%.0Lf\", __units));\n    unique_ptr<char, void(*)(void*)> __hn(0, free);\n    unique_ptr<char_type, void(*)(void*)> __hd(0, free);\n    // secure memory for digit storage\n    if (__n > __bs-1)\n    {\n        __n = static_cast<size_t>(__libcpp_asprintf_l(&__bb, _LIBCPP_GET_C_LOCALE, \"%.0Lf\", __units));\n        if (__bb == 0)\n            __throw_bad_alloc();\n        __hn.reset(__bb);\n        __hd.reset((char_type*)malloc(__n * sizeof(char_type)));\n        if (__hd == nullptr)\n            __throw_bad_alloc();\n        __db = __hd.get();\n    }\n    // gather info\n    locale __loc = __iob.getloc();\n    const ctype<char_type>& __ct = use_facet<ctype<char_type> >(__loc);\n    __ct.widen(__bb, __bb + __n, __db);\n    bool __neg = __n > 0 && __bb[0] == '-';\n    money_base::pattern __pat;\n    char_type __dp;\n    char_type __ts;\n    string __grp;\n    string_type __sym;\n    string_type __sn;\n    int __fd;\n    this->__gather_info(__intl, __neg, __loc, __pat, __dp, __ts, __grp, __sym, __sn, __fd);\n    // secure memory for formatting\n    char_type __mbuf[__bs];\n    char_type* __mb = __mbuf;\n    unique_ptr<char_type, void(*)(void*)> __hw(0, free);\n    size_t __exn = static_cast<int>(__n) > __fd ?\n                   (__n - static_cast<size_t>(__fd)) * 2 + __sn.size() +\n                    __sym.size() + static_cast<size_t>(__fd) + 1\n                 : __sn.size() + __sym.size() + static_cast<size_t>(__fd) + 2;\n    if (__exn > __bs)\n    {\n        __hw.reset((char_type*)malloc(__exn * sizeof(char_type)));\n        __mb = __hw.get();\n        if (__mb == 0)\n            __throw_bad_alloc();\n    }\n    // format\n    char_type* __mi;\n    char_type* __me;\n    this->__format(__mb, __mi, __me, __iob.flags(),\n                   __db, __db + __n, __ct,\n                   __neg, __pat, __dp, __ts, __grp, __sym, __sn, __fd);\n    return __pad_and_output(__s, __mb, __mi, __me, __iob, __fl);\n}\n\ntemplate <class _CharT, class _OutputIterator>\n_OutputIterator\nmoney_put<_CharT, _OutputIterator>::do_put(iter_type __s, bool __intl,\n                                           ios_base& __iob, char_type __fl,\n                                           const string_type& __digits) const\n{\n    // gather info\n    locale __loc = __iob.getloc();\n    const ctype<char_type>& __ct = use_facet<ctype<char_type> >(__loc);\n    bool __neg = __digits.size() > 0 && __digits[0] == __ct.widen('-');\n    money_base::pattern __pat;\n    char_type __dp;\n    char_type __ts;\n    string __grp;\n    string_type __sym;\n    string_type __sn;\n    int __fd;\n    this->__gather_info(__intl, __neg, __loc, __pat, __dp, __ts, __grp, __sym, __sn, __fd);\n    // secure memory for formatting\n    char_type __mbuf[100];\n    char_type* __mb = __mbuf;\n    unique_ptr<char_type, void(*)(void*)> __h(0, free);\n    size_t __exn = static_cast<int>(__digits.size()) > __fd ?\n                   (__digits.size() - static_cast<size_t>(__fd)) * 2 +\n                    __sn.size() + __sym.size() + static_cast<size_t>(__fd) + 1\n                 : __sn.size() + __sym.size() + static_cast<size_t>(__fd) + 2;\n    if (__exn > 100)\n    {\n        __h.reset((char_type*)malloc(__exn * sizeof(char_type)));\n        __mb = __h.get();\n        if (__mb == 0)\n            __throw_bad_alloc();\n    }\n    // format\n    char_type* __mi;\n    char_type* __me;\n    this->__format(__mb, __mi, __me, __iob.flags(),\n                   __digits.data(), __digits.data() + __digits.size(), __ct,\n                   __neg, __pat, __dp, __ts, __grp, __sym, __sn, __fd);\n    return __pad_and_output(__s, __mb, __mi, __me, __iob, __fl);\n}\n\n_LIBCPP_EXTERN_TEMPLATE2(class _LIBCPP_EXTERN_TEMPLATE_TYPE_VIS money_put<char>)\n_LIBCPP_EXTERN_TEMPLATE2(class _LIBCPP_EXTERN_TEMPLATE_TYPE_VIS money_put<wchar_t>)\n\n// messages\n\nclass _LIBCPP_TYPE_VIS messages_base\n{\npublic:\n    typedef ptrdiff_t catalog;\n\n    _LIBCPP_ALWAYS_INLINE messages_base() {}\n};\n\ntemplate <class _CharT>\nclass _LIBCPP_TEMPLATE_VIS messages\n    : public locale::facet,\n      public messages_base\n{\npublic:\n    typedef _CharT               char_type;\n    typedef basic_string<_CharT> string_type;\n\n    _LIBCPP_ALWAYS_INLINE\n    explicit messages(size_t __refs = 0)\n        : locale::facet(__refs) {}\n\n    _LIBCPP_ALWAYS_INLINE\n    catalog open(const basic_string<char>& __nm, const locale& __loc) const\n    {\n        return do_open(__nm, __loc);\n    }\n\n    _LIBCPP_ALWAYS_INLINE\n    string_type get(catalog __c, int __set, int __msgid,\n                    const string_type& __dflt) const\n    {\n        return do_get(__c, __set, __msgid, __dflt);\n    }\n\n    _LIBCPP_ALWAYS_INLINE\n    void close(catalog __c) const\n    {\n        do_close(__c);\n    }\n\n    static locale::id id;\n\nprotected:\n    _LIBCPP_ALWAYS_INLINE\n    ~messages() {}\n\n    virtual catalog do_open(const basic_string<char>&, const locale&) const;\n    virtual string_type do_get(catalog, int __set, int __msgid,\n                               const string_type& __dflt) const;\n    virtual void do_close(catalog) const;\n};\n\ntemplate <class _CharT>\nlocale::id\nmessages<_CharT>::id;\n\ntemplate <class _CharT>\ntypename messages<_CharT>::catalog\nmessages<_CharT>::do_open(const basic_string<char>& __nm, const locale&) const\n{\n#ifdef _LIBCPP_HAS_CATOPEN\n    catalog __cat = (catalog)catopen(__nm.c_str(), NL_CAT_LOCALE);\n    if (__cat != -1)\n        __cat = static_cast<catalog>((static_cast<size_t>(__cat) >> 1));\n    return __cat;\n#else // !_LIBCPP_HAS_CATOPEN\n    return -1;\n#endif // _LIBCPP_HAS_CATOPEN\n}\n\ntemplate <class _CharT>\ntypename messages<_CharT>::string_type\nmessages<_CharT>::do_get(catalog __c, int __set, int __msgid,\n                         const string_type& __dflt) const\n{\n#ifdef _LIBCPP_HAS_CATOPEN\n    string __ndflt;\n    __narrow_to_utf8<sizeof(char_type)*__CHAR_BIT__>()(back_inserter(__ndflt),\n                                                       __dflt.c_str(),\n                                                       __dflt.c_str() + __dflt.size());\n    if (__c != -1)\n        __c <<= 1;\n    nl_catd __cat = (nl_catd)__c;\n    char* __n = catgets(__cat, __set, __msgid, __ndflt.c_str());\n    string_type __w;\n    __widen_from_utf8<sizeof(char_type)*__CHAR_BIT__>()(back_inserter(__w),\n                                                        __n, __n + strlen(__n));\n    return __w;\n#else // !_LIBCPP_HAS_CATOPEN\n    return __dflt;\n#endif // _LIBCPP_HAS_CATOPEN\n}\n\ntemplate <class _CharT>\nvoid\nmessages<_CharT>::do_close(catalog __c) const\n{\n#ifdef _LIBCPP_HAS_CATOPEN\n    if (__c != -1)\n        __c <<= 1;\n    nl_catd __cat = (nl_catd)__c;\n    catclose(__cat);\n#endif // _LIBCPP_HAS_CATOPEN\n}\n\n_LIBCPP_EXTERN_TEMPLATE2(class _LIBCPP_EXTERN_TEMPLATE_TYPE_VIS messages<char>)\n_LIBCPP_EXTERN_TEMPLATE2(class _LIBCPP_EXTERN_TEMPLATE_TYPE_VIS messages<wchar_t>)\n\ntemplate <class _CharT>\nclass _LIBCPP_TEMPLATE_VIS messages_byname\n    : public messages<_CharT>\n{\npublic:\n    typedef messages_base::catalog catalog;\n    typedef basic_string<_CharT> string_type;\n\n    _LIBCPP_ALWAYS_INLINE\n    explicit messages_byname(const char*, size_t __refs = 0)\n        : messages<_CharT>(__refs) {}\n\n    _LIBCPP_ALWAYS_INLINE\n    explicit messages_byname(const string&, size_t __refs = 0)\n        : messages<_CharT>(__refs) {}\n\nprotected:\n    _LIBCPP_ALWAYS_INLINE\n    ~messages_byname() {}\n};\n\n_LIBCPP_EXTERN_TEMPLATE2(class _LIBCPP_EXTERN_TEMPLATE_TYPE_VIS messages_byname<char>)\n_LIBCPP_EXTERN_TEMPLATE2(class _LIBCPP_EXTERN_TEMPLATE_TYPE_VIS messages_byname<wchar_t>)\n\ntemplate<class _Codecvt, class _Elem = wchar_t,\n         class _Wide_alloc = allocator<_Elem>,\n         class _Byte_alloc = allocator<char> >\nclass _LIBCPP_TEMPLATE_VIS wstring_convert\n{\npublic:\n    typedef basic_string<char, char_traits<char>, _Byte_alloc>   byte_string;\n    typedef basic_string<_Elem, char_traits<_Elem>, _Wide_alloc> wide_string;\n    typedef typename _Codecvt::state_type                        state_type;\n    typedef typename wide_string::traits_type::int_type          int_type;\n\nprivate:\n    byte_string __byte_err_string_;\n    wide_string __wide_err_string_;\n    _Codecvt* __cvtptr_;\n    state_type __cvtstate_;\n    size_t __cvtcount_;\n\n    wstring_convert(const wstring_convert& __wc);\n    wstring_convert& operator=(const wstring_convert& __wc);\npublic:\n    _LIBCPP_ALWAYS_INLINE\n    _LIBCPP_EXPLICIT_AFTER_CXX11 wstring_convert(_Codecvt* __pcvt = new _Codecvt);\n    _LIBCPP_ALWAYS_INLINE\n    wstring_convert(_Codecvt* __pcvt, state_type __state);\n    _LIBCPP_EXPLICIT_AFTER_CXX11 wstring_convert(const byte_string& __byte_err,\n                    const wide_string& __wide_err = wide_string());\n#ifndef _LIBCPP_HAS_NO_RVALUE_REFERENCES\n    _LIBCPP_ALWAYS_INLINE\n    wstring_convert(wstring_convert&& __wc);\n#endif\n    ~wstring_convert();\n\n    _LIBCPP_ALWAYS_INLINE\n    wide_string from_bytes(char __byte)\n        {return from_bytes(&__byte, &__byte+1);}\n    _LIBCPP_ALWAYS_INLINE\n    wide_string from_bytes(const char* __ptr)\n        {return from_bytes(__ptr, __ptr + char_traits<char>::length(__ptr));}\n    _LIBCPP_ALWAYS_INLINE\n    wide_string from_bytes(const byte_string& __str)\n        {return from_bytes(__str.data(), __str.data() + __str.size());}\n    wide_string from_bytes(const char* __first, const char* __last);\n\n    _LIBCPP_ALWAYS_INLINE\n    byte_string to_bytes(_Elem __wchar)\n        {return to_bytes(&__wchar, &__wchar+1);}\n    _LIBCPP_ALWAYS_INLINE\n    byte_string to_bytes(const _Elem* __wptr)\n        {return to_bytes(__wptr, __wptr + char_traits<_Elem>::length(__wptr));}\n    _LIBCPP_ALWAYS_INLINE\n    byte_string to_bytes(const wide_string& __wstr)\n        {return to_bytes(__wstr.data(), __wstr.data() + __wstr.size());}\n    byte_string to_bytes(const _Elem* __first, const _Elem* __last);\n\n    _LIBCPP_ALWAYS_INLINE\n    size_t converted() const _NOEXCEPT {return __cvtcount_;}\n    _LIBCPP_ALWAYS_INLINE\n    state_type state() const {return __cvtstate_;}\n};\n\ntemplate<class _Codecvt, class _Elem, class _Wide_alloc, class _Byte_alloc>\ninline\nwstring_convert<_Codecvt, _Elem, _Wide_alloc, _Byte_alloc>::\n    wstring_convert(_Codecvt* __pcvt)\n        : __cvtptr_(__pcvt), __cvtstate_(), __cvtcount_(0)\n{\n}\n\ntemplate<class _Codecvt, class _Elem, class _Wide_alloc, class _Byte_alloc>\ninline\nwstring_convert<_Codecvt, _Elem, _Wide_alloc, _Byte_alloc>::\n    wstring_convert(_Codecvt* __pcvt, state_type __state)\n        : __cvtptr_(__pcvt), __cvtstate_(__state), __cvtcount_(0)\n{\n}\n\ntemplate<class _Codecvt, class _Elem, class _Wide_alloc, class _Byte_alloc>\nwstring_convert<_Codecvt, _Elem, _Wide_alloc, _Byte_alloc>::\n    wstring_convert(const byte_string& __byte_err, const wide_string& __wide_err)\n        : __byte_err_string_(__byte_err), __wide_err_string_(__wide_err),\n          __cvtstate_(), __cvtcount_(0)\n{\n    __cvtptr_ = new _Codecvt;\n}\n\n#ifndef _LIBCPP_HAS_NO_RVALUE_REFERENCES\n\ntemplate<class _Codecvt, class _Elem, class _Wide_alloc, class _Byte_alloc>\ninline\nwstring_convert<_Codecvt, _Elem, _Wide_alloc, _Byte_alloc>::\n    wstring_convert(wstring_convert&& __wc)\n        : __byte_err_string_(_VSTD::move(__wc.__byte_err_string_)),\n          __wide_err_string_(_VSTD::move(__wc.__wide_err_string_)),\n          __cvtptr_(__wc.__cvtptr_),\n          __cvtstate_(__wc.__cvtstate_), __cvtcount_(__wc.__cvtcount_)\n{\n    __wc.__cvtptr_ = nullptr;\n}\n\n#endif  // _LIBCPP_HAS_NO_RVALUE_REFERENCES\n\ntemplate<class _Codecvt, class _Elem, class _Wide_alloc, class _Byte_alloc>\nwstring_convert<_Codecvt, _Elem, _Wide_alloc, _Byte_alloc>::~wstring_convert()\n{\n    delete __cvtptr_;\n}\n\ntemplate<class _Codecvt, class _Elem, class _Wide_alloc, class _Byte_alloc>\ntypename wstring_convert<_Codecvt, _Elem, _Wide_alloc, _Byte_alloc>::wide_string\nwstring_convert<_Codecvt, _Elem, _Wide_alloc, _Byte_alloc>::\n    from_bytes(const char* __frm, const char* __frm_end)\n{\n    __cvtcount_ = 0;\n    if (__cvtptr_ != nullptr)\n    {\n        wide_string __ws(2*(__frm_end - __frm), _Elem());\n        if (__frm != __frm_end)\n            __ws.resize(__ws.capacity());\n        codecvt_base::result __r = codecvt_base::ok;\n        state_type __st = __cvtstate_;\n        if (__frm != __frm_end)\n        {\n            _Elem* __to = &__ws[0];\n            _Elem* __to_end = __to + __ws.size();\n            const char* __frm_nxt;\n            do\n            {\n                _Elem* __to_nxt;\n                __r = __cvtptr_->in(__st, __frm, __frm_end, __frm_nxt,\n                                          __to, __to_end, __to_nxt);\n                __cvtcount_ += __frm_nxt - __frm;\n                if (__frm_nxt == __frm)\n                {\n                    __r = codecvt_base::error;\n                }\n                else if (__r == codecvt_base::noconv)\n                {\n                    __ws.resize(__to - &__ws[0]);\n                    // This only gets executed if _Elem is char\n                    __ws.append((const _Elem*)__frm, (const _Elem*)__frm_end);\n                    __frm = __frm_nxt;\n                    __r = codecvt_base::ok;\n                }\n                else if (__r == codecvt_base::ok)\n                {\n                    __ws.resize(__to_nxt - &__ws[0]);\n                    __frm = __frm_nxt;\n                }\n                else if (__r == codecvt_base::partial)\n                {\n                    ptrdiff_t __s = __to_nxt - &__ws[0];\n                    __ws.resize(2 * __s);\n                    __to = &__ws[0] + __s;\n                    __to_end = &__ws[0] + __ws.size();\n                    __frm = __frm_nxt;\n                }\n            } while (__r == codecvt_base::partial && __frm_nxt < __frm_end);\n        }\n        if (__r == codecvt_base::ok)\n            return __ws;\n    }\n\n    if (__wide_err_string_.empty())\n        __throw_range_error(\"wstring_convert: from_bytes error\");\n\n    return __wide_err_string_;\n}\n\ntemplate<class _Codecvt, class _Elem, class _Wide_alloc, class _Byte_alloc>\ntypename wstring_convert<_Codecvt, _Elem, _Wide_alloc, _Byte_alloc>::byte_string\nwstring_convert<_Codecvt, _Elem, _Wide_alloc, _Byte_alloc>::\n    to_bytes(const _Elem* __frm, const _Elem* __frm_end)\n{\n    __cvtcount_ = 0;\n    if (__cvtptr_ != nullptr)\n    {\n        byte_string __bs(2*(__frm_end - __frm), char());\n        if (__frm != __frm_end)\n            __bs.resize(__bs.capacity());\n        codecvt_base::result __r = codecvt_base::ok;\n        state_type __st = __cvtstate_;\n        if (__frm != __frm_end)\n        {\n            char* __to = &__bs[0];\n            char* __to_end = __to + __bs.size();\n            const _Elem* __frm_nxt;\n            do\n            {\n                char* __to_nxt;\n                __r = __cvtptr_->out(__st, __frm, __frm_end, __frm_nxt,\n                                           __to, __to_end, __to_nxt);\n                __cvtcount_ += __frm_nxt - __frm;\n                if (__frm_nxt == __frm)\n                {\n                    __r = codecvt_base::error;\n                }\n                else if (__r == codecvt_base::noconv)\n                {\n                    __bs.resize(__to - &__bs[0]);\n                    // This only gets executed if _Elem is char\n                    __bs.append((const char*)__frm, (const char*)__frm_end);\n                    __frm = __frm_nxt;\n                    __r = codecvt_base::ok;\n                }\n                else if (__r == codecvt_base::ok)\n                {\n                    __bs.resize(__to_nxt - &__bs[0]);\n                    __frm = __frm_nxt;\n                }\n                else if (__r == codecvt_base::partial)\n                {\n                    ptrdiff_t __s = __to_nxt - &__bs[0];\n                    __bs.resize(2 * __s);\n                    __to = &__bs[0] + __s;\n                    __to_end = &__bs[0] + __bs.size();\n                    __frm = __frm_nxt;\n                }\n            } while (__r == codecvt_base::partial && __frm_nxt < __frm_end);\n        }\n        if (__r == codecvt_base::ok)\n        {\n            size_t __s = __bs.size();\n            __bs.resize(__bs.capacity());\n            char* __to = &__bs[0] + __s;\n            char* __to_end = __to + __bs.size();\n            do\n            {\n                char* __to_nxt;\n                __r = __cvtptr_->unshift(__st, __to, __to_end, __to_nxt);\n                if (__r == codecvt_base::noconv)\n                {\n                    __bs.resize(__to - &__bs[0]);\n                    __r = codecvt_base::ok;\n                }\n                else if (__r == codecvt_base::ok)\n                {\n                    __bs.resize(__to_nxt - &__bs[0]);\n                }\n                else if (__r == codecvt_base::partial)\n                {\n                    ptrdiff_t __sp = __to_nxt - &__bs[0];\n                    __bs.resize(2 * __sp);\n                    __to = &__bs[0] + __sp;\n                    __to_end = &__bs[0] + __bs.size();\n                }\n            } while (__r == codecvt_base::partial);\n            if (__r == codecvt_base::ok)\n                return __bs;\n        }\n    }\n\n    if (__byte_err_string_.empty())\n        __throw_range_error(\"wstring_convert: to_bytes error\");\n\n    return __byte_err_string_;\n}\n\ntemplate <class _Codecvt, class _Elem = wchar_t, class _Tr = char_traits<_Elem> >\nclass _LIBCPP_TEMPLATE_VIS wbuffer_convert\n    : public basic_streambuf<_Elem, _Tr>\n{\npublic:\n    // types:\n    typedef _Elem                          char_type;\n    typedef _Tr                            traits_type;\n    typedef typename traits_type::int_type int_type;\n    typedef typename traits_type::pos_type pos_type;\n    typedef typename traits_type::off_type off_type;\n    typedef typename _Codecvt::state_type  state_type;\n\nprivate:\n    char*       __extbuf_;\n    const char* __extbufnext_;\n    const char* __extbufend_;\n    char __extbuf_min_[8];\n    size_t __ebs_;\n    char_type* __intbuf_;\n    size_t __ibs_;\n    streambuf* __bufptr_;\n    _Codecvt* __cv_;\n    state_type __st_;\n    ios_base::openmode __cm_;\n    bool __owns_eb_;\n    bool __owns_ib_;\n    bool __always_noconv_;\n\n    wbuffer_convert(const wbuffer_convert&);\n    wbuffer_convert& operator=(const wbuffer_convert&);\npublic:\n    _LIBCPP_EXPLICIT_AFTER_CXX11 wbuffer_convert(streambuf* __bytebuf = 0, \n            _Codecvt* __pcvt = new _Codecvt, state_type __state = state_type());\n    ~wbuffer_convert();\n\n    _LIBCPP_INLINE_VISIBILITY\n    streambuf* rdbuf() const {return __bufptr_;}\n    _LIBCPP_INLINE_VISIBILITY\n    streambuf* rdbuf(streambuf* __bytebuf)\n    {\n        streambuf* __r = __bufptr_;\n        __bufptr_ = __bytebuf;\n        return __r;\n    }\n\n    _LIBCPP_INLINE_VISIBILITY\n    state_type state() const {return __st_;}\n\nprotected:\n    virtual int_type underflow();\n    virtual int_type pbackfail(int_type __c = traits_type::eof());\n    virtual int_type overflow (int_type __c = traits_type::eof());\n    virtual basic_streambuf<char_type, traits_type>* setbuf(char_type* __s,\n                                                            streamsize __n);\n    virtual pos_type seekoff(off_type __off, ios_base::seekdir __way,\n                             ios_base::openmode __wch = ios_base::in | ios_base::out);\n    virtual pos_type seekpos(pos_type __sp,\n                             ios_base::openmode __wch = ios_base::in | ios_base::out);\n    virtual int sync();\n\nprivate:\n    bool __read_mode();\n    void __write_mode();\n    wbuffer_convert* __close();\n};\n\ntemplate <class _Codecvt, class _Elem, class _Tr>\nwbuffer_convert<_Codecvt, _Elem, _Tr>::\n    wbuffer_convert(streambuf* __bytebuf, _Codecvt* __pcvt, state_type __state)\n    : __extbuf_(0),\n      __extbufnext_(0),\n      __extbufend_(0),\n      __ebs_(0),\n      __intbuf_(0),\n      __ibs_(0),\n      __bufptr_(__bytebuf),\n      __cv_(__pcvt),\n      __st_(__state),\n      __cm_(0),\n      __owns_eb_(false),\n      __owns_ib_(false),\n      __always_noconv_(__cv_ ? __cv_->always_noconv() : false)\n{\n    setbuf(0, 4096);\n}\n\ntemplate <class _Codecvt, class _Elem, class _Tr>\nwbuffer_convert<_Codecvt, _Elem, _Tr>::~wbuffer_convert()\n{\n    __close();\n    delete __cv_;\n    if (__owns_eb_)\n        delete [] __extbuf_;\n    if (__owns_ib_)\n        delete [] __intbuf_;\n}\n\ntemplate <class _Codecvt, class _Elem, class _Tr>\ntypename wbuffer_convert<_Codecvt, _Elem, _Tr>::int_type\nwbuffer_convert<_Codecvt, _Elem, _Tr>::underflow()\n{\n    if (__cv_ == 0 || __bufptr_ == 0)\n        return traits_type::eof();\n    bool __initial = __read_mode();\n    char_type __1buf;\n    if (this->gptr() == 0)\n        this->setg(&__1buf, &__1buf+1, &__1buf+1);\n    const size_t __unget_sz = __initial ? 0 : min<size_t>((this->egptr() - this->eback()) / 2, 4);\n    int_type __c = traits_type::eof();\n    if (this->gptr() == this->egptr())\n    {\n        memmove(this->eback(), this->egptr() - __unget_sz, __unget_sz * sizeof(char_type));\n        if (__always_noconv_)\n        {\n            streamsize __nmemb = static_cast<streamsize>(this->egptr() - this->eback() - __unget_sz);\n            __nmemb = __bufptr_->sgetn((char*)this->eback() + __unget_sz, __nmemb);\n            if (__nmemb != 0)\n            {\n                this->setg(this->eback(),\n                           this->eback() + __unget_sz,\n                           this->eback() + __unget_sz + __nmemb);\n                __c = *this->gptr();\n            }\n        }\n        else\n        {\n             _LIBCPP_ASSERT(!(__extbufnext_ == NULL && (__extbufend_ != __extbufnext_)), \"underflow moving from NULL\" );\n             if (__extbufend_ != __extbufnext_)\n                memmove(__extbuf_, __extbufnext_, __extbufend_ - __extbufnext_);\n            __extbufnext_ = __extbuf_ + (__extbufend_ - __extbufnext_);\n            __extbufend_ = __extbuf_ + (__extbuf_ == __extbuf_min_ ? sizeof(__extbuf_min_) : __ebs_);\n            streamsize __nmemb = _VSTD::min(static_cast<streamsize>(this->egptr() - this->eback() - __unget_sz),\n                                 static_cast<streamsize>(__extbufend_ - __extbufnext_));\n            codecvt_base::result __r;\n            // FIXME: Do we ever need to restore the state here?\n            //state_type __svs = __st_;\n            streamsize __nr = __bufptr_->sgetn(const_cast<char*>(__extbufnext_), __nmemb);\n            if (__nr != 0)\n            {\n                __extbufend_ = __extbufnext_ + __nr;\n                char_type*  __inext;\n                __r = __cv_->in(__st_, __extbuf_, __extbufend_, __extbufnext_,\n                                       this->eback() + __unget_sz,\n                                       this->egptr(), __inext);\n                if (__r == codecvt_base::noconv)\n                {\n                    this->setg((char_type*)__extbuf_, (char_type*)__extbuf_, (char_type*)__extbufend_);\n                    __c = *this->gptr();\n                }\n                else if (__inext != this->eback() + __unget_sz)\n                {\n                    this->setg(this->eback(), this->eback() + __unget_sz, __inext);\n                    __c = *this->gptr();\n                }\n            }\n        }\n    }\n    else\n        __c = *this->gptr();\n    if (this->eback() == &__1buf)\n        this->setg(0, 0, 0);\n    return __c;\n}\n\ntemplate <class _Codecvt, class _Elem, class _Tr>\ntypename wbuffer_convert<_Codecvt, _Elem, _Tr>::int_type\nwbuffer_convert<_Codecvt, _Elem, _Tr>::pbackfail(int_type __c)\n{\n    if (__cv_ != 0 && __bufptr_ != 0 && this->eback() < this->gptr())\n    {\n        if (traits_type::eq_int_type(__c, traits_type::eof()))\n        {\n            this->gbump(-1);\n            return traits_type::not_eof(__c);\n        }\n        if (traits_type::eq(traits_type::to_char_type(__c), this->gptr()[-1]))\n        {\n            this->gbump(-1);\n            *this->gptr() = traits_type::to_char_type(__c);\n            return __c;\n        }\n    }\n    return traits_type::eof();\n}\n\ntemplate <class _Codecvt, class _Elem, class _Tr>\ntypename wbuffer_convert<_Codecvt, _Elem, _Tr>::int_type\nwbuffer_convert<_Codecvt, _Elem, _Tr>::overflow(int_type __c)\n{\n    if (__cv_ == 0 || __bufptr_ == 0)\n        return traits_type::eof();\n    __write_mode();\n    char_type __1buf;\n    char_type* __pb_save = this->pbase();\n    char_type* __epb_save = this->epptr();\n    if (!traits_type::eq_int_type(__c, traits_type::eof()))\n    {\n        if (this->pptr() == 0)\n            this->setp(&__1buf, &__1buf+1);\n        *this->pptr() = traits_type::to_char_type(__c);\n        this->pbump(1);\n    }\n    if (this->pptr() != this->pbase())\n    {\n        if (__always_noconv_)\n        {\n            streamsize __nmemb = static_cast<streamsize>(this->pptr() - this->pbase());\n            if (__bufptr_->sputn((const char*)this->pbase(), __nmemb) != __nmemb)\n                return traits_type::eof();\n        }\n        else\n        {\n            char* __extbe = __extbuf_;\n            codecvt_base::result __r;\n            do\n            {\n                const char_type* __e;\n                __r = __cv_->out(__st_, this->pbase(), this->pptr(), __e,\n                                        __extbuf_, __extbuf_ + __ebs_, __extbe);\n                if (__e == this->pbase())\n                    return traits_type::eof();\n                if (__r == codecvt_base::noconv)\n                {\n                    streamsize __nmemb = static_cast<size_t>(this->pptr() - this->pbase());\n                    if (__bufptr_->sputn((const char*)this->pbase(), __nmemb) != __nmemb)\n                        return traits_type::eof();\n                }\n                else if (__r == codecvt_base::ok || __r == codecvt_base::partial)\n                {\n                    streamsize __nmemb = static_cast<size_t>(__extbe - __extbuf_);\n                    if (__bufptr_->sputn(__extbuf_, __nmemb) != __nmemb)\n                        return traits_type::eof();\n                    if (__r == codecvt_base::partial)\n                    {\n                        this->setp((char_type*)__e, this->pptr());\n                        this->pbump(this->epptr() - this->pbase());\n                    }\n                }\n                else\n                    return traits_type::eof();\n            } while (__r == codecvt_base::partial);\n        }\n        this->setp(__pb_save, __epb_save);\n    }\n    return traits_type::not_eof(__c);\n}\n\ntemplate <class _Codecvt, class _Elem, class _Tr>\nbasic_streambuf<_Elem, _Tr>*\nwbuffer_convert<_Codecvt, _Elem, _Tr>::setbuf(char_type* __s, streamsize __n)\n{\n    this->setg(0, 0, 0);\n    this->setp(0, 0);\n    if (__owns_eb_)\n        delete [] __extbuf_;\n    if (__owns_ib_)\n        delete [] __intbuf_;\n    __ebs_ = __n;\n    if (__ebs_ > sizeof(__extbuf_min_))\n    {\n        if (__always_noconv_ && __s)\n        {\n            __extbuf_ = (char*)__s;\n            __owns_eb_ = false;\n        }\n        else\n        {\n            __extbuf_ = new char[__ebs_];\n            __owns_eb_ = true;\n        }\n    }\n    else\n    {\n        __extbuf_ = __extbuf_min_;\n        __ebs_ = sizeof(__extbuf_min_);\n        __owns_eb_ = false;\n    }\n    if (!__always_noconv_)\n    {\n        __ibs_ = max<streamsize>(__n, sizeof(__extbuf_min_));\n        if (__s && __ibs_ >= sizeof(__extbuf_min_))\n        {\n            __intbuf_ = __s;\n            __owns_ib_ = false;\n        }\n        else\n        {\n            __intbuf_ = new char_type[__ibs_];\n            __owns_ib_ = true;\n        }\n    }\n    else\n    {\n        __ibs_ = 0;\n        __intbuf_ = 0;\n        __owns_ib_ = false;\n    }\n    return this;\n}\n\ntemplate <class _Codecvt, class _Elem, class _Tr>\ntypename wbuffer_convert<_Codecvt, _Elem, _Tr>::pos_type\nwbuffer_convert<_Codecvt, _Elem, _Tr>::seekoff(off_type __off, ios_base::seekdir __way,\n                                        ios_base::openmode __om)\n{\n    int __width = __cv_->encoding();\n    if (__cv_ == 0 || __bufptr_ == 0 || (__width <= 0 && __off != 0) || sync())\n        return pos_type(off_type(-1));\n    // __width > 0 || __off == 0, now check __way\n    if (__way != ios_base::beg && __way != ios_base::cur && __way != ios_base::end)\n        return pos_type(off_type(-1));\n    pos_type __r = __bufptr_->pubseekoff(__width * __off, __way, __om);\n    __r.state(__st_);\n    return __r;\n}\n\ntemplate <class _Codecvt, class _Elem, class _Tr>\ntypename wbuffer_convert<_Codecvt, _Elem, _Tr>::pos_type\nwbuffer_convert<_Codecvt, _Elem, _Tr>::seekpos(pos_type __sp, ios_base::openmode __wch)\n{\n    if (__cv_ == 0 || __bufptr_ == 0 || sync())\n        return pos_type(off_type(-1));\n    if (__bufptr_->pubseekpos(__sp, __wch) == pos_type(off_type(-1)))\n        return pos_type(off_type(-1));\n    return __sp;\n}\n\ntemplate <class _Codecvt, class _Elem, class _Tr>\nint\nwbuffer_convert<_Codecvt, _Elem, _Tr>::sync()\n{\n    if (__cv_ == 0 || __bufptr_ == 0)\n        return 0;\n    if (__cm_ & ios_base::out)\n    {\n        if (this->pptr() != this->pbase())\n            if (overflow() == traits_type::eof())\n                return -1;\n        codecvt_base::result __r;\n        do\n        {\n            char* __extbe;\n            __r = __cv_->unshift(__st_, __extbuf_, __extbuf_ + __ebs_, __extbe);\n            streamsize __nmemb = static_cast<streamsize>(__extbe - __extbuf_);\n            if (__bufptr_->sputn(__extbuf_, __nmemb) != __nmemb)\n                return -1;\n        } while (__r == codecvt_base::partial);\n        if (__r == codecvt_base::error)\n            return -1;\n        if (__bufptr_->pubsync())\n            return -1;\n    }\n    else if (__cm_ & ios_base::in)\n    {\n        off_type __c;\n        if (__always_noconv_)\n            __c = this->egptr() - this->gptr();\n        else\n        {\n            int __width = __cv_->encoding();\n            __c = __extbufend_ - __extbufnext_;\n            if (__width > 0)\n                __c += __width * (this->egptr() - this->gptr());\n            else\n            {\n                if (this->gptr() != this->egptr())\n                {\n                    reverse(this->gptr(), this->egptr());\n                    codecvt_base::result __r;\n                    const char_type* __e = this->gptr();\n                    char* __extbe;\n                    do\n                    {\n                        __r = __cv_->out(__st_, __e, this->egptr(), __e,\n                                         __extbuf_, __extbuf_ + __ebs_, __extbe);\n                        switch (__r)\n                        {\n                        case codecvt_base::noconv:\n                            __c += this->egptr() - this->gptr();\n                            break;\n                        case codecvt_base::ok:\n                        case codecvt_base::partial:\n                            __c += __extbe - __extbuf_;\n                            break;\n                        default:\n                            return -1;\n                        }\n                    } while (__r == codecvt_base::partial);\n                }\n            }\n        }\n        if (__bufptr_->pubseekoff(-__c, ios_base::cur, __cm_) == pos_type(off_type(-1)))\n            return -1;\n        this->setg(0, 0, 0);\n        __cm_ = 0;\n    }\n    return 0;\n}\n\ntemplate <class _Codecvt, class _Elem, class _Tr>\nbool\nwbuffer_convert<_Codecvt, _Elem, _Tr>::__read_mode()\n{\n    if (!(__cm_ & ios_base::in))\n    {\n        this->setp(0, 0);\n        if (__always_noconv_)\n            this->setg((char_type*)__extbuf_,\n                       (char_type*)__extbuf_ + __ebs_,\n                       (char_type*)__extbuf_ + __ebs_);\n        else\n            this->setg(__intbuf_, __intbuf_ + __ibs_, __intbuf_ + __ibs_);\n        __cm_ = ios_base::in;\n        return true;\n    }\n    return false;\n}\n\ntemplate <class _Codecvt, class _Elem, class _Tr>\nvoid\nwbuffer_convert<_Codecvt, _Elem, _Tr>::__write_mode()\n{\n    if (!(__cm_ & ios_base::out))\n    {\n        this->setg(0, 0, 0);\n        if (__ebs_ > sizeof(__extbuf_min_))\n        {\n            if (__always_noconv_)\n                this->setp((char_type*)__extbuf_,\n                           (char_type*)__extbuf_ + (__ebs_ - 1));\n            else\n                this->setp(__intbuf_, __intbuf_ + (__ibs_ - 1));\n        }\n        else\n            this->setp(0, 0);\n        __cm_ = ios_base::out;\n    }\n}\n\ntemplate <class _Codecvt, class _Elem, class _Tr>\nwbuffer_convert<_Codecvt, _Elem, _Tr>*\nwbuffer_convert<_Codecvt, _Elem, _Tr>::__close()\n{\n    wbuffer_convert* __rt = 0;\n    if (__cv_ != 0 && __bufptr_ != 0)\n    {\n        __rt = this;\n        if ((__cm_ & ios_base::out) && sync())\n            __rt = 0;\n    }\n    return __rt;\n}\n\n_LIBCPP_END_NAMESPACE_STD\n\n#endif  // _LIBCPP_LOCALE\n","// -*- C++ -*-\n//===---------------------------- math.h ----------------------------------===//\n//\n//                     The LLVM Compiler Infrastructure\n//\n// This file is dual licensed under the MIT and the University of Illinois Open\n// Source Licenses. See LICENSE.TXT for details.\n//\n//===----------------------------------------------------------------------===//\n\n#ifndef _LIBCPP_MATH_H\n#define _LIBCPP_MATH_H\n\n/*\n    math.h synopsis\n\nMacros:\n\n    HUGE_VAL\n    HUGE_VALF               // C99\n    HUGE_VALL               // C99\n    INFINITY                // C99\n    NAN                     // C99\n    FP_INFINITE             // C99\n    FP_NAN                  // C99\n    FP_NORMAL               // C99\n    FP_SUBNORMAL            // C99\n    FP_ZERO                 // C99\n    FP_FAST_FMA             // C99\n    FP_FAST_FMAF            // C99\n    FP_FAST_FMAL            // C99\n    FP_ILOGB0               // C99\n    FP_ILOGBNAN             // C99\n    MATH_ERRNO              // C99\n    MATH_ERREXCEPT          // C99\n    math_errhandling        // C99\n\nTypes:\n\n    float_t                 // C99\n    double_t                // C99\n\n// C90\n\nfloating_point abs(floating_point x);\n\nfloating_point acos (arithmetic x);\nfloat          acosf(float x);\nlong double    acosl(long double x);\n\nfloating_point asin (arithmetic x);\nfloat          asinf(float x);\nlong double    asinl(long double x);\n\nfloating_point atan (arithmetic x);\nfloat          atanf(float x);\nlong double    atanl(long double x);\n\nfloating_point atan2 (arithmetic y, arithmetic x);\nfloat          atan2f(float y, float x);\nlong double    atan2l(long double y, long double x);\n\nfloating_point ceil (arithmetic x);\nfloat          ceilf(float x);\nlong double    ceill(long double x);\n\nfloating_point cos (arithmetic x);\nfloat          cosf(float x);\nlong double    cosl(long double x);\n\nfloating_point cosh (arithmetic x);\nfloat          coshf(float x);\nlong double    coshl(long double x);\n\nfloating_point exp (arithmetic x);\nfloat          expf(float x);\nlong double    expl(long double x);\n\nfloating_point fabs (arithmetic x);\nfloat          fabsf(float x);\nlong double    fabsl(long double x);\n\nfloating_point floor (arithmetic x);\nfloat          floorf(float x);\nlong double    floorl(long double x);\n\nfloating_point fmod (arithmetic x, arithmetic y);\nfloat          fmodf(float x, float y);\nlong double    fmodl(long double x, long double y);\n\nfloating_point frexp (arithmetic value, int* exp);\nfloat          frexpf(float value, int* exp);\nlong double    frexpl(long double value, int* exp);\n\nfloating_point ldexp (arithmetic value, int exp);\nfloat          ldexpf(float value, int exp);\nlong double    ldexpl(long double value, int exp);\n\nfloating_point log (arithmetic x);\nfloat          logf(float x);\nlong double    logl(long double x);\n\nfloating_point log10 (arithmetic x);\nfloat          log10f(float x);\nlong double    log10l(long double x);\n\nfloating_point modf (floating_point value, floating_point* iptr);\nfloat          modff(float value, float* iptr);\nlong double    modfl(long double value, long double* iptr);\n\nfloating_point pow (arithmetic x, arithmetic y);\nfloat          powf(float x, float y);\nlong double    powl(long double x, long double y);\n\nfloating_point sin (arithmetic x);\nfloat          sinf(float x);\nlong double    sinl(long double x);\n\nfloating_point sinh (arithmetic x);\nfloat          sinhf(float x);\nlong double    sinhl(long double x);\n\nfloating_point sqrt (arithmetic x);\nfloat          sqrtf(float x);\nlong double    sqrtl(long double x);\n\nfloating_point tan (arithmetic x);\nfloat          tanf(float x);\nlong double    tanl(long double x);\n\nfloating_point tanh (arithmetic x);\nfloat          tanhf(float x);\nlong double    tanhl(long double x);\n\n//  C99\n\nbool signbit(arithmetic x);\n\nint fpclassify(arithmetic x);\n\nbool isfinite(arithmetic x);\nbool isinf(arithmetic x);\nbool isnan(arithmetic x);\nbool isnormal(arithmetic x);\n\nbool isgreater(arithmetic x, arithmetic y);\nbool isgreaterequal(arithmetic x, arithmetic y);\nbool isless(arithmetic x, arithmetic y);\nbool islessequal(arithmetic x, arithmetic y);\nbool islessgreater(arithmetic x, arithmetic y);\nbool isunordered(arithmetic x, arithmetic y);\n\nfloating_point acosh (arithmetic x);\nfloat          acoshf(float x);\nlong double    acoshl(long double x);\n\nfloating_point asinh (arithmetic x);\nfloat          asinhf(float x);\nlong double    asinhl(long double x);\n\nfloating_point atanh (arithmetic x);\nfloat          atanhf(float x);\nlong double    atanhl(long double x);\n\nfloating_point cbrt (arithmetic x);\nfloat          cbrtf(float x);\nlong double    cbrtl(long double x);\n\nfloating_point copysign (arithmetic x, arithmetic y);\nfloat          copysignf(float x, float y);\nlong double    copysignl(long double x, long double y);\n\nfloating_point erf (arithmetic x);\nfloat          erff(float x);\nlong double    erfl(long double x);\n\nfloating_point erfc (arithmetic x);\nfloat          erfcf(float x);\nlong double    erfcl(long double x);\n\nfloating_point exp2 (arithmetic x);\nfloat          exp2f(float x);\nlong double    exp2l(long double x);\n\nfloating_point expm1 (arithmetic x);\nfloat          expm1f(float x);\nlong double    expm1l(long double x);\n\nfloating_point fdim (arithmetic x, arithmetic y);\nfloat          fdimf(float x, float y);\nlong double    fdiml(long double x, long double y);\n\nfloating_point fma (arithmetic x, arithmetic y, arithmetic z);\nfloat          fmaf(float x, float y, float z);\nlong double    fmal(long double x, long double y, long double z);\n\nfloating_point fmax (arithmetic x, arithmetic y);\nfloat          fmaxf(float x, float y);\nlong double    fmaxl(long double x, long double y);\n\nfloating_point fmin (arithmetic x, arithmetic y);\nfloat          fminf(float x, float y);\nlong double    fminl(long double x, long double y);\n\nfloating_point hypot (arithmetic x, arithmetic y);\nfloat          hypotf(float x, float y);\nlong double    hypotl(long double x, long double y);\n\nint ilogb (arithmetic x);\nint ilogbf(float x);\nint ilogbl(long double x);\n\nfloating_point lgamma (arithmetic x);\nfloat          lgammaf(float x);\nlong double    lgammal(long double x);\n\nlong long llrint (arithmetic x);\nlong long llrintf(float x);\nlong long llrintl(long double x);\n\nlong long llround (arithmetic x);\nlong long llroundf(float x);\nlong long llroundl(long double x);\n\nfloating_point log1p (arithmetic x);\nfloat          log1pf(float x);\nlong double    log1pl(long double x);\n\nfloating_point log2 (arithmetic x);\nfloat          log2f(float x);\nlong double    log2l(long double x);\n\nfloating_point logb (arithmetic x);\nfloat          logbf(float x);\nlong double    logbl(long double x);\n\nlong lrint (arithmetic x);\nlong lrintf(float x);\nlong lrintl(long double x);\n\nlong lround (arithmetic x);\nlong lroundf(float x);\nlong lroundl(long double x);\n\ndouble      nan (const char* str);\nfloat       nanf(const char* str);\nlong double nanl(const char* str);\n\nfloating_point nearbyint (arithmetic x);\nfloat          nearbyintf(float x);\nlong double    nearbyintl(long double x);\n\nfloating_point nextafter (arithmetic x, arithmetic y);\nfloat          nextafterf(float x, float y);\nlong double    nextafterl(long double x, long double y);\n\nfloating_point nexttoward (arithmetic x, long double y);\nfloat          nexttowardf(float x, long double y);\nlong double    nexttowardl(long double x, long double y);\n\nfloating_point remainder (arithmetic x, arithmetic y);\nfloat          remainderf(float x, float y);\nlong double    remainderl(long double x, long double y);\n\nfloating_point remquo (arithmetic x, arithmetic y, int* pquo);\nfloat          remquof(float x, float y, int* pquo);\nlong double    remquol(long double x, long double y, int* pquo);\n\nfloating_point rint (arithmetic x);\nfloat          rintf(float x);\nlong double    rintl(long double x);\n\nfloating_point round (arithmetic x);\nfloat          roundf(float x);\nlong double    roundl(long double x);\n\nfloating_point scalbln (arithmetic x, long ex);\nfloat          scalblnf(float x, long ex);\nlong double    scalblnl(long double x, long ex);\n\nfloating_point scalbn (arithmetic x, int ex);\nfloat          scalbnf(float x, int ex);\nlong double    scalbnl(long double x, int ex);\n\nfloating_point tgamma (arithmetic x);\nfloat          tgammaf(float x);\nlong double    tgammal(long double x);\n\nfloating_point trunc (arithmetic x);\nfloat          truncf(float x);\nlong double    truncl(long double x);\n\n*/\n\n#include <__config>\n\n#if !defined(_LIBCPP_HAS_NO_PRAGMA_SYSTEM_HEADER)\n#pragma GCC system_header\n#endif\n\n#include_next <math.h>\n\n#ifdef __cplusplus\n\n// We support including .h headers inside 'extern \"C\"' contexts, so switch\n// back to C++ linkage before including these C++ headers.\nextern \"C++\" {\n\n#include <type_traits>\n\n// signbit\n\n#ifdef signbit\n\ntemplate <class _A1>\n_LIBCPP_ALWAYS_INLINE\nbool\n__libcpp_signbit(_A1 __lcpp_x) _NOEXCEPT\n{\n    return signbit(__lcpp_x);\n}\n\n#undef signbit\n\ntemplate <class _A1>\ninline _LIBCPP_INLINE_VISIBILITY\ntypename std::enable_if<std::is_arithmetic<_A1>::value, bool>::type\nsignbit(_A1 __lcpp_x) _NOEXCEPT\n{\n    return __libcpp_signbit((typename std::__promote<_A1>::type)__lcpp_x);\n}\n\n#endif  // signbit\n\n// fpclassify\n\n#ifdef fpclassify\n\ntemplate <class _A1>\n_LIBCPP_ALWAYS_INLINE\nint\n__libcpp_fpclassify(_A1 __lcpp_x) _NOEXCEPT\n{\n    return fpclassify(__lcpp_x);\n}\n\n#undef fpclassify\n\ntemplate <class _A1>\ninline _LIBCPP_INLINE_VISIBILITY\ntypename std::enable_if<std::is_arithmetic<_A1>::value, int>::type\nfpclassify(_A1 __lcpp_x) _NOEXCEPT\n{\n    return __libcpp_fpclassify((typename std::__promote<_A1>::type)__lcpp_x);\n}\n\n#endif  // fpclassify\n\n// isfinite\n\n#ifdef isfinite\n\ntemplate <class _A1>\n_LIBCPP_ALWAYS_INLINE\nbool\n__libcpp_isfinite(_A1 __lcpp_x) _NOEXCEPT\n{\n    return isfinite(__lcpp_x);\n}\n\n#undef isfinite\n\ntemplate <class _A1>\ninline _LIBCPP_INLINE_VISIBILITY\ntypename std::enable_if<std::is_arithmetic<_A1>::value, bool>::type\nisfinite(_A1 __lcpp_x) _NOEXCEPT\n{\n    return __libcpp_isfinite((typename std::__promote<_A1>::type)__lcpp_x);\n}\n\n#endif  // isfinite\n\n// isinf\n\n#ifdef isinf\n\ntemplate <class _A1>\n_LIBCPP_ALWAYS_INLINE\nbool\n__libcpp_isinf(_A1 __lcpp_x) _NOEXCEPT\n{\n    return isinf(__lcpp_x);\n}\n\n#undef isinf\n\ntemplate <class _A1>\ninline _LIBCPP_INLINE_VISIBILITY\ntypename std::enable_if<std::is_arithmetic<_A1>::value, bool>::type\nisinf(_A1 __lcpp_x) _NOEXCEPT\n{\n    return __libcpp_isinf((typename std::__promote<_A1>::type)__lcpp_x);\n}\n\n#endif  // isinf\n\n// isnan\n\n#ifdef isnan\n\ntemplate <class _A1>\n_LIBCPP_ALWAYS_INLINE\nbool\n__libcpp_isnan(_A1 __lcpp_x) _NOEXCEPT\n{\n    return isnan(__lcpp_x);\n}\n\n#undef isnan\n\ntemplate <class _A1>\ninline _LIBCPP_INLINE_VISIBILITY\ntypename std::enable_if<std::is_arithmetic<_A1>::value, bool>::type\nisnan(_A1 __lcpp_x) _NOEXCEPT\n{\n    return __libcpp_isnan((typename std::__promote<_A1>::type)__lcpp_x);\n}\n\n#endif  // isnan\n\n// isnormal\n\n#ifdef isnormal\n\ntemplate <class _A1>\n_LIBCPP_ALWAYS_INLINE\nbool\n__libcpp_isnormal(_A1 __lcpp_x) _NOEXCEPT\n{\n    return isnormal(__lcpp_x);\n}\n\n#undef isnormal\n\ntemplate <class _A1>\ninline _LIBCPP_INLINE_VISIBILITY\ntypename std::enable_if<std::is_arithmetic<_A1>::value, bool>::type\nisnormal(_A1 __lcpp_x) _NOEXCEPT\n{\n    return __libcpp_isnormal((typename std::__promote<_A1>::type)__lcpp_x);\n}\n\n#endif  // isnormal\n\n// isgreater\n\n#ifdef isgreater\n\ntemplate <class _A1, class _A2>\n_LIBCPP_ALWAYS_INLINE\nbool\n__libcpp_isgreater(_A1 __lcpp_x, _A2 __lcpp_y) _NOEXCEPT\n{\n    return isgreater(__lcpp_x, __lcpp_y);\n}\n\n#undef isgreater\n\ntemplate <class _A1, class _A2>\ninline _LIBCPP_INLINE_VISIBILITY\ntypename std::enable_if\n<\n    std::is_arithmetic<_A1>::value &&\n    std::is_arithmetic<_A2>::value,\n    bool\n>::type\nisgreater(_A1 __lcpp_x, _A2 __lcpp_y) _NOEXCEPT\n{\n    typedef typename std::__promote<_A1, _A2>::type type;\n    return __libcpp_isgreater((type)__lcpp_x, (type)__lcpp_y);\n}\n\n#endif  // isgreater\n\n// isgreaterequal\n\n#ifdef isgreaterequal\n\ntemplate <class _A1, class _A2>\n_LIBCPP_ALWAYS_INLINE\nbool\n__libcpp_isgreaterequal(_A1 __lcpp_x, _A2 __lcpp_y) _NOEXCEPT\n{\n    return isgreaterequal(__lcpp_x, __lcpp_y);\n}\n\n#undef isgreaterequal\n\ntemplate <class _A1, class _A2>\ninline _LIBCPP_INLINE_VISIBILITY\ntypename std::enable_if\n<\n    std::is_arithmetic<_A1>::value &&\n    std::is_arithmetic<_A2>::value,\n    bool\n>::type\nisgreaterequal(_A1 __lcpp_x, _A2 __lcpp_y) _NOEXCEPT\n{\n    typedef typename std::__promote<_A1, _A2>::type type;\n    return __libcpp_isgreaterequal((type)__lcpp_x, (type)__lcpp_y);\n}\n\n#endif  // isgreaterequal\n\n// isless\n\n#ifdef isless\n\ntemplate <class _A1, class _A2>\n_LIBCPP_ALWAYS_INLINE\nbool\n__libcpp_isless(_A1 __lcpp_x, _A2 __lcpp_y) _NOEXCEPT\n{\n    return isless(__lcpp_x, __lcpp_y);\n}\n\n#undef isless\n\ntemplate <class _A1, class _A2>\ninline _LIBCPP_INLINE_VISIBILITY\ntypename std::enable_if\n<\n    std::is_arithmetic<_A1>::value &&\n    std::is_arithmetic<_A2>::value,\n    bool\n>::type\nisless(_A1 __lcpp_x, _A2 __lcpp_y) _NOEXCEPT\n{\n    typedef typename std::__promote<_A1, _A2>::type type;\n    return __libcpp_isless((type)__lcpp_x, (type)__lcpp_y);\n}\n\n#endif  // isless\n\n// islessequal\n\n#ifdef islessequal\n\ntemplate <class _A1, class _A2>\n_LIBCPP_ALWAYS_INLINE\nbool\n__libcpp_islessequal(_A1 __lcpp_x, _A2 __lcpp_y) _NOEXCEPT\n{\n    return islessequal(__lcpp_x, __lcpp_y);\n}\n\n#undef islessequal\n\ntemplate <class _A1, class _A2>\ninline _LIBCPP_INLINE_VISIBILITY\ntypename std::enable_if\n<\n    std::is_arithmetic<_A1>::value &&\n    std::is_arithmetic<_A2>::value,\n    bool\n>::type\nislessequal(_A1 __lcpp_x, _A2 __lcpp_y) _NOEXCEPT\n{\n    typedef typename std::__promote<_A1, _A2>::type type;\n    return __libcpp_islessequal((type)__lcpp_x, (type)__lcpp_y);\n}\n\n#endif  // islessequal\n\n// islessgreater\n\n#ifdef islessgreater\n\ntemplate <class _A1, class _A2>\n_LIBCPP_ALWAYS_INLINE\nbool\n__libcpp_islessgreater(_A1 __lcpp_x, _A2 __lcpp_y) _NOEXCEPT\n{\n    return islessgreater(__lcpp_x, __lcpp_y);\n}\n\n#undef islessgreater\n\ntemplate <class _A1, class _A2>\ninline _LIBCPP_INLINE_VISIBILITY\ntypename std::enable_if\n<\n    std::is_arithmetic<_A1>::value &&\n    std::is_arithmetic<_A2>::value,\n    bool\n>::type\nislessgreater(_A1 __lcpp_x, _A2 __lcpp_y) _NOEXCEPT\n{\n    typedef typename std::__promote<_A1, _A2>::type type;\n    return __libcpp_islessgreater((type)__lcpp_x, (type)__lcpp_y);\n}\n\n#endif  // islessgreater\n\n// isunordered\n\n#ifdef isunordered\n\ntemplate <class _A1, class _A2>\n_LIBCPP_ALWAYS_INLINE\nbool\n__libcpp_isunordered(_A1 __lcpp_x, _A2 __lcpp_y) _NOEXCEPT\n{\n    return isunordered(__lcpp_x, __lcpp_y);\n}\n\n#undef isunordered\n\ntemplate <class _A1, class _A2>\ninline _LIBCPP_INLINE_VISIBILITY\ntypename std::enable_if\n<\n    std::is_arithmetic<_A1>::value &&\n    std::is_arithmetic<_A2>::value,\n    bool\n>::type\nisunordered(_A1 __lcpp_x, _A2 __lcpp_y) _NOEXCEPT\n{\n    typedef typename std::__promote<_A1, _A2>::type type;\n    return __libcpp_isunordered((type)__lcpp_x, (type)__lcpp_y);\n}\n\n#endif  // isunordered\n\n// abs\n\n#if !(defined(_AIX) || defined(__sun__))\ninline _LIBCPP_INLINE_VISIBILITY\nfloat\nabs(float __lcpp_x) _NOEXCEPT {return fabsf(__lcpp_x);}\n\ninline _LIBCPP_INLINE_VISIBILITY\ndouble\nabs(double __lcpp_x) _NOEXCEPT {return fabs(__lcpp_x);}\n\ninline _LIBCPP_INLINE_VISIBILITY\nlong double\nabs(long double __lcpp_x) _NOEXCEPT {return fabsl(__lcpp_x);}\n#endif // !(defined(_AIX) || defined(__sun__))\n\n// acos\n\n#if !(defined(_LIBCPP_MSVCRT) || defined(_AIX) || defined(__sun__))\ninline _LIBCPP_INLINE_VISIBILITY float       acos(float __lcpp_x) _NOEXCEPT       {return acosf(__lcpp_x);}\ninline _LIBCPP_INLINE_VISIBILITY long double acos(long double __lcpp_x) _NOEXCEPT {return acosl(__lcpp_x);}\n#endif\n\ntemplate <class _A1>\ninline _LIBCPP_INLINE_VISIBILITY\ntypename std::enable_if<std::is_integral<_A1>::value, double>::type\nacos(_A1 __lcpp_x) _NOEXCEPT {return acos((double)__lcpp_x);}\n\n// asin\n\n#if !(defined(_LIBCPP_MSVCRT) || defined(_AIX) || defined(__sun__))\ninline _LIBCPP_INLINE_VISIBILITY float       asin(float __lcpp_x) _NOEXCEPT       {return asinf(__lcpp_x);}\ninline _LIBCPP_INLINE_VISIBILITY long double asin(long double __lcpp_x) _NOEXCEPT {return asinl(__lcpp_x);}\n#endif\n\ntemplate <class _A1>\ninline _LIBCPP_INLINE_VISIBILITY\ntypename std::enable_if<std::is_integral<_A1>::value, double>::type\nasin(_A1 __lcpp_x) _NOEXCEPT {return asin((double)__lcpp_x);}\n\n// atan\n\n#if !(defined(_LIBCPP_MSVCRT) || defined(_AIX) || defined(__sun__))\ninline _LIBCPP_INLINE_VISIBILITY float       atan(float __lcpp_x) _NOEXCEPT       {return atanf(__lcpp_x);}\ninline _LIBCPP_INLINE_VISIBILITY long double atan(long double __lcpp_x) _NOEXCEPT {return atanl(__lcpp_x);}\n#endif\n\ntemplate <class _A1>\ninline _LIBCPP_INLINE_VISIBILITY\ntypename std::enable_if<std::is_integral<_A1>::value, double>::type\natan(_A1 __lcpp_x) _NOEXCEPT {return atan((double)__lcpp_x);}\n\n// atan2\n\n#if !(defined(_LIBCPP_MSVCRT) || defined(_AIX) || defined(__sun__))\ninline _LIBCPP_INLINE_VISIBILITY float       atan2(float __lcpp_y, float __lcpp_x) _NOEXCEPT             {return atan2f(__lcpp_y, __lcpp_x);}\ninline _LIBCPP_INLINE_VISIBILITY long double atan2(long double __lcpp_y, long double __lcpp_x) _NOEXCEPT {return atan2l(__lcpp_y, __lcpp_x);}\n#endif\n\ntemplate <class _A1, class _A2>\ninline _LIBCPP_INLINE_VISIBILITY\ntypename std::__lazy_enable_if\n<\n    std::is_arithmetic<_A1>::value &&\n    std::is_arithmetic<_A2>::value,\n    std::__promote<_A1, _A2>\n>::type\natan2(_A1 __lcpp_y, _A2 __lcpp_x) _NOEXCEPT\n{\n    typedef typename std::__promote<_A1, _A2>::type __result_type;\n    static_assert((!(std::is_same<_A1, __result_type>::value &&\n                     std::is_same<_A2, __result_type>::value)), \"\");\n    return atan2((__result_type)__lcpp_y, (__result_type)__lcpp_x);\n}\n\n// ceil\n\n#if !(defined(_LIBCPP_MSVCRT) || defined(_AIX) || defined(__sun__))\ninline _LIBCPP_INLINE_VISIBILITY float       ceil(float __lcpp_x) _NOEXCEPT       {return ceilf(__lcpp_x);}\ninline _LIBCPP_INLINE_VISIBILITY long double ceil(long double __lcpp_x) _NOEXCEPT {return ceill(__lcpp_x);}\n#endif\n\ntemplate <class _A1>\ninline _LIBCPP_INLINE_VISIBILITY\ntypename std::enable_if<std::is_integral<_A1>::value, double>::type\nceil(_A1 __lcpp_x) _NOEXCEPT {return ceil((double)__lcpp_x);}\n\n// cos\n\n#if !(defined(_LIBCPP_MSVCRT) || defined(_AIX) || defined(__sun__))\ninline _LIBCPP_INLINE_VISIBILITY float       cos(float __lcpp_x) _NOEXCEPT       {return cosf(__lcpp_x);}\ninline _LIBCPP_INLINE_VISIBILITY long double cos(long double __lcpp_x) _NOEXCEPT {return cosl(__lcpp_x);}\n#endif\n\ntemplate <class _A1>\ninline _LIBCPP_INLINE_VISIBILITY\ntypename std::enable_if<std::is_integral<_A1>::value, double>::type\ncos(_A1 __lcpp_x) _NOEXCEPT {return cos((double)__lcpp_x);}\n\n// cosh\n\n#if !(defined(_LIBCPP_MSVCRT) || defined(_AIX) || defined(__sun__))\ninline _LIBCPP_INLINE_VISIBILITY float       cosh(float __lcpp_x) _NOEXCEPT       {return coshf(__lcpp_x);}\ninline _LIBCPP_INLINE_VISIBILITY long double cosh(long double __lcpp_x) _NOEXCEPT {return coshl(__lcpp_x);}\n#endif\n\ntemplate <class _A1>\ninline _LIBCPP_INLINE_VISIBILITY\ntypename std::enable_if<std::is_integral<_A1>::value, double>::type\ncosh(_A1 __lcpp_x) _NOEXCEPT {return cosh((double)__lcpp_x);}\n\n// exp\n\n#if !(defined(_LIBCPP_MSVCRT) || defined(_AIX) || defined(__sun__))\ninline _LIBCPP_INLINE_VISIBILITY float       exp(float __lcpp_x) _NOEXCEPT       {return expf(__lcpp_x);}\ninline _LIBCPP_INLINE_VISIBILITY long double exp(long double __lcpp_x) _NOEXCEPT {return expl(__lcpp_x);}\n#endif\n\ntemplate <class _A1>\ninline _LIBCPP_INLINE_VISIBILITY\ntypename std::enable_if<std::is_integral<_A1>::value, double>::type\nexp(_A1 __lcpp_x) _NOEXCEPT {return exp((double)__lcpp_x);}\n\n// fabs\n\n#if !(defined(_LIBCPP_MSVCRT) || defined(_AIX) || defined(__sun__))\ninline _LIBCPP_INLINE_VISIBILITY float       fabs(float __lcpp_x) _NOEXCEPT       {return fabsf(__lcpp_x);}\ninline _LIBCPP_INLINE_VISIBILITY long double fabs(long double __lcpp_x) _NOEXCEPT {return fabsl(__lcpp_x);}\n#endif\n\ntemplate <class _A1>\ninline _LIBCPP_INLINE_VISIBILITY\ntypename std::enable_if<std::is_integral<_A1>::value, double>::type\nfabs(_A1 __lcpp_x) _NOEXCEPT {return fabs((double)__lcpp_x);}\n\n// floor\n\n#if !(defined(_LIBCPP_MSVCRT) || defined(_AIX) || defined(__sun__))\ninline _LIBCPP_INLINE_VISIBILITY float       floor(float __lcpp_x) _NOEXCEPT       {return floorf(__lcpp_x);}\ninline _LIBCPP_INLINE_VISIBILITY long double floor(long double __lcpp_x) _NOEXCEPT {return floorl(__lcpp_x);}\n#endif\n\ntemplate <class _A1>\ninline _LIBCPP_INLINE_VISIBILITY\ntypename std::enable_if<std::is_integral<_A1>::value, double>::type\nfloor(_A1 __lcpp_x) _NOEXCEPT {return floor((double)__lcpp_x);}\n\n// fmod\n\n#if !(defined(_LIBCPP_MSVCRT) || defined(_AIX) || defined(__sun__))\ninline _LIBCPP_INLINE_VISIBILITY float       fmod(float __lcpp_x, float __lcpp_y) _NOEXCEPT             {return fmodf(__lcpp_x, __lcpp_y);}\ninline _LIBCPP_INLINE_VISIBILITY long double fmod(long double __lcpp_x, long double __lcpp_y) _NOEXCEPT {return fmodl(__lcpp_x, __lcpp_y);}\n#endif\n\ntemplate <class _A1, class _A2>\ninline _LIBCPP_INLINE_VISIBILITY\ntypename std::__lazy_enable_if\n<\n    std::is_arithmetic<_A1>::value &&\n    std::is_arithmetic<_A2>::value,\n    std::__promote<_A1, _A2>\n>::type\nfmod(_A1 __lcpp_x, _A2 __lcpp_y) _NOEXCEPT\n{\n    typedef typename std::__promote<_A1, _A2>::type __result_type;\n    static_assert((!(std::is_same<_A1, __result_type>::value &&\n                     std::is_same<_A2, __result_type>::value)), \"\");\n    return fmod((__result_type)__lcpp_x, (__result_type)__lcpp_y);\n}\n\n// frexp\n\n#if !(defined(_LIBCPP_MSVCRT) || defined(_AIX) || defined(__sun__))\ninline _LIBCPP_INLINE_VISIBILITY float       frexp(float __lcpp_x, int* __lcpp_e) _NOEXCEPT       {return frexpf(__lcpp_x, __lcpp_e);}\ninline _LIBCPP_INLINE_VISIBILITY long double frexp(long double __lcpp_x, int* __lcpp_e) _NOEXCEPT {return frexpl(__lcpp_x, __lcpp_e);}\n#endif\n\ntemplate <class _A1>\ninline _LIBCPP_INLINE_VISIBILITY\ntypename std::enable_if<std::is_integral<_A1>::value, double>::type\nfrexp(_A1 __lcpp_x, int* __lcpp_e) _NOEXCEPT {return frexp((double)__lcpp_x, __lcpp_e);}\n\n// ldexp\n\n#if !(defined(_LIBCPP_MSVCRT) || defined(_AIX) || defined(__sun__))\ninline _LIBCPP_INLINE_VISIBILITY float       ldexp(float __lcpp_x, int __lcpp_e) _NOEXCEPT       {return ldexpf(__lcpp_x, __lcpp_e);}\ninline _LIBCPP_INLINE_VISIBILITY long double ldexp(long double __lcpp_x, int __lcpp_e) _NOEXCEPT {return ldexpl(__lcpp_x, __lcpp_e);}\n#endif\n\ntemplate <class _A1>\ninline _LIBCPP_INLINE_VISIBILITY\ntypename std::enable_if<std::is_integral<_A1>::value, double>::type\nldexp(_A1 __lcpp_x, int __lcpp_e) _NOEXCEPT {return ldexp((double)__lcpp_x, __lcpp_e);}\n\n// log\n\n#if !(defined(_LIBCPP_MSVCRT) || defined(_AIX) || defined(__sun__))\ninline _LIBCPP_INLINE_VISIBILITY float       log(float __lcpp_x) _NOEXCEPT       {return logf(__lcpp_x);}\ninline _LIBCPP_INLINE_VISIBILITY long double log(long double __lcpp_x) _NOEXCEPT {return logl(__lcpp_x);}\n#endif\n\ntemplate <class _A1>\ninline _LIBCPP_INLINE_VISIBILITY\ntypename std::enable_if<std::is_integral<_A1>::value, double>::type\nlog(_A1 __lcpp_x) _NOEXCEPT {return log((double)__lcpp_x);}\n\n// log10\n\n#if !(defined(_LIBCPP_MSVCRT) || defined(_AIX) || defined(__sun__))\ninline _LIBCPP_INLINE_VISIBILITY float       log10(float __lcpp_x) _NOEXCEPT       {return log10f(__lcpp_x);}\ninline _LIBCPP_INLINE_VISIBILITY long double log10(long double __lcpp_x) _NOEXCEPT {return log10l(__lcpp_x);}\n#endif\n\ntemplate <class _A1>\ninline _LIBCPP_INLINE_VISIBILITY\ntypename std::enable_if<std::is_integral<_A1>::value, double>::type\nlog10(_A1 __lcpp_x) _NOEXCEPT {return log10((double)__lcpp_x);}\n\n// modf\n\n#if !(defined(_LIBCPP_MSVCRT) || defined(_AIX) || defined(__sun__))\ninline _LIBCPP_INLINE_VISIBILITY float       modf(float __lcpp_x, float* __lcpp_y) _NOEXCEPT             {return modff(__lcpp_x, __lcpp_y);}\ninline _LIBCPP_INLINE_VISIBILITY long double modf(long double __lcpp_x, long double* __lcpp_y) _NOEXCEPT {return modfl(__lcpp_x, __lcpp_y);}\n#endif\n\n// pow\n\n#if !(defined(_LIBCPP_MSVCRT) || defined(_AIX) || defined(__sun__))\ninline _LIBCPP_INLINE_VISIBILITY float       pow(float __lcpp_x, float __lcpp_y) _NOEXCEPT             {return powf(__lcpp_x, __lcpp_y);}\ninline _LIBCPP_INLINE_VISIBILITY long double pow(long double __lcpp_x, long double __lcpp_y) _NOEXCEPT {return powl(__lcpp_x, __lcpp_y);}\n#endif\n\ntemplate <class _A1, class _A2>\ninline _LIBCPP_INLINE_VISIBILITY\ntypename std::__lazy_enable_if\n<\n    std::is_arithmetic<_A1>::value &&\n    std::is_arithmetic<_A2>::value,\n    std::__promote<_A1, _A2>\n>::type\npow(_A1 __lcpp_x, _A2 __lcpp_y) _NOEXCEPT\n{\n    typedef typename std::__promote<_A1, _A2>::type __result_type;\n    static_assert((!(std::is_same<_A1, __result_type>::value &&\n                     std::is_same<_A2, __result_type>::value)), \"\");\n    return pow((__result_type)__lcpp_x, (__result_type)__lcpp_y);\n}\n\n// sin\n\n#if !(defined(_LIBCPP_MSVCRT) || defined(_AIX) || defined(__sun__))\ninline _LIBCPP_INLINE_VISIBILITY float       sin(float __lcpp_x) _NOEXCEPT       {return sinf(__lcpp_x);}\ninline _LIBCPP_INLINE_VISIBILITY long double sin(long double __lcpp_x) _NOEXCEPT {return sinl(__lcpp_x);}\n#endif\n\ntemplate <class _A1>\ninline _LIBCPP_INLINE_VISIBILITY\ntypename std::enable_if<std::is_integral<_A1>::value, double>::type\nsin(_A1 __lcpp_x) _NOEXCEPT {return sin((double)__lcpp_x);}\n\n// sinh\n\n#if !(defined(_LIBCPP_MSVCRT) || defined(_AIX) || defined(__sun__))\ninline _LIBCPP_INLINE_VISIBILITY float       sinh(float __lcpp_x) _NOEXCEPT       {return sinhf(__lcpp_x);}\ninline _LIBCPP_INLINE_VISIBILITY long double sinh(long double __lcpp_x) _NOEXCEPT {return sinhl(__lcpp_x);}\n#endif\n\ntemplate <class _A1>\ninline _LIBCPP_INLINE_VISIBILITY\ntypename std::enable_if<std::is_integral<_A1>::value, double>::type\nsinh(_A1 __lcpp_x) _NOEXCEPT {return sinh((double)__lcpp_x);}\n\n// sqrt\n\n#if !(defined(_LIBCPP_MSVCRT) || defined(_AIX) || defined(__sun__))\ninline _LIBCPP_INLINE_VISIBILITY float       sqrt(float __lcpp_x) _NOEXCEPT       {return sqrtf(__lcpp_x);}\ninline _LIBCPP_INLINE_VISIBILITY long double sqrt(long double __lcpp_x) _NOEXCEPT {return sqrtl(__lcpp_x);}\n#endif\n\ntemplate <class _A1>\ninline _LIBCPP_INLINE_VISIBILITY\ntypename std::enable_if<std::is_integral<_A1>::value, double>::type\nsqrt(_A1 __lcpp_x) _NOEXCEPT {return sqrt((double)__lcpp_x);}\n\n// tan\n\n#if !(defined(_LIBCPP_MSVCRT) || defined(_AIX) || defined(__sun__))\ninline _LIBCPP_INLINE_VISIBILITY float       tan(float __lcpp_x) _NOEXCEPT       {return tanf(__lcpp_x);}\ninline _LIBCPP_INLINE_VISIBILITY long double tan(long double __lcpp_x) _NOEXCEPT {return tanl(__lcpp_x);}\n#endif\n\ntemplate <class _A1>\ninline _LIBCPP_INLINE_VISIBILITY\ntypename std::enable_if<std::is_integral<_A1>::value, double>::type\ntan(_A1 __lcpp_x) _NOEXCEPT {return tan((double)__lcpp_x);}\n\n// tanh\n\n#if !(defined(_LIBCPP_MSVCRT) || defined(_AIX) || defined(__sun__))\ninline _LIBCPP_INLINE_VISIBILITY float       tanh(float __lcpp_x) _NOEXCEPT       {return tanhf(__lcpp_x);}\ninline _LIBCPP_INLINE_VISIBILITY long double tanh(long double __lcpp_x) _NOEXCEPT {return tanhl(__lcpp_x);}\n#endif\n\ntemplate <class _A1>\ninline _LIBCPP_INLINE_VISIBILITY\ntypename std::enable_if<std::is_integral<_A1>::value, double>::type\ntanh(_A1 __lcpp_x) _NOEXCEPT {return tanh((double)__lcpp_x);}\n\n// acosh\n\n#ifndef _LIBCPP_MSVCRT\ninline _LIBCPP_INLINE_VISIBILITY float       acosh(float __lcpp_x) _NOEXCEPT       {return acoshf(__lcpp_x);}\ninline _LIBCPP_INLINE_VISIBILITY long double acosh(long double __lcpp_x) _NOEXCEPT {return acoshl(__lcpp_x);}\n\ntemplate <class _A1>\ninline _LIBCPP_INLINE_VISIBILITY\ntypename std::enable_if<std::is_integral<_A1>::value, double>::type\nacosh(_A1 __lcpp_x) _NOEXCEPT {return acosh((double)__lcpp_x);}\n#endif\n\n// asinh\n\n#ifndef _LIBCPP_MSVCRT\ninline _LIBCPP_INLINE_VISIBILITY float       asinh(float __lcpp_x) _NOEXCEPT       {return asinhf(__lcpp_x);}\ninline _LIBCPP_INLINE_VISIBILITY long double asinh(long double __lcpp_x) _NOEXCEPT {return asinhl(__lcpp_x);}\n\ntemplate <class _A1>\ninline _LIBCPP_INLINE_VISIBILITY\ntypename std::enable_if<std::is_integral<_A1>::value, double>::type\nasinh(_A1 __lcpp_x) _NOEXCEPT {return asinh((double)__lcpp_x);}\n#endif\n\n// atanh\n\n#ifndef _LIBCPP_MSVCRT\ninline _LIBCPP_INLINE_VISIBILITY float       atanh(float __lcpp_x) _NOEXCEPT       {return atanhf(__lcpp_x);}\ninline _LIBCPP_INLINE_VISIBILITY long double atanh(long double __lcpp_x) _NOEXCEPT {return atanhl(__lcpp_x);}\n\ntemplate <class _A1>\ninline _LIBCPP_INLINE_VISIBILITY\ntypename std::enable_if<std::is_integral<_A1>::value, double>::type\natanh(_A1 __lcpp_x) _NOEXCEPT {return atanh((double)__lcpp_x);}\n#endif\n\n// cbrt\n\n#ifndef _LIBCPP_MSVCRT\ninline _LIBCPP_INLINE_VISIBILITY float       cbrt(float __lcpp_x) _NOEXCEPT       {return cbrtf(__lcpp_x);}\ninline _LIBCPP_INLINE_VISIBILITY long double cbrt(long double __lcpp_x) _NOEXCEPT {return cbrtl(__lcpp_x);}\n\ntemplate <class _A1>\ninline _LIBCPP_INLINE_VISIBILITY\ntypename std::enable_if<std::is_integral<_A1>::value, double>::type\ncbrt(_A1 __lcpp_x) _NOEXCEPT {return cbrt((double)__lcpp_x);}\n#endif\n\n// copysign\n\n#if !defined(_VC_CRT_MAJOR_VERSION) || (_VC_CRT_MAJOR_VERSION < 12)\ninline _LIBCPP_INLINE_VISIBILITY float copysign(float __lcpp_x,\n                                                float __lcpp_y) _NOEXCEPT {\n  return copysignf(__lcpp_x, __lcpp_y);\n}\ninline _LIBCPP_INLINE_VISIBILITY long double\ncopysign(long double __lcpp_x, long double __lcpp_y) _NOEXCEPT {\n  return copysignl(__lcpp_x, __lcpp_y);\n}\n#endif\n\ntemplate <class _A1, class _A2>\ninline _LIBCPP_INLINE_VISIBILITY\ntypename std::__lazy_enable_if\n<\n    std::is_arithmetic<_A1>::value &&\n    std::is_arithmetic<_A2>::value,\n    std::__promote<_A1, _A2>\n>::type\ncopysign(_A1 __lcpp_x, _A2 __lcpp_y) _NOEXCEPT\n{\n    typedef typename std::__promote<_A1, _A2>::type __result_type;\n    static_assert((!(std::is_same<_A1, __result_type>::value &&\n                     std::is_same<_A2, __result_type>::value)), \"\");\n    return copysign((__result_type)__lcpp_x, (__result_type)__lcpp_y);\n}\n\n#ifndef _LIBCPP_MSVCRT\n\n// erf\n\ninline _LIBCPP_INLINE_VISIBILITY float       erf(float __lcpp_x) _NOEXCEPT       {return erff(__lcpp_x);}\ninline _LIBCPP_INLINE_VISIBILITY long double erf(long double __lcpp_x) _NOEXCEPT {return erfl(__lcpp_x);}\n\ntemplate <class _A1>\ninline _LIBCPP_INLINE_VISIBILITY\ntypename std::enable_if<std::is_integral<_A1>::value, double>::type\nerf(_A1 __lcpp_x) _NOEXCEPT {return erf((double)__lcpp_x);}\n\n// erfc\n\ninline _LIBCPP_INLINE_VISIBILITY float       erfc(float __lcpp_x) _NOEXCEPT       {return erfcf(__lcpp_x);}\ninline _LIBCPP_INLINE_VISIBILITY long double erfc(long double __lcpp_x) _NOEXCEPT {return erfcl(__lcpp_x);}\n\ntemplate <class _A1>\ninline _LIBCPP_INLINE_VISIBILITY\ntypename std::enable_if<std::is_integral<_A1>::value, double>::type\nerfc(_A1 __lcpp_x) _NOEXCEPT {return erfc((double)__lcpp_x);}\n\n// exp2\n\ninline _LIBCPP_INLINE_VISIBILITY float       exp2(float __lcpp_x) _NOEXCEPT       {return exp2f(__lcpp_x);}\ninline _LIBCPP_INLINE_VISIBILITY long double exp2(long double __lcpp_x) _NOEXCEPT {return exp2l(__lcpp_x);}\n\ntemplate <class _A1>\ninline _LIBCPP_INLINE_VISIBILITY\ntypename std::enable_if<std::is_integral<_A1>::value, double>::type\nexp2(_A1 __lcpp_x) _NOEXCEPT {return exp2((double)__lcpp_x);}\n\n// expm1\n\ninline _LIBCPP_INLINE_VISIBILITY float       expm1(float __lcpp_x) _NOEXCEPT       {return expm1f(__lcpp_x);}\ninline _LIBCPP_INLINE_VISIBILITY long double expm1(long double __lcpp_x) _NOEXCEPT {return expm1l(__lcpp_x);}\n\ntemplate <class _A1>\ninline _LIBCPP_INLINE_VISIBILITY\ntypename std::enable_if<std::is_integral<_A1>::value, double>::type\nexpm1(_A1 __lcpp_x) _NOEXCEPT {return expm1((double)__lcpp_x);}\n\n// fdim\n\ninline _LIBCPP_INLINE_VISIBILITY float       fdim(float __lcpp_x, float __lcpp_y) _NOEXCEPT             {return fdimf(__lcpp_x, __lcpp_y);}\ninline _LIBCPP_INLINE_VISIBILITY long double fdim(long double __lcpp_x, long double __lcpp_y) _NOEXCEPT {return fdiml(__lcpp_x, __lcpp_y);}\n\ntemplate <class _A1, class _A2>\ninline _LIBCPP_INLINE_VISIBILITY\ntypename std::__lazy_enable_if\n<\n    std::is_arithmetic<_A1>::value &&\n    std::is_arithmetic<_A2>::value,\n    std::__promote<_A1, _A2>\n>::type\nfdim(_A1 __lcpp_x, _A2 __lcpp_y) _NOEXCEPT\n{\n    typedef typename std::__promote<_A1, _A2>::type __result_type;\n    static_assert((!(std::is_same<_A1, __result_type>::value &&\n                     std::is_same<_A2, __result_type>::value)), \"\");\n    return fdim((__result_type)__lcpp_x, (__result_type)__lcpp_y);\n}\n\n// fma\n\ninline _LIBCPP_INLINE_VISIBILITY float       fma(float __lcpp_x, float __lcpp_y, float __lcpp_z) _NOEXCEPT                   {return fmaf(__lcpp_x, __lcpp_y, __lcpp_z);}\ninline _LIBCPP_INLINE_VISIBILITY long double fma(long double __lcpp_x, long double __lcpp_y, long double __lcpp_z) _NOEXCEPT {return fmal(__lcpp_x, __lcpp_y, __lcpp_z);}\n\ntemplate <class _A1, class _A2, class _A3>\ninline _LIBCPP_INLINE_VISIBILITY\ntypename std::__lazy_enable_if\n<\n    std::is_arithmetic<_A1>::value &&\n    std::is_arithmetic<_A2>::value &&\n    std::is_arithmetic<_A3>::value,\n    std::__promote<_A1, _A2, _A3>\n>::type\nfma(_A1 __lcpp_x, _A2 __lcpp_y, _A3 __lcpp_z) _NOEXCEPT\n{\n    typedef typename std::__promote<_A1, _A2, _A3>::type __result_type;\n    static_assert((!(std::is_same<_A1, __result_type>::value &&\n                     std::is_same<_A2, __result_type>::value &&\n                     std::is_same<_A3, __result_type>::value)), \"\");\n    return fma((__result_type)__lcpp_x, (__result_type)__lcpp_y, (__result_type)__lcpp_z);\n}\n\n// fmax\n\ninline _LIBCPP_INLINE_VISIBILITY float       fmax(float __lcpp_x, float __lcpp_y) _NOEXCEPT             {return fmaxf(__lcpp_x, __lcpp_y);}\ninline _LIBCPP_INLINE_VISIBILITY long double fmax(long double __lcpp_x, long double __lcpp_y) _NOEXCEPT {return fmaxl(__lcpp_x, __lcpp_y);}\n\ntemplate <class _A1, class _A2>\ninline _LIBCPP_INLINE_VISIBILITY\ntypename std::__lazy_enable_if\n<\n    std::is_arithmetic<_A1>::value &&\n    std::is_arithmetic<_A2>::value,\n    std::__promote<_A1, _A2>\n>::type\nfmax(_A1 __lcpp_x, _A2 __lcpp_y) _NOEXCEPT\n{\n    typedef typename std::__promote<_A1, _A2>::type __result_type;\n    static_assert((!(std::is_same<_A1, __result_type>::value &&\n                     std::is_same<_A2, __result_type>::value)), \"\");\n    return fmax((__result_type)__lcpp_x, (__result_type)__lcpp_y);\n}\n\n// fmin\n\ninline _LIBCPP_INLINE_VISIBILITY float       fmin(float __lcpp_x, float __lcpp_y) _NOEXCEPT             {return fminf(__lcpp_x, __lcpp_y);}\ninline _LIBCPP_INLINE_VISIBILITY long double fmin(long double __lcpp_x, long double __lcpp_y) _NOEXCEPT {return fminl(__lcpp_x, __lcpp_y);}\n\ntemplate <class _A1, class _A2>\ninline _LIBCPP_INLINE_VISIBILITY\ntypename std::__lazy_enable_if\n<\n    std::is_arithmetic<_A1>::value &&\n    std::is_arithmetic<_A2>::value,\n    std::__promote<_A1, _A2>\n>::type\nfmin(_A1 __lcpp_x, _A2 __lcpp_y) _NOEXCEPT\n{\n    typedef typename std::__promote<_A1, _A2>::type __result_type;\n    static_assert((!(std::is_same<_A1, __result_type>::value &&\n                     std::is_same<_A2, __result_type>::value)), \"\");\n    return fmin((__result_type)__lcpp_x, (__result_type)__lcpp_y);\n}\n\n// hypot\n\ninline _LIBCPP_INLINE_VISIBILITY float       hypot(float __lcpp_x, float __lcpp_y) _NOEXCEPT             {return hypotf(__lcpp_x, __lcpp_y);}\ninline _LIBCPP_INLINE_VISIBILITY long double hypot(long double __lcpp_x, long double __lcpp_y) _NOEXCEPT {return hypotl(__lcpp_x, __lcpp_y);}\n\ntemplate <class _A1, class _A2>\ninline _LIBCPP_INLINE_VISIBILITY\ntypename std::__lazy_enable_if\n<\n    std::is_arithmetic<_A1>::value &&\n    std::is_arithmetic<_A2>::value,\n    std::__promote<_A1, _A2>\n>::type\nhypot(_A1 __lcpp_x, _A2 __lcpp_y) _NOEXCEPT\n{\n    typedef typename std::__promote<_A1, _A2>::type __result_type;\n    static_assert((!(std::is_same<_A1, __result_type>::value &&\n                     std::is_same<_A2, __result_type>::value)), \"\");\n    return hypot((__result_type)__lcpp_x, (__result_type)__lcpp_y);\n}\n\n// ilogb\n\ninline _LIBCPP_INLINE_VISIBILITY int ilogb(float __lcpp_x) _NOEXCEPT       {return ilogbf(__lcpp_x);}\ninline _LIBCPP_INLINE_VISIBILITY int ilogb(long double __lcpp_x) _NOEXCEPT {return ilogbl(__lcpp_x);}\n\ntemplate <class _A1>\ninline _LIBCPP_INLINE_VISIBILITY\ntypename std::enable_if<std::is_integral<_A1>::value, int>::type\nilogb(_A1 __lcpp_x) _NOEXCEPT {return ilogb((double)__lcpp_x);}\n\n// lgamma\n\ninline _LIBCPP_INLINE_VISIBILITY float       lgamma(float __lcpp_x) _NOEXCEPT       {return lgammaf(__lcpp_x);}\ninline _LIBCPP_INLINE_VISIBILITY long double lgamma(long double __lcpp_x) _NOEXCEPT {return lgammal(__lcpp_x);}\n\ntemplate <class _A1>\ninline _LIBCPP_INLINE_VISIBILITY\ntypename std::enable_if<std::is_integral<_A1>::value, double>::type\nlgamma(_A1 __lcpp_x) _NOEXCEPT {return lgamma((double)__lcpp_x);}\n\n// llrint\n\ninline _LIBCPP_INLINE_VISIBILITY long long llrint(float __lcpp_x) _NOEXCEPT       {return llrintf(__lcpp_x);}\ninline _LIBCPP_INLINE_VISIBILITY long long llrint(long double __lcpp_x) _NOEXCEPT {return llrintl(__lcpp_x);}\n\ntemplate <class _A1>\ninline _LIBCPP_INLINE_VISIBILITY\ntypename std::enable_if<std::is_integral<_A1>::value, long long>::type\nllrint(_A1 __lcpp_x) _NOEXCEPT {return llrint((double)__lcpp_x);}\n\n// llround\n\ninline _LIBCPP_INLINE_VISIBILITY long long llround(float __lcpp_x) _NOEXCEPT       {return llroundf(__lcpp_x);}\ninline _LIBCPP_INLINE_VISIBILITY long long llround(long double __lcpp_x) _NOEXCEPT {return llroundl(__lcpp_x);}\n\ntemplate <class _A1>\ninline _LIBCPP_INLINE_VISIBILITY\ntypename std::enable_if<std::is_integral<_A1>::value, long long>::type\nllround(_A1 __lcpp_x) _NOEXCEPT {return llround((double)__lcpp_x);}\n\n// log1p\n\ninline _LIBCPP_INLINE_VISIBILITY float       log1p(float __lcpp_x) _NOEXCEPT       {return log1pf(__lcpp_x);}\ninline _LIBCPP_INLINE_VISIBILITY long double log1p(long double __lcpp_x) _NOEXCEPT {return log1pl(__lcpp_x);}\n\ntemplate <class _A1>\ninline _LIBCPP_INLINE_VISIBILITY\ntypename std::enable_if<std::is_integral<_A1>::value, double>::type\nlog1p(_A1 __lcpp_x) _NOEXCEPT {return log1p((double)__lcpp_x);}\n\n// log2\n\ninline _LIBCPP_INLINE_VISIBILITY float       log2(float __lcpp_x) _NOEXCEPT       {return log2f(__lcpp_x);}\ninline _LIBCPP_INLINE_VISIBILITY long double log2(long double __lcpp_x) _NOEXCEPT {return log2l(__lcpp_x);}\n\ntemplate <class _A1>\ninline _LIBCPP_INLINE_VISIBILITY\ntypename std::enable_if<std::is_integral<_A1>::value, double>::type\nlog2(_A1 __lcpp_x) _NOEXCEPT {return log2((double)__lcpp_x);}\n\n// logb\n\ninline _LIBCPP_INLINE_VISIBILITY float       logb(float __lcpp_x) _NOEXCEPT       {return logbf(__lcpp_x);}\ninline _LIBCPP_INLINE_VISIBILITY long double logb(long double __lcpp_x) _NOEXCEPT {return logbl(__lcpp_x);}\n\ntemplate <class _A1>\ninline _LIBCPP_INLINE_VISIBILITY\ntypename std::enable_if<std::is_integral<_A1>::value, double>::type\nlogb(_A1 __lcpp_x) _NOEXCEPT {return logb((double)__lcpp_x);}\n\n// lrint\n\ninline _LIBCPP_INLINE_VISIBILITY long lrint(float __lcpp_x) _NOEXCEPT       {return lrintf(__lcpp_x);}\ninline _LIBCPP_INLINE_VISIBILITY long lrint(long double __lcpp_x) _NOEXCEPT {return lrintl(__lcpp_x);}\n\ntemplate <class _A1>\ninline _LIBCPP_INLINE_VISIBILITY\ntypename std::enable_if<std::is_integral<_A1>::value, long>::type\nlrint(_A1 __lcpp_x) _NOEXCEPT {return lrint((double)__lcpp_x);}\n\n// lround\n\ninline _LIBCPP_INLINE_VISIBILITY long lround(float __lcpp_x) _NOEXCEPT       {return lroundf(__lcpp_x);}\ninline _LIBCPP_INLINE_VISIBILITY long lround(long double __lcpp_x) _NOEXCEPT {return lroundl(__lcpp_x);}\n\ntemplate <class _A1>\ninline _LIBCPP_INLINE_VISIBILITY\ntypename std::enable_if<std::is_integral<_A1>::value, long>::type\nlround(_A1 __lcpp_x) _NOEXCEPT {return lround((double)__lcpp_x);}\n\n// nan\n\n// nearbyint\n\ninline _LIBCPP_INLINE_VISIBILITY float       nearbyint(float __lcpp_x) _NOEXCEPT       {return nearbyintf(__lcpp_x);}\ninline _LIBCPP_INLINE_VISIBILITY long double nearbyint(long double __lcpp_x) _NOEXCEPT {return nearbyintl(__lcpp_x);}\n\ntemplate <class _A1>\ninline _LIBCPP_INLINE_VISIBILITY\ntypename std::enable_if<std::is_integral<_A1>::value, double>::type\nnearbyint(_A1 __lcpp_x) _NOEXCEPT {return nearbyint((double)__lcpp_x);}\n\n// nextafter\n\ninline _LIBCPP_INLINE_VISIBILITY float       nextafter(float __lcpp_x, float __lcpp_y) _NOEXCEPT             {return nextafterf(__lcpp_x, __lcpp_y);}\ninline _LIBCPP_INLINE_VISIBILITY long double nextafter(long double __lcpp_x, long double __lcpp_y) _NOEXCEPT {return nextafterl(__lcpp_x, __lcpp_y);}\n\ntemplate <class _A1, class _A2>\ninline _LIBCPP_INLINE_VISIBILITY\ntypename std::__lazy_enable_if\n<\n    std::is_arithmetic<_A1>::value &&\n    std::is_arithmetic<_A2>::value,\n    std::__promote<_A1, _A2>\n>::type\nnextafter(_A1 __lcpp_x, _A2 __lcpp_y) _NOEXCEPT\n{\n    typedef typename std::__promote<_A1, _A2>::type __result_type;\n    static_assert((!(std::is_same<_A1, __result_type>::value &&\n                     std::is_same<_A2, __result_type>::value)), \"\");\n    return nextafter((__result_type)__lcpp_x, (__result_type)__lcpp_y);\n}\n\n// nexttoward\n\ninline _LIBCPP_INLINE_VISIBILITY float       nexttoward(float __lcpp_x, long double __lcpp_y) _NOEXCEPT       {return nexttowardf(__lcpp_x, __lcpp_y);}\ninline _LIBCPP_INLINE_VISIBILITY long double nexttoward(long double __lcpp_x, long double __lcpp_y) _NOEXCEPT {return nexttowardl(__lcpp_x, __lcpp_y);}\n\ntemplate <class _A1>\ninline _LIBCPP_INLINE_VISIBILITY\ntypename std::enable_if<std::is_integral<_A1>::value, double>::type\nnexttoward(_A1 __lcpp_x, long double __lcpp_y) _NOEXCEPT {return nexttoward((double)__lcpp_x, __lcpp_y);}\n\n// remainder\n\ninline _LIBCPP_INLINE_VISIBILITY float       remainder(float __lcpp_x, float __lcpp_y) _NOEXCEPT             {return remainderf(__lcpp_x, __lcpp_y);}\ninline _LIBCPP_INLINE_VISIBILITY long double remainder(long double __lcpp_x, long double __lcpp_y) _NOEXCEPT {return remainderl(__lcpp_x, __lcpp_y);}\n\ntemplate <class _A1, class _A2>\ninline _LIBCPP_INLINE_VISIBILITY\ntypename std::__lazy_enable_if\n<\n    std::is_arithmetic<_A1>::value &&\n    std::is_arithmetic<_A2>::value,\n    std::__promote<_A1, _A2>\n>::type\nremainder(_A1 __lcpp_x, _A2 __lcpp_y) _NOEXCEPT\n{\n    typedef typename std::__promote<_A1, _A2>::type __result_type;\n    static_assert((!(std::is_same<_A1, __result_type>::value &&\n                     std::is_same<_A2, __result_type>::value)), \"\");\n    return remainder((__result_type)__lcpp_x, (__result_type)__lcpp_y);\n}\n\n// remquo\n\ninline _LIBCPP_INLINE_VISIBILITY float       remquo(float __lcpp_x, float __lcpp_y, int* __lcpp_z) _NOEXCEPT             {return remquof(__lcpp_x, __lcpp_y, __lcpp_z);}\ninline _LIBCPP_INLINE_VISIBILITY long double remquo(long double __lcpp_x, long double __lcpp_y, int* __lcpp_z) _NOEXCEPT {return remquol(__lcpp_x, __lcpp_y, __lcpp_z);}\n\ntemplate <class _A1, class _A2>\ninline _LIBCPP_INLINE_VISIBILITY\ntypename std::__lazy_enable_if\n<\n    std::is_arithmetic<_A1>::value &&\n    std::is_arithmetic<_A2>::value,\n    std::__promote<_A1, _A2>\n>::type\nremquo(_A1 __lcpp_x, _A2 __lcpp_y, int* __lcpp_z) _NOEXCEPT\n{\n    typedef typename std::__promote<_A1, _A2>::type __result_type;\n    static_assert((!(std::is_same<_A1, __result_type>::value &&\n                     std::is_same<_A2, __result_type>::value)), \"\");\n    return remquo((__result_type)__lcpp_x, (__result_type)__lcpp_y, __lcpp_z);\n}\n\n// rint\n\ninline _LIBCPP_INLINE_VISIBILITY float       rint(float __lcpp_x) _NOEXCEPT       {return rintf(__lcpp_x);}\ninline _LIBCPP_INLINE_VISIBILITY long double rint(long double __lcpp_x) _NOEXCEPT {return rintl(__lcpp_x);}\n\ntemplate <class _A1>\ninline _LIBCPP_INLINE_VISIBILITY\ntypename std::enable_if<std::is_integral<_A1>::value, double>::type\nrint(_A1 __lcpp_x) _NOEXCEPT {return rint((double)__lcpp_x);}\n\n// round\n\ninline _LIBCPP_INLINE_VISIBILITY float       round(float __lcpp_x) _NOEXCEPT       {return roundf(__lcpp_x);}\ninline _LIBCPP_INLINE_VISIBILITY long double round(long double __lcpp_x) _NOEXCEPT {return roundl(__lcpp_x);}\n\ntemplate <class _A1>\ninline _LIBCPP_INLINE_VISIBILITY\ntypename std::enable_if<std::is_integral<_A1>::value, double>::type\nround(_A1 __lcpp_x) _NOEXCEPT {return round((double)__lcpp_x);}\n\n// scalbln\n\ninline _LIBCPP_INLINE_VISIBILITY float       scalbln(float __lcpp_x, long __lcpp_y) _NOEXCEPT       {return scalblnf(__lcpp_x, __lcpp_y);}\ninline _LIBCPP_INLINE_VISIBILITY long double scalbln(long double __lcpp_x, long __lcpp_y) _NOEXCEPT {return scalblnl(__lcpp_x, __lcpp_y);}\n\ntemplate <class _A1>\ninline _LIBCPP_INLINE_VISIBILITY\ntypename std::enable_if<std::is_integral<_A1>::value, double>::type\nscalbln(_A1 __lcpp_x, long __lcpp_y) _NOEXCEPT {return scalbln((double)__lcpp_x, __lcpp_y);}\n\n// scalbn\n\ninline _LIBCPP_INLINE_VISIBILITY float       scalbn(float __lcpp_x, int __lcpp_y) _NOEXCEPT       {return scalbnf(__lcpp_x, __lcpp_y);}\ninline _LIBCPP_INLINE_VISIBILITY long double scalbn(long double __lcpp_x, int __lcpp_y) _NOEXCEPT {return scalbnl(__lcpp_x, __lcpp_y);}\n\ntemplate <class _A1>\ninline _LIBCPP_INLINE_VISIBILITY\ntypename std::enable_if<std::is_integral<_A1>::value, double>::type\nscalbn(_A1 __lcpp_x, int __lcpp_y) _NOEXCEPT {return scalbn((double)__lcpp_x, __lcpp_y);}\n\n// tgamma\n\ninline _LIBCPP_INLINE_VISIBILITY float       tgamma(float __lcpp_x) _NOEXCEPT       {return tgammaf(__lcpp_x);}\ninline _LIBCPP_INLINE_VISIBILITY long double tgamma(long double __lcpp_x) _NOEXCEPT {return tgammal(__lcpp_x);}\n\ntemplate <class _A1>\ninline _LIBCPP_INLINE_VISIBILITY\ntypename std::enable_if<std::is_integral<_A1>::value, double>::type\ntgamma(_A1 __lcpp_x) _NOEXCEPT {return tgamma((double)__lcpp_x);}\n\n// trunc\n\ninline _LIBCPP_INLINE_VISIBILITY float       trunc(float __lcpp_x) _NOEXCEPT       {return truncf(__lcpp_x);}\ninline _LIBCPP_INLINE_VISIBILITY long double trunc(long double __lcpp_x) _NOEXCEPT {return truncl(__lcpp_x);}\n\ntemplate <class _A1>\ninline _LIBCPP_INLINE_VISIBILITY\ntypename std::enable_if<std::is_integral<_A1>::value, double>::type\ntrunc(_A1 __lcpp_x) _NOEXCEPT {return trunc((double)__lcpp_x);}\n\n#endif // !_LIBCPP_MSVCRT\n\n} // extern \"C++\"\n\n#endif // __cplusplus\n\n#endif  // _LIBCPP_MATH_H\n","#include <stdexcept>\n\n#include \"FunctionAnalyzer.h\"\n#include \"ParserTypes.h\"\n#include \"Error.h\"\n#include \"Debug.h\"\n\nFunctionAnalyzer::FunctionAnalyzer() {\n}\n\nvoid FunctionAnalyzer::addTypeSignature(CharmTypeSignature t) {\n    typeSignatures[t.functionName] = t;\n}\n\nvoid FunctionAnalyzer::addToInlineDefinitions(CharmFunction f) {\n    if (f.functionType == FUNCTION_DEFINITION) {\n        ONLYDEBUG printf(\"Adding %s to the inlineDefinitions\\n\", f.functionName.c_str());\n        inlineDefinitions[f.functionName] = f;\n    } else {\n        throw std::runtime_error(\"Tried to insert non-function definition into inlineDefinitions\");\n    }\n}\n\nbool FunctionAnalyzer::doInline(CHARM_LIST_TYPE& out, CharmFunction currentFunction) {\n    //search through the inline definitions that have been parsed to see if this function is inlineable\n    auto fIter = inlineDefinitions.find(currentFunction.functionName);\n    ONLYDEBUG printf(\"Looking for inlineDefinition of %s, did we find it? %s\\n\", currentFunction.functionName.c_str(), fIter != inlineDefinitions.end() ? \"Yes\" : \"No\");\n    if (fIter != inlineDefinitions.end()) {\n        ONLYDEBUG printf(\"PERFORMING INLINE REPLACEMENT FOR %s\\n    %s -> \", currentFunction.functionName.c_str(), currentFunction.functionName.c_str());\n        for (CharmFunction inlineReplacement : fIter->second.literalFunctions) {\n            out.push_back(inlineReplacement);\n            ONLYDEBUG printf(\"%s \", charmFunctionToString(inlineReplacement).c_str());\n        }\n        ONLYDEBUG printf(\"\\n\");\n        if (DEBUGMODE) {\n            printf(\"AFTER INLINE OPTIMIZATION, OUT NOW LOOKS LIKE THIS:\\n     \");\n            for (CharmFunction f : out) {\n                printf(\"%s \", charmFunctionToString(f).c_str());\n            }\n            printf(\"\\n\");\n        }\n        return true;\n    }\n    return false;\n}\n\nbool FunctionAnalyzer::_isInlineable(std::string fName, CharmFunction f) {\n\t//if the function calls itself, it's recursive and not inlineable\n\tbool recursive = false;\n\tfor (unsigned long long fIndex = 0; fIndex < f.literalFunctions.size(); fIndex++) {\n\t\tif (f.literalFunctions[fIndex].functionType == LIST_FUNCTION) {\n\t\t\trecursive = recursive || (!_isInlineable(fName, f.literalFunctions[fIndex]));\n\t\t} else {\n\t\t\trecursive = recursive || (fName == f.literalFunctions[fIndex].functionName);\n\t\t}\n\t\tif (recursive) {\n\t\t\tbreak;\n\t\t}\n\t}\n\treturn !recursive;\n}\nbool FunctionAnalyzer::isInlinable(CharmFunction f) {\n\treturn (_isInlineable(f.functionName, f));\n}\n\nbool FunctionAnalyzer::isTailCallRecursive(CharmFunction f) {\n\t//this is only static, basic tail call recursion analysis.\n\t//this only catches functions of form `f := <code> f`\n\t//and sends this flag off to Runner.cpp::handleDefinedFunctions()\n\t//the rest of the tail call recursion code happens within PredefinedFunctions.cpp::ifthen\n\t//over there, the usual case is caught, with code of the form `f := [ <cond> ] [ <code> f] [ <code> f ] ifthen`\n    if (f.literalFunctions.size() > 0) {\n       return (f.functionName == f.literalFunctions.back().functionName);\n    } else {\n        return false;\n    }\n}\n","#include \"Parser.h\"\n#include \"Runner.h\"\n#include \"Prelude.charm.h\"\n\n#include <iostream>\n#include <sstream>\n\nextern \"C\" {\n    class CInterpretationCapsule {\n    private:\n        Parser* p;\n        Runner* r;\n    public:\n        CInterpretationCapsule() {\n            p = new Parser();\n            r = new Runner();\n            this->run(prelude.c_str());\n        };\n        void run(const char* in) {\n            std::string inS(in);\n            r->run(p->lex(inS));\n        };\n    };\n    \n    CInterpretationCapsule* initCapsule() {\n        return new CInterpretationCapsule();\n    }\n    \n    const char* runCapsule(CInterpretationCapsule* c, char* in) {\n        //redirect cout to our stringstream\n        std::streambuf* oldCout = std::cout.rdbuf();\n        std::ostringstream newCout;\n        std::cout.rdbuf(newCout.rdbuf());\n        //then run\n        try {\n            c->run(in);\n        } catch (std::exception& e) {\n            std::cout << e.what();\n        }\n        //restore cout\n        std::cout.rdbuf(oldCout);\n        //and return the output\n        return newCout.str().c_str();\n    }\n};\n\n","// -*- C++ -*-\n//===----------------------- initializer_list -----------------------------===//\n//\n//                     The LLVM Compiler Infrastructure\n//\n// This file is dual licensed under the MIT and the University of Illinois Open\n// Source Licenses. See LICENSE.TXT for details.\n//\n//===----------------------------------------------------------------------===//\n\n#ifndef _LIBCPP_INITIALIZER_LIST\n#define _LIBCPP_INITIALIZER_LIST\n\n/*\n    initializer_list synopsis\n\nnamespace std\n{\n\ntemplate<class E>\nclass initializer_list\n{\npublic:\n    typedef E        value_type;\n    typedef const E& reference;\n    typedef const E& const_reference;\n    typedef size_t   size_type;\n\n    typedef const E* iterator;\n    typedef const E* const_iterator;\n\n    initializer_list() noexcept; // constexpr in C++14\n\n    size_t   size()  const noexcept; // constexpr in C++14\n    const E* begin() const noexcept; // constexpr in C++14\n    const E* end()   const noexcept; // constexpr in C++14\n};\n\ntemplate<class E> const E* begin(initializer_list<E> il) noexcept; // constexpr in C++14\ntemplate<class E> const E* end(initializer_list<E> il) noexcept; // constexpr in C++14\n\n}  // std\n\n*/\n\n#include <__config>\n#include <cstddef>\n\n#if !defined(_LIBCPP_HAS_NO_PRAGMA_SYSTEM_HEADER)\n#pragma GCC system_header\n#endif\n\nnamespace std  // purposefully not versioned\n{\n\n#ifndef _LIBCPP_HAS_NO_GENERALIZED_INITIALIZERS\n\ntemplate<class _Ep>\nclass _LIBCPP_TEMPLATE_VIS initializer_list\n{\n    const _Ep* __begin_;\n    size_t    __size_;\n\n    _LIBCPP_ALWAYS_INLINE\n    _LIBCPP_CONSTEXPR_AFTER_CXX11\n    initializer_list(const _Ep* __b, size_t __s) _NOEXCEPT\n        : __begin_(__b),\n          __size_(__s)\n        {}\npublic:\n    typedef _Ep        value_type;\n    typedef const _Ep& reference;\n    typedef const _Ep& const_reference;\n    typedef size_t    size_type;\n\n    typedef const _Ep* iterator;\n    typedef const _Ep* const_iterator;\n\n    _LIBCPP_ALWAYS_INLINE\n    _LIBCPP_CONSTEXPR_AFTER_CXX11\n    initializer_list() _NOEXCEPT : __begin_(nullptr), __size_(0) {}\n\n    _LIBCPP_ALWAYS_INLINE\n    _LIBCPP_CONSTEXPR_AFTER_CXX11\n    size_t    size()  const _NOEXCEPT {return __size_;}\n    \n    _LIBCPP_ALWAYS_INLINE\n    _LIBCPP_CONSTEXPR_AFTER_CXX11\n    const _Ep* begin() const _NOEXCEPT {return __begin_;}\n\n    _LIBCPP_ALWAYS_INLINE\n    _LIBCPP_CONSTEXPR_AFTER_CXX11\n    const _Ep* end()   const _NOEXCEPT {return __begin_ + __size_;}\n};\n\ntemplate<class _Ep>\ninline _LIBCPP_INLINE_VISIBILITY\n_LIBCPP_CONSTEXPR_AFTER_CXX11\nconst _Ep*\nbegin(initializer_list<_Ep> __il) _NOEXCEPT\n{\n    return __il.begin();\n}\n\ntemplate<class _Ep>\ninline _LIBCPP_INLINE_VISIBILITY\n_LIBCPP_CONSTEXPR_AFTER_CXX11\nconst _Ep*\nend(initializer_list<_Ep> __il) _NOEXCEPT\n{\n    return __il.end();\n}\n\n#endif  // _LIBCPP_HAS_NO_GENERALIZED_INITIALIZERS\n\n}  // std\n\n#endif  // _LIBCPP_INITIALIZER_LIST\n"]}
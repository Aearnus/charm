
<meta charset="utf-8">
<html>
    <head>
        <title>
            Charm Function Glossary
        </title>
        <script type="text/javascript">
            function codeClick(e) {
                var elem = e.target;
                var codePre = elem.parentElement.getElementsByClassName("code-drawer")[0];
                if (codePre.classList.contains("code-open")) {
                    codePre.classList.remove("code-open");
                    //codePre.style.height = "0";
                } else {
                    codePre.classList.add("code-open");
                    //var lineHeight = parseInt(window.getComputedStyle(codePre).lineHeight);
                    //codePre.style.height = (codePre.innerHTML.split("\n").length * lineHeight) + "px";
                }
            }
            function init() {
                var codes = document.getElementsByClassName("code-button");
                for (let code of codes) {
                    code.onclick = function (e) { codeClick(e); };
                }
            }
            window.onload = init;
        </script>
        <style type="text/css">
            html {
                background-color: #ddd;
            }
            body {
                width: 80%;
                min-width: 30em;
                margin: 0 auto;
                padding: 4em;
                padding-top: 2em;
                box-shadow: 0 0 100px black;
                background-color: #fff;
            }
            h2 {
                border-bottom: 2px solid #000;
            }
            h3 {
                border-bottom: 1px solid #000;
            }
            h3.function {
                border-bottom: 1px dotted #000;
            }
            .info {
                padding-left: 2em;
                margin-top: 0.5em;
                margin-bottom: 0.5em;
            }
            .code {
                overflow-y: hidden;
                background-color: #ccc;
                font-family: monospace;
                padding: 1em;
                white-space: pre;
            }
            .code-drawer {
                height: 0;
                padding: 0;
                margin: 0;

                transition: padding 0.5s cubic-bezier(0, 1, 0, 1);
                transition: margin 0.5s cubic-bezier(0, 1, 0, 1);
            }
            .code-open {
                padding: 1em;
                margin-top: 0.75em;
                margin-bottom: 0.75em;
                height: auto;
            }
        </style>
    </head>
    <body>
        <h1>
            Charm Function Glossary
        </h1>
        <p>
            This page was autogenerated by docs/GenerateGlossary.rb on 2018-03-31 22:25:49 -0700. It lists all of the functions in the Charm glossary in an easy to read, useful reference format.
        </p>
        <h2>
            Native Functions
        </h2>
        <h3>Input / Output</h3><h3 class="function">pp</h3><h4>Description</h4><div class="info">Prints the function off the top of the stack.</div><h4>Quick Usage View</h4><div class="code"><i>any</i> pp </div><div><h4>Pops</h4><dl class="info"><dt>Stack index 0: any</dt><dd>The function that will be printed</dd></dl></div>
<div class="code-container">
    <button class="code-button">
        Source (click to open/close)
    </button>
    <pre class="code code-drawer">void PredefinedFunctions::p(Runner* r) {
	PredefinedFunctions::print(r-&gt;getCurrentStack()-&gt;pop());
}

void PredefinedFunctions::print(CharmFunction f1) {
	printf(&quot;%s&quot;, charmFunctionToString(f1).c_str());
}
</pre>
</div>
<h3 class="function">newline</h3><h4>Description</h4><div class="info">Prints a newline.</div><h4>Quick Usage View</h4><div class="code">newline </div>
<div class="code-container">
    <button class="code-button">
        Source (click to open/close)
    </button>
    <pre class="code code-drawer">void PredefinedFunctions::newline(Runner* r) {
	printf(&quot;\n&quot;);
}
</pre>
</div>

<h3>Stack Manipulations</h3><h3 class="function">dup</h3><h4>Description</h4><div class="info">Duplicates the top value on the stack.</div><h4>Quick Usage View</h4><div class="code"><i>any</i> dup         => <i>any</i> <i>any</i> </div><div><h4>Pops</h4><dl class="info"><dt>Stack index 0: any</dt><dd>The duplicand</dd></dl></div><div><h4>Pushes</h4><dl class="info"><dt>Stack index 1: any</dt><dd>The duplicand</dd><dt>Stack index 0: any</dt><dd>The duplicand</dd></dl></div>
<div class="code-container">
    <button class="code-button">
        Source (click to open/close)
    </button>
    <pre class="code code-drawer">void PredefinedFunctions::dup(Runner* r) {
	CharmFunction f1 = r-&gt;getCurrentStack()-&gt;pop();
	r-&gt;getCurrentStack()-&gt;push(f1);
	r-&gt;getCurrentStack()-&gt;push(f1);
}
</pre>
</div>
<h3 class="function">pop</h3><h4>Description</h4><div class="info">Pops the top value off the stack.</div><h4>Quick Usage View</h4><div class="code"><i>any</i> pop </div><div><h4>Pops</h4><dl class="info"><dt>Stack index 0: any</dt><dd>The popped function</dd></dl></div>
<div class="code-container">
    <button class="code-button">
        Source (click to open/close)
    </button>
    <pre class="code code-drawer">void PredefinedFunctions::pop(Runner* r) {
	r-&gt;getCurrentStack()-&gt;pop();
}
</pre>
</div>
<h3 class="function">swap</h3><h4>Description</h4><div class="info">Swaps two values on the stack.</div><h4>Quick Usage View</h4><div class="code"><i>int</i> <i>int</i> swap </div><div><h4>Pops</h4><dl class="info"><dt>Stack index 1: int</dt><dd>The stack index of a value to swap</dd><dt>Stack index 0: int</dt><dd>The stack index of the other value to swap</dd></dl></div>
<div class="code-container">
    <button class="code-button">
        Source (click to open/close)
    </button>
    <pre class="code code-drawer">void PredefinedFunctions::swap(Runner* r) {
	CharmFunction f1 = r-&gt;getCurrentStack()-&gt;pop();
	CharmFunction f2 = r-&gt;getCurrentStack()-&gt;pop();
	//check to make sure we&#39;ve got ints that are positive and below MAX_STACK
	if (Stack::isInt(f1) &amp;&amp; Stack::isInt(f2)) {
		if ((f1.numberValue.integerValue &lt; 0) || (f2.numberValue.integerValue &lt; 0)) {
			runtime_die(&quot;Negative int passed to `swap`.&quot;);
		}
		if ((f1.numberValue.integerValue &gt;= r-&gt;MAX_STACK) || (f2.numberValue.integerValue &gt;= r-&gt;MAX_STACK)) {
			runtime_die(&quot;Overflowing pointers passed to `swap`.&quot;);
		}
		r-&gt;getCurrentStack()-&gt;swap((unsigned long long)f1.numberValue.integerValue, (unsigned long long)f2.numberValue.integerValue);
	} else {
		runtime_die(&quot;Non integer passed to `swap`.&quot;);
	}
}
</pre>
</div>

<h3>List / String Manipulations</h3><h3 class="function">len</h3><h4>Description</h4><div class="info">Finds the length of a list or string.</div><div class="info">NOTE: This can be used with any type, but will push a trivial value.</div><h4>Quick Usage View</h4><div class="code"><i>any</i> len         => <i>any</i> <i>int</i> </div><div><h4>Pops</h4><dl class="info"><dt>Stack index 0: any</dt><dd>The function to find the length of (usually lists or strings)</dd></dl></div><div><h4>Pushes</h4><dl class="info"><dt>Stack index 1: any</dt><dd>The previously popped function</dd><dt>Stack index 0: int</dt><dd>The popped function's length</dd></dl></div>
<div class="code-container">
    <button class="code-button">
        Source (click to open/close)
    </button>
    <pre class="code code-drawer">void PredefinedFunctions::len(Runner* r) {
	//list to check length of
	CharmFunction f1 = r-&gt;getCurrentStack()-&gt;pop();
	//push list back on because we dont need to get rid of it
	r-&gt;getCurrentStack()-&gt;push(f1);
	CharmFunction out;
	out.functionType = NUMBER_FUNCTION;
	CharmNumber num;
	num.whichType = INTEGER_VALUE;
	//make sure f1 is a list or string
	if (f1.functionType == LIST_FUNCTION) {
		num.integerValue = f1.literalFunctions.size();
	} else if (f1.functionType == STRING_FUNCTION) {
		num.integerValue = f1.stringValue.size();
	} else {
		//so if it&#39;s a bad type, i was going to just report a len of 0 or 1
		//but i feel like that would be really misleading. eh, i&#39;ll just do 1
		num.integerValue = 1;
	}
	out.numberValue = num;
	r-&gt;getCurrentStack()-&gt;push(out);
}
</pre>
</div>
<h3 class="function">at</h3><h4>Description</h4><div class="info">Gets the element at an index of a list or string.</div><div class="info">NOTE: This function cannot "unquote" values -- for a list, it pushes a list; and for a string, it pushes a string. This is deliberate, and is in order to prevent naked functions from being pushed to the stack. To "unquote" values, use `i`.</div><h4>Quick Usage View</h4><div class="code"><i>list/string</i> <i>int</i> at         => <i>list/string</i> <i>list/string</i> </div><div><h4>Pops</h4><dl class="info"><dt>Stack index 1: list/string</dt><dd>The list or string to index</dd><dt>Stack index 0: int</dt><dd>The index</dd></dl></div><div><h4>Pushes</h4><dl class="info"><dt>Stack index 1: list/string</dt><dd>The list or string previously popped</dd><dt>Stack index 0: list/string</dt><dd>The indexed element</dd></dl></div>
<div class="code-container">
    <button class="code-button">
        Source (click to open/close)
    </button>
    <pre class="code code-drawer">void PredefinedFunctions::at(Runner* r) {
	//index number
	CharmFunction f1 = r-&gt;getCurrentStack()-&gt;pop();
	//list / string
	CharmFunction f2 = r-&gt;getCurrentStack()-&gt;pop();
	r-&gt;getCurrentStack()-&gt;push(f2);
	if (Stack::isInt(f1)) {
		CharmFunction out;
		if (f2.functionType == LIST_FUNCTION) {
			out.functionType = LIST_FUNCTION;
			out.literalFunctions = { f2.literalFunctions.at(f1.numberValue.integerValue % f2.literalFunctions.size()) };
		} else if (f2.functionType == STRING_FUNCTION) {
			out.functionType = STRING_FUNCTION;
			out.stringValue = f2.stringValue[f1.numberValue.integerValue % f2.stringValue.size()];
		} else {
			runtime_die(&quot;Neither a list nor a string was passed to `at`&quot;);
		}
		r-&gt;getCurrentStack()-&gt;push(out);
	} else {
		runtime_die(&quot;Non integer index passed to `at`&quot;);
	}
}
</pre>
</div>
<h3 class="function">insert</h3><h4>Description</h4><div class="info">Insert an element into a list or string.</div><h4>Quick Usage View</h4><div class="code"><i>list/string</i> <i>list/string</i> <i>int</i> insert         => <i>list/string</i> </div><div><h4>Pops</h4><dl class="info"><dt>Stack index 2: list/string</dt><dd>The list or string to modify</dd><dt>Stack index 1: list/string</dt><dd>The element to be unboxed and inserted</dd><dt>Stack index 0: int</dt><dd>The insertation index</dd></dl></div><div><h4>Pushes</h4><dl class="info"><dt>Stack index 0: list/string</dt><dd>The modified list or string</dd></dl></div>
<div class="code-container">
    <button class="code-button">
        Source (click to open/close)
    </button>
    <pre class="code code-drawer">void PredefinedFunctions::insert(Runner* r) {
	//get index to insert in
	CharmFunction f1 = r-&gt;getCurrentStack()-&gt;pop();
	//get element to insert
	CharmFunction f2 = r-&gt;getCurrentStack()-&gt;pop();
	//get list or string
	CharmFunction f3 = r-&gt;getCurrentStack()-&gt;pop();
	//make sure f1 is an int
	if (!Stack::isInt(f1))
		runtime_die(&quot;Non integer index passed to `insert`.&quot;);
	if (f3.functionType == LIST_FUNCTION) {
		//only allow a list to be inserted into a list
		if (f2.functionType == LIST_FUNCTION) {
			f3.literalFunctions.insert(
				f3.literalFunctions.begin() + (f1.numberValue.integerValue % f3.literalFunctions.size()),
				f2.literalFunctions.begin(),
				f2.literalFunctions.end()
			);
		} else {
			runtime_die(&quot;Attempted to `insert` a non list into a list.&quot;);
		}
	} else if (f3.functionType == STRING_FUNCTION) {
		//only allow a string to be inserted into another string
		if (f2.functionType == STRING_FUNCTION) {
			f3.stringValue.insert(
				f1.numberValue.integerValue % f3.stringValue.size(),
				f2.stringValue
			);
		} else {
			runtime_die(&quot;Attempted to `insert` a non string into a string.&quot;);
		}
	}
	r-&gt;getCurrentStack()-&gt;push(f3);
}
</pre>
</div>
<h3 class="function">concat</h3><h4>Description</h4><div class="info">Concatenates two lists or strings.</div><h4>Quick Usage View</h4><div class="code"><i>list/string</i> <i>list/string</i> concat         => <i>list/string</i> </div><div><h4>Pops</h4><dl class="info"><dt>Stack index 1: list/string</dt><dd>The first list or string</dd><dt>Stack index 0: list/string</dt><dd>The second list or string</dd></dl></div><div><h4>Pushes</h4><dl class="info"><dt>Stack index 0: list/string</dt><dd>The concatenated list or string</dd></dl></div>
<div class="code-container">
    <button class="code-button">
        Source (click to open/close)
    </button>
    <pre class="code code-drawer">void PredefinedFunctions::concat(Runner* r) {
	//get first list
	CharmFunction f1 = r-&gt;getCurrentStack()-&gt;pop();
	//get second list (first in order of concatination)
	CharmFunction f2 = r-&gt;getCurrentStack()-&gt;pop();
	//make sure they&#39;re both lists or strings
	if ((f1.functionType == LIST_FUNCTION) &amp;&amp; (f2.functionType == LIST_FUNCTION)) {
		f2.literalFunctions.insert(f2.literalFunctions.end(), f1.literalFunctions.begin(), f1.literalFunctions.end());
	} else if ((f1.functionType == STRING_FUNCTION) &amp;&amp; (f2.functionType == STRING_FUNCTION)) {
		f2.stringValue = f2.stringValue + f1.stringValue;
	} else {
		runtime_die(&quot;Unmatching types passed to `concat`.&quot;);
	}
	r-&gt;getCurrentStack()-&gt;push(f2);
}
</pre>
</div>

<h3>Control Flow</h3><h3 class="function">i</h3><h4>Description</h4><div class="info">Similar to Lisp's `unquote`, runs the top of the stack as a program.</div><h4>Quick Usage View</h4><div class="code"><i>list</i> i </div><div><h4>Pops</h4><dl class="info"><dt>Stack index 0: list</dt><dd>The list to be unquoted and run</dd></dl></div>
<div class="code-container">
    <button class="code-button">
        Source (click to open/close)
    </button>
    <pre class="code code-drawer">void PredefinedFunctions::i(Runner* r) {
	//pop the top of the stack and run it
	CharmFunction f1 = r-&gt;getCurrentStack()-&gt;pop();
	if (f1.functionType == LIST_FUNCTION) {
		r-&gt;run(f1.literalFunctions);
	} else {
		runtime_die(&quot;Non list passed to `i`.&quot;);
	}
}
</pre>
</div>
<h3 class="function">ifthen</h3><h4>Description</h4><div class="info">Branching operator; runs the first block then decides whether or not to run the second or third based off of whether the top of the stack is > 0 or <= 0.</div><div class="info">NOTE: This is the only function which provides inherent tail call optimization. More info is written up in Documentation.md.</div><div class="info">NOTE: This function does not clean up after itself more than listed -- you need to clear the stack yourself if you want it cleared in a recursive function!</div><h4>Quick Usage View</h4><div class="code"><i>list</i> <i>list</i> <i>list</i> ifthen </div><div><h4>Pops</h4><dl class="info"><dt>Stack index 2: list</dt><dd>Condition to run before running truthy or falsy blocks</dd><dt>Stack index 1: list</dt><dd>Truthy (> 0) block</dd><dt>Stack index 0: list</dt><dd>Falsy (<= 0) block</dd></dl></div>
<div class="code-container">
    <button class="code-button">
        Source (click to open/close)
    </button>
    <pre class="code code-drawer">void PredefinedFunctions::ifthen(Runner* r, FunctionDefinition *context) {
	//the arguments to this function are a little different...
	//ifthen performs very basic tail-call optimization on its two sections (truthy/falsy)
	//if truthy (or falsy) end with the function itself (found through fD.functionName), then
	//the tail-call optimizer kicks in and the function simply loops instead of
	//creating a new stack frame by calling r-&gt;run()

	//this one is gonna take 3 arguments --
	//stack[2] = condition to run truthy section
	//stack[1] = truthy section (if...)
	//stack[0] = falsy section (else...)
	//have to reverse it because popping is weird
	CharmFunction falsy = r-&gt;getCurrentStack()-&gt;pop();
	bool falsyTailCall = false;
	CharmFunction truthy = r-&gt;getCurrentStack()-&gt;pop();
	bool truthyTailCall = false;
	CharmFunction condFunction = r-&gt;getCurrentStack()-&gt;pop();
	if ((condFunction.functionType == LIST_FUNCTION) &amp;&amp;
		(truthy.functionType == LIST_FUNCTION) &amp;&amp;
		(falsy.functionType == LIST_FUNCTION)) {
			//first, we run checks to set the tail call bools
			if (context != nullptr) {
				if (truthy.literalFunctions.back().functionName == context-&gt;functionName) {
					truthyTailCall = true;
				}
				if (falsy.literalFunctions.back().functionName == context-&gt;functionName) {
					falsyTailCall = true;
				}
				//now, if we _DO_ have a tail call, modify truthy/falsy and enter a loop instead
				//there are 3 seperate cases here -- truthy tail call, falsy tail call, or both
				if (truthyTailCall) {
					ONLYDEBUG printf(&quot;ENGAGING TRUTHY IF/THEN TAIL CALL OPTIMIZATION\n&quot;);
					//remove the tail call
					truthy.literalFunctions.pop_back();
					while (1) {
						r-&gt;run(condFunction.literalFunctions);
						CharmFunction cond = r-&gt;getCurrentStack()-&gt;pop();
						if (Stack::isInt(cond)) {
							if (cond.numberValue.integerValue &gt; 0) {
								r-&gt;run(truthy.literalFunctions);
							} else {
								r-&gt;run(falsy.literalFunctions);
								//end this function immediately once the tail call loop ends
								ONLYDEBUG printf(&quot;DISENGAGING TRUTHY IF/THEN TAIL CALL OPTIMIZATION\n&quot;);
								return;
							}
						} else {
							runtime_die(&quot;`ifthen` condition returned non integer.&quot;);
						}
					}
				}
				if (falsyTailCall) {
					ONLYDEBUG printf(&quot;ENGAGING FALSY IF/THEN TAIL CALL OPTIMIZATION\n&quot;);
					//remove the tail call
					falsy.literalFunctions.pop_back();
					while (1) {
						r-&gt;run(condFunction.literalFunctions);
						CharmFunction cond = r-&gt;getCurrentStack()-&gt;pop();
						if (Stack::isInt(cond)) {
							if (cond.numberValue.integerValue &gt; 0) {
								r-&gt;run(truthy.literalFunctions);
								//end this function immediately once the tail call loop ends
								ONLYDEBUG printf(&quot;DISENGAGING FALSY IF/THEN TAIL CALL OPTIMIZATION\n&quot;);
								return;
							} else {
								r-&gt;run(falsy.literalFunctions);
							}
						} else {
							runtime_die(&quot;`ifthen` condition returned non integer.&quot;);
						}
					}
				}
				//here&#39;s an extra special case if both truthy and falsy have a tail call
				//that is `f := [ &lt;cond&gt; ] [ &lt;code&gt; f ] [ &lt;code&gt; f ] ifthen`
				//this is equivalent to `f := [ &lt;cond&gt; ] [ &lt;code&gt; ] [ &lt;code&gt; ] ifthen f`
				//so we run it as an infinite loop
				if (truthyTailCall &amp;&amp; falsyTailCall) {
					ONLYDEBUG printf(&quot;ENGAGING TRUTHY/FALSY IF/THEN TAIL CALL OPTIMIZATION\n&quot;);
					//remove the tail calls
					truthy.literalFunctions.pop_back();
					falsy.literalFunctions.pop_back();
					while (1) {
						CharmFunction cond = r-&gt;getCurrentStack()-&gt;pop();
						if (Stack::isInt(cond)) {
							if (cond.numberValue.integerValue &gt; 0) {
								r-&gt;run(truthy.literalFunctions);
							} else {
								r-&gt;run(falsy.literalFunctions);
							}
						} else {
							runtime_die(&quot;`ifthen` condition returned non integer.&quot;);
						}
					}
				}
				//good joke
				ONLYDEBUG printf(&quot;DISENGAGING TRUTHY/FALSY IF/THEN TAIL CALL OPTIMIZATION\n&quot;);
			}
			//but if not (or context was nullptr), continue execution as normal
			r-&gt;run(condFunction.literalFunctions);
			//now we check the top of the stack to see if it&#39;s truthy or falsy
			CharmFunction cond = r-&gt;getCurrentStack()-&gt;pop();
			if (Stack::isInt(cond)) {
				if (cond.numberValue.integerValue &gt; 0) {
					r-&gt;run(truthy.literalFunctions);
				} else {
					r-&gt;run(falsy.literalFunctions);
				}
			} else {
				runtime_die(&quot;`ifthen` condition returned non integer.&quot;);
			}
		} else {
			runtime_die(&quot;Non list passed to `ifthen`.&quot;);
		}
}
</pre>
</div>

        <h2>
            Prelude Functions
        </h2>
</html>

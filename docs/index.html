
<!DOCTYPE html>
<meta charset="utf-8" />
<html>
    <head>
        <title>
            Charm Function Glossary
        </title>
        <script type="text/javascript" src="charm.js"></script>
        <script type="text/javascript" src="expose_charm.js"></script>
        <script type="text/javascript">
            function codeClick(e) {
                var elem = e.target;
                var codePre = elem.parentElement.getElementsByClassName("code-drawer")[0];
                if (codePre.classList.contains("code-open")) {
                    codePre.classList.remove("code-open");
                    //codePre.style.height = "0";
                } else {
                    codePre.classList.add("code-open");
                    //var lineHeight = parseInt(window.getComputedStyle(codePre).lineHeight);
                    //codePre.style.height = (codePre.innerHTML.split("\n").length * lineHeight) + "px";
                }
            }
            function replOnKeyDown(e) {
                if (e.keyCode == 13) {
                    var i = document.getElementById("replInput");
                    runCharm(i.value);
                    i.value = "";
                }
            }
            function init() {
                var codes = document.getElementsByClassName("code-button");
                for (let code of codes) {
                    code.onclick = function (e) { codeClick(e); };
                }
                document.getElementById("replInput").onkeydown = function (e) { replOnKeyDown(e); };
                initCharm();
            }
            window.onload = init;
        </script>
        <style type="text/css">
            html {
                background-color: #ddd;
                font-family: sans-serif;
            }
            body {
                width: 80%;
                min-width: 30em;
                margin: 0 auto;
                padding: 4em;
                padding-top: 2em;
                box-shadow: 0 0 100px #666;
                background-color: #fff;
            }
            h2.function-header {
                border-bottom: 2px solid #000;
            }
            .index-header {
                width: 100%;
                text-align: center;
            }
            h3 {
                border-bottom: 1px solid #000;
            }
            h3.function {
                border-bottom: 1px dotted #000;
            }
            h3.function:target {
                background-color: yellow;
            }
            #replOutput {
                margin: 0 auto;
                width: 100%;
                height: 16em;
                padding: 8px;
                border-width: thin;
                border-color: black;
                border-style: solid;
                border-radius: 5px
                background-color: #ccc;
                font-family: monospace;
                overflow-y: scroll;
            }
            #replInput {
                width: calc(100% - 15em);
            }
            .info {
                padding-left: 2em;
                margin-top: 0.5em;
                margin-bottom: 0.5em;
            }
            .code {
                overflow-y: hidden;
                background-color: #ccc;
                font-family: monospace;
                padding: 1em;
                white-space: pre;
            }
            .code-drawer {
                height: 0;
                padding: 0;
                margin: 0;

                transition: padding 0.5s cubic-bezier(0, 1, 0, 1);
                transition: margin 0.5s cubic-bezier(0, 1, 0, 1);
            }
            .code-open {
                padding: 1em;
                margin-top: 0.75em;
                margin-bottom: 0.75em;
                height: auto;
            }
        </style>
    </head>
    <body>
        <h1>
            Charm Function Glossary
        </h1>
        <p>
            This page was autogenerated by docs/GenerateGlossary.rb on 2018-04-24 01:02:28 -0700. It lists all of the functions in the Charm glossary in an easy to read, useful reference format.
        </p>
        <p>
            If you've stumbled across this page on accident, please feel free to check out Charm, a stack-based functional programming language at <a href="https://github.com/aearnus/charm">https://github.com/aearnus/charm</a>. It's free, terse, paradigm-smashing, and fun to use and think in.
        </p>
        <h2>
            Try Charm!
        </h2>
        <pre id="replOutput">charm version 0.1.0, built on Apr 23 2018 at 19:09:55. built using emscripten.</pre>
        <label id="replInputLabel" for="replInput">
            Charm (stack omitted)$
        </label>
        <input type="text" name="replInput" id="replInput" placeholder="Type Charm code here and press return...">
        <h2 class="index-header">
            Quick Function Index
        </h2>
        <div>
            <div style="float:left;width:45%">
                <h3 class="index-header">
                    Native Functions
                </h3>
                <h3 class="function">Input / Output</h3><a href="#p-id">p</a> <a href="#pstring-id">pstring</a> <a href="#newline-id">newline</a> <a href="#getline-id">getline</a> <h3 class="function">Debugging Functions</h3><a href="#type-id">type</a> <h3 class="function">Function Definition</h3><a href="#def-id">def</a> <a href="#ffi-id">ffi</a> <h3 class="function">Comparisons</h3><a href="#eq-id">eq</a> <h3 class="function">Stack Manipulations</h3><a href="#dup-id">dup</a> <a href="#pop-id">pop</a> <a href="#swap-id">swap</a> <h3 class="function">List / String Manipulations</h3><a href="#len-id">len</a> <a href="#at-id">at</a> <a href="#insert-id">insert</a> <a href="#concat-id">concat</a> <a href="#split-id">split</a> <h3 class="function">String Manipulation</h3><a href="#tostring-id">tostring</a> <a href="#char-id">char</a> <a href="#ord-id">ord</a> <h3 class="function">Control Flow</h3><a href="#i-id">i</a> <a href="#q-id">q</a> <a href="#ifthen-id">ifthen</a> <a href="#inline-id">inline</a> <h3 class="function">Boolean Operations</h3><a href="#xor-id">xor</a> <h3 class="function">Type Inspecific Math</h3><a href="#abs-id">abs</a> <h3 class="function">Integer Operations</h3><a href="#+-id">+</a> <a href="#--id">-</a> <a href="#*-id">*</a> <a href="#/-id">/</a> <a href="#toint-id">toint</a> <h3 class="function">Stack Creation and Destruction</h3><a href="#createstack-id">createstack</a> <a href="#getstack-id">getstack</a> <a href="#switchstack-id">switchstack</a> <h3 class="function">Reference Getting and Setting</h3><a href="#getref-id">getref</a> <a href="#setref-id">setref</a> <h3 class="function">Library Interaction</h3><a href="#include-id">include</a> 
            </div>
            <div style="float:right;width:45%">
                <h3 class="index-header">
                    Prelude Functions
                </h3>
                <h3 class="function">Output Functions</h3><a href="#put-id">put</a> <h3 class="function">Debugging Functions</h3><a href="#clearstack-id">clearstack</a> <a href="#pause-id">pause</a> <a href="#printstack-id">printstack</a> <a href="#stepthrough-id">stepthrough</a> <h3 class="function">Stack Manipulation</h3><a href="#flip-id">flip</a> <a href="#swapnth-id">swapnth</a> <a href="#copyfrom-id">copyfrom</a> <a href="#pushto-id">pushto</a> <a href="#rotate-id">rotate</a> <a href="#stack-id">stack</a> <h3 class="function">String Manipulation</h3><a href="#substring-id">substring</a> <a href="#space-id">space</a> <h3 class="function">List Manipulation</h3><a href="#cut-id">cut</a> <a href="#repeat-id">repeat</a> <a href="#map-id">map</a> 
            </div>
            <div style="clear:both"></div>
        </div>
        <h2 class="function-header">
            Native Functions
        </h2>
        <h3>Input / Output</h3><h3 id="p-id" class="function">p</h3><h4>Description</h4><div class="info">Prints the function off the top of the stack.</div><h4>Quick Usage View</h4><div class="code"><i>any</i> p </div><div><h4>Pops</h4><dl class="info"><dt>Stack index 0: any</dt><dd>The function that will be printed</dd></dl></div>
<div class="code-container">
    <button class="code-button">
        Source (click to open/close)
    </button>
    <pre class="code code-drawer">void PredefinedFunctions::p(Runner* r) {
	PredefinedFunctions::print(r-&gt;getCurrentStack()-&gt;pop());
}

void PredefinedFunctions::print(CharmFunction f1) {
	printf(&quot;%s&quot;, charmFunctionToString(f1).c_str());
}
</pre>
</div>
<h3 id="pstring-id" class="function">pstring</h3><h4>Description</h4><div class="info">Prints a string off the top of the stack.</div><h4>Quick Usage View</h4><div class="code"><i>string</i> pstring </div><div><h4>Pops</h4><dl class="info"><dt>Stack index 0: string</dt><dd>The string that will be printed</dd></dl></div>
<div class="code-container">
    <button class="code-button">
        Source (click to open/close)
    </button>
    <pre class="code code-drawer">addBuiltinFunction(&quot;pstring&quot;, [](Runner* r) {
	CharmFunction f1 = r-&gt;getCurrentStack()-&gt;pop();
	if (f1.functionType == STRING_FUNCTION) {
		printf(&quot;%s&quot;, f1.stringValue.c_str());
	} else {
		runtime_die(&quot;Non string passed to `pstring`.&quot;);
	}
});
</pre>
</div>
<h3 id="newline-id" class="function">newline</h3><h4>Description</h4><div class="info">Prints a newline.</div><h4>Quick Usage View</h4><div class="code">newline </div>
<div class="code-container">
    <button class="code-button">
        Source (click to open/close)
    </button>
    <pre class="code code-drawer">void PredefinedFunctions::newline(Runner* r) {
	printf(&quot;\n&quot;);
}
</pre>
</div>
<h3 id="getline-id" class="function">getline</h3><h4>Description</h4><div class="info">Gets a line from standard input.</div><h4>Quick Usage View</h4><div class="code">getline         => <i>string</i> </div><div><h4>Pushes</h4><dl class="info"><dt>Stack index 0: string</dt><dd>The line from standard input</dd></dl></div>
<div class="code-container">
    <button class="code-button">
        Source (click to open/close)
    </button>
    <pre class="code code-drawer">void PredefinedFunctions::getline(Runner* r) {
	CharmFunction input;
	input.functionType = STRING_FUNCTION;
	std::getline(std::cin, input.stringValue);
	r-&gt;getCurrentStack()-&gt;push(input);
}
</pre>
</div>

<h3>Debugging Functions</h3><h3 id="type-id" class="function">type</h3><h4>Description</h4><div class="info">Pushes the type of the function to the stack.</div><h4>Quick Usage View</h4><div class="code"><i>any</i> type         => <i>any</i> <i>string</i> </div><div><h4>Pops</h4><dl class="info"><dt>Stack index 0: any</dt><dd>The function to find the type of</dd></dl></div><div><h4>Pushes</h4><dl class="info"><dt>Stack index 1: any</dt><dd>The input function</dd><dt>Stack index 0: string</dt><dd>The type of the input function</dd></dl></div>
<div class="code-container">
    <button class="code-button">
        Source (click to open/close)
    </button>
    <pre class="code code-drawer">addBuiltinFunction(&quot;type&quot;, [](Runner* r) {
	CharmFunction f1 = r-&gt;getCurrentStack()-&gt;pop();
	CharmFunction out;
	out.functionType = STRING_FUNCTION;
	switch (f1.functionType) {
		case LIST_FUNCTION:
		out.stringValue = &quot;LIST_FUNCTION&quot;;
		break;

		case NUMBER_FUNCTION:
		out.stringValue = &quot;NUMBER_FUNCTION&quot;
		break;

		case STRING_FUNCTION:
		out.stringValue = &quot;STRING_FUNCTION&quot;
		break;

		case DEFINED_FUNCTION:
		out.stringValue = &quot;DEFINED_FUNCTION&quot;
		break;

		case FUNCTION_DEFINITION:
		out.stringValue = &quot;FUNCTION_DEFINITION&quot;
		break;
	}
	r-&gt;getCurrentStack()-&gt;push(out);
});
</pre>
</div>

<h3>Function Definition</h3><h3 id="def-id" class="function">def</h3><h4>Description</h4><div class="info">Define a function without any special syntax.</div><h4>Quick Usage View</h4><div class="code"><i>string</i> <i>list</i> def </div><div><h4>Pops</h4><dl class="info"><dt>Stack index 1: string</dt><dd>The name of the function to define</dd><dt>Stack index 0: list</dt><dd>The body of the function</dd></dl></div>
<div class="code-container">
    <button class="code-button">
        Source (click to open/close)
    </button>
    <pre class="code code-drawer">addBuiltinFunction(&quot;def&quot;, [](Runner* r, RunnerContext* context) {
	//function body
	CharmFunction f1 = r-&gt;getCurrentStack()-&gt;pop();
	//function name
	CharmFunction f2 = r-&gt;getCurrentStack()-&gt;pop();
	if (f2.functionType != STRING_FUNCTION) {
		runtime_die(&quot;Non string passed to `def`.&quot;);
	}
	if (f1.functionType != LIST_FUNCTION) {
		runtime_die(&quot;Non list passed to `def`.&quot;);
	}
	//a function with type FUNCTION_DEFINITION
	CharmFunction f;
	f.functionType = FUNCTION_DEFINITION;
	f.functionName = f2.stringValue;
	f.literalFunctions = f1.literalFunctions;

	FunctionDefinition fD;
	fD.functionName = f.functionName;
	fD.functionBody = f.literalFunctions;

	CharmFunctionDefinitionInfo defInfo;
	defInfo.inlineable = context-&gt;fA-&gt;isInlinable(f);
	if (defInfo.inlineable) {
		context-&gt;fA-&gt;addToInlineDefinitions(f);
	}
	defInfo.tailCallRecursive = context-&gt;fA-&gt;isInlinable(f);

	fD.definitionInfo = defInfo;
	r-&gt;addFunctionDefinition(fD);
});
</pre>
</div>
<h3 id="ffi-id" class="function">ffi</h3><h4>Description</h4><div class="info">Define a function through the Foreign Function Interface.</div><div class="info">NOTE: There is only one type of function accepted, and that type is defined in <span class="code">FFI.h</span> as <span class="code">typedef void (*MutateFFI)(Runner*);</span>. Since <span class="code">Runner</span> uses C++ types inside of it, any functions from other languages must be called through a C++ compatibility layer.</div><h4>Quick Usage View</h4><div class="code"><i>string</i> <i>string</i> <i>string</i> ffi </div><div><h4>Pops</h4><dl class="info"><dt>Stack index 2: string</dt><dd>The name of the charm function to define</dd><dt>Stack index 1: string</dt><dd>The path to the library</dd><dt>Stack index 0: string</dt><dd>The name of the function symbol from the library</dd></dl></div>
<div class="code-container">
    <button class="code-button">
        Source (click to open/close)
    </button>
    <pre class="code code-drawer">addBuiltinFunction(&quot;ffi&quot;, [](Runner* r) {
	//library symbol
	CharmFunction f1 = r-&gt;getCurrentStack()-&gt;pop();
	//library path
	CharmFunction f2 = r-&gt;getCurrentStack()-&gt;pop();
	//charm function name
	CharmFunction f3 = r-&gt;getCurrentStack()-&gt;pop();
	if (f1.functionType != STRING_FUNCTION || f2.functionType != STRING_FUNCTION || f3.functionType != STRING_FUNCTION) {
		runtime_die(&quot;Non string passed to `ffi`.&quot;);
	}
	r-&gt;ffi-&gt;loadMutateFFI(f3.stringValue, f2.stringValue, f1.stringValue);
});
</pre>
</div>

<h3>Comparisons</h3><h3 id="eq-id" class="function">eq</h3><h4>Description</h4><div class="info">Compares the equality of the top two functions on the stack.</div><h4>Quick Usage View</h4><div class="code"><i>any</i> <i>any</i> eq         => <i>int</i> </div><div><h4>Pops</h4><dl class="info"><dt>Stack index 1: any</dt><dd>The first function to check equality of</dd><dt>Stack index 0: any</dt><dd>The second function to check equality of</dd></dl></div><div><h4>Pushes</h4><dl class="info"><dt>Stack index 0: int</dt><dd>1 if equal, 0 if not</dd></dl></div>
<div class="code-container">
    <button class="code-button">
        Source (click to open/close)
    </button>
    <pre class="code code-drawer">addBuiltinFunction(&quot;eq&quot;, [](Runner* r) {
	CharmFunction f1 = r-&gt;getCurrentStack()-&gt;pop();
	CharmFunction f2 = r-&gt;getCurrentStack()-&gt;pop();
	CharmFunction out;
	out.functionType = NUMBER_FUNCTION;
	out.numberValue.whichType = INTEGER_VALUE;
	out.numberValue.integerValue = f1 == f2 ? 1 : 0;
	r-&gt;getCurrentStack()-&gt;push(out);
});
</pre>
</div>

<h3>Stack Manipulations</h3><h3 id="dup-id" class="function">dup</h3><h4>Description</h4><div class="info">Duplicates the top value on the stack.</div><h4>Quick Usage View</h4><div class="code"><i>any</i> dup         => <i>any</i> <i>any</i> </div><div><h4>Pops</h4><dl class="info"><dt>Stack index 0: any</dt><dd>The duplicand</dd></dl></div><div><h4>Pushes</h4><dl class="info"><dt>Stack index 1: any</dt><dd>The duplicand</dd><dt>Stack index 0: any</dt><dd>The duplicand</dd></dl></div>
<div class="code-container">
    <button class="code-button">
        Source (click to open/close)
    </button>
    <pre class="code code-drawer">void PredefinedFunctions::dup(Runner* r) {
	CharmFunction f1 = r-&gt;getCurrentStack()-&gt;pop();
	r-&gt;getCurrentStack()-&gt;push(f1);
	r-&gt;getCurrentStack()-&gt;push(f1);
}
</pre>
</div>
<h3 id="pop-id" class="function">pop</h3><h4>Description</h4><div class="info">Pops the top value off the stack.</div><h4>Quick Usage View</h4><div class="code"><i>any</i> pop </div><div><h4>Pops</h4><dl class="info"><dt>Stack index 0: any</dt><dd>The popped function</dd></dl></div>
<div class="code-container">
    <button class="code-button">
        Source (click to open/close)
    </button>
    <pre class="code code-drawer">void PredefinedFunctions::pop(Runner* r) {
	r-&gt;getCurrentStack()-&gt;pop();
}
</pre>
</div>
<h3 id="swap-id" class="function">swap</h3><h4>Description</h4><div class="info">Swaps two values on the stack.</div><h4>Quick Usage View</h4><div class="code"><i>int</i> <i>int</i> swap </div><div><h4>Pops</h4><dl class="info"><dt>Stack index 1: int</dt><dd>The stack index of a value to swap</dd><dt>Stack index 0: int</dt><dd>The stack index of the other value to swap</dd></dl></div>
<div class="code-container">
    <button class="code-button">
        Source (click to open/close)
    </button>
    <pre class="code code-drawer">void PredefinedFunctions::swap(Runner* r) {
	CharmFunction f1 = r-&gt;getCurrentStack()-&gt;pop();
	CharmFunction f2 = r-&gt;getCurrentStack()-&gt;pop();
	//check to make sure we&#39;ve got ints that are positive and below MAX_STACK
	if (Stack::isInt(f1) &amp;&amp; Stack::isInt(f2)) {
		if ((f1.numberValue.integerValue &lt; 0) || (f2.numberValue.integerValue &lt; 0)) {
			runtime_die(&quot;Negative int passed to `swap`.&quot;);
		}
		if ((f1.numberValue.integerValue &gt;= r-&gt;MAX_STACK) || (f2.numberValue.integerValue &gt;= r-&gt;MAX_STACK)) {
			runtime_die(&quot;Overflowing pointers passed to `swap`.&quot;);
		}
		r-&gt;getCurrentStack()-&gt;swap((unsigned long long)f1.numberValue.integerValue, (unsigned long long)f2.numberValue.integerValue);
	} else {
		runtime_die(&quot;Non integer passed to `swap`.&quot;);
	}
}
</pre>
</div>

<h3>List / String Manipulations</h3><h3 id="len-id" class="function">len</h3><h4>Description</h4><div class="info">Finds the length of a list or string.</div><div class="info">NOTE: This can be used with any type, but will push a trivial value.</div><h4>Quick Usage View</h4><div class="code"><i>any</i> len         => <i>any</i> <i>int</i> </div><div><h4>Pops</h4><dl class="info"><dt>Stack index 0: any</dt><dd>The function to find the length of (usually lists or strings)</dd></dl></div><div><h4>Pushes</h4><dl class="info"><dt>Stack index 1: any</dt><dd>The previously popped function</dd><dt>Stack index 0: int</dt><dd>The popped function's length</dd></dl></div>
<div class="code-container">
    <button class="code-button">
        Source (click to open/close)
    </button>
    <pre class="code code-drawer">void PredefinedFunctions::len(Runner* r) {
	//list to check length of
	CharmFunction f1 = r-&gt;getCurrentStack()-&gt;pop();
	//push list back on because we dont need to get rid of it
	r-&gt;getCurrentStack()-&gt;push(f1);
	CharmFunction out;
	out.functionType = NUMBER_FUNCTION;
	CharmNumber num;
	num.whichType = INTEGER_VALUE;
	//make sure f1 is a list or string
	if (f1.functionType == LIST_FUNCTION) {
		num.integerValue = f1.literalFunctions.size();
	} else if (f1.functionType == STRING_FUNCTION) {
		num.integerValue = f1.stringValue.size();
	} else {
		//so if it&#39;s a bad type, i was going to just report a len of 0 or 1
		//but i feel like that would be really misleading. eh, i&#39;ll just do 1
		num.integerValue = 1;
	}
	out.numberValue = num;
	r-&gt;getCurrentStack()-&gt;push(out);
}
</pre>
</div>
<h3 id="at-id" class="function">at</h3><h4>Description</h4><div class="info">Gets the element at an index of a list or string.</div><div class="info">NOTE: This function cannot "unquote" values -- for a list, it pushes a list; and for a string, it pushes a string. This is deliberate, and is in order to prevent naked functions from being pushed to the stack. To "unquote" values, use `i`.</div><h4>Quick Usage View</h4><div class="code"><i>list/string</i> <i>int</i> at         => <i>list/string</i> <i>list/string</i> </div><div><h4>Pops</h4><dl class="info"><dt>Stack index 1: list/string</dt><dd>The list or string to index</dd><dt>Stack index 0: int</dt><dd>The index</dd></dl></div><div><h4>Pushes</h4><dl class="info"><dt>Stack index 1: list/string</dt><dd>The list or string previously popped</dd><dt>Stack index 0: list/string</dt><dd>The indexed element</dd></dl></div>
<div class="code-container">
    <button class="code-button">
        Source (click to open/close)
    </button>
    <pre class="code code-drawer">void PredefinedFunctions::at(Runner* r) {
	//index number
	CharmFunction f1 = r-&gt;getCurrentStack()-&gt;pop();
	//list / string
	CharmFunction f2 = r-&gt;getCurrentStack()-&gt;pop();
	r-&gt;getCurrentStack()-&gt;push(f2);
	if (Stack::isInt(f1)) {
		CharmFunction out;
		if (f2.functionType == LIST_FUNCTION) {
			out.functionType = LIST_FUNCTION;
			out.literalFunctions = { f2.literalFunctions.at(f1.numberValue.integerValue % f2.literalFunctions.size()) };
		} else if (f2.functionType == STRING_FUNCTION) {
			out.functionType = STRING_FUNCTION;
			out.stringValue = f2.stringValue[f1.numberValue.integerValue % f2.stringValue.size()];
		} else {
			runtime_die(&quot;Neither a list nor a string was passed to `at`&quot;);
		}
		r-&gt;getCurrentStack()-&gt;push(out);
	} else {
		runtime_die(&quot;Non integer index passed to `at`&quot;);
	}
}
</pre>
</div>
<h3 id="insert-id" class="function">insert</h3><h4>Description</h4><div class="info">Insert an element into a list or string.</div><h4>Quick Usage View</h4><div class="code"><i>list/string</i> <i>list/string</i> <i>int</i> insert         => <i>list/string</i> </div><div><h4>Pops</h4><dl class="info"><dt>Stack index 2: list/string</dt><dd>The list or string to modify</dd><dt>Stack index 1: list/string</dt><dd>The element to be unboxed and inserted</dd><dt>Stack index 0: int</dt><dd>The insertation index</dd></dl></div><div><h4>Pushes</h4><dl class="info"><dt>Stack index 0: list/string</dt><dd>The modified list or string</dd></dl></div>
<div class="code-container">
    <button class="code-button">
        Source (click to open/close)
    </button>
    <pre class="code code-drawer">void PredefinedFunctions::insert(Runner* r) {
	//get index to insert in
	CharmFunction f1 = r-&gt;getCurrentStack()-&gt;pop();
	//get element to insert
	CharmFunction f2 = r-&gt;getCurrentStack()-&gt;pop();
	//get list or string
	CharmFunction f3 = r-&gt;getCurrentStack()-&gt;pop();
	//make sure f1 is an int
	if (!Stack::isInt(f1))
		runtime_die(&quot;Non integer index passed to `insert`.&quot;);
	if (f3.functionType == LIST_FUNCTION) {
		//only allow a list to be inserted into a list
		if (f2.functionType == LIST_FUNCTION) {
			f3.literalFunctions.insert(
				f3.literalFunctions.begin() + (f1.numberValue.integerValue % f3.literalFunctions.size()),
				f2.literalFunctions.begin(),
				f2.literalFunctions.end()
			);
		} else {
			runtime_die(&quot;Attempted to `insert` a non list into a list.&quot;);
		}
	} else if (f3.functionType == STRING_FUNCTION) {
		//only allow a string to be inserted into another string
		if (f2.functionType == STRING_FUNCTION) {
			f3.stringValue.insert(
				f1.numberValue.integerValue % f3.stringValue.size(),
				f2.stringValue
			);
		} else {
			runtime_die(&quot;Attempted to `insert` a non string into a string.&quot;);
		}
	}
	r-&gt;getCurrentStack()-&gt;push(f3);
}
</pre>
</div>
<h3 id="concat-id" class="function">concat</h3><h4>Description</h4><div class="info">Concatenates two lists or strings.</div><h4>Quick Usage View</h4><div class="code"><i>list/string</i> <i>list/string</i> concat         => <i>list/string</i> </div><div><h4>Pops</h4><dl class="info"><dt>Stack index 1: list/string</dt><dd>The first list or string</dd><dt>Stack index 0: list/string</dt><dd>The second list or string</dd></dl></div><div><h4>Pushes</h4><dl class="info"><dt>Stack index 0: list/string</dt><dd>The concatenated list or string</dd></dl></div>
<div class="code-container">
    <button class="code-button">
        Source (click to open/close)
    </button>
    <pre class="code code-drawer">void PredefinedFunctions::concat(Runner* r) {
	//get first list
	CharmFunction f1 = r-&gt;getCurrentStack()-&gt;pop();
	//get second list (first in order of concatination)
	CharmFunction f2 = r-&gt;getCurrentStack()-&gt;pop();
	//make sure they&#39;re both lists or strings
	if ((f1.functionType == LIST_FUNCTION) &amp;&amp; (f2.functionType == LIST_FUNCTION)) {
		f2.literalFunctions.insert(f2.literalFunctions.end(), f1.literalFunctions.begin(), f1.literalFunctions.end());
	} else if ((f1.functionType == STRING_FUNCTION) &amp;&amp; (f2.functionType == STRING_FUNCTION)) {
		f2.stringValue = f2.stringValue + f1.stringValue;
	} else {
		runtime_die(&quot;Unmatching types passed to `concat`.&quot;);
	}
	r-&gt;getCurrentStack()-&gt;push(f2);
}
</pre>
</div>
<h3 id="split-id" class="function">split</h3><h4>Description</h4><div class="info">Split a list or string after a certain amount of elements.</div><div class="info">NOTE: This function is the inverse of `concat`. That is, `[ list ] n split concat` is equal to `[ list ]`.</div><h4>Quick Usage View</h4><div class="code"><i>list/string</i> <i>int</i> split         => <i>list/string</i> <i>list/string</i> </div><div><h4>Pops</h4><dl class="info"><dt>Stack index 1: list/string</dt><dd>The list or string to split</dd><dt>Stack index 0: int</dt><dd>The amount of elements before the list or string is split</dd></dl></div><div><h4>Pushes</h4><dl class="info"><dt>Stack index 1: list/string</dt><dd>The first part of the list or string</dd><dt>Stack index 0: list/string</dt><dd>The rest of the list or string</dd></dl></div>
<div class="code-container">
    <button class="code-button">
        Source (click to open/close)
    </button>
    <pre class="code code-drawer">void PredefinedFunctions::concat(Runner* r) {
	//get first list
	CharmFunction f1 = r-&gt;getCurrentStack()-&gt;pop();
	//get second list (first in order of concatination)
	CharmFunction f2 = r-&gt;getCurrentStack()-&gt;pop();
	//make sure they&#39;re both lists or strings
	if ((f1.functionType == LIST_FUNCTION) &amp;&amp; (f2.functionType == LIST_FUNCTION)) {
		f2.literalFunctions.insert(f2.literalFunctions.end(), f1.literalFunctions.begin(), f1.literalFunctions.end());
	} else if ((f1.functionType == STRING_FUNCTION) &amp;&amp; (f2.functionType == STRING_FUNCTION)) {
		f2.stringValue = f2.stringValue + f1.stringValue;
	} else {
		runtime_die(&quot;Unmatching types passed to `concat`.&quot;);
	}
	r-&gt;getCurrentStack()-&gt;push(f2);
}
</pre>
</div>

<h3>String Manipulation</h3><h3 id="tostring-id" class="function">tostring</h3><h4>Description</h4><div class="info">Convert a function into a parseable string.</div><div class="info">NOTE: This function essentially turns a function into a string that can be plopped back into the interpreter. This may cause unexpected functionality, such as <span class="code">" hello " tostring</span> shooting back <span class="code">" " hello " " </span>.</div><h4>Quick Usage View</h4><div class="code"><i>any</i> tostring         => <i>string</i> </div><div><h4>Pops</h4><dl class="info"><dt>Stack index 0: any</dt><dd>The function to convert to a string</dd></dl></div><div><h4>Pushes</h4><dl class="info"><dt>Stack index 0: string</dt><dd>The converted, parseable function</dd></dl></div>
<div class="code-container">
    <button class="code-button">
        Source (click to open/close)
    </button>
    <pre class="code code-drawer">addBuiltinFunction(&quot;tostring&quot;, [](Runner* r) {
	CharmFunction f1 = r-&gt;getCurrentStack()-&gt;pop();
	CharmFunction out;
	out.functionType = STRING_FUNCTION;
	out.stringValue = charmFunctionToString(f1);
	r-&gt;getCurrentStack()-&gt;push(out);
});
</pre>
</div>
<h3 id="char-id" class="function">char</h3><h4>Description</h4><div class="info">Convert an integer to its corresponding character.</div><h4>Quick Usage View</h4><div class="code"><i>int</i> char         => <i>string</i> </div><div><h4>Pops</h4><dl class="info"><dt>Stack index 0: int</dt><dd>The integer to convert to a character</dd></dl></div><div><h4>Pushes</h4><dl class="info"><dt>Stack index 0: string</dt><dd>A string containing the converted character</dd></dl></div>
<div class="code-container">
    <button class="code-button">
        Source (click to open/close)
    </button>
    <pre class="code code-drawer">addBuiltinFunction(&quot;char&quot;, [](Runner* r) {
    CharmFunction f1 = r-&gt;getCurrentStack()-&gt;pop();
    if (f1.functionType == NUMBER_FUNCTION) {
        if (f1.numberValue.whichType == INTEGER_VALUE) {
            if (f1.numberValue.integerValue &lt; 0) {
                runtime_die(&quot;Negative integer passed to `char`.&quot;);
            } else {
                CharmFunction out;
                out.functionType = STRING_FUNCTION;
                out.stringValue = std::string(1, static_cast&lt;char&gt;(f1.numberValue.integerValue));
                r-&gt;getCurrentStack()-&gt;push(out);
            }
        } else {
            runtime_die(&quot;Non integer passed to `char`.&quot;);
        }
    } else {
        runtime_die(&quot;Non number passed to `char`.&quot;);
    }
});
</pre>
</div>
<h3 id="ord-id" class="function">ord</h3><h4>Description</h4><div class="info">Convert a character to its corresponding integer.</div><h4>Quick Usage View</h4><div class="code"><i>string</i> ord         => <i>int</i> </div><div><h4>Pops</h4><dl class="info"><dt>Stack index 0: string</dt><dd>The string containing a first character to convert to an integer</dd></dl></div><div><h4>Pushes</h4><dl class="info"><dt>Stack index 0: int</dt><dd>An integer representing the first character in the input string</dd></dl></div>
<div class="code-container">
    <button class="code-button">
        Source (click to open/close)
    </button>
    <pre class="code code-drawer">addBuiltinFunction(&quot;ord&quot;, [](Runner* r) {
    CharmFunction f1 = r-&gt;getCurrentStack()-&gt;pop();
    if (f1.functionType == STRING_FUNCTION) {
        if (f1.stringValue.size() &gt; 0) {
            CharmFunction out;
            CharmNumber n;
            n.whichType = INTEGER_VALUE;
            n.integerValue = static_cast&lt;long long&gt;(f1.stringValue[0]);
            out.functionType = NUMBER_FUNCTION;
            out.numberValue = n;
            r-&gt;getCurrentStack()-&gt;push(out);
        } else {
            runtime_die(&quot;Empty string passed to `ord`.&quot;);
        }
    } else {
        runtime_die(&quot;Non string passed to `ord`.&quot;);
    }
});
</pre>
</div>

<h3>Control Flow</h3><h3 id="i-id" class="function">i</h3><h4>Description</h4><div class="info">Similar to Lisp's `unquote`, runs the top of the stack as a program.</div><h4>Quick Usage View</h4><div class="code"><i>list</i> i </div><div><h4>Pops</h4><dl class="info"><dt>Stack index 0: list</dt><dd>The list to be unquoted and run</dd></dl></div>
<div class="code-container">
    <button class="code-button">
        Source (click to open/close)
    </button>
    <pre class="code code-drawer">addBuiltinFunction(&quot;i&quot;, [](Runner* r, RunnerContext* context) {
	//pop the top of the stack and run it
	CharmFunction f1 = r-&gt;getCurrentStack()-&gt;pop();
	if (f1.functionType == LIST_FUNCTION) {
		//when we run with `i`, remove the context (we can&#39;t tail call from an `i`)
		r-&gt;run(std::pair&lt;CHARM_LIST_TYPE, FunctionAnalyzer*&gt;(f1.literalFunctions, context-&gt;fA));
	} else {
		runtime_die(&quot;Non list passed to `i`.&quot;);
	}
});
</pre>
</div>
<h3 id="q-id" class="function">q</h3><h4>Description</h4><div class="info">Similar to Lisp's `quote`, boxes the top of the stack.</div><div class="info">NOTE: This is the inverse of i, so `<value> q i` is the same as `<value>`</div><h4>Quick Usage View</h4><div class="code"><i>any</i> <i>list</i> q </div><div><h4>Pops</h4><dl class="info"><dt>Stack index 1: any</dt><dd>The value to be boxed</dd><dt>Stack index 0: list</dt><dd>The boxed value</dd></dl></div>
<div class="code-container">
    <button class="code-button">
        Source (click to open/close)
    </button>
    <pre class="code code-drawer">void PredefinedFunctions::q(Runner* r) {
	CharmFunction f1 = r-&gt;getCurrentStack()-&gt;pop();
	CharmFunction list;
	list.functionType = LIST_FUNCTION;
	list.literalFunctions.push_back(f1);
	r-&gt;getCurrentStack()-&gt;push(list);
}
</pre>
</div>
<h3 id="ifthen-id" class="function">ifthen</h3><h4>Description</h4><div class="info">Branching operator; runs the first block then decides whether or not to run the second or third based off of whether the top of the stack is > 0 or <= 0.</div><div class="info">NOTE: This is the only function which provides inherent tail call optimization. More info is written up in Documentation.md.</div><div class="info">NOTE: This function does not clean up after itself more than listed -- you need to clear the stack yourself if you want it cleared in a recursive function!</div><h4>Quick Usage View</h4><div class="code"><i>list</i> <i>list</i> <i>list</i> ifthen </div><div><h4>Pops</h4><dl class="info"><dt>Stack index 2: list</dt><dd>Condition to run before running truthy or falsy blocks</dd><dt>Stack index 1: list</dt><dd>Truthy (> 0) block</dd><dt>Stack index 0: list</dt><dd>Falsy (<= 0) block</dd></dl></div>
<div class="code-container">
    <button class="code-button">
        Source (click to open/close)
    </button>
    <pre class="code code-drawer">void PredefinedFunctions::ifthen(Runner* r, FunctionDefinition *context) {
	//the arguments to this function are a little different...
	//ifthen performs very basic tail-call optimization on its two sections (truthy/falsy)
	//if truthy (or falsy) end with the function itself (found through fD.functionName), then
	//the tail-call optimizer kicks in and the function simply loops instead of
	//creating a new stack frame by calling r-&gt;run()

	//this one is gonna take 3 arguments --
	//stack[2] = condition to run truthy section
	//stack[1] = truthy section (if...)
	//stack[0] = falsy section (else...)
	//have to reverse it because popping is weird
	CharmFunction falsy = r-&gt;getCurrentStack()-&gt;pop();
	bool falsyTailCall = false;
	CharmFunction truthy = r-&gt;getCurrentStack()-&gt;pop();
	bool truthyTailCall = false;
	CharmFunction condFunction = r-&gt;getCurrentStack()-&gt;pop();
	if ((condFunction.functionType == LIST_FUNCTION) &amp;&amp;
		(truthy.functionType == LIST_FUNCTION) &amp;&amp;
		(falsy.functionType == LIST_FUNCTION)) {
			//first, we run checks to set the tail call bools
			if (context != nullptr) {
				if (truthy.literalFunctions.back().functionName == context-&gt;functionName) {
					truthyTailCall = true;
				}
				if (falsy.literalFunctions.back().functionName == context-&gt;functionName) {
					falsyTailCall = true;
				}
				//now, if we _DO_ have a tail call, modify truthy/falsy and enter a loop instead
				//there are 3 seperate cases here -- truthy tail call, falsy tail call, or both
				if (truthyTailCall) {
					ONLYDEBUG printf(&quot;ENGAGING TRUTHY IF/THEN TAIL CALL OPTIMIZATION\n&quot;);
					//remove the tail call
					truthy.literalFunctions.pop_back();
					while (1) {
						r-&gt;run(condFunction.literalFunctions);
						CharmFunction cond = r-&gt;getCurrentStack()-&gt;pop();
						if (Stack::isInt(cond)) {
							if (cond.numberValue.integerValue &gt; 0) {
								r-&gt;run(truthy.literalFunctions);
							} else {
								r-&gt;run(falsy.literalFunctions);
								//end this function immediately once the tail call loop ends
								ONLYDEBUG printf(&quot;DISENGAGING TRUTHY IF/THEN TAIL CALL OPTIMIZATION\n&quot;);
								return;
							}
						} else {
							runtime_die(&quot;`ifthen` condition returned non integer.&quot;);
						}
					}
				}
				if (falsyTailCall) {
					ONLYDEBUG printf(&quot;ENGAGING FALSY IF/THEN TAIL CALL OPTIMIZATION\n&quot;);
					//remove the tail call
					falsy.literalFunctions.pop_back();
					while (1) {
						r-&gt;run(condFunction.literalFunctions);
						CharmFunction cond = r-&gt;getCurrentStack()-&gt;pop();
						if (Stack::isInt(cond)) {
							if (cond.numberValue.integerValue &gt; 0) {
								r-&gt;run(truthy.literalFunctions);
								//end this function immediately once the tail call loop ends
								ONLYDEBUG printf(&quot;DISENGAGING FALSY IF/THEN TAIL CALL OPTIMIZATION\n&quot;);
								return;
							} else {
								r-&gt;run(falsy.literalFunctions);
							}
						} else {
							runtime_die(&quot;`ifthen` condition returned non integer.&quot;);
						}
					}
				}
				//here&#39;s an extra special case if both truthy and falsy have a tail call
				//that is `f := [ &lt;cond&gt; ] [ &lt;code&gt; f ] [ &lt;code&gt; f ] ifthen`
				//this is equivalent to `f := [ &lt;cond&gt; ] [ &lt;code&gt; ] [ &lt;code&gt; ] ifthen f`
				//so we run it as an infinite loop
				if (truthyTailCall &amp;&amp; falsyTailCall) {
					ONLYDEBUG printf(&quot;ENGAGING TRUTHY/FALSY IF/THEN TAIL CALL OPTIMIZATION\n&quot;);
					//remove the tail calls
					truthy.literalFunctions.pop_back();
					falsy.literalFunctions.pop_back();
					while (1) {
						CharmFunction cond = r-&gt;getCurrentStack()-&gt;pop();
						if (Stack::isInt(cond)) {
							if (cond.numberValue.integerValue &gt; 0) {
								r-&gt;run(truthy.literalFunctions);
							} else {
								r-&gt;run(falsy.literalFunctions);
							}
						} else {
							runtime_die(&quot;`ifthen` condition returned non integer.&quot;);
						}
					}
				}
				//good joke
				ONLYDEBUG printf(&quot;DISENGAGING TRUTHY/FALSY IF/THEN TAIL CALL OPTIMIZATION\n&quot;);
			}
			//but if not (or context was nullptr), continue execution as normal
			r-&gt;run(condFunction.literalFunctions);
			//now we check the top of the stack to see if it&#39;s truthy or falsy
			CharmFunction cond = r-&gt;getCurrentStack()-&gt;pop();
			if (Stack::isInt(cond)) {
				if (cond.numberValue.integerValue &gt; 0) {
					r-&gt;run(truthy.literalFunctions);
				} else {
					r-&gt;run(falsy.literalFunctions);
				}
			} else {
				runtime_die(&quot;`ifthen` condition returned non integer.&quot;);
			}
		} else {
			runtime_die(&quot;Non list passed to `ifthen`.&quot;);
		}
}
</pre>
</div>
<h3 id="inline-id" class="function">inline</h3><h4>Description</h4><div class="info">Shows the result of an inlining optimization on a function.</div><h4>Quick Usage View</h4><div class="code"><i>list</i> inline         => <i>list</i> </div><div><h4>Pops</h4><dl class="info"><dt>Stack index 0: list</dt><dd>The function to inline</dd></dl></div><div><h4>Pushes</h4><dl class="info"><dt>Stack index 0: list</dt><dd>The completed inline optimization</dd></dl></div>
<div class="code-container">
    <button class="code-button">
        Source (click to open/close)
    </button>
    <pre class="code code-drawer">addBuiltinFunction(&quot;inline&quot;, [](Runner* r, RunnerContext* context) {
	//the boxed function to take in
	CharmFunction f1 = r-&gt;getCurrentStack()-&gt;pop();
	if (f1.functionType == LIST_FUNCTION) {
		CharmFunction out;
		out.functionType = LIST_FUNCTION;
		for (CharmFunction f : f1.literalFunctions) {
			if (f.functionType == DEFINED_FUNCTION) {
				if (!context-&gt;fA-&gt;doInline(out.literalFunctions, f)) {
					out.literalFunctions.push_back(f);
				}
			} else {
				out.literalFunctions.push_back(f);
			}
		}
		r-&gt;getCurrentStack()-&gt;push(out);
	} else {
		runtime_die(&quot;Non list passed to `inline`.&quot;);
	}
});
</pre>
</div>

<h3>Boolean Operations</h3><h3 id="xor-id" class="function">xor</h3><h4>Description</h4><div class="info">Exclusive or.</div><div class="info">NOTE: This considers any value greater than 0 as true and less than 0 as false. It is not a bitwise call.</div><h4>Quick Usage View</h4><div class="code"><i>int</i> <i>int</i> xor         => <i>int</i> </div><div><h4>Pops</h4><dl class="info"><dt>Stack index 1: int</dt><dd>The first value to xor</dd><dt>Stack index 0: int</dt><dd>The second value to xor</dd></dl></div><div><h4>Pushes</h4><dl class="info"><dt>Stack index 0: int</dt><dd>The result of the xoring</dd></dl></div>
<div class="code-container">
    <button class="code-button">
        Source (click to open/close)
    </button>
    <pre class="code code-drawer">void PredefinedFunctions::exor(Runner* r) {
  	CharmFunction f1 = r-&gt;getCurrentStack()-&gt;pop();
  	CharmFunction f2 = r-&gt;getCurrentStack()-&gt;pop();
  	if (Stack::isInt(f1) &amp;&amp; Stack::isInt(f2)) {
  		CharmFunction out;
  		out.functionType = NUMBER_FUNCTION;
  		CharmNumber outNum;
  		outNum.whichType = INTEGER_VALUE;
  		//cancer incoming
  		outNum.integerValue = ((f1.numberValue.integerValue &gt; 0) ^ (f2.numberValue.integerValue &gt; 0));
  		//no more cancer
  		out.numberValue = outNum;
  		r-&gt;getCurrentStack()-&gt;push(out);
  	} else {
  		runtime_die(&quot;Non integer passed to logic function.&quot;);
  	}
}
</pre>
</div>

<h3>Type Inspecific Math</h3><h3 id="abs-id" class="function">abs</h3><h4>Description</h4><div class="info">Absolute value.</div><h4>Quick Usage View</h4><div class="code"><i>int/float</i> abs         => <i>int/float</i> </div><div><h4>Pops</h4><dl class="info"><dt>Stack index 0: int/float</dt><dd>The value to find the absolute value of</dd></dl></div><div><h4>Pushes</h4><dl class="info"><dt>Stack index 0: int/float</dt><dd>The absolute value</dd></dl></div>
<div class="code-container">
    <button class="code-button">
        Source (click to open/close)
    </button>
    <pre class="code code-drawer">void PredefinedFunctions::abs(Runner* r) {
	CharmFunction f1 = r-&gt;getCurrentStack()-&gt;pop();
	if (Stack::isInt(f1)) {
		std::abs(f1.numberValue.integerValue);
	} else if (Stack::isFloat(f1)) {
		if (f1.numberValue.floatValue &lt; 0) {
			f1.numberValue.floatValue = -f1.numberValue.floatValue;
		}
	} else {
		runtime_die(&quot;Non number passed to `abs`.&quot;);
	}
}
</pre>
</div>

<h3>Integer Operations</h3><h3 id="+-id" class="function">+</h3><h4>Description</h4><div class="info">Addition.</div><h4>Quick Usage View</h4><div class="code"><i>int</i> <i>int</i> +         => <i>int</i> </div><div><h4>Pops</h4><dl class="info"><dt>Stack index 1: int</dt><dd>The first value to add</dd><dt>Stack index 0: int</dt><dd>The second value to add</dd></dl></div><div><h4>Pushes</h4><dl class="info"><dt>Stack index 0: int</dt><dd>The added values</dd></dl></div>
<div class="code-container">
    <button class="code-button">
        Source (click to open/close)
    </button>
    <pre class="code code-drawer">void PredefinedFunctions::plusI(Runner* r) {
	CharmFunction f1 = r-&gt;getCurrentStack()-&gt;pop();
	CharmFunction f2 = r-&gt;getCurrentStack()-&gt;pop();
	if (Stack::isInt(f1) &amp;&amp; Stack::isInt(f2)) {
		f1.numberValue.integerValue = f1.numberValue.integerValue + f2.numberValue.integerValue;
	} else {
		runtime_die(&quot;Non integer passed to `+`.&quot;);
	}
	r-&gt;getCurrentStack()-&gt;push(f1);
}
</pre>
</div>
<h3 id="--id" class="function">-</h3><h4>Description</h4><div class="info">Subtraction.</div><h4>Quick Usage View</h4><div class="code"><i>int</i> <i>int</i> -         => <i>int</i> </div><div><h4>Pops</h4><dl class="info"><dt>Stack index 1: int</dt><dd>The first value to subtract from</dd><dt>Stack index 0: int</dt><dd>The second value to subtract</dd></dl></div><div><h4>Pushes</h4><dl class="info"><dt>Stack index 0: int</dt><dd>The subtracted values</dd></dl></div>
<div class="code-container">
    <button class="code-button">
        Source (click to open/close)
    </button>
    <pre class="code code-drawer">void PredefinedFunctions::minusI(Runner* r) {
	CharmFunction f1 = r-&gt;getCurrentStack()-&gt;pop();
	CharmFunction f2 = r-&gt;getCurrentStack()-&gt;pop();
	if (Stack::isInt(f1) &amp;&amp; Stack::isInt(f2)) {
		f1.numberValue.integerValue = f2.numberValue.integerValue - f1.numberValue.integerValue;
	} else {
		runtime_die(&quot;Non integer passed to `-`.&quot;);
	}
	r-&gt;getCurrentStack()-&gt;push(f1);
}
</pre>
</div>
<h3 id="*-id" class="function">*</h3><h4>Description</h4><div class="info">Multiplication.</div><h4>Quick Usage View</h4><div class="code"><i>int</i> <i>int</i> *         => <i>int</i> </div><div><h4>Pops</h4><dl class="info"><dt>Stack index 1: int</dt><dd>The first value to multiply</dd><dt>Stack index 0: int</dt><dd>The second value to multiply</dd></dl></div><div><h4>Pushes</h4><dl class="info"><dt>Stack index 0: int</dt><dd>The multiplied values</dd></dl></div>
<div class="code-container">
    <button class="code-button">
        Source (click to open/close)
    </button>
    <pre class="code code-drawer">void PredefinedFunctions::timesI(Runner* r) {
	CharmFunction f1 = r-&gt;getCurrentStack()-&gt;pop();
	CharmFunction f2 = r-&gt;getCurrentStack()-&gt;pop();
	if (Stack::isInt(f1) &amp;&amp; Stack::isInt(f2)) {
		f1.numberValue.integerValue = f1.numberValue.integerValue * f2.numberValue.integerValue;
	} else {
		runtime_die(&quot;Non integer passed to `*`.&quot;);
	}
	r-&gt;getCurrentStack()-&gt;push(f1);
}
</pre>
</div>
<h3 id="/-id" class="function">/</h3><h4>Description</h4><div class="info">Division.</div><h4>Quick Usage View</h4><div class="code"><i>int</i> <i>int</i> /         => <i>int</i> <i>int</i> </div><div><h4>Pops</h4><dl class="info"><dt>Stack index 1: int</dt><dd>The numerator</dd><dt>Stack index 0: int</dt><dd>The denominator</dd></dl></div><div><h4>Pushes</h4><dl class="info"><dt>Stack index 1: int</dt><dd>The remainder</dd><dt>Stack index 0: int</dt><dd>The divided value</dd></dl></div>
<div class="code-container">
    <button class="code-button">
        Source (click to open/close)
    </button>
    <pre class="code code-drawer">void PredefinedFunctions::divI(Runner* r) {
	CharmFunction f1 = r-&gt;getCurrentStack()-&gt;pop();
	CharmFunction f2 = r-&gt;getCurrentStack()-&gt;pop();
	if (Stack::isInt(f1) &amp;&amp; Stack::isInt(f2)) {
		//f1 used as answer
		f1.numberValue.integerValue = f2.numberValue.integerValue / f1.numberValue.integerValue;
		//f2 used as modulus
		f2.numberValue.integerValue = f2.numberValue.integerValue % f1.numberValue.integerValue;
	} else {
		runtime_die(&quot;Non integer passed to `+`.&quot;);
	}
	r-&gt;getCurrentStack()-&gt;push(f2);
	r-&gt;getCurrentStack()-&gt;push(f1);
}
</pre>
</div>
<h3 id="toint-id" class="function">toint</h3><h4>Description</h4><div class="info">Convert a floating point value to an integer through truncation.</div><h4>Quick Usage View</h4><div class="code"><i>float</i> toint         => <i>int</i> </div><div><h4>Pops</h4><dl class="info"><dt>Stack index 0: float</dt><dd>The floating point value to convert</dd></dl></div><div><h4>Pushes</h4><dl class="info"><dt>Stack index 0: int</dt><dd>The integer representation</dd></dl></div>
<div class="code-container">
    <button class="code-button">
        Source (click to open/close)
    </button>
    <pre class="code code-drawer">void PredefinedFunctions::toInt(Runner* r) {
	CharmFunction f1 = r-&gt;getCurrentStack()-&gt;pop();
	if (Stack::isFloat(f1)) {
		f1.numberValue.whichType = INTEGER_VALUE;
		f1.numberValue.integerValue = (long long)f1.numberValue.floatValue;
	} else if (Stack::isInt(f1)) {
		//do nothing, it&#39;s already an int
	} else {
		runtime_die(&quot;Non number passed to `toInt`.&quot;);
	}
}
</pre>
</div>

<h3>Stack Creation and Destruction</h3><h3 id="createstack-id" class="function">createstack</h3><h4>Description</h4><div class="info">Creates a new named stack to work with.</div><div class="info">NOTE: This function does not switch to the specified stack. Use <span class="code">switchstack</span> for that.</div><h4>Quick Usage View</h4><div class="code"><i>any</i> createstack </div><div><h4>Pops</h4><dl class="info"><dt>Stack index 0: any</dt><dd>The name of the stack</dd></dl></div>
<div class="code-container">
    <button class="code-button">
        Source (click to open/close)
    </button>
    <pre class="code code-drawer">addBuiltinFunction(&quot;createstack&quot;, [](Runner* r) {
	//name of the stack
	CharmFunction f1 = r-&gt;getCurrentStack()-&gt;pop();
	r-&gt;createStack(f1);
});
</pre>
</div>
<h3 id="getstack-id" class="function">getstack</h3><h4>Description</h4><div class="info">Gets the name of the current stack.</div><h4>Quick Usage View</h4><div class="code">getstack         => <i>any</i> </div><div><h4>Pushes</h4><dl class="info"><dt>Stack index 0: any</dt><dd>The name of the current stack</dd></dl></div>
<div class="code-container">
    <button class="code-button">
        Source (click to open/close)
    </button>
    <pre class="code code-drawer">addBuiltinFunction(&quot;getstack&quot;, [](Runner* r) {
    //name of the stack
    r-&gt;getCurrentStack()-&gt;push(r-&gt;getCurrentStack()-&gt;name);
});
</pre>
</div>
<h3 id="switchstack-id" class="function">switchstack</h3><h4>Description</h4><div class="info">Switches to a named stack.</div><div class="info">NOTE: The default stack is named <span class="code">0</span>.</div><h4>Quick Usage View</h4><div class="code"><i>any</i> switchstack </div><div><h4>Pops</h4><dl class="info"><dt>Stack index 0: any</dt><dd>The name of the stack to switch to</dd></dl></div>
<div class="code-container">
    <button class="code-button">
        Source (click to open/close)
    </button>
    <pre class="code code-drawer">void PredefinedFunctions::switchStack(Runner* r) {
	CharmFunction f1 = r-&gt;getCurrentStack()-&gt;pop();
	r-&gt;switchCurrentStack(f1);
}
</pre>
</div>

<h3>Reference Getting and Setting</h3><h3 id="getref-id" class="function">getref</h3><h4>Description</h4><div class="info">Gets the value of a global reference.</div><h4>Quick Usage View</h4><div class="code"><i>any</i> getref </div><div><h4>Pops</h4><dl class="info"><dt>Stack index 0: any</dt><dd>The name of the reference to get</dd></dl></div>
<div class="code-container">
    <button class="code-button">
        Source (click to open/close)
    </button>
    <pre class="code code-drawer">void PredefinedFunctions::getRef(Runner* r) {
	CharmFunction f1 = r-&gt;getCurrentStack()-&gt;pop();
	r-&gt;getCurrentStack()-&gt;push(r-&gt;getReference(f1));
}
</pre>
</div>
<h3 id="setref-id" class="function">setref</h3><h4>Description</h4><div class="info">Sets the value of a global reference.</div><div class="info">NOTE: Though this is not enforced, it's canonical to use <span class="code">" &lt;description&gt;&lt;function&gt;ref "</span> as the reference name.</div><h4>Quick Usage View</h4><div class="code"><i>any</i> <i>any</i> setref </div><div><h4>Pops</h4><dl class="info"><dt>Stack index 1: any</dt><dd>The name of the reference</dd><dt>Stack index 0: any</dt><dd>The value of the reference</dd></dl></div>
<div class="code-container">
    <button class="code-button">
        Source (click to open/close)
    </button>
    <pre class="code code-drawer">void PredefinedFunctions::setRef(Runner* r) {
	//the value of the reference
	CharmFunction f1 = r-&gt;getCurrentStack()-&gt;pop();
	//the name of the reference
	CharmFunction f2 = r-&gt;getCurrentStack()-&gt;pop();
	r-&gt;setReference(f2, f1);
}
</pre>
</div>

<h3>Library Interaction</h3><h3 id="include-id" class="function">include</h3><h4>Description</h4><div class="info">Includes a Charm library into another file.</div><div class="info">NOTE: No inline optimization is done for functions called from a library. This is because all inlining is indexed and performed at compile time, whereas library includsion is performed at runtime.</div><div class="info">NOTE: For proper calling syntax and usage (as the quick view does not do this function justice), visit <a href="https://github.com/Aearnus/charm/blob/master/test/include-test">https://github.com/Aearnus/charm/blob/master/test/include-test</a> for a real world usage example.</div><h4>Quick Usage View</h4><div class="code"><i>string</i> <i>string</i> include </div><div><h4>Pops</h4><dl class="info"><dt>Stack index 1: string</dt><dd>The path to the Charm file to include</dd><dt>Stack index 0: string</dt><dd>The namespace, which gets prepended to the functions in the library</dd></dl></div>
<div class="code-container">
    <button class="code-button">
        Source (click to open/close)
    </button>
    <pre class="code code-drawer">addBuiltinFunction(&quot;include&quot;, [](Runner* r) {
	//NOTE: no inlining is done for included files
	//this is because all inlining is done at compiletime,
	//and this inclusion happens at run-time

	//the namespace to place functions in
	CharmFunction f1 = r-&gt;getCurrentStack()-&gt;pop();
	//the path of the file to import
	CharmFunction f2 = r-&gt;getCurrentStack()-&gt;pop();
	if ((f1.functionType != STRING_FUNCTION) || (f2.functionType != STRING_FUNCTION)) {
		runtime_die(&quot;Non string passed to `include`.&quot;);
	}
	std::string line;
	std::ifstream importFile(f2.stringValue);
	Parser parser = Parser();
	while (std::getline(importFile, line)) {
		r-&gt;run(parser.lex(line), f1.stringValue);
	}
});
</pre>
</div>

        <h2 class="function-header">
            Prelude Functions
        </h2>
        <h3>Output Functions</h3><h3 id="put-id" class="function">put</h3><h4>Description</h4><div class="info">Prints without popping, adding a newline.</div><h4>Quick Usage View</h4><div class="code"><i>any</i> put         => <i>any</i> </div><div><h4>Pops</h4><dl class="info"><dt>Stack index 0: any</dt><dd>The value to print</dd></dl></div><div><h4>Pushes</h4><dl class="info"><dt>Stack index 0: any</dt><dd>The value to print</dd></dl></div>
<div class="code-container">
    <button class="code-button">
        Source (click to open/close)
    </button>
    <pre class="code code-drawer">put := dup p newline
</pre>
</div>

<h3>Debugging Functions</h3><h3 id="clearstack-id" class="function">clearstack</h3><h4>Description</h4><div class="info">Clears the stack to a certain depth.</div><div class="info">NOTE: This pushes a variadic amount of zeroes to the stack, but that isn't significant to pay attention to.</div><h4>Quick Usage View</h4><div class="code"><i>int</i> clearstack </div><div><h4>Pops</h4><dl class="info"><dt>Stack index 0: int</dt><dd>The depth to clear up to</dd></dl></div>
<div class="code-container">
    <button class="code-button">
        Source (click to open/close)
    </button>
    <pre class="code code-drawer">_clearstack_args := &quot; clearstackref &quot; flip setref
_clearstack_cond := &quot; clearstackref &quot; getref 1 - dup &quot; clearstackref &quot; flip setref
_clearstack      := [ _clearstack_cond ] [ 0 _clearstack ] [ ] ifthen
clearstack       := _clearstack_args _clearstack
</pre>
</div>
<h3 id="pause-id" class="function">pause</h3><h4>Description</h4><div class="info">Require the user to hit return to continue execution.</div><h4>Quick Usage View</h4><div class="code">pause </div>
<div class="code-container">
    <button class="code-button">
        Source (click to open/close)
    </button>
    <pre class="code code-drawer">pause := &quot; Press return to continue... &quot; pstring getline pop
</pre>
</div>
<h3 id="printstack-id" class="function">printstack</h3><h4>Description</h4><div class="info">Prints the stack to a certain depth.</div><h4>Quick Usage View</h4><div class="code"><i>int</i> printstack </div><div><h4>Pops</h4><dl class="info"><dt>Stack index 0: int</dt><dd>The depth to print up until</dd></dl></div>
<div class="code-container">
    <button class="code-button">
        Source (click to open/close)
    </button>
    <pre class="code code-drawer">_printstack_args       := &quot; printstackref &quot; flip setref
_printstack_correction := &quot; printstackref &quot; getref rotate
printstack             := _printstack_args [ put &quot; printstackref &quot; getref rotate ] &quot; printstackref &quot; getref repeat i _printstack_correction
</pre>
</div>
<h3 id="stepthrough-id" class="function">stepthrough</h3><h4>Description</h4><div class="info">Interactively steps through a function in a sandboxed stack.</div><div class="info">NOTE: This creates a dummy stack named <span class="code">" stepthroughstack "</span>.</div><div class="info">NOTE: After this code runs, your current stack will be stack <span class="code">0</span>. If you don't want to return to the main stack, make sure to switch back after using this function.</div><h4>Quick Usage View</h4><div class="code"><i>list</i> <i>list</i> <i>int</i> stepthrough </div><div><h4>Pops</h4><dl class="info"><dt>Stack index 2: list</dt><dd>The list of arguments for the functions to step through</dd><dt>Stack index 1: list</dt><dd>The program to step through</dd><dt>Stack index 0: int</dt><dd>The stack depth to print</dd></dl></div>
<div class="code-container">
    <button class="code-button">
        Source (click to open/close)
    </button>
    <pre class="code code-drawer">20000 &quot; stepthroughstack &quot; createstack

_stepthrough_pop_args          := &quot; stepthroughdepthref &quot; flip setref   inline &quot; stepthroughcoderef &quot; flip setref   &quot; stepthroughargsref &quot; flip setref
_stepthrough_stack_init&amp;switch := &quot; stepthroughstack &quot; switchstack clearstack &quot; stepthroughargsref &quot; getref i
_stepthrough_init_cursor       := &quot; stepthroughcursor &quot; 0 setref
_stepthrough_init              := _stepthrough_pop_args _stepthrough_init_cursor _stepthrough_stack_init&amp;switch &quot; Initial stack: &quot; pstring newline _stepthrough_print_stack pause newline

_stepthrough_arg_depth := &quot; stepthroughdepthref &quot; getref
_stepthrough_arg_code  := &quot; stepthroughcoderef &quot; getref

_stepthrough_set_headref := &quot; stepthroughheadref &quot; flip setref
_stepthrough_get_headref := &quot; stepthroughheadref &quot; getref

_stepthrough_func_string_len     := tostring len 4 -
_stepthrough_move_cursor_int     := &quot; stepthroughcursor &quot; getref + &quot; stepthroughcursor &quot; flip setref
_stepthrough_move_cursor_len     := _stepthrough_func_string_len 1 + _stepthrough_move_cursor_int pop
_stepthrough_move_cursor_headref := _stepthrough_get_headref _stepthrough_move_cursor_len

_stepthrough_print_func   := tostring 2 flip len 2 - 1 2 swap substring flip pop pstring
_stepthrough_print_stack  := &quot; Stack: &quot; pstring newline _stepthrough_arg_depth printstack
_stepthrough_print_cursor := &quot; &quot; [ space concat ] &quot; stepthroughcursor &quot; getref repeat i &quot; ^ &quot; concat pstring newline
_stepthrough_print_info   := &quot; Running functions... &quot; pstring newline _stepthrough_arg_code _stepthrough_print_func newline

_stepthrough_iter       := _stepthrough_print_info _stepthrough_print_cursor _stepthrough_set_headref &quot; stepthroughstack &quot; switchstack _stepthrough_get_headref i _stepthrough_print_stack _stepthrough_move_cursor_headref 0 switchstack pause newline [ ]
_stepthrough_map        := 0 switchstack _stepthrough_arg_code [ _stepthrough_iter ] map 0 switchstack
stepthrough             := _stepthrough_init _stepthrough_map
</pre>
</div>

<h3>Stack Manipulation</h3><h3 id="flip-id" class="function">flip</h3><h4>Description</h4><div class="info">Flips two elements on the stack.</div><h4>Quick Usage View</h4><div class="code"><i>any</i> <i>any</i> flip         => <i>any</i> <i>any</i> </div><div><h4>Pops</h4><dl class="info"><dt>Stack index 1: any</dt><dd>One value to flip</dd><dt>Stack index 0: any</dt><dd>The other value to flip</dd></dl></div><div><h4>Pushes</h4><dl class="info"><dt>Stack index 1: any</dt><dd>One value to flip</dd><dt>Stack index 0: any</dt><dd>The other value to flip</dd></dl></div>
<div class="code-container">
    <button class="code-button">
        Source (click to open/close)
    </button>
    <pre class="code code-drawer">flip := 0 1 swap
</pre>
</div>
<h3 id="swapnth-id" class="function">swapnth</h3><h4>Description</h4><div class="info">Swap the top value with the value at an index on the stack.</div><div class="info">NOTE: This function is magic-ish. It doesn't push another top value, but it replaces the previous one.</div><h4>Quick Usage View</h4><div class="code"><i>int</i> swapnth </div><div><h4>Pops</h4><dl class="info"><dt>Stack index 0: int</dt><dd>The stack index to swap the top value to</dd></dl></div>
<div class="code-container">
    <button class="code-button">
        Source (click to open/close)
    </button>
    <pre class="code code-drawer">swapnth := dup 1 + swap
</pre>
</div>
<h3 id="copyfrom-id" class="function">copyfrom</h3><h4>Description</h4><div class="info">Copy a value from an index on the stack.</div><div class="info">NOTE: Unlike swap, this does not move any values from their place in the stack.</div><h4>Quick Usage View</h4><div class="code"><i>int</i> copyfrom         => <i>any</i> </div><div><h4>Pops</h4><dl class="info"><dt>Stack index 0: int</dt><dd>The stack index to copy from</dd></dl></div><div><h4>Pushes</h4><dl class="info"><dt>Stack index 0: any</dt><dd>The value copied from the stack</dd></dl></div>
<div class="code-container">
    <button class="code-button">
        Source (click to open/close)
    </button>
    <pre class="code code-drawer">copyfrom := &quot; copyfromref &quot; flip setref 0 &quot; copyfromref &quot; getref swap dup 1 &quot; copyfromref &quot; getref 1 + swap
</pre>
</div>
<h3 id="pushto-id" class="function">pushto</h3><h4>Description</h4><div class="info">Push a value to an index on the stack.</div><div class="info">NOTE: This function is SLOW! Don't use it unless you absolutely understand it -- it can turn a relatively fast function from O(n) to O(n^2) just like it did to <a href="#printstack-id">printstack</a>.</div><h4>Quick Usage View</h4><div class="code"><i>any</i> <i>int</i> pushto </div><div><h4>Pops</h4><dl class="info"><dt>Stack index 1: any</dt><dd>The object to push</dd><dt>Stack index 0: int</dt><dd>The stack index to push the object to</dd></dl></div>
<div class="code-container">
    <button class="code-button">
        Source (click to open/close)
    </button>
    <pre class="code code-drawer">_pushto_args := 0 flip
_pushto_cond := print flip print flip dup 2 copyfrom -
_pushto_inc  := flip 1 + flip
_pushto      := [ _pushto_cond ] [ 1 copyfrom 2 + swapnth _pushto_inc _pushto ] [ pop pop ] ifthen
pushto       := _pushto_args _pushto
</pre>
</div>
<h3 id="rotate-id" class="function">rotate</h3><h4>Description</h4><div class="info">Rotate values up through the stack, down to a certain depth.</div><div class="info">NOTE: See <a href="#pushto-id">pushto</a>.</div><h4>Quick Usage View</h4><div class="code"><i>int</i> rotate </div><div><h4>Pops</h4><dl class="info"><dt>Stack index 0: int</dt><dd>The depth of rotation</dd></dl></div>
<div class="code-container">
    <button class="code-button">
        Source (click to open/close)
    </button>
    <pre class="code code-drawer">rotate := pushto
</pre>
</div>
<h3 id="stack-id" class="function">stack</h3><h4>Description</h4><div class="info">Duplicates a value multiple times.</div><h4>Quick Usage View</h4><div class="code"><i>any</i> <i>int</i> stack         => <i>...</i> </div><div><h4>Pops</h4><dl class="info"><dt>Stack index 1: any</dt><dd>The object to duplicate</dd><dt>Stack index 0: int</dt><dd>The amount of times to duplicate</dd></dl></div><div><h4>Pushes</h4><dl class="info"><dt>Stack index 0: ...</dt><dd>All of the duplicated objects</dd></dl></div>
<div class="code-container">
    <button class="code-button">
        Source (click to open/close)
    </button>
    <pre class="code code-drawer">stack := [ 1 - dup ] [ flip dup 0 2 swap stack ] [ pop ] ifthen
</pre>
</div>

<h3>String Manipulation</h3><h3 id="substring-id" class="function">substring</h3><h4>Description</h4><div class="info">Gets a substring of a string.</div><h4>Quick Usage View</h4><div class="code"><i>string</i> <i>int</i> <i>int</i> substring         => <i>string</i> <i>string</i> </div><div><h4>Pops</h4><dl class="info"><dt>Stack index 2: string</dt><dd>Stirng to get a substring of</dd><dt>Stack index 1: int</dt><dd>Starting index of substring</dd><dt>Stack index 0: int</dt><dd>Ending index of substring</dd></dl></div><div><h4>Pushes</h4><dl class="info"><dt>Stack index 1: string</dt><dd>Original string</dd><dt>Stack index 0: string</dt><dd>Cut string</dd></dl></div>
<div class="code-container">
    <button class="code-button">
        Source (click to open/close)
    </button>
    <pre class="code code-drawer">_substring_args     := &quot; &quot; 3 pushto
_substring_distance := dup 2 copyfrom - 1 -
_substring_iter     := 0 2 swap 1 copyfrom at 1 4 swap concat 0 3 swap 0 2 swap flip succ flip
_substring          := [ _substring_distance succ ] [ _substring_iter _substring ] [ pop pop flip ] ifthen
substring           := _substring_args _substring
</pre>
</div>
<h3 id="space-id" class="function">space</h3><h4>Description</h4><div class="info">Pushes a space to the top of the stack.</div><div class="info">NOTE: Due to the intracacies of the parser, <span class="code">"   "</span> simply pushes an empty string to the stack.</div><h4>Quick Usage View</h4><div class="code">space         => <i>string</i> </div><div><h4>Pushes</h4><dl class="info"><dt>Stack index 0: string</dt><dd>Space character</dd></dl></div>
<div class="code-container">
    <button class="code-button">
        Source (click to open/close)
    </button>
    <pre class="code code-drawer">space := 32 char
</pre>
</div>

<h3>List Manipulation</h3><h3 id="cut-id" class="function">cut</h3><h4>Description</h4><div class="info">Gets a sublist of a list.</div><div class="info">NOTE: Just like <span class="code">at</span>, accessing an element out of bounds causes this function to repeat the list.</div><h4>Quick Usage View</h4><div class="code"><i>list</i> <i>int</i> <i>int</i> cut         => <i>list</i> <i>list</i> </div><div><h4>Pops</h4><dl class="info"><dt>Stack index 2: list</dt><dd>List to cut</dd><dt>Stack index 1: int</dt><dd>Starting index of sublist</dd><dt>Stack index 0: int</dt><dd>Ending index of sublist</dd></dl></div><div><h4>Pushes</h4><dl class="info"><dt>Stack index 1: list</dt><dd>Cut list</dd><dt>Stack index 0: list</dt><dd>Original list</dd></dl></div>
<div class="code-container">
    <button class="code-button">
        Source (click to open/close)
    </button>
    <pre class="code code-drawer">_cut_args     := [ ] 3 pushto
_cut_distance := dup 2 copyfrom - 1 -
_cut_iter     := 0 2 swap 1 copyfrom at 1 4 swap concat 0 3 swap 0 2 swap flip succ flip
_cut          := [ _cut_distance succ ] [ _cut_iter _cut ] [ pop pop flip ] ifthen
cut           := _cut_args _cut
</pre>
</div>
<h3 id="repeat-id" class="function">repeat</h3><h4>Description</h4><div class="info">Repeats a list a certain number of times.</div><div class="info">NOTE: Using this as <span class="code"> [ &ltfunction&gt; ] flip repeat i</span> works as something akin to a for-loop construct!</div><h4>Quick Usage View</h4><div class="code"><i>list/string</i> <i>int</i> repeat         => <i>list/string</i> </div><div><h4>Pops</h4><dl class="info"><dt>Stack index 1: list/string</dt><dd>List or string to repeat</dd><dt>Stack index 0: int</dt><dd>Number of times to repeat</dd></dl></div><div><h4>Pushes</h4><dl class="info"><dt>Stack index 0: list/string</dt><dd>Repeated list or string</dd></dl></div>
<div class="code-container">
    <button class="code-button">
        Source (click to open/close)
    </button>
    <pre class="code code-drawer">_repeat_args := flip type &quot; repeattyperef &quot; flip setref dup 0 2 swap 1 -
_repeat_iter := 0 2 swap dup 0 2 swap concat flip 2 0 swap 1 -
_repeat_zero := [ &quot; repeattyperef &quot; getref &quot; LIST_FUNCTION &quot; eq ] [ [ ] ] [ &quot; &quot; ] ifthen
_repeat      := [ dup ] [ _repeat_iter _repeat ] [ pop flip pop ] ifthen
repeat       := _repeat_args [ dup ] [ _repeat ] [ pop pop pop _repeat_zero ] ifthen
</pre>
</div>
<h3 id="map-id" class="function">map</h3><h4>Description</h4><div class="info">Applies a function to every element in a list.</div><div class="info">NOTE: The function passed to <span class="code">map</span> must pop exactly 1 boxed value and must push exactly 1 list. If not, it will break the internal workings of <span class="code">map</span> and you will get strange, arcane error messages!</div><div class="info">NOTE: A good example of a proper <span class="code">map</span> call is <span class="code">[ 1 2 3 ] [ i 1 + q ] map</span>. Note how the value is unquoted (<span class="code">i</span>) and quoted again (<span class="code">q</span>) afterwards.</div><h4>Quick Usage View</h4><div class="code"><i>list</i> <i>function(list -> list)</i> map         => <i>list</i> </div><div><h4>Pops</h4><dl class="info"><dt>Stack index 1: list</dt><dd>List to map over</dd><dt>Stack index 0: function(list -> list)</dt><dd>Function to apply to every element in the list</dd></dl></div><div><h4>Pushes</h4><dl class="info"><dt>Stack index 0: list</dt><dd>Mapped list</dd></dl></div>
<div class="code-container">
    <button class="code-button">
        Source (click to open/close)
    </button>
    <pre class="code code-drawer">_map_args    := &quot; mapfuncref &quot; flip setref [ ]
_map_iter    := flip 1 split flip &quot; mapfuncref &quot; getref i 1 2 swap concat
_map_cond    := flip len 1 2 swap
_map_cleanup := flip pop
_map         := [ _map_cond ] [ _map_iter _map ] [ _map_cleanup ] ifthen
map          := _map_args _map_iter
</pre>
</div>

</html>


<!DOCTYPE html>
<meta charset="utf-8" />
<html>
    <head>
        <title>
            Charm Function Glossary
        </title>
        <script type="text/javascript">
            function codeClick(e) {
                var elem = e.target;
                var codePre = elem.parentElement.getElementsByClassName("code-drawer")[0];
                if (codePre.classList.contains("code-open")) {
                    codePre.classList.remove("code-open");
                    //codePre.style.height = "0";
                } else {
                    codePre.classList.add("code-open");
                    //var lineHeight = parseInt(window.getComputedStyle(codePre).lineHeight);
                    //codePre.style.height = (codePre.innerHTML.split("\n").length * lineHeight) + "px";
                }
            }
            function init() {
                var codes = document.getElementsByClassName("code-button");
                for (let code of codes) {
                    code.onclick = function (e) { codeClick(e); };
                }
            }
            window.onload = init;
        </script>
        <style type="text/css">
            html {
                background-color: #ddd;
                font-family: sans-serif;
            }
            body {
                width: 80%;
                min-width: 30em;
                margin: 0 auto;
                padding: 4em;
                padding-top: 2em;
                box-shadow: 0 0 100px #666;
                background-color: #fff;
            }
            h2.function-header {
                border-bottom: 2px solid #000;
            }
            .index-header {
                width: 100%;
                text-align: center;
            }
            h3 {
                border-bottom: 1px solid #000;
            }
            h3.function {
                border-bottom: 1px dotted #000;
            }
            h3.function:target {
                background-color: yellow;
            }
            .info {
                padding-left: 2em;
                margin-top: 0.5em;
                margin-bottom: 0.5em;
            }
            .code {
                overflow-y: hidden;
                background-color: #ccc;
                font-family: monospace;
                padding: 1em;
                white-space: pre;
            }
            .code-drawer {
                height: 0;
                padding: 0;
                margin: 0;

                transition: padding 0.5s cubic-bezier(0, 1, 0, 1);
                transition: margin 0.5s cubic-bezier(0, 1, 0, 1);
            }
            .code-open {
                padding: 1em;
                margin-top: 0.75em;
                margin-bottom: 0.75em;
                height: auto;
            }
        </style>
    </head>
    <body>
        <h1>
            Charm Function Glossary
        </h1>
        <p>
            This page was autogenerated by docs/GenerateGlossary.rb on 2018-04-08 18:30:40 -0700. It lists all of the functions in the Charm glossary in an easy to read, useful reference format.
        </p>
        <p>
            If you've stumbled across this page on accident, please feel free to check out Charm, a stack-based functional programming language at <a href="https://github.com/aearnus/charm">https://github.com/aearnus/charm</a>. It's free, terse, paradigm-smashing, and fun to use and think in.
        </p>
        <h2 class="index-header">
            Quick Function Index
        </h2>
        <div>
            <div style="float:left;width:45%">
                <h3 class="index-header">
                    Native Functions
                </h3>
                <h3 class="function">Input / Output</h3><a href="#pp-id">pp</a> <a href="#newline-id">newline</a> <h3 class="function">Stack Manipulations</h3><a href="#dup-id">dup</a> <a href="#pop-id">pop</a> <a href="#swap-id">swap</a> <h3 class="function">List / String Manipulations</h3><a href="#len-id">len</a> <a href="#at-id">at</a> <a href="#insert-id">insert</a> <a href="#concat-id">concat</a> <a href="#split-id">split</a> <h3 class="function">Control Flow</h3><a href="#i-id">i</a> <a href="#q-id">q</a> <a href="#ifthen-id">ifthen</a> <h3 class="function">Boolean Operations</h3><a href="#xor-id">xor</a> <h3 class="function">Type Inspecific Math</h3><a href="#abs-id">abs</a> <h3 class="function">Integer Operations</h3><a href="#+-id">+</a> <a href="#--id">-</a> <a href="#*-id">*</a> <a href="#/-id">/</a> <a href="#toint-id">toint</a> <h3 class="function">Stack Creation and Destruction</h3><a href="#createstack-id">createstack</a> <a href="#switchstack-id">switchstack</a> <h3 class="function">Reference Getting and Setting</h3><a href="#getref-id">getref</a> <a href="#setref-id">setref</a> 
            </div>
            <div style="float:right;width:45%">
                <h3 class="index-header">
                    Prelude Functions
                </h3>
                <h3 class="function">Output Functions</h3><a href="#p-id">p</a> <a href="#print-id">print</a> <h3 class="function">Debugging Functions</h3><a href="#printstack-id">printstack</a> <h3 class="function">Stack Manipulation</h3><a href="#flip-id">flip</a> <a href="#swapnth-id">swapnth</a> <a href="#copyfrom-id">copyfrom</a> <a href="#pushto-id">pushto</a> <a href="#rotate-id">rotate</a> <a href="#stack-id">stack</a> <h3 class="function">List Manipulation</h3><a href="#repeat-id">repeat</a> <a href="#map-id">map</a> 
            </div>
            <div style="clear:both"></div>
        </div>
        <h2 class="function-header">
            Native Functions
        </h2>
        <h3>Input / Output</h3><h3 id="pp-id" class="function">pp</h3><h4>Description</h4><div class="info">Prints the function off the top of the stack.</div><h4>Quick Usage View</h4><div class="code"><i>any</i> pp </div><div><h4>Pops</h4><dl class="info"><dt>Stack index 0: any</dt><dd>The function that will be printed</dd></dl></div>
<div class="code-container">
    <button class="code-button">
        Source (click to open/close)
    </button>
    <pre class="code code-drawer">void PredefinedFunctions::p(Runner* r) {
	PredefinedFunctions::print(r-&gt;getCurrentStack()-&gt;pop());
}

void PredefinedFunctions::print(CharmFunction f1) {
	printf(&quot;%s&quot;, charmFunctionToString(f1).c_str());
}
</pre>
</div>
<h3 id="newline-id" class="function">newline</h3><h4>Description</h4><div class="info">Prints a newline.</div><h4>Quick Usage View</h4><div class="code">newline </div>
<div class="code-container">
    <button class="code-button">
        Source (click to open/close)
    </button>
    <pre class="code code-drawer">void PredefinedFunctions::newline(Runner* r) {
	printf(&quot;\n&quot;);
}
</pre>
</div>

<h3>Stack Manipulations</h3><h3 id="dup-id" class="function">dup</h3><h4>Description</h4><div class="info">Duplicates the top value on the stack.</div><h4>Quick Usage View</h4><div class="code"><i>any</i> dup         => <i>any</i> <i>any</i> </div><div><h4>Pops</h4><dl class="info"><dt>Stack index 0: any</dt><dd>The duplicand</dd></dl></div><div><h4>Pushes</h4><dl class="info"><dt>Stack index 1: any</dt><dd>The duplicand</dd><dt>Stack index 0: any</dt><dd>The duplicand</dd></dl></div>
<div class="code-container">
    <button class="code-button">
        Source (click to open/close)
    </button>
    <pre class="code code-drawer">void PredefinedFunctions::dup(Runner* r) {
	CharmFunction f1 = r-&gt;getCurrentStack()-&gt;pop();
	r-&gt;getCurrentStack()-&gt;push(f1);
	r-&gt;getCurrentStack()-&gt;push(f1);
}
</pre>
</div>
<h3 id="pop-id" class="function">pop</h3><h4>Description</h4><div class="info">Pops the top value off the stack.</div><h4>Quick Usage View</h4><div class="code"><i>any</i> pop </div><div><h4>Pops</h4><dl class="info"><dt>Stack index 0: any</dt><dd>The popped function</dd></dl></div>
<div class="code-container">
    <button class="code-button">
        Source (click to open/close)
    </button>
    <pre class="code code-drawer">void PredefinedFunctions::pop(Runner* r) {
	r-&gt;getCurrentStack()-&gt;pop();
}
</pre>
</div>
<h3 id="swap-id" class="function">swap</h3><h4>Description</h4><div class="info">Swaps two values on the stack.</div><h4>Quick Usage View</h4><div class="code"><i>int</i> <i>int</i> swap </div><div><h4>Pops</h4><dl class="info"><dt>Stack index 1: int</dt><dd>The stack index of a value to swap</dd><dt>Stack index 0: int</dt><dd>The stack index of the other value to swap</dd></dl></div>
<div class="code-container">
    <button class="code-button">
        Source (click to open/close)
    </button>
    <pre class="code code-drawer">void PredefinedFunctions::swap(Runner* r) {
	CharmFunction f1 = r-&gt;getCurrentStack()-&gt;pop();
	CharmFunction f2 = r-&gt;getCurrentStack()-&gt;pop();
	//check to make sure we&#39;ve got ints that are positive and below MAX_STACK
	if (Stack::isInt(f1) &amp;&amp; Stack::isInt(f2)) {
		if ((f1.numberValue.integerValue &lt; 0) || (f2.numberValue.integerValue &lt; 0)) {
			runtime_die(&quot;Negative int passed to `swap`.&quot;);
		}
		if ((f1.numberValue.integerValue &gt;= r-&gt;MAX_STACK) || (f2.numberValue.integerValue &gt;= r-&gt;MAX_STACK)) {
			runtime_die(&quot;Overflowing pointers passed to `swap`.&quot;);
		}
		r-&gt;getCurrentStack()-&gt;swap((unsigned long long)f1.numberValue.integerValue, (unsigned long long)f2.numberValue.integerValue);
	} else {
		runtime_die(&quot;Non integer passed to `swap`.&quot;);
	}
}
</pre>
</div>

<h3>List / String Manipulations</h3><h3 id="len-id" class="function">len</h3><h4>Description</h4><div class="info">Finds the length of a list or string.</div><div class="info">NOTE: This can be used with any type, but will push a trivial value.</div><h4>Quick Usage View</h4><div class="code"><i>any</i> len         => <i>any</i> <i>int</i> </div><div><h4>Pops</h4><dl class="info"><dt>Stack index 0: any</dt><dd>The function to find the length of (usually lists or strings)</dd></dl></div><div><h4>Pushes</h4><dl class="info"><dt>Stack index 1: any</dt><dd>The previously popped function</dd><dt>Stack index 0: int</dt><dd>The popped function's length</dd></dl></div>
<div class="code-container">
    <button class="code-button">
        Source (click to open/close)
    </button>
    <pre class="code code-drawer">void PredefinedFunctions::len(Runner* r) {
	//list to check length of
	CharmFunction f1 = r-&gt;getCurrentStack()-&gt;pop();
	//push list back on because we dont need to get rid of it
	r-&gt;getCurrentStack()-&gt;push(f1);
	CharmFunction out;
	out.functionType = NUMBER_FUNCTION;
	CharmNumber num;
	num.whichType = INTEGER_VALUE;
	//make sure f1 is a list or string
	if (f1.functionType == LIST_FUNCTION) {
		num.integerValue = f1.literalFunctions.size();
	} else if (f1.functionType == STRING_FUNCTION) {
		num.integerValue = f1.stringValue.size();
	} else {
		//so if it&#39;s a bad type, i was going to just report a len of 0 or 1
		//but i feel like that would be really misleading. eh, i&#39;ll just do 1
		num.integerValue = 1;
	}
	out.numberValue = num;
	r-&gt;getCurrentStack()-&gt;push(out);
}
</pre>
</div>
<h3 id="at-id" class="function">at</h3><h4>Description</h4><div class="info">Gets the element at an index of a list or string.</div><div class="info">NOTE: This function cannot "unquote" values -- for a list, it pushes a list; and for a string, it pushes a string. This is deliberate, and is in order to prevent naked functions from being pushed to the stack. To "unquote" values, use `i`.</div><h4>Quick Usage View</h4><div class="code"><i>list/string</i> <i>int</i> at         => <i>list/string</i> <i>list/string</i> </div><div><h4>Pops</h4><dl class="info"><dt>Stack index 1: list/string</dt><dd>The list or string to index</dd><dt>Stack index 0: int</dt><dd>The index</dd></dl></div><div><h4>Pushes</h4><dl class="info"><dt>Stack index 1: list/string</dt><dd>The list or string previously popped</dd><dt>Stack index 0: list/string</dt><dd>The indexed element</dd></dl></div>
<div class="code-container">
    <button class="code-button">
        Source (click to open/close)
    </button>
    <pre class="code code-drawer">void PredefinedFunctions::at(Runner* r) {
	//index number
	CharmFunction f1 = r-&gt;getCurrentStack()-&gt;pop();
	//list / string
	CharmFunction f2 = r-&gt;getCurrentStack()-&gt;pop();
	r-&gt;getCurrentStack()-&gt;push(f2);
	if (Stack::isInt(f1)) {
		CharmFunction out;
		if (f2.functionType == LIST_FUNCTION) {
			out.functionType = LIST_FUNCTION;
			out.literalFunctions = { f2.literalFunctions.at(f1.numberValue.integerValue % f2.literalFunctions.size()) };
		} else if (f2.functionType == STRING_FUNCTION) {
			out.functionType = STRING_FUNCTION;
			out.stringValue = f2.stringValue[f1.numberValue.integerValue % f2.stringValue.size()];
		} else {
			runtime_die(&quot;Neither a list nor a string was passed to `at`&quot;);
		}
		r-&gt;getCurrentStack()-&gt;push(out);
	} else {
		runtime_die(&quot;Non integer index passed to `at`&quot;);
	}
}
</pre>
</div>
<h3 id="insert-id" class="function">insert</h3><h4>Description</h4><div class="info">Insert an element into a list or string.</div><h4>Quick Usage View</h4><div class="code"><i>list/string</i> <i>list/string</i> <i>int</i> insert         => <i>list/string</i> </div><div><h4>Pops</h4><dl class="info"><dt>Stack index 2: list/string</dt><dd>The list or string to modify</dd><dt>Stack index 1: list/string</dt><dd>The element to be unboxed and inserted</dd><dt>Stack index 0: int</dt><dd>The insertation index</dd></dl></div><div><h4>Pushes</h4><dl class="info"><dt>Stack index 0: list/string</dt><dd>The modified list or string</dd></dl></div>
<div class="code-container">
    <button class="code-button">
        Source (click to open/close)
    </button>
    <pre class="code code-drawer">void PredefinedFunctions::insert(Runner* r) {
	//get index to insert in
	CharmFunction f1 = r-&gt;getCurrentStack()-&gt;pop();
	//get element to insert
	CharmFunction f2 = r-&gt;getCurrentStack()-&gt;pop();
	//get list or string
	CharmFunction f3 = r-&gt;getCurrentStack()-&gt;pop();
	//make sure f1 is an int
	if (!Stack::isInt(f1))
		runtime_die(&quot;Non integer index passed to `insert`.&quot;);
	if (f3.functionType == LIST_FUNCTION) {
		//only allow a list to be inserted into a list
		if (f2.functionType == LIST_FUNCTION) {
			f3.literalFunctions.insert(
				f3.literalFunctions.begin() + (f1.numberValue.integerValue % f3.literalFunctions.size()),
				f2.literalFunctions.begin(),
				f2.literalFunctions.end()
			);
		} else {
			runtime_die(&quot;Attempted to `insert` a non list into a list.&quot;);
		}
	} else if (f3.functionType == STRING_FUNCTION) {
		//only allow a string to be inserted into another string
		if (f2.functionType == STRING_FUNCTION) {
			f3.stringValue.insert(
				f1.numberValue.integerValue % f3.stringValue.size(),
				f2.stringValue
			);
		} else {
			runtime_die(&quot;Attempted to `insert` a non string into a string.&quot;);
		}
	}
	r-&gt;getCurrentStack()-&gt;push(f3);
}
</pre>
</div>
<h3 id="concat-id" class="function">concat</h3><h4>Description</h4><div class="info">Concatenates two lists or strings.</div><h4>Quick Usage View</h4><div class="code"><i>list/string</i> <i>list/string</i> concat         => <i>list/string</i> </div><div><h4>Pops</h4><dl class="info"><dt>Stack index 1: list/string</dt><dd>The first list or string</dd><dt>Stack index 0: list/string</dt><dd>The second list or string</dd></dl></div><div><h4>Pushes</h4><dl class="info"><dt>Stack index 0: list/string</dt><dd>The concatenated list or string</dd></dl></div>
<div class="code-container">
    <button class="code-button">
        Source (click to open/close)
    </button>
    <pre class="code code-drawer">void PredefinedFunctions::concat(Runner* r) {
	//get first list
	CharmFunction f1 = r-&gt;getCurrentStack()-&gt;pop();
	//get second list (first in order of concatination)
	CharmFunction f2 = r-&gt;getCurrentStack()-&gt;pop();
	//make sure they&#39;re both lists or strings
	if ((f1.functionType == LIST_FUNCTION) &amp;&amp; (f2.functionType == LIST_FUNCTION)) {
		f2.literalFunctions.insert(f2.literalFunctions.end(), f1.literalFunctions.begin(), f1.literalFunctions.end());
	} else if ((f1.functionType == STRING_FUNCTION) &amp;&amp; (f2.functionType == STRING_FUNCTION)) {
		f2.stringValue = f2.stringValue + f1.stringValue;
	} else {
		runtime_die(&quot;Unmatching types passed to `concat`.&quot;);
	}
	r-&gt;getCurrentStack()-&gt;push(f2);
}
</pre>
</div>
<h3 id="split-id" class="function">split</h3><h4>Description</h4><div class="info">Split a list or string after a certain amount of elements.</div><div class="info">NOTE: This function is the inverse of `concat`. That is, `[ list ] n split concat` is equal to `[ list ]`.</div><h4>Quick Usage View</h4><div class="code"><i>list/string</i> <i>int</i> split         => <i>list/string</i> <i>list/string</i> </div><div><h4>Pops</h4><dl class="info"><dt>Stack index 1: list/string</dt><dd>The list or string to split</dd><dt>Stack index 0: int</dt><dd>The amount of elements before the list or string is split</dd></dl></div><div><h4>Pushes</h4><dl class="info"><dt>Stack index 1: list/string</dt><dd>The first part of the list or string</dd><dt>Stack index 0: list/string</dt><dd>The rest of the list or string</dd></dl></div>
<div class="code-container">
    <button class="code-button">
        Source (click to open/close)
    </button>
    <pre class="code code-drawer">void PredefinedFunctions::concat(Runner* r) {
	//get first list
	CharmFunction f1 = r-&gt;getCurrentStack()-&gt;pop();
	//get second list (first in order of concatination)
	CharmFunction f2 = r-&gt;getCurrentStack()-&gt;pop();
	//make sure they&#39;re both lists or strings
	if ((f1.functionType == LIST_FUNCTION) &amp;&amp; (f2.functionType == LIST_FUNCTION)) {
		f2.literalFunctions.insert(f2.literalFunctions.end(), f1.literalFunctions.begin(), f1.literalFunctions.end());
	} else if ((f1.functionType == STRING_FUNCTION) &amp;&amp; (f2.functionType == STRING_FUNCTION)) {
		f2.stringValue = f2.stringValue + f1.stringValue;
	} else {
		runtime_die(&quot;Unmatching types passed to `concat`.&quot;);
	}
	r-&gt;getCurrentStack()-&gt;push(f2);
}
</pre>
</div>

<h3>Control Flow</h3><h3 id="i-id" class="function">i</h3><h4>Description</h4><div class="info">Similar to Lisp's `unquote`, runs the top of the stack as a program.</div><h4>Quick Usage View</h4><div class="code"><i>list</i> i </div><div><h4>Pops</h4><dl class="info"><dt>Stack index 0: list</dt><dd>The list to be unquoted and run</dd></dl></div>
<div class="code-container">
    <button class="code-button">
        Source (click to open/close)
    </button>
    <pre class="code code-drawer">void PredefinedFunctions::i(Runner* r) {
	//pop the top of the stack and run it
	CharmFunction f1 = r-&gt;getCurrentStack()-&gt;pop();
	if (f1.functionType == LIST_FUNCTION) {
		r-&gt;run(f1.literalFunctions);
	} else {
		runtime_die(&quot;Non list passed to `i`.&quot;);
	}
}
</pre>
</div>
<h3 id="q-id" class="function">q</h3><h4>Description</h4><div class="info">Similar to Lisp's `quote`, boxes the top of the stack.</div><div class="info">NOTE: This is the inverse of i, so `<value> q i` is the same as `<value>`</div><h4>Quick Usage View</h4><div class="code"><i>any</i> <i>list</i> q </div><div><h4>Pops</h4><dl class="info"><dt>Stack index 1: any</dt><dd>The value to be boxed</dd><dt>Stack index 0: list</dt><dd>The boxed value</dd></dl></div>
<div class="code-container">
    <button class="code-button">
        Source (click to open/close)
    </button>
    <pre class="code code-drawer">void PredefinedFunctions::q(Runner* r) {
	CharmFunction f1 = r-&gt;getCurrentStack()-&gt;pop();
	CharmFunction list;
	list.functionType = LIST_FUNCTION;
	list.literalFunctions.push_back(f1);
	r-&gt;getCurrentStack()-&gt;push(list);
}
</pre>
</div>
<h3 id="ifthen-id" class="function">ifthen</h3><h4>Description</h4><div class="info">Branching operator; runs the first block then decides whether or not to run the second or third based off of whether the top of the stack is > 0 or <= 0.</div><div class="info">NOTE: This is the only function which provides inherent tail call optimization. More info is written up in Documentation.md.</div><div class="info">NOTE: This function does not clean up after itself more than listed -- you need to clear the stack yourself if you want it cleared in a recursive function!</div><h4>Quick Usage View</h4><div class="code"><i>list</i> <i>list</i> <i>list</i> ifthen </div><div><h4>Pops</h4><dl class="info"><dt>Stack index 2: list</dt><dd>Condition to run before running truthy or falsy blocks</dd><dt>Stack index 1: list</dt><dd>Truthy (> 0) block</dd><dt>Stack index 0: list</dt><dd>Falsy (<= 0) block</dd></dl></div>
<div class="code-container">
    <button class="code-button">
        Source (click to open/close)
    </button>
    <pre class="code code-drawer">void PredefinedFunctions::ifthen(Runner* r, FunctionDefinition *context) {
	//the arguments to this function are a little different...
	//ifthen performs very basic tail-call optimization on its two sections (truthy/falsy)
	//if truthy (or falsy) end with the function itself (found through fD.functionName), then
	//the tail-call optimizer kicks in and the function simply loops instead of
	//creating a new stack frame by calling r-&gt;run()

	//this one is gonna take 3 arguments --
	//stack[2] = condition to run truthy section
	//stack[1] = truthy section (if...)
	//stack[0] = falsy section (else...)
	//have to reverse it because popping is weird
	CharmFunction falsy = r-&gt;getCurrentStack()-&gt;pop();
	bool falsyTailCall = false;
	CharmFunction truthy = r-&gt;getCurrentStack()-&gt;pop();
	bool truthyTailCall = false;
	CharmFunction condFunction = r-&gt;getCurrentStack()-&gt;pop();
	if ((condFunction.functionType == LIST_FUNCTION) &amp;&amp;
		(truthy.functionType == LIST_FUNCTION) &amp;&amp;
		(falsy.functionType == LIST_FUNCTION)) {
			//first, we run checks to set the tail call bools
			if (context != nullptr) {
				if (truthy.literalFunctions.back().functionName == context-&gt;functionName) {
					truthyTailCall = true;
				}
				if (falsy.literalFunctions.back().functionName == context-&gt;functionName) {
					falsyTailCall = true;
				}
				//now, if we _DO_ have a tail call, modify truthy/falsy and enter a loop instead
				//there are 3 seperate cases here -- truthy tail call, falsy tail call, or both
				if (truthyTailCall) {
					ONLYDEBUG printf(&quot;ENGAGING TRUTHY IF/THEN TAIL CALL OPTIMIZATION\n&quot;);
					//remove the tail call
					truthy.literalFunctions.pop_back();
					while (1) {
						r-&gt;run(condFunction.literalFunctions);
						CharmFunction cond = r-&gt;getCurrentStack()-&gt;pop();
						if (Stack::isInt(cond)) {
							if (cond.numberValue.integerValue &gt; 0) {
								r-&gt;run(truthy.literalFunctions);
							} else {
								r-&gt;run(falsy.literalFunctions);
								//end this function immediately once the tail call loop ends
								ONLYDEBUG printf(&quot;DISENGAGING TRUTHY IF/THEN TAIL CALL OPTIMIZATION\n&quot;);
								return;
							}
						} else {
							runtime_die(&quot;`ifthen` condition returned non integer.&quot;);
						}
					}
				}
				if (falsyTailCall) {
					ONLYDEBUG printf(&quot;ENGAGING FALSY IF/THEN TAIL CALL OPTIMIZATION\n&quot;);
					//remove the tail call
					falsy.literalFunctions.pop_back();
					while (1) {
						r-&gt;run(condFunction.literalFunctions);
						CharmFunction cond = r-&gt;getCurrentStack()-&gt;pop();
						if (Stack::isInt(cond)) {
							if (cond.numberValue.integerValue &gt; 0) {
								r-&gt;run(truthy.literalFunctions);
								//end this function immediately once the tail call loop ends
								ONLYDEBUG printf(&quot;DISENGAGING FALSY IF/THEN TAIL CALL OPTIMIZATION\n&quot;);
								return;
							} else {
								r-&gt;run(falsy.literalFunctions);
							}
						} else {
							runtime_die(&quot;`ifthen` condition returned non integer.&quot;);
						}
					}
				}
				//here&#39;s an extra special case if both truthy and falsy have a tail call
				//that is `f := [ &lt;cond&gt; ] [ &lt;code&gt; f ] [ &lt;code&gt; f ] ifthen`
				//this is equivalent to `f := [ &lt;cond&gt; ] [ &lt;code&gt; ] [ &lt;code&gt; ] ifthen f`
				//so we run it as an infinite loop
				if (truthyTailCall &amp;&amp; falsyTailCall) {
					ONLYDEBUG printf(&quot;ENGAGING TRUTHY/FALSY IF/THEN TAIL CALL OPTIMIZATION\n&quot;);
					//remove the tail calls
					truthy.literalFunctions.pop_back();
					falsy.literalFunctions.pop_back();
					while (1) {
						CharmFunction cond = r-&gt;getCurrentStack()-&gt;pop();
						if (Stack::isInt(cond)) {
							if (cond.numberValue.integerValue &gt; 0) {
								r-&gt;run(truthy.literalFunctions);
							} else {
								r-&gt;run(falsy.literalFunctions);
							}
						} else {
							runtime_die(&quot;`ifthen` condition returned non integer.&quot;);
						}
					}
				}
				//good joke
				ONLYDEBUG printf(&quot;DISENGAGING TRUTHY/FALSY IF/THEN TAIL CALL OPTIMIZATION\n&quot;);
			}
			//but if not (or context was nullptr), continue execution as normal
			r-&gt;run(condFunction.literalFunctions);
			//now we check the top of the stack to see if it&#39;s truthy or falsy
			CharmFunction cond = r-&gt;getCurrentStack()-&gt;pop();
			if (Stack::isInt(cond)) {
				if (cond.numberValue.integerValue &gt; 0) {
					r-&gt;run(truthy.literalFunctions);
				} else {
					r-&gt;run(falsy.literalFunctions);
				}
			} else {
				runtime_die(&quot;`ifthen` condition returned non integer.&quot;);
			}
		} else {
			runtime_die(&quot;Non list passed to `ifthen`.&quot;);
		}
}
</pre>
</div>

<h3>Boolean Operations</h3><h3 id="xor-id" class="function">xor</h3><h4>Description</h4><div class="info">Exclusive or.</div><div class="info">NOTE: This considers any value greater than 0 as true and less than 0 as false. It is not a bitwise call.</div><h4>Quick Usage View</h4><div class="code"><i>int</i> <i>int</i> xor         => <i>int</i> </div><div><h4>Pops</h4><dl class="info"><dt>Stack index 1: int</dt><dd>The first value to xor</dd><dt>Stack index 0: int</dt><dd>The second value to xor</dd></dl></div><div><h4>Pushes</h4><dl class="info"><dt>Stack index 0: int</dt><dd>The result of the xoring</dd></dl></div>
<div class="code-container">
    <button class="code-button">
        Source (click to open/close)
    </button>
    <pre class="code code-drawer">void PredefinedFunctions::exor(Runner* r) {
  	CharmFunction f1 = r-&gt;getCurrentStack()-&gt;pop();
  	CharmFunction f2 = r-&gt;getCurrentStack()-&gt;pop();
  	if (Stack::isInt(f1) &amp;&amp; Stack::isInt(f2)) {
  		CharmFunction out;
  		out.functionType = NUMBER_FUNCTION;
  		CharmNumber outNum;
  		outNum.whichType = INTEGER_VALUE;
  		//cancer incoming
  		outNum.integerValue = ((f1.numberValue.integerValue &gt; 0) ^ (f2.numberValue.integerValue &gt; 0));
  		//no more cancer
  		out.numberValue = outNum;
  		r-&gt;getCurrentStack()-&gt;push(out);
  	} else {
  		runtime_die(&quot;Non integer passed to logic function.&quot;);
  	}
}
</pre>
</div>

<h3>Type Inspecific Math</h3><h3 id="abs-id" class="function">abs</h3><h4>Description</h4><div class="info">Absolute value.</div><h4>Quick Usage View</h4><div class="code"><i>int/float</i> abs         => <i>int/float</i> </div><div><h4>Pops</h4><dl class="info"><dt>Stack index 0: int/float</dt><dd>The value to find the absolute value of</dd></dl></div><div><h4>Pushes</h4><dl class="info"><dt>Stack index 0: int/float</dt><dd>The absolute value</dd></dl></div>
<div class="code-container">
    <button class="code-button">
        Source (click to open/close)
    </button>
    <pre class="code code-drawer">void PredefinedFunctions::abs(Runner* r) {
	CharmFunction f1 = r-&gt;getCurrentStack()-&gt;pop();
	if (Stack::isInt(f1)) {
		std::abs(f1.numberValue.integerValue);
	} else if (Stack::isFloat(f1)) {
		if (f1.numberValue.floatValue &lt; 0) {
			f1.numberValue.floatValue = -f1.numberValue.floatValue;
		}
	} else {
		runtime_die(&quot;Non number passed to `abs`.&quot;);
	}
}
</pre>
</div>

<h3>Integer Operations</h3><h3 id="+-id" class="function">+</h3><h4>Description</h4><div class="info">Addition.</div><h4>Quick Usage View</h4><div class="code"><i>int</i> <i>int</i> +         => <i>int</i> </div><div><h4>Pops</h4><dl class="info"><dt>Stack index 1: int</dt><dd>The first value to add</dd><dt>Stack index 0: int</dt><dd>The second value to add</dd></dl></div><div><h4>Pushes</h4><dl class="info"><dt>Stack index 0: int</dt><dd>The added values</dd></dl></div>
<div class="code-container">
    <button class="code-button">
        Source (click to open/close)
    </button>
    <pre class="code code-drawer">void PredefinedFunctions::plusI(Runner* r) {
	CharmFunction f1 = r-&gt;getCurrentStack()-&gt;pop();
	CharmFunction f2 = r-&gt;getCurrentStack()-&gt;pop();
	if (Stack::isInt(f1) &amp;&amp; Stack::isInt(f2)) {
		f1.numberValue.integerValue = f1.numberValue.integerValue + f2.numberValue.integerValue;
	} else {
		runtime_die(&quot;Non integer passed to `+`.&quot;);
	}
	r-&gt;getCurrentStack()-&gt;push(f1);
}
</pre>
</div>
<h3 id="--id" class="function">-</h3><h4>Description</h4><div class="info">Subtraction.</div><h4>Quick Usage View</h4><div class="code"><i>int</i> <i>int</i> -         => <i>int</i> </div><div><h4>Pops</h4><dl class="info"><dt>Stack index 1: int</dt><dd>The first value to subtract from</dd><dt>Stack index 0: int</dt><dd>The second value to subtract</dd></dl></div><div><h4>Pushes</h4><dl class="info"><dt>Stack index 0: int</dt><dd>The subtracted values</dd></dl></div>
<div class="code-container">
    <button class="code-button">
        Source (click to open/close)
    </button>
    <pre class="code code-drawer">void PredefinedFunctions::minusI(Runner* r) {
	CharmFunction f1 = r-&gt;getCurrentStack()-&gt;pop();
	CharmFunction f2 = r-&gt;getCurrentStack()-&gt;pop();
	if (Stack::isInt(f1) &amp;&amp; Stack::isInt(f2)) {
		f1.numberValue.integerValue = f2.numberValue.integerValue - f1.numberValue.integerValue;
	} else {
		runtime_die(&quot;Non integer passed to `-`.&quot;);
	}
	r-&gt;getCurrentStack()-&gt;push(f1);
}
</pre>
</div>
<h3 id="*-id" class="function">*</h3><h4>Description</h4><div class="info">Multiplication.</div><h4>Quick Usage View</h4><div class="code"><i>int</i> <i>int</i> *         => <i>int</i> </div><div><h4>Pops</h4><dl class="info"><dt>Stack index 1: int</dt><dd>The first value to multiply</dd><dt>Stack index 0: int</dt><dd>The second value to multiply</dd></dl></div><div><h4>Pushes</h4><dl class="info"><dt>Stack index 0: int</dt><dd>The multiplied values</dd></dl></div>
<div class="code-container">
    <button class="code-button">
        Source (click to open/close)
    </button>
    <pre class="code code-drawer">void PredefinedFunctions::timesI(Runner* r) {
	CharmFunction f1 = r-&gt;getCurrentStack()-&gt;pop();
	CharmFunction f2 = r-&gt;getCurrentStack()-&gt;pop();
	if (Stack::isInt(f1) &amp;&amp; Stack::isInt(f2)) {
		f1.numberValue.integerValue = f1.numberValue.integerValue * f2.numberValue.integerValue;
	} else {
		runtime_die(&quot;Non integer passed to `*`.&quot;);
	}
	r-&gt;getCurrentStack()-&gt;push(f1);
}
</pre>
</div>
<h3 id="/-id" class="function">/</h3><h4>Description</h4><div class="info">Division.</div><h4>Quick Usage View</h4><div class="code"><i>int</i> <i>int</i> /         => <i>int</i> <i>int</i> </div><div><h4>Pops</h4><dl class="info"><dt>Stack index 1: int</dt><dd>The numerator</dd><dt>Stack index 0: int</dt><dd>The denominator</dd></dl></div><div><h4>Pushes</h4><dl class="info"><dt>Stack index 1: int</dt><dd>The remainder</dd><dt>Stack index 0: int</dt><dd>The divided value</dd></dl></div>
<div class="code-container">
    <button class="code-button">
        Source (click to open/close)
    </button>
    <pre class="code code-drawer">void PredefinedFunctions::divI(Runner* r) {
	CharmFunction f1 = r-&gt;getCurrentStack()-&gt;pop();
	CharmFunction f2 = r-&gt;getCurrentStack()-&gt;pop();
	if (Stack::isInt(f1) &amp;&amp; Stack::isInt(f2)) {
		//f1 used as answer
		f1.numberValue.integerValue = f2.numberValue.integerValue / f1.numberValue.integerValue;
		//f2 used as modulus
		f2.numberValue.integerValue = f2.numberValue.integerValue % f1.numberValue.integerValue;
	} else {
		runtime_die(&quot;Non integer passed to `+`.&quot;);
	}
	r-&gt;getCurrentStack()-&gt;push(f2);
	r-&gt;getCurrentStack()-&gt;push(f1);
}
</pre>
</div>
<h3 id="toint-id" class="function">toint</h3><h4>Description</h4><div class="info">Convert a floating point value to an integer through truncation.</div><h4>Quick Usage View</h4><div class="code"><i>float</i> toint         => <i>int</i> </div><div><h4>Pops</h4><dl class="info"><dt>Stack index 0: float</dt><dd>The floating point value to convert</dd></dl></div><div><h4>Pushes</h4><dl class="info"><dt>Stack index 0: int</dt><dd>The integer representation</dd></dl></div>
<div class="code-container">
    <button class="code-button">
        Source (click to open/close)
    </button>
    <pre class="code code-drawer">void PredefinedFunctions::toInt(Runner* r) {
	CharmFunction f1 = r-&gt;getCurrentStack()-&gt;pop();
	if (Stack::isFloat(f1)) {
		f1.numberValue.whichType = INTEGER_VALUE;
		f1.numberValue.integerValue = (long long)f1.numberValue.floatValue;
	} else if (Stack::isInt(f1)) {
		//do nothing, it&#39;s already an int
	} else {
		runtime_die(&quot;Non number passed to `toInt`.&quot;);
	}
}
</pre>
</div>

<h3>Stack Creation and Destruction</h3><h3 id="createstack-id" class="function">createstack</h3><h4>Description</h4><div class="info">Creates a new named stack to work with.</div><div class="info">NOTE: This function does not switch to the specified stack. Use <span class="code">switchstack</span> for that.</div><div class="info">NOTE: The default stack is 20,000 functions long and named <span class="code">0</span>.</div><h4>Quick Usage View</h4><div class="code"><i>int</i> <i>any</i> createstack </div><div><h4>Pops</h4><dl class="info"><dt>Stack index 1: int</dt><dd>The size of the stack to create</dd><dt>Stack index 0: any</dt><dd>The name of the stack</dd></dl></div>
<div class="code-container">
    <button class="code-button">
        Source (click to open/close)
    </button>
    <pre class="code code-drawer">void PredefinedFunctions::createStack(Runner* r) {
	//name of the stack
	CharmFunction f1 = r-&gt;getCurrentStack()-&gt;pop();
	//length of the stack
	CharmFunction f2 = r-&gt;getCurrentStack()-&gt;pop();
	if (Stack::isInt(f2)) {
		if (f2.numberValue.integerValue &gt; 0) {
			r-&gt;createStack(f2.numberValue.integerValue, f1);
		} else {
			runtime_die(&quot;Negative integer or zero passed to `createStack`.&quot;);
		}
	} else {
		runtime_die(&quot;Non integer passed to `createStack`.&quot;);
	}
}
</pre>
</div>
<h3 id="switchstack-id" class="function">switchstack</h3><h4>Description</h4><div class="info">Switches to a named stack.</div><div class="info">NOTE: The default stack is named <span class="code">0</span>.</div><h4>Quick Usage View</h4><div class="code"><i>any</i> switchstack </div><div><h4>Pops</h4><dl class="info"><dt>Stack index 0: any</dt><dd>The name of the stack to switch to</dd></dl></div>
<div class="code-container">
    <button class="code-button">
        Source (click to open/close)
    </button>
    <pre class="code code-drawer">void PredefinedFunctions::switchStack(Runner* r) {
	CharmFunction f1 = r-&gt;getCurrentStack()-&gt;pop();
	r-&gt;switchCurrentStack(f1);
}
</pre>
</div>

<h3>Reference Getting and Setting</h3><h3 id="getref-id" class="function">getref</h3><h4>Description</h4><div class="info">Gets the value of a global reference.</div><h4>Quick Usage View</h4><div class="code"><i>any</i> getref </div><div><h4>Pops</h4><dl class="info"><dt>Stack index 0: any</dt><dd>The name of the reference to get</dd></dl></div>
<div class="code-container">
    <button class="code-button">
        Source (click to open/close)
    </button>
    <pre class="code code-drawer">void PredefinedFunctions::getRef(Runner* r) {
	CharmFunction f1 = r-&gt;getCurrentStack()-&gt;pop();
	r-&gt;getCurrentStack()-&gt;push(r-&gt;getReference(f1));
}
</pre>
</div>
<h3 id="setref-id" class="function">setref</h3><h4>Description</h4><div class="info">Sets the value of a global reference.</div><div class="info">NOTE: Though this is not enforced, it's canonical to use <span class="code">" &lt;description&gt;&lt;function&gt;ref "</span> as the reference name.</div><h4>Quick Usage View</h4><div class="code"><i>any</i> <i>any</i> setref </div><div><h4>Pops</h4><dl class="info"><dt>Stack index 1: any</dt><dd>The name of the reference</dd><dt>Stack index 0: any</dt><dd>The value of the reference</dd></dl></div>
<div class="code-container">
    <button class="code-button">
        Source (click to open/close)
    </button>
    <pre class="code code-drawer">void PredefinedFunctions::setRef(Runner* r) {
	//the value of the reference
	CharmFunction f1 = r-&gt;getCurrentStack()-&gt;pop();
	//the name of the reference
	CharmFunction f2 = r-&gt;getCurrentStack()-&gt;pop();
	r-&gt;setReference(f2, f1);
}
</pre>
</div>

        <h2 class="function-header">
            Prelude Functions
        </h2>
        <h3>Output Functions</h3><h3 id="p-id" class="function">p</h3><h4>Description</h4><div class="info">Prints without popping.</div><h4>Quick Usage View</h4><div class="code"><i>any</i> p         => <i>any</i> </div><div><h4>Pops</h4><dl class="info"><dt>Stack index 0: any</dt><dd>The value to print</dd></dl></div><div><h4>Pushes</h4><dl class="info"><dt>Stack index 0: any</dt><dd>The value to print</dd></dl></div>
<div class="code-container">
    <button class="code-button">
        Source (click to open/close)
    </button>
    <pre class="code code-drawer">p := dup pp
</pre>
</div>
<h3 id="print-id" class="function">print</h3><h4>Description</h4><div class="info">Prints without popping then prints a newline</div><h4>Quick Usage View</h4><div class="code"><i>any</i> print         => <i>any</i> </div><div><h4>Pops</h4><dl class="info"><dt>Stack index 0: any</dt><dd>The value to print</dd></dl></div><div><h4>Pushes</h4><dl class="info"><dt>Stack index 0: any</dt><dd>The value to print</dd></dl></div>
<div class="code-container">
    <button class="code-button">
        Source (click to open/close)
    </button>
    <pre class="code code-drawer">print := p newline
</pre>
</div>

<h3>Debugging Functions</h3><h3 id="printstack-id" class="function">printstack</h3><h4>Description</h4><div class="info">Prints the stack to a certain depth.</div><h4>Quick Usage View</h4><div class="code"><i>int</i> printstack </div><div><h4>Pops</h4><dl class="info"><dt>Stack index 0: int</dt><dd>The depth to print up until</dd></dl></div>
<div class="code-container">
    <button class="code-button">
        Source (click to open/close)
    </button>
    <pre class="code code-drawer">_printstack_args := &quot; printstackref &quot; flip setref
_printstack_correction := &quot; printstackref &quot; getref rotate
printstack := _printstack_args [ print &quot; printstackref &quot; getref rotate ] &quot; printstackref &quot; getref repeat i _printstack_correction
</pre>
</div>

<h3>Stack Manipulation</h3><h3 id="flip-id" class="function">flip</h3><h4>Description</h4><div class="info">Flips two elements on the stack.</div><h4>Quick Usage View</h4><div class="code"><i>any</i> <i>any</i> flip         => <i>any</i> <i>any</i> </div><div><h4>Pops</h4><dl class="info"><dt>Stack index 1: any</dt><dd>One value to flip</dd><dt>Stack index 0: any</dt><dd>The other value to flip</dd></dl></div><div><h4>Pushes</h4><dl class="info"><dt>Stack index 1: any</dt><dd>One value to flip</dd><dt>Stack index 0: any</dt><dd>The other value to flip</dd></dl></div>
<div class="code-container">
    <button class="code-button">
        Source (click to open/close)
    </button>
    <pre class="code code-drawer">flip := 0 1 swap
</pre>
</div>
<h3 id="swapnth-id" class="function">swapnth</h3><h4>Description</h4><div class="info">Swap the top value with the value at an index on the stack.</div><div class="info">NOTE: This function is magic-ish. It doesn't push another top value, but it replaces the previous one.</div><h4>Quick Usage View</h4><div class="code"><i>int</i> swapnth </div><div><h4>Pops</h4><dl class="info"><dt>Stack index 0: int</dt><dd>The stack index to swap the top value to</dd></dl></div>
<div class="code-container">
    <button class="code-button">
        Source (click to open/close)
    </button>
    <pre class="code code-drawer">swapnth := dup 1 + swap
</pre>
</div>
<h3 id="copyfrom-id" class="function">copyfrom</h3><h4>Description</h4><div class="info">Copy a value from an index on the stack.</div><div class="info">NOTE: Unlike swap, this does not move any values from their place in the stack.</div><h4>Quick Usage View</h4><div class="code"><i>int</i> copyfrom         => <i>any</i> </div><div><h4>Pops</h4><dl class="info"><dt>Stack index 0: int</dt><dd>The stack index to copy from</dd></dl></div><div><h4>Pushes</h4><dl class="info"><dt>Stack index 0: any</dt><dd>The value copied from the stack</dd></dl></div>
<div class="code-container">
    <button class="code-button">
        Source (click to open/close)
    </button>
    <pre class="code code-drawer">copyfrom := &quot; copyfromref &quot; flip setref 0 &quot; copyfromref &quot; getref swap dup 1 &quot; copyfromref &quot; getref 1 + swap
</pre>
</div>
<h3 id="pushto-id" class="function">pushto</h3><h4>Description</h4><div class="info">Push a value to an index on the stack.</div><div class="info">NOTE: This function is SLOW! Don't use it unless you absolutely understand it -- it can turn a relatively fast function from O(n) to O(n^2) just like it did to <a href="#printstack-id">printstack</a>.</div><h4>Quick Usage View</h4><div class="code"><i>any</i> <i>int</i> pushto </div><div><h4>Pops</h4><dl class="info"><dt>Stack index 1: any</dt><dd>The object to push</dd><dt>Stack index 0: int</dt><dd>The stack index to push the object to</dd></dl></div>
<div class="code-container">
    <button class="code-button">
        Source (click to open/close)
    </button>
    <pre class="code code-drawer">_pushto_args := 0 flip
_pushto_cond := print flip print flip dup 2 copyfrom -
_pushto_inc  := flip 1 + flip
_pushto      := [ _pushto_cond ] [ 1 copyfrom 2 + swapnth _pushto_inc _pushto ] [ pop pop ] ifthen
pushto       := _pushto_args _pushto
</pre>
</div>
<h3 id="rotate-id" class="function">rotate</h3><h4>Description</h4><div class="info">Rotate values up through the stack, down to a certain depth.</div><div class="info">NOTE: See <a href="#pushto-id">pushto</a>.</div><h4>Quick Usage View</h4><div class="code"><i>int</i> rotate </div><div><h4>Pops</h4><dl class="info"><dt>Stack index 0: int</dt><dd>The depth of rotation</dd></dl></div>
<div class="code-container">
    <button class="code-button">
        Source (click to open/close)
    </button>
    <pre class="code code-drawer">rotate := pushto
</pre>
</div>
<h3 id="stack-id" class="function">stack</h3><h4>Description</h4><div class="info">Duplicates a value multiple times.</div><h4>Quick Usage View</h4><div class="code"><i>any</i> <i>int</i> stack         => <i>...</i> </div><div><h4>Pops</h4><dl class="info"><dt>Stack index 1: any</dt><dd>The object to duplicate</dd><dt>Stack index 0: int</dt><dd>The amount of times to duplicate</dd></dl></div><div><h4>Pushes</h4><dl class="info"><dt>Stack index 0: ...</dt><dd>All of the duplicated objects</dd></dl></div>
<div class="code-container">
    <button class="code-button">
        Source (click to open/close)
    </button>
    <pre class="code code-drawer">stack := [ 1 - dup ] [ flip dup 0 2 swap stack ] [ pop ] ifthen
</pre>
</div>

<h3>List Manipulation</h3><h3 id="repeat-id" class="function">repeat</h3><h4>Description</h4><div class="info">Repeats a list a certain number of times.</div><div class="info">NOTE: Using this as <span class="code"> [ &ltfunction&gt; ] flip repeat i</span> works as something akin to a for-loop construct!</div><h4>Quick Usage View</h4><div class="code"><i>list/string</i> <i>int</i> repeat         => <i>list/string</i> </div><div><h4>Pops</h4><dl class="info"><dt>Stack index 1: list/string</dt><dd>List or string to repeat</dd><dt>Stack index 0: int</dt><dd>Number of times to repeat</dd></dl></div><div><h4>Pushes</h4><dl class="info"><dt>Stack index 0: list/string</dt><dd>Repeated list or string</dd></dl></div>
<div class="code-container">
    <button class="code-button">
        Source (click to open/close)
    </button>
    <pre class="code code-drawer">_repeat_args := flip dup 0 2 swap 1 -
_repeat_iter := 0 2 swap dup 0 2 swap concat flip 2 0 swap 1 -
_repeat      :=  [ dup ] [ _repeat_iter _repeat ] [ pop flip pop ] ifthen
repeat       := _repeat_args _repeat
</pre>
</div>
<h3 id="map-id" class="function">map</h3><h4>Description</h4><div class="info">Applies a function to every element in a list.</div><div class="info">NOTE: The function passed to <span class="code">map</span> must pop exactly 1 boxed value and must push exactly 1 list. If not, it will break the internal workings of <span class="code">map</span> and you will get strange, arcane error messages!</div><div class="info">NOTE: A good example of a proper <span class="code">map</span> call is <span class="code">[ 1 2 3 ] [ i 1 + q ] map</span>. Note how the value is unquoted (<span class="code">i</span>) and quoted again (<span class="code">q</span>) afterwards.</div><h4>Quick Usage View</h4><div class="code"><i>list</i> <i>function(list -> list)</i> map         => <i>list</i> </div><div><h4>Pops</h4><dl class="info"><dt>Stack index 1: list</dt><dd>List to map over</dd><dt>Stack index 0: function(list -> list)</dt><dd>Function to apply to every element in the list</dd></dl></div><div><h4>Pushes</h4><dl class="info"><dt>Stack index 0: list</dt><dd>Mapped list</dd></dl></div>
<div class="code-container">
    <button class="code-button">
        Source (click to open/close)
    </button>
    <pre class="code code-drawer">_map_args    := &quot; mapfuncref &quot; flip setref [ ]
_map_iter    := flip 1 split flip &quot; mapfuncref &quot; getref i 1 2 swap concat
_map_cond    := flip len 1 2 swap
_map_cleanup := flip pop
_map         := [ _map_cond ] [ _map_iter _map ] [ _map_cleanup ] ifthen
map          := _map_args _map_iter
</pre>
</div>

</html>
